# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´05æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers mailing2025-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-05)

å…¨éƒ¨ã§99æœ¬ã‚ã‚Šã¾ã™ã€‚

ã‚‚ãã˜

[:contents]

### [N5010 WG21 agenda: 16-21 June 2025, Sofia Bulgaria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5010.html)

2025å¹´6æœˆã«ã‚½ãƒ•ã‚£ã‚¢ï¼ˆãƒ–ãƒ«ã‚¬ãƒªã‚¢ï¼‰ã§è¡Œã‚ã‚Œã‚‹ä¼šè­°ã®ã‚¢ã‚¸ã‚§ãƒ³ãƒ€ã€‚

### [P0085R1 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r1.html)

8é€²ãƒªãƒ†ãƒ©ãƒ«ã®æ–°ã—ã„ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã®ææ¡ˆã€‚

ç¾åœ¨ã®8é€²ãƒªãƒ†ãƒ©ãƒ«ã®æ§‹æ–‡ã§ã¯ã€`0`å§‹ã¾ã‚Šã®æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ãŒ8é€²ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦èªè­˜ã•ã‚Œã¾ã™ã€‚

```cpp
01234; // 8é€²ãƒªãƒ†ãƒ©ãƒ«
0;     // 8é€²ãƒªãƒ†ãƒ©ãƒ«
08;    // ngã€8ã¯8é€²æ•°å€¤ã¨ã—ã¦ç„¡åŠ¹
```

ãŸã ã€ã“ã®æ§‹æ–‡ã¯åˆå­¦è€…ã«ã¨ã£ã¦é–“é•ãˆã‚„ã™ã„ã“ã¨ãŒæŒ‡æ‘˜ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€10é€²ãƒªãƒ†ãƒ©ãƒ«ã®æ•´æ•°å€¤ã‚’å¹…ã‚’ãã‚ãˆã‚‹ãªã©ã®ç›®çš„ã§å…ˆé ­ã«0ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã—ã¦ã—ã¾ã£ãŸã¨ãã§ã‚‚ã‚¨ãƒ©ãƒ¼ã«ã¯ãªã‚‰ãšã€8é€²ãƒªãƒ†ãƒ©ãƒ«ã¨ã—ã¦è§£é‡ˆã•ã‚Œã‚‹ã“ã¨ã§æ•´æ•°å€¤ãŒå¤‰åŒ–ã—ã¾ã™ã€‚

```cpp
 12340; // 10é€²ãƒªãƒ†ãƒ©ãƒ«
012340; // 8é€²ãƒªãƒ†ãƒ©ãƒ«
```

ã“ã®ææ¡ˆã¯ã“ã®ã‚ˆã†ãªæ§‹æ–‡ã‚’ä¿®æ­£ã™ã‚‹ãŸã‚ã«ã€8é€²ãƒªãƒ†ãƒ©ãƒ«ã®æ–°ã—ã„ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã¨ã—ã¦`0o`/`0O`ã‚’è¿½åŠ ã™ã‚‹ã¨ã¨ã‚‚ã«ã€ç¾åœ¨ã®8é€²ãƒªãƒ†ãƒ©ãƒ«ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’éæ¨å¥¨ã«ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

```cpp
// ã“ã®ææ¡ˆã®8é€²ãƒªãƒ†ãƒ©ãƒ«
0o1234;
0O1234;
```

ã“ã®æ§‹æ–‡ã¯Haskellã‚„Pythonãªã©ã‚’å§‹ã‚ã¨ã™ã‚‹ä»–è¨€èªã§æ¡ç”¨ã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã¨åŒæ§˜ã§ã€ç¾åœ¨8é€²æ•°å€¤ãƒªãƒ†ãƒ©ãƒ«ã®æ§‹æ–‡ã¨ãƒ‡ãƒ•ã‚¡ã‚¯ãƒˆã¨ãªã‚Šã¤ã¤ã‚ã‚Šã¾ã™ã€‚ã¾ãŸã€16é€²ãƒªãƒ†ãƒ©ãƒ«ã‚„2é€²ãƒªãƒ†ãƒ©ãƒ«ã®ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã¨æ•´åˆã—ã¦ã„ã¾ã™ã€‚

```cpp
0b00101010; // 2é€²ãƒªãƒ†ãƒ©ãƒ«
0o52;       // 8é€²ãƒªãƒ†ãƒ©ãƒ«
0x2A;       // 16é€²ãƒªãƒ†ãƒ©ãƒ«
```

Cã®8é€²ãƒªãƒ†ãƒ©ãƒ«ã‚‚C++ã®ç¾åœ¨ã®ã‚‚ã®ã¨åŒæ§˜ã®æ§‹æ–‡ã‚’å–ã£ã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯ã™ã§ã«éæ¨å¥¨åŒ–ã•ã‚Œã¦ãŠã‚Šã€å»ƒæ­¢äºˆå®šã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚C++ã§ã‚‚ã“ã‚Œã«å€£ã£ã¦ã€ã¾ãšéæ¨å¥¨åŒ–ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®è­¦å‘Šã‚’ä¿ƒã—ã€å°†æ¥çš„ã«å»ƒæ­¢ã™ã‚‹ã“ã¨ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚

ã“ã®ä¿®æ­£ã¯åŸºæœ¬çš„ã«å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã™ã‚‹ã‚‚ã®ã§ã™ãŒã€ä¸€ã¤éäº’æ›ãªå¤‰æ›´ã¨ãªã‚‹éƒ¨åˆ†ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã¯`std::format()`ã§æ•´æ•°å€¤ã‚’8é€²å‡ºåŠ›ã—ãŸæ™‚ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆçµæœã§ã€`#o`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦åŸºæ•°ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºã•ã›ã‚‹ã‚ˆã†ã«ã—ãŸã¨ãã®çµæœãŒæ§‹æ–‡ã¨ä¸€è²«ã—ãªããªã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚

```cpp
std::println("{:o}", 0o77);  // 8é€²å‡ºåŠ›
std::println("{:#o}", 0o77); // åŸºæ•°ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ã8é€²å‡ºåŠ›
                             // `#O`ã¯ãªã„
std::println("{:#x}", 0x3f); // åŸºæ•°ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ã16é€²å‡ºåŠ›ï¼ˆå°æ–‡å­—ï¼‰
std::println("{:#X}", 0x3f); // åŸºæ•°ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ä»˜ã16é€²å‡ºåŠ›ï¼ˆå¤§æ–‡å­—ï¼‰
```
```
77
077
0x3f
0X3F
```

ç‰¹ã«ã“ã®ææ¡ˆã®å¾Œã§ã€ã“ã®å‡ºåŠ›ã¯16é€²ã®å ´åˆï¼ˆ`#X`ã ã¨ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ãŒ`0X`ã«ãªã‚‹ï¼‰ã¨ä¸€è²«ã—ãªããªã‚Šã¾ã™ï¼ˆ`#O`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒç„¡ã„ãŸã‚ï¼‰ã€‚

ã“ã®ææ¡ˆã§ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯ãã®ã¾ã¾ã¨ã—ã¦`#o`ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®å‡ºåŠ›çµæœã®ãƒ—ãƒªãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’`0o`ã«å¤‰æ›´ã™ã‚‹ã“ã¨ã‚’æ¨å¥¨ã—ã¦ã„ã¾ã™ï¼ˆææ¡ˆã«ã¯ã—ã¦ã„ã¾ã›ã‚“ï¼‰ã€‚ã“ã‚Œã¯ç ´å£Šçš„å¤‰æ›´ã«ãªã‚Šã¾ã™ãŒã€Githubã®æ¤œç´¢ã§ã¯åˆ©ç”¨é »åº¦ãŒä½ã„ã®ã§å•é¡Œãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã¨ã—ã¦ã„ã¾ã™ã€‚ã¾ãŸã€ä»£æ›¿ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’4ã¤æç¤ºã—ã¦ã„ã¾ã™ã€‚

- [N3353 Obsolete implicitly octal literals and add delimited escape sequences](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm)
- [P0085 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2055)

### [P0149R2 Generalised member pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0149r2.pdf)
### [P0149R3 Generalised member pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0149r3.pdf)
### [P1144R13 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1144r13.html)
### [P1306R4 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1306r4.html)
### [P2079R8 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r8.html)
### [P2287R5 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2287r5.html)
### [P2414R7 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r7.pdf)
### [P2434R4 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2434r4.html)
### [P2509R1 A proposal for a type trait to detect value-preserving conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2509r1.html)
### [P2664R10 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2664r10.html)
### [P2719R5 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r5.html)
### [P2902R2 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2902r2.pdf)
### [P2927R3 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2927r3.html)
### [P2956R1 Add saturating library support to std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2956r1.html)
### [P2970R0 Partial application of concepts in template arguments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2970r0.pdf)

ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã€éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’å—ã‘å…¥ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

C++26ã§ã¯ã€ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ã‚ˆã£ã¦ã‚³ãƒ³ã‚»ãƒ—ãƒˆãã®ã‚‚ã®ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã«æ¸¡ã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€æ¸¡ã›ã‚‹ã®ã¯ãã®å¼•æ•°ã‚’åŸ‹ã‚ã‚‹å‰ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆãã®ã‚‚ã®ã§ã‚ã‚Šã€ä½•ã‹ã—ã‚‰ã®å¼•æ•°ãŒéƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

```cpp
// Cã‚’æº€ãŸã™è¦ç´ å‹ã«ã‚ˆã‚‹rangeã§ã‚ã‚‹ã“ã¨ã‚’åˆ¶ç´„ã™ã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆ
template <typename R, template <typename> concept C>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>>;

auto f(range_of<std::integral> auto&&);     // ok
auto f(range_of<std::same_as<int>> auto&&); // ng
```

ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿`C`ã«ã¯å¼•æ•°é©ç”¨å‰ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™ã“ã¨ã—ã‹ã§ãã¾ã›ã‚“ã€‚

ã“ã‚Œã«å¯¾å‡¦ã™ã‚‹ä¸€ã¤ã®æ–¹æ³•ã¨ã—ã¦ã¯ã€`range_of`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®å®šç¾©ã‚’ã“ã‚Œã‚’è€ƒæ…®ã—ã¦å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
template <typename R, template <typename...> concept C, typename... Args>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>, Args...>;

void f(range_of<std::same_as, int> auto&&);
```

`C`ã«æ¸¡ã™ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã‚’åˆ¥ã«å—ã‘å–ã‚‹ã‚ˆã†ã«ã—ã¦ã€å†…éƒ¨ã§é©ç”¨ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ã“ã‚Œã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®å®šç¾©ã§ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒå¿…è¦ã«ãªã‚‹ã¨ã¨ã‚‚ã«ã€å¼•æ•°ã®æ„å‘³ãŒæ˜ç¢ºã§ã¯ãªãã€è¦ç´ å‹ã«å¯¾ã™ã‚‹åˆ¶ç´„ã‚’è¤‡æ•°å–ã‚Œã‚‹ã‚ˆã†ã«`range_of`ã‚’æ‹¡å¼µã™ã‚‹æ–¹å‘æ€§ã‚’é–‰ã–ã—ã¦ã—ã¾ã„ã¾ã™ã€‚

åˆ¥ã®æ–¹æ³•ã¨ã—ã¦ã€ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ãã®å¼•æ•°ã‚’åˆ¥ã®å‹ã‚’çµŒç”±ã—ã¦æ¸¡ã™ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ã‚‚è€ƒãˆã‚‰ã‚Œã¾ã™ã€‚

```cpp
template <template <typename...> concept C, typename... Args>
struct packed_concept {
  template <typename T>
  static constexpr bool apply = C<T, Args...>;
};

template <typename R, typename... PackedConcept>
concept range_of = std::ranges::range<R> && (PackedConcept::template apply<std::ranges::range_value_t<R>> && ...);

void f(range_of<packed_concept<std::convertible_to, int>, packed_concept<std::regular>> auto&&);
```

ã“ã¡ã‚‰ã®å ´åˆã¯è¦ç´ å‹ã«å¯¾ã™ã‚‹åˆ¶ç´„ã®åˆæˆãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‚‚ã®ã®ã€å…ˆã»ã©ã®æ–¹æ³•ã¨æ¯”è¼ƒã—ã¦ã‚‚å¯èª­æ€§ãŒä½ä¸‹ã—ã¦ãŠã‚Šã€åŒ…æ‘‚é–¢ä¿‚ã®æˆç«‹ã‚’å¦¨ã’ã‚‹ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

çµå±€ã€æœ€åˆã®ä¾‹ã«ã‚ã£ãŸã‚ˆã†ãªéƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ãã®ã¾ã¾æ¸¡ã™ã“ã¨ãŒã§ãã‚Œã°ä¸€ç•ªä½¿ã„ã‚„ã™ããªã‚‹ã¨ã—ã¦ã€ã“ã“ã§ã¯ãã‚Œã‚’ææ¡ˆã—ã¦ã„ã¾ã™ã€‚ãŸã ã—ã€éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™æ§‹æ–‡ã¯ã€`concept`ã®æŒ‡å®šãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

```cpp
// ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹ä½•ã‚‰ã‹ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã¨ã™ã‚‹
some_template_name <
  std::regular,           // ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™ï¼ˆC++26
  concept regular<>,      // 0å¼•æ•°ãŒéƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™ï¼ˆã“ã®ææ¡ˆ
  invocable<int>,         // ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®çµæœã®boolå€¤ãŒæ¸¡ã•ã‚Œã‚‹ï¼ˆè¨ºæ–­ã•ã‚Œã‚‹ã¯ãš
  concept invocable<int>  // 1å¼•æ•°ãŒéƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™ï¼ˆã“ã®ææ¡ˆ
>;
```

ã“ã®ã‚ˆã†ã«ã€éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã™éš›ã¯æ¸¡ã™å´ã§`concept`ã®æŒ‡å®šãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã“ã‚Œã¯ã€å¯å¤‰é•·å¼•æ•°ã‚’å–ã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆã§ã¯`bool`å€¤ã‚’æ¸¡ãã†ã¨ã—ã¦ã„ã‚‹ã®ã‹éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ãã†ã¨ã—ã¦ã„ã‚‹ã®ã‹ãŒæ›–æ˜§ã¨ãªã‚Šã€ç„¡ç†ã‚„ã‚Šæ¨å®šã—ã‚ˆã†ã¨ã™ã‚‹ã¨æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã‚’å£Šã—ã¦ã—ã¾ã†å¯èƒ½æ€§ãŒã‚ã‚‹ã»ã‹ã€å°†æ¥ã®æ©Ÿèƒ½ã¨ã—ã¦ã®ãƒ¦ãƒ‹ãƒãƒ¼ã‚µãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæ¥ãŸå ´åˆã«æ¨å®šãŒæ›–æ˜§ã«ãªã‚‹ã“ã¨ãŒäºˆæƒ³ã•ã‚Œã‚‹ã€ãªã©ã®ç†ç”±ã«ã‚ˆã£ã¦ã“ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚

æœ€åˆã®`range_of`ã®ä¾‹ã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆå®šç¾©ã®å¤‰æ›´ã‚’å¿…è¦ã¨ã›ãšã€`concept`ã‚’åˆ©ç”¨å´ã§è¿½åŠ ã™ã‚‹ã“ã¨ã§æœ‰åŠ¹ã«ãªã‚Šã¾ã™ã€‚

```cpp
// Cã‚’æº€ãŸã™è¦ç´ å‹ã«ã‚ˆã‚‹rangeã§ã‚ã‚‹ã“ã¨ã‚’åˆ¶ç´„ã™ã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆ
template <typename R, template <typename> concept C>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>>;

auto f(range_of<std::integral> auto&&);     // ok
auto f(range_of<std::same_as<int>> auto&&); // ng
auto f(range_of<concept std::same_as<int>> auto&&); // ok
```

ã“ã®éƒ¨åˆ†é©ç”¨ã‚³ãƒ³ã‚»ãƒ—ãƒˆãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¯ã€ãã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ãƒ©ãƒƒãƒ—ã—ã¦å¼•æ•°ã‚’éƒ¨åˆ†é©ç”¨ã™ã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ãã®å ´ã§ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã§å®šç¾©ã—ã¦ãã‚Œã‚’ä½¿ç”¨ã™ã‚‹ã‹ã®ã‚ˆã†ã«å‹•ä½œã—ã¾ã™ã€‚

```cpp
template<typename T>
concept invented_same_as = std::same_as<T, int>;

// ã“ã‚Œã¯
auto f(range_of<concept std::same_as<int>> auto&&);

// ã“ã†æ›¸ãã‹ãˆã‚‰ã‚Œã‚‹ã®ã¨ç­‰ã—ã„
auto f(range_of<invented_same_as<int>> auto&&);
```

ã“ã‚Œã«ã‚ˆã£ã¦ã€ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®åŒ…æ‘‚é–¢ä¿‚ã¯éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ¸¡ã—ãŸæ™‚ã§ã‚‚ä¿ãŸã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã“ã®æ›¸ãæ›ãˆä¾‹ã‹ã‚‰ã‚‚åˆ†ã‹ã‚‹ã‚ˆã†ã«ã€éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚³ãƒ³ã‚»ãƒ—ãƒˆã¯ç¬¬äºŒå¼•æ•°ä»¥é™ãŒéƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸã‚‚ã®ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚ã“ã‚Œã¯ã€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®£è¨€æ™‚ãªã©ã«ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ç¬¬ä¸€å¼•æ•°æŒ‡å®šã‚’çœç•¥ã§ãã‚‹æ©Ÿèƒ½ã¨ä¸€è²«ã—ãŸã‚‚ã®ã§ã™ã€‚

```cpp
// ã“ã‚Œã‚‰3ã¤ã®ä¾‹ã®åˆ¶ç´„ã¯å…¨ã¦ç­‰ã—ã„

template<typename T>
void f() requires invocable<T, int>;

template<invocable<int> T>  // TãŒç¬¬ä¸€å¼•æ•°ã«è‡ªå‹•çš„ã«è£œã‚ã‚Œã‚‹
void f();

void f(invocable<int> auto&& f);  // decltype((f))ãŒç¬¬ä¸€å¼•æ•°ã«è‡ªå‹•çš„ã«è£œã‚ã‚Œã‚‹
```

```cpp
// ã“ã®ã‚ˆã†ã«ä½¿ç”¨ã—ãŸã¨ã™ã‚‹ã¨
auto f(range_of<concept invocable<int>> auto&&);

// ã“ã®ã‚ˆã†ãªå³å¸­ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’å®šç¾©ã—ã¦
template<typename T>
concept invented_invocable = invocable<T, int>;

// ã“ã†æ›¸ãã‹ãˆã‚‰ã‚Œã‚‹ã®ã¨ç­‰ã—ã„
auto f(range_of<invented_invocable<int>> auto&&);
```

ã“ã®ãŸã‚ã«ã€ã“ã®éƒ¨åˆ†é©ç”¨ã•ã‚ŒãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’æ¸¡ã™æ©Ÿèƒ½ã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã«é™ã‚‰ã‚Œã¦ãŠã‚Šã€å¤‰æ•°ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãªã©ã§ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ï¼ˆã»ã‹ã®ç¨®é¡ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®å ´åˆã¯ã“ã®ã‚ˆã†ãªè£œå®Œã§æœ‰ç”¨ãªã‚‚ã®ãŒç¢ºç«‹ã•ã‚Œã¦ã„ãªã„ãŸã‚ï¼‰ã€‚

ã¾ãŸã€2ã¤ä»¥ä¸Šã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ®‹ã—ãŸçŠ¶æ…‹ã§éƒ¨åˆ†é©ç”¨ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

ææ¡ˆã•ã‚Œã¦ã„ã‚‹æ–‡è¨€ã‹ã‚‰ã®ä¾‹

```cpp
template <typename T, template <typename> concept... Concepts>
concept all_of = (Concepts<T> && ...);

template <typename, auto>
concept A = true;

template <typename T, typename>
concept C = true;

template <typename... T>
concept D = true;

template <typename>
concept E = true;

void f(all_of<concept C<0>, concept C<int>, concept D<int>> auto); // ok
void f(all_of<concept E<int>> auto);      // error: Eã¯å˜ä¸€ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã—ã‹å–ã‚‰ãªã„ï¼ˆã“ã‚Œä»¥ä¸Šå¼•æ•°ã‚’é©ç”¨ã§ããªã„ï¼‰
void f(all_of<concept C<int, int>> auto); // error: å³å¸­ã‚³ãƒ³ã‚»ãƒ—ãƒˆå†…ã®åˆ¶ç´„å¼ã¯C<T, int, int>ã¨ãªã‚‹ãŒã€ã“ã‚Œã¯æœ‰åŠ¹ãªå¼ã§ã¯ãªã„
```

ã“ã®æ©Ÿèƒ½ã¯P2841R7ã®æ—©æœŸã®ãƒªãƒ“ã‚¸ãƒ§ãƒ³ã§ã¯å«ã¾ã‚Œã¦ææ¡ˆã•ã‚Œã¦ã„ãŸã‚‚ã®ã®ã€C++26ã‚’ç›®æŒ‡ã™ãŸã‚ã«ææ¡ˆã®ã‚¹ã‚³ãƒ¼ãƒ—ã‚’çµã£ãŸã“ã¨ã‚„EWGãŒé‡è¦–ã—ã¦ã„ãªã‹ã£ãŸã“ã¨ã‚‚ã‚ã‚Šã€æœ€çµ‚çš„ãªP2841R7ã§ã¯ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¦ã„ãŸã‚‚ã®ã§ã™ã€‚

- [P2841R7 Concept and variable-template template-parameters -  WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´03æœˆï¼‰](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2841R7-Concept-and-variable-template-template-parameters)
- [P2970 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2304)

### [P2996R12 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r12.html)
### [P3008R5 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r5.html)
### [P3008R5 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r5.html)
### [P3037R6 constexpr std::shared_ptr and friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3037r6.pdf)
### [P3086R4 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3086r4.pdf)
### [P3096R9 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r9.pdf)
### [P3100R2 Implicit contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r2.pdf)
### [P3111R6 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r6.html)
### [P3125R4 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3125r4.html)
### [P3149R10 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r10.html)
### [P3164R4 Early Diagnostics for Sender Expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3164r4.html)
### [P3179R8 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r8.html)
### [P3284R4 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3284r4.html)
### [P3293R2 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3293r2.html)
### [P3310R6 Solving issues introduced by relaxed template template parameter matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3310r6.html)
### [P3347R2 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r2.pdf)
### [P3375R3 Reproducible floating-point results](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3375r3.html)
### [P3385R5 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r5.html)
### [P3394R3 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r3.html)
### [P3395R4 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r4.html)
### [P3402R3 A Safety Profile Verifying Initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3402r3.html)
### [P3411R2 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r2.html)
### [P3412R2 String interpolation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3412r2.pdf)
### [P3439R2 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3439r2.pdf)
### [P3442R2 [[invalidate_dereferencing]] attribute](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3442r2.pdf)
### [P3480R5 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r5.pdf)
### [P3516R2 Uninitialized algorithms for relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r2.html)

ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªAPIã‚’æ•´ç†ã™ã‚‹ææ¡ˆã€‚

P2786R13ã§ã¯ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«é–¢ã™ã‚‹è¨€èªè¦å®šã¨æœ€å°ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªAPIãŒå°å…¥ã•ã‚Œã€P3516ã§ã¯æœªåˆæœŸåŒ–ãƒ¡ãƒ¢ãƒªã«å¯¾ã™ã‚‹ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ãŒææ¡ˆã•ã‚Œã¦ã„ã¾ã™ã€‚P2786ã¯ã™ã§ã«C++26ã«ãƒãƒ¼ã‚¸æ¸ˆã¿ã§ã€P3516ã¯ï¼ˆã“ã®ææ¡ˆãŒæ›¸ã‹ã‚ŒãŸæ™‚ç‚¹ã§ï¼‰LEWGã®è¨­è¨ˆæ‰¿èªã‚’ç²å¾—ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã™ã€‚

ãŸã ã—ã€P3516ã®å°å…¥ã«ã‚ˆã£ã¦P2786ã§å°å…¥ã•ã‚ŒãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªAPIã«ã¯ä¸è¦ã«ãªã‚‹ã‚‚ã®ãŒã‚ã‚‹ãŸã‚æ•´ç†ã®å¿…è¦ãŒèªè­˜ã•ã‚Œã¦ã„ã¾ã—ãŸã€‚ã“ã®ææ¡ˆã¯ãã®æ•´ç†ã‚’è¡Œã†ã‚‚ã®ã§ã™ã€‚

ã“ã®ææ¡ˆç„¡ã—ã®ç¾çŠ¶ã®ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ãƒ©ã‚¤ãƒ–ãƒ©ãƒªAPIã¯æ¬¡ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™

```cpp
// P2786 APIs (in draft)
template <class T>
T* trivially_relocate(T* first, T* last, T* result); // freestanding

template <class T>
constexpr T* relocate(T* first, T* last, T* result); // freestanding

// P3516 APIs (design approved)
template<class T>
 requires relocatable-from<T, T>
  constexpr T* relocate_at(T* dest, T* source)
    noexcept(is_nothrow_relocatable_v<T>);

template<class NoThrowForwardIterator1, class NoThrowForwardIterator2>
  constexpr NoThrowForwardIterator2
    uninitialized_relocate(NoThrowForwardIterator1 first,
                           NoThrowForwardIterator1 last,
                           NoThrowForwardIterator2 result); // freestanding

template<class NoThrowForwardIterator1, class Size, class NoThrowForwardIterator2>
  constexpr pair<NoThrowForwardIterator1, NoThrowForwardIterator2>
    uninitialized_relocate_n(NoThrowForwardIterator1 first,
                             Size n,
                             NoThrowForwardIterator2 result); // freestanding

template<class NoThrowBidirectionalIterator1, class NoThrowBidirectionalIterator2>
  constexpr NoThrowBidirectionalIterator2
    uninitialized_relocate_backward(NoThrowBidirectionalIterator1 first,
                                    NoThrowBidirectionalIterator1 last,
                                    NoThrowBidirectionalIterator2 result); // freestanding

// execution_policyã‚’å–ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
...

namespace ranges {
  // rangeç‰ˆã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
  ...
}
```

ã“ã®ææ¡ˆã§ã¯ã“ã®ã†ã¡`std::relocate()`ã‚’å‰Šé™¤ã—ã‚ˆã†ã¨ã—ã¦ã„ã¾ã™ã€‚

ã“ã®é–¢æ•°ã¯P3516ã§ææ¡ˆã•ã‚Œã¦ã„ã‚‹æœªåˆæœŸåŒ–ãƒ¡ãƒ¢ãƒªã«å¯¾ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ©Ÿèƒ½åˆ¶é™ç‰ˆã§ã‚ã‚Šã€P3516ãŒæå‡ºã•ã‚Œã‚‹ã‚ˆã‚Šã‚‚å‰ã«ç™ºæ˜ã•ã‚Œæ®‹ã•ã‚Œã¦ã„ãŸã‚‚ã®ã§ã™ã€‚ä¸¡è€…ã®é•ã„ã¯`std::relocate()`ãŒå…¥åŠ›ç¯„å›²ã¨å‡ºåŠ›ç¯„å›²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã„ã€å‰æ–¹/å¾Œæ–¹ã®ã©ã¡ã‚‰ã«ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã™ã¹ãã‹ã‚’åˆ¤å®šã™ã‚‹ç‚¹ã«ã‚ã‚Šã¾ã™ãŒã€P3516ã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã¯ãƒªãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã™ã¹ãæ–¹å‘ã®æ±ºå®šã‚’`_backward`ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã§æŒ‡å®šã—ã¦ãŠã‚Šã€ã“ã®APIã¯æ—¢å­˜ã®æœªåˆæœŸåŒ–ãƒ¡ãƒ¢ãƒªã«å¯¾ã™ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã¨ä¸€è²«ã—ã¦ã„ã¾ã™ã€‚

- [P2786R13 Trivial Relocatability For C++26 - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´03æœˆï¼‰](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2786R13-Trivial-Relocatability-For-C26)
- [P3516R1 Uninitialized algorithms for relocation - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´03æœˆï¼‰](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3516R1-Uninitialized-algorithms-for-relocation)
- [P3516 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2193)

### [P3552R2 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r2.pdf)
### [P3556R1 Input files are source files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3556r1.pdf)
### [P3557R2 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r2.html)
### [P3560R1 Error Handling in Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3560r1.html)
### [P3565R1 Virtual floating-point values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3565r1.html)
### [P3566R1 You shall not pass `char*` - Safety concerns working with unbounded null-terminated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3566r1.pdf)
### [P3570R1 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r1.html)
### [P3588R1 Allow static data members in local and unnamed classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3588r1.html)
### [P3589R2 C++ Profiles: The Framework](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3589r2.pdf)
### [P3617R0 `std::meta::reflect_constant_{array,string}`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3617r0.html)

å®šæ•°æ–‡å­—åˆ—ãƒ»é…åˆ—ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™APIã®ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯ä»¥å‰ã«P3491ã§ææ¡ˆã•ã‚Œã¦ã„ãŸ`define_static_string()`/`define_static_array()`ã®æ‹¡å¼µã¨ãªã‚‹æ©Ÿèƒ½ã®ææ¡ˆã§ã™ã€‚

```cpp
// P3491ã§ææ¡ˆã•ã‚Œã¦ã„ã‚‹APIã®ä¸€éƒ¨

template <ranges::input_range R> // only if the value_type is char or char8_t
consteval auto define_static_string(R&& r) -> ranges::range_value_t<R> const*;

template <ranges::input_range R>
consteval auto define_static_array(R&& r) -> span<ranges::range_value_t<R> const>;
```

ã¾ãšã€`define_static_string(r)`ã¯æ–‡å­—ç¯„å›²`r`ã‹ã‚‰é™çš„æ–‡å­—åˆ—ã‚’ä½œæˆã—ãã®å…ˆé ­ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚ã—ã‹ã—ã€ãƒã‚¤ãƒ³ã‚¿ã‚’è¿”ã™ã“ã¨ã«ã‚ˆã£ã¦C++20ã‹ã‚‰ã®NTTPæ–‡å­—åˆ—ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ä½¿ç”¨ã§ããªã„å•é¡ŒãŒæŒ‡æ‘˜ã•ã‚Œã¾ã—ãŸ

```cpp
// NTTPã§ä½¿ç”¨å¯èƒ½ãªå›ºå®šé•·æ–‡å­—åˆ—å‹
template <size_t N>
struct FixedString {
  char data[N] = {};

  constexpr FixedString(char const(&str)[N]) {
    std::ranges::copy(str, str+N, data);
  }
};

template <FixedString S>
struct Test { };
```

ã“ã‚Œã®ä½¿ç”¨ä¾‹ã¨å•é¡Œã®ä¾‹ã¯ã¤ãã®ã‚‚ã®ã§ã™

```cpp
using A = Test<"foo">;  // okã€æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã¯ãã®ã¾ã¾æ¸¡ã›ã‚‹
using B = [: substitute(^^Test, {reflect_constant("foo"sv)}) :];  // ngã€string_viewã¯NTTPã¨ã—ã¦ä½¿ç”¨ã§ããªã„
using C = Test<define_static_string("foo")>;  // ngã€define_static_string()ã®æˆ»ã‚Šå€¤ã‹ã‚‰ã ã¨é•·ã•ãŒå–å¾—ã§ããªã„
using D = [: substitute(^^Test, {reflect_constant(define_static_string("foo"))}) :];  // ngã€åŒã˜ãé•·ã•ãŒå–å¾—ã§ããªã„
```

`substitute(template_refr, refle...)`ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³`template_refr`ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå¼•æ•°ã«å¯¾ã—ã¦`refle...`ã‚’é †ç•ªã«å¼•æ•°ã¨ã—ã¦ä¸ãˆã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã—ãŸã‚‚ã®ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ã‚‚ã®ã§ã€`reflect_constant(arg)`ã¯`arg`ã«ã‚ˆã‚‹å®šæ•°ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ã‚‚ã®ã§ã™ã€‚

ã“ã“ã§ã¯ã€`substitute()`ã®æˆ»ã‚Šå€¤ã‚’ã‚¹ãƒ—ãƒ©ã‚¤ã‚¹ï¼ˆ`[: refl :]`ï¼‰ã™ã‚‹ã“ã¨ã§ã‚¯ãƒ©ã‚¹å‹ï¼ˆã“ã“ã§ã¯ã™ã¹ã¦`Test<"...">`å‹ï¼‰ã¨ã—ã¦å®šç¾©ã—ã‚ˆã†ã¨ã¦ã„ã¾ã™ã€‚

ã—ã‹ã—ã€ç¾çŠ¶ã§ã¯`A`ä»¥å¤–ã¯å…¨ã¦ã‚¨ãƒ©ãƒ¼ã¨ãªã‚Šã¾ã™ã€‚`define_static_string()`ã®å•é¡Œç‚¹ã¯æ–‡å­—åˆ—ãƒã‚¤ãƒ³ã‚¿ï¼ˆ`const char*`ï¼‰ã‚’è¿”ã™ãŸã‚ã«`FixedString`ã®CTADã«å¤±æ•—ï¼ˆæ–‡å­—åˆ—é…åˆ—`char[N]`ã§ã¯ãªã„ãŸã‚ï¼‰ã™ã‚‹ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚ã“ã“ã§é‡è¦ãªã“ã¨ã¯ã€`substitute`ã¨ã‚¹ãƒ—ãƒ©ã‚¤ã‚¹ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ã‚ˆã†ã«ã€ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦ã“ã®`Test`å‹ã®å®Ÿä½“ã‚’ç”Ÿæˆã™ã‚‹ã€ã‚ˆã†ãªç”Ÿæˆã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‘ãªã„ã“ã¨ã«ã‚ã‚Šã¾ã™ã€‚

æ¬¡ã«ã€`define_static_array(r)`ã¯ç¯„å›²`r`ã‹ã‚‰é™çš„é…åˆ—ã‚’ä½œæˆã—ãã®å‚ç…§ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚

```cpp
template <class T>
auto f(const T& var) -> void {
  template for (constexpr auto M : define_static_array(nsdms(^^T))) {
    do_something_with(var.[:M:]);
  }
}
```

`nsdms(class_refl)`ã¯ã‚¯ãƒ©ã‚¹å‹ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³`class_refl`ã‹ã‚‰éé™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é…åˆ—ï¼ˆ`std::vector<std::meta::info>`ï¼‰ã‚’å¾—ã‚‹ã‚‚ã®ã§ã™ï¼ˆãŠãã‚‰ãP2996R12ã®`nonstatic_data_members_of()`ã®ç•¥è¨˜ï¼‰ã€‚å±•é–‹ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã¯ãã®å‡¦ç†ã®éƒ½åˆä¸Š`nsdms()`ã®è¿”ã™`std::vector`ã‚’ç›´æ¥ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ããªã„ãŸã‚ã€`define_static_array()`ã‚’é€šã—ã¦é™çš„é…åˆ—ã«å¤‰æ›ã—ã¦å±•é–‹ã—ã¦ã„ã¾ã™ï¼ˆã“ã®ã‚ˆã†ãªä½¿ã„æ–¹ãŒP3491ã®ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ï¼‰ã€‚

ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`f()`å†…éƒ¨ã§`T`ã®éé™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°å…¨ã¦ã«ã‚ˆã£ã¦`do_something_with()`ã‚’å‘¼ã³å‡ºã—ã¦ã„ãã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¾ã™ã€‚

ã—ã‹ã—ã€åˆ¥ã®çŠ¶æ³ã§ã¯1ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆå†…ã§å…¨ã¦ã®ãƒ¡ãƒ³ãƒï¼ˆ`nsdms(^^T)`ã®æˆ»ã‚Šå€¤ï¼‰ã‚’å‡¦ç†ã—ãŸã„å ´åˆãŒã‚ã‚Šã¾ã™ã€‚å±•é–‹ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã¯ãã®ãƒ«ãƒ¼ãƒ—ã®çµæœã¨ã—ã¦ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ç”Ÿæˆã—ã¦ã„ããŸã‚ã€ã“ã®ã‚ˆã†ãªç”¨é€”ã«ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ã“ã®å ´åˆã€C++26ã‹ã‚‰ã®ä»•æ§˜ã§ã‚ã‚‹æ§‹é€ åŒ–æŸç¸›ã®ãƒ‘ãƒƒã‚¯å°å…¥ã¨`constexpr`æ§‹é€ åŒ–æŸç¸›ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã‚·ãƒ³ãƒ—ãƒ«ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
// ææ¡ˆæ–‡æ›¸ã‚ˆã‚Šã€é…åˆ—ã®æ§‹é€ ä½“ã‚¯ãƒ©ã‚¹ã®ä¾‹
template <class T>
struct SoaVector {
  // é…åˆ—ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
  Pointers pointers_;
  ...
  
  // Pointerså‹ã®éé™çš„ãƒ¡ãƒ³ãƒï¼ˆ=å„é…åˆ—ï¼‰ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆ—æŒ™
  // ã“ã‚Œã¯`span<const info>`å‹ã«ãªã‚‹
  static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
  ...

  auto operator[](size_t idx) const -> T {
    // æ§‹é€ åŒ–æŸç¸›ã§ã®ãƒ‘ãƒƒã‚¯å°å…¥ã¨constexpræ§‹é€ åŒ–æŸç¸›
    constexpr auto [...M] = [: ptr_mems :]; // ngã€spanã‚’ãƒ‘ãƒƒã‚¯ã«å±•é–‹ã§ããªã„

    // ãƒ¡ãƒ³ãƒé…åˆ—ã‹ã‚‰idxç•ªç›®ã®è¦ç´ ã‚’å¼•ãå½“ã¦ã¦é…åˆ—ã§è¿”ã™
    // ç•³ã¿è¾¼ã¿å¼ã«ã‚ˆã£ã¦ä¸€æ–‡ã§å±•é–‹ã™ã‚‹
    return T{pointers_.[:M:][idx]...};
  }
};
```

ã—ã‹ã—ã€`define_static_array()`ã¯ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é…åˆ—ã®å‚ç…§ï¼ˆ`span<const info>`ï¼‰ã‚’è¿”ã—ã¦ã—ã¾ã„ã€ã“ã‚Œã¯ãƒ‘ãƒƒã‚¯ã«å¤‰æ›ã§ããªã„ãŸã‚ã€ã“ã®ç”¨é€”ã«ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚å¿…è¦ãªã®ã¯ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®é…åˆ—ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå‹ã¨ã—ã¦ã¯`info`ã«ãªã‚‹ï¼‰ã‚’è¿”ã™ä½•ã‹ã§ã™ãŒã€P3491ã«ã¯ãã‚Œã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ã“ã®ææ¡ˆã¯ã€P3491ã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ã¤ã¤ã“ã‚Œã‚‰2ã¤ã®ç”¨é€”ã«æ²¿ã†ã‚ˆã†ãªAPIã‚’è¿½åŠ ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

```cpp
// P3491ã§ææ¡ˆã•ã‚Œã¦ã„ã‚‹APIã®ä¸€éƒ¨

template <ranges::input_range R> // only if the value_type is char or char8_t
consteval auto define_static_string(R&& r) -> ranges::range_value_t<R> const*;

template <ranges::input_range R>
consteval auto define_static_array(R&& r) -> span<ranges::range_value_t<R> const>;

// ã“ã®ææ¡ˆã®API

template <ranges::input_range R>
consteval info reflect_constant_string(R&& r);

template <ranges::input_range R>
consteval info reflect_constant_array(R&& r);
```

ã©ã¡ã‚‰ã‚‚ã€å—ã‘å–ã£ãŸç¯„å›²`r`ã‹ã‚‰ç”Ÿæˆã—ãŸå®šæ•°æ–‡å­—åˆ—/é…åˆ—ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã‚‰ã®é–¢æ•°ã‚’ç”¨ã„ã‚‹ã¨å…ˆã»ã©å•é¡Œã¨ã—ã¦æŒ™ã’ãŸä¾‹ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«è§£æ¶ˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

å›ºå®šé•·æ–‡å­—åˆ—ã‚¯ãƒ©ã‚¹å‹ã®NTTPã‚’ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã£ã¦ç”Ÿæˆã™ã‚‹ä¾‹

```cpp
using E = Test<[:reflect_constant_string("foo"):]>; // ok
using F = [:substitute(^^Test, {reflect_constant_string("foo")}):]; // ok
```

`reflect_constant_string()`ã¯å®šæ•°æ–‡å­—åˆ—ã¸ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¿”ã™ãŸã‚ã€ãã‚Œã‚’ç”¨ã„ã¦`Test`å‹ã‚’ç”Ÿæˆã™ã‚‹ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’è¨˜è¿°ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

`SoaVector`ã®æ·»ãˆå­—æ¼”ç®—å­ã®å®Ÿè£…ä¾‹

```cpp
// ææ¡ˆæ–‡æ›¸ã‚ˆã‚Šã€é…åˆ—ã®æ§‹é€ ä½“ã‚¯ãƒ©ã‚¹ã®ä¾‹
template <class T>
struct SoaVector {
  // é…åˆ—ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
  Pointers pointers_;
  ...
  
  // Pointerså‹ã®éé™çš„ãƒ¡ãƒ³ãƒï¼ˆ=å„é…åˆ—ï¼‰ã®ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’åˆ—æŒ™
  // ã“ã‚Œã¯`std::array<info, N>`å‹ã«ãªã‚‹
  static constexpr auto ptr_mems = reflect_constant_array(nsdms(^^Pointers)); // ğŸ‘ˆ
  ...

  auto operator[](size_t idx) const -> T {
    // æ§‹é€ åŒ–æŸç¸›ã§ã®ãƒ‘ãƒƒã‚¯å°å…¥ã¨constexpræ§‹é€ åŒ–æŸç¸›
    constexpr auto [...M] = [: ptr_mems :]; // okã€std::arrayã¯ã‚¿ãƒ—ãƒ«ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã«ã‚ˆã£ã¦ãƒ‘ãƒƒã‚¯ã¸å¤‰æ›ã§ãã‚‹

    // ãƒ¡ãƒ³ãƒé…åˆ—ã‹ã‚‰idxç•ªç›®ã®è¦ç´ ã‚’å¼•ãå½“ã¦ã¦é…åˆ—ã§è¿”ã™
    // ç•³ã¿è¾¼ã¿å¼ã«ã‚ˆã£ã¦ä¸€æ–‡ã§å±•é–‹ã™ã‚‹
    return T{pointers_.[:M:][idx]...};
  }
};
```

`define_static_array()`ãŒãã†ã ã£ãŸã‚ˆã†ã«ã€ã“ã®é–¢æ•°ã‚‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç‰¹åˆ¥ãªã‚µãƒãƒ¼ãƒˆã‚’å¿…è¦ã¨ã›ãšã«æ‰‹æ›¸ãã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã‚‚ã€`define_static_array()`ã®å®Ÿè£…ã‚’å°‘ã—ç§»å‹•ã™ã‚‹ã ã‘ã§ã‚ˆãã€æ–‡è¨€ã®å¤‰æ›´çš„ã«ã‚‚å°‘ãªãæ¸ˆã¿ã¾ã™ã€‚

```cpp
template <typename T, T... Vs>
inline constexpr T __fixed_array[sizeof...(Vs)]{Vs...};

template <ranges::input_range R>
consteval auto reflect_constant_array(R&& r) -> meta::info {
  auto args = vector<meta::info>{
    ^^ranges::range_value_t<R>};
  for (auto&& elem : r) {
    args.push_back(meta::reflect_constant(elem));
  }
  return substitute(^^__fixed_array, args);
}

template <ranges::input_range R>
consteval auto define_static_array(R&& r)
    -> span<ranges::range_value_t<R> const>
{
  using T = ranges::range_value_t<R>;

  // produce the array
  auto array = reflect_constant_array(r);

  // turn the array into a span
  return span<T const>(
      extract<T const*>(array),
      extent(type_of(array)));
}
```

ã—ãŸãŒã£ã¦C++26ã«å¿…é ˆã®æ©Ÿèƒ½ã¨ã„ã†ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãã‚Œã§ã‚‚ã€ã“ã®ã‚ˆã†ãªã‚‚ã®ã¯äººã€…ãŒå†ç™ºæ˜ã™ã‚‹ã“ã¨ãŒæƒ³å®šã§ãã‚‹ã“ã¨ã‚„ã€P3491ã®æ–‡è¨€ã‚’ãƒ™ãƒ¼ã‚¹ã«å°ã•ãªå¤‰æ›´ã§æ¸ˆã‚€ã“ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æ”¯æ´ã«ã‚ˆã£ã¦`__fixed_array`ã®ã‚ˆã†ãªãƒãƒƒã‚¯é…åˆ—ã‚’ï¼ˆæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚„`initializer_list`ã®ã‚ˆã†ã«ï¼‰å…±é€šåŒ–ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ãªã©ã®ç†ç”±ã«ã‚ˆã‚ŠC++26ã®æ©Ÿèƒ½ã¨ã—ã¦ææ¡ˆã—ã¦ã„ã¾ã™ã€‚

ã“ã®ææ¡ˆã¯EWGã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§æ‰¿èªã•ã‚Œã€P3491R2ã«ãƒãƒ¼ã‚¸ã•ã‚Œã¦ã„ã¾ã™ã€‚ãã—ã¦ã€P3492R3ã¯6æœˆå…¨ä½“ä¼šè­°ã§æ‰¿èªã•ã‚ŒC++26ã«ãƒãƒ¼ã‚¸ã•ã‚Œã¦ã„ã¾ã™ã€‚

- [P3491R2 `define_static_{string,object,array}` - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´03æœˆï¼‰](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3491R2-define_static_stringobjectarray)
- [P3617 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2305)

### [P3631R0 Cleaning up the trivial relocation APIs in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3631r0.html)
### [P3649R0 A principled approach to safety profiles](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3649r0.html)
### [P3655R1 zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r1.html)
### [P3658R1 Adjust identifier following new Unicode recommendations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3658r1.pdf)
### [P3663R1 Future-proof `submdspan-mapping`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r1.html)
### [P3668R1 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r1.html)
### [P3669R1 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r1.html)
### [P3670R1 Pack Indexing for Template Names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3670r1.pdf)
### [P3676R0 Enhanced inline Keyword with Configurable Inlining Levels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3676r0.pdf)
### [P3677R0 Preserving LC_CTYPE at program start for UTF-8 locales](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3677r0.pdf)
### [P3678R0 Arbitrary attributes in define_aggregate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3678r0.html)
### [P3679R0 SFINAEable constexpr exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3679r0.html)
### [P3681R0 char_traits: Stop the bleeding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3681r0.pdf)
### [P3682R0 Remove std::execution::split](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3682r0.pdf)
### [P3685R0 Rename async_scope_token](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3685r0.pdf)
### [P3686R0 Allow named modules to export macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3686r0.html)
### [P3687R0 Final Adjustments to C++26 Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3687r0.html)
### [P3688R0 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r0.html)
### [P3689R0 Convenience functions for Random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3689r0.pdf)
### [P3690R0 Consistency fix: Make simd reductions SIMD-generic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3690r0.pdf)
### [P3691R0 Reconsider naming of the namespace for â€œstd::simdâ€](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3691r0.pdf)
### [P3692R0 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r0.pdf)
### [P3693R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2025/04/09-2025/05/07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3693r0.pdf)
### [P3694R0 SG19: Machine Learning virtual Meeting Minutes to 2025/03/13-2025/05/08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3694r0.pdf)
### [P3695R0 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r0.html)
### [P3696R0 Discovering Header Units via Module Maps](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3696r0.html)
### [P3697R0 Minor additions to C++26 standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3697r0.html)
### [P3698R0 Cross-capacity comparisons for inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3698r0.html)
### [P3699R0 Rename `conqueue_errc`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3699r0.html)
### [P3700R0 Making Safe C++ happen](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3700r0.html)
### [P3701R0 Concepts for integer types, not integral types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3701r0.html)
### [P3702R0 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r0.html)
### [P3703R0 Constness and Locking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3703r0.pdf)
### [P3704R0 What are profiles?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3704r0.pdf)
### [P3705R0 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r0.html)
### [P3706R0 Rename join and nest in async_scope proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3706r0.html)
### [P3707R0 A std::is_always_exhaustive trait](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3707r0.pdf)
### [P3709R0 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r0.html)
### [P3710R0 zstring_view: a string_view with guaranteed null termination](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3710r0.pdf)
### [P3711R0 Safer StringViewLike Functions for Replacing char* strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3711r0.pdf)
### [P3712R0 2025-05 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3712r0.html)
### [P3714R0 Virtual values have Virtual Value](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3714r0.pdf)
### [P3715R0 Tightening floating-point semantics for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3715r0.html)
### [P3716R0 Subsetting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3716r0.html)
### [P3717R0 Update Annex E onto Unicode 16](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3717r0.pdf)
