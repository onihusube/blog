# ［C++］WG21月次提案文書を眺める（2025年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-05)

全部で99本あります。

もくじ

[:contents]

### [N5010 WG21 agenda: 16-21 June 2025, Sofia Bulgaria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5010.html)

2025年6月にソフィア（ブルガリア）で行われる会議のアジェンダ。

### [P0085R1 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r1.html)

8進リテラルの新しいプリフィックスの提案。

現在の8進リテラルの構文では、`0`始まりの数値リテラルが8進リテラルとして認識されます。

```cpp
01234; // 8進リテラル
0;     // 8進リテラル
08;    // ng、8は8進数値として無効
```

ただ、この構文は初学者にとって間違えやすいことが指摘されています。例えば、10進リテラルの整数値を幅をそろえるなどの目的で先頭に0パディングしてしまったときでもエラーにはならず、8進リテラルとして解釈されることで整数値が変化します。

```cpp
 12340; // 10進リテラル
012340; // 8進リテラル
```

この提案はこのような構文を修正するために、8進リテラルの新しいプリフィックスとして`0o`/`0O`を追加するとともに、現在の8進リテラルプリフィックスを非推奨にするものです。

```cpp
// この提案の8進リテラル
0o1234;
0O1234;
```

この構文はHaskellやPythonなどを始めとする他言語で採用されているものと同様で、現在8進数値リテラルの構文とデファクトとなりつつあります。また、16進リテラルや2進リテラルのプリフィックスと整合しています。

```cpp
0b00101010; // 2進リテラル
0o52;       // 8進リテラル
0x2A;       // 16進リテラル
```

Cの8進リテラルもC++の現在のものと同様の構文を取っていますが、これはすでに非推奨化されており、廃止予定とされています。C++でもこれに倣って、まず非推奨化してコンパイラの警告を促し、将来的に廃止することを目指します。

この修正は基本的に後方互換性を維持するものですが、一つ非互換な変更となる部分があります。それは`std::format()`で整数値を8進出力した時のフォーマット結果で、`#o`オプションによって基数プリフィックスを表示させるようにしたときの結果が構文と一貫しなくなるというものです。

```cpp
std::println("{:o}", 0o77);  // 8進出力
std::println("{:#o}", 0o77); // 基数プリフィックス付き8進出力
                             // `#O`はない
std::println("{:#x}", 0x3f); // 基数プリフィックス付き16進出力（小文字）
std::println("{:#X}", 0x3f); // 基数プリフィックス付き16進出力（大文字）
```
```
77
077
0x3f
0X3F
```

特にこの提案の後で、この出力は16進の場合（`#X`だとプリフィックスが`0X`になる）と一貫しなくなります（`#O`オプションが無いため）。

この提案では、オプションはそのままとして`#o`オプションの出力結果のプリフィックスを`0o`に変更することを推奨しています（提案にはしていません）。これは破壊的変更になりますが、Githubの検索では利用頻度が低いので問題ない可能性があるとしています。また、代替のオプションを4つ提示しています。

- [N3353 Obsolete implicitly octal literals and add delimited escape sequences](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3353.htm)
- [P0085 進行状況](https://github.com/cplusplus/papers/issues/2055)

### [P0149R2 Generalised member pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0149r2.pdf)
### [P0149R3 Generalised member pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0149r3.pdf)
### [P1144R13 std::is_trivially_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1144r13.html)
### [P1306R4 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1306r4.html)
### [P2079R8 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r8.html)
### [P2287R5 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2287r5.html)
### [P2414R7 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r7.pdf)
### [P2434R4 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2434r4.html)
### [P2509R1 A proposal for a type trait to detect value-preserving conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2509r1.html)
### [P2664R10 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2664r10.html)
### [P2719R5 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r5.html)
### [P2902R2 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2902r2.pdf)
### [P2927R3 Observing exceptions stored in exception_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2927r3.html)
### [P2956R1 Add saturating library support to std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2956r1.html)
### [P2970R0 Partial application of concepts in template arguments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2970r0.pdf)

コンセプトテンプレートパラメータで、部分適用されたコンセプトを受け入れるようにする提案。

C++26では、コンセプトテンプレートパラメータによってコンセプトそのものをテンプレート引数に渡すことができるようになっています。しかし、渡せるのはその引数を埋める前のコンセプトそのものであり、何かしらの引数が部分適用されたコンセプトを渡すことはできません。

```cpp
// Cを満たす要素型によるrangeであることを制約するコンセプト
template <typename R, template <typename> concept C>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>>;

auto f(range_of<std::integral> auto&&);     // ok
auto f(range_of<std::same_as<int>> auto&&); // ng
```

コンセプトテンプレートパラメータ`C`には引数適用前のコンセプトを渡すことしかできません。

これに対処する一つの方法としては、`range_of`コンセプトの定義をこれを考慮して変更することができます。

```cpp
template <typename R, template <typename...> concept C, typename... Args>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>, Args...>;

void f(range_of<std::same_as, int> auto&&);
```

`C`に渡すテンプレート引数を別に受け取るようにして、内部で適用するようにしています。しかし、これはコンセプトの定義でテクニックが必要になるとともに、引数の意味が明確ではなく、要素型に対する制約を複数取れるように`range_of`を拡張する方向性を閉ざしてしまいます。

別の方法として、コンセプトテンプレートパラメータとその引数を別の型を経由して渡すようにする方法も考えられます。

```cpp
template <template <typename...> concept C, typename... Args>
struct packed_concept {
  template <typename T>
  static constexpr bool apply = C<T, Args...>;
};

template <typename R, typename... PackedConcept>
concept range_of = std::ranges::range<R> && (PackedConcept::template apply<std::ranges::range_value_t<R>> && ...);

void f(range_of<packed_concept<std::convertible_to, int>, packed_concept<std::regular>> auto&&);
```

こちらの場合は要素型に対する制約の合成がサポートされているものの、先ほどの方法と比較しても可読性が低下しており、包摂関係の成立を妨げるようになっています。

結局、最初の例にあったような部分適用されたコンセプトをそのまま渡すことができれば一番使いやすくなるとして、ここではそれを提案しています。ただし、部分適用されたコンセプトを渡す構文は、`concept`の指定が必要になります。

```cpp
// コンセプトテンプレートパラメータを受け取る何らかのテンプレートとする
some_template_name <
  std::regular,           // コンセプトを渡す（C++26
  concept regular<>,      // 0引数が部分適用されたコンセプトを渡す（この提案
  invocable<int>,         // コンセプトの結果のbool値が渡される（診断されるはず
  concept invocable<int>  // 1引数が部分適用されたコンセプトを渡す（この提案
>;
```

このように、部分適用されたコンセプトを渡す際は渡す側で`concept`の指定が必要になります。

これは、可変長引数を取るコンセプトでは`bool`値を渡そうとしているのか部分適用されたコンセプトを渡そうとしているのかが曖昧となり、無理やり推定しようとすると既存のコードを壊してしまう可能性があるほか、将来の機能としてのユニバーサルテンプレートパラメータが来た場合に推定が曖昧になることが予想される、などの理由によってこのようになっています。

最初の`range_of`の例はコンセプト定義の変更を必要とせず、`concept`を利用側で追加することで有効になります。

```cpp
// Cを満たす要素型によるrangeであることを制約するコンセプト
template <typename R, template <typename> concept C>
concept range_of = std::ranges::range<R> && C<std::ranges::range_value_t<R>>;

auto f(range_of<std::integral> auto&&);     // ok
auto f(range_of<std::same_as<int>> auto&&); // ng
auto f(range_of<concept std::same_as<int>> auto&&); // ok
```

この部分適用コンセプトテンプレートパラメータは、そのコンセプトをラップして引数を部分適用するコンセプトをその場でインラインで定義してそれを使用するかのように動作します。

```cpp
template<typename T>
concept invented_same_as = std::same_as<T, int>;

// これは
auto f(range_of<concept std::same_as<int>> auto&&);

// こう書きかえられるのと等しい
auto f(range_of<invented_same_as<int>> auto&&);
```

これによって、コンセプトの包摂関係は部分適用されたコンセプトを渡した時でも保たれるようになります。

この書き換え例からも分かるように、部分適用されたコンセプトは第二引数以降が部分適用されたものとして扱われます。これは、テンプレートパラメータ宣言時などにコンセプトの第一引数指定を省略できる機能と一貫したものです。

```cpp
// これら3つの例の制約は全て等しい

template<typename T>
void f() requires invocable<T, int>;

template<invocable<int> T>  // Tが第一引数に自動的に補われる
void f();

void f(invocable<int> auto&& f);  // decltype((f))が第一引数に自動的に補われる
```

```cpp
// このように使用したとすると
auto f(range_of<concept invocable<int>> auto&&);

// このような即席コンセプトを定義して
template<typename T>
concept invented_invocable = invocable<T, int>;

// こう書きかえられるのと等しい
auto f(range_of<invented_invocable<int>> auto&&);
```

このために、この部分適用されたテンプレートを渡す機能はコンセプトに限られており、変数テンプレートなどでは利用できません（ほかの種類のテンプレートの場合はこのような補完で有用なものが確立されていないため）。

また、2つ以上のテンプレートパラメータを残した状態で部分適用することはできません。

提案されている文言からの例

```cpp
template <typename T, template <typename> concept... Concepts>
concept all_of = (Concepts<T> && ...);

template <typename, auto>
concept A = true;

template <typename T, typename>
concept C = true;

template <typename... T>
concept D = true;

template <typename>
concept E = true;

void f(all_of<concept C<0>, concept C<int>, concept D<int>> auto); // ok
void f(all_of<concept E<int>> auto);      // error: Eは単一のテンプレート引数しか取らない（これ以上引数を適用できない）
void f(all_of<concept C<int, int>> auto); // error: 即席コンセプト内の制約式はC<T, int, int>となるが、これは有効な式ではない
```

この機能はP2841R7の早期のリビジョンでは含まれて提案されていたものの、C++26を目指すために提案のスコープを絞ったことやEWGが重視していなかったこともあり、最終的なP2841R7ではドロップされていたものです。

- [P2841R7 Concept and variable-template template-parameters -  WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2841R7-Concept-and-variable-template-template-parameters)
- [P2970 進行状況](https://github.com/cplusplus/papers/issues/2304)

### [P2996R12 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r12.html)
### [P3008R5 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r5.html)
### [P3008R5 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r5.html)
### [P3037R6 constexpr std::shared_ptr and friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3037r6.pdf)
### [P3086R4 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3086r4.pdf)
### [P3096R9 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r9.pdf)
### [P3100R2 Implicit contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r2.pdf)
### [P3111R6 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r6.html)
### [P3125R4 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3125r4.html)
### [P3149R10 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r10.html)
### [P3164R4 Early Diagnostics for Sender Expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3164r4.html)
### [P3179R8 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r8.html)
### [P3284R4 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3284r4.html)
### [P3293R2 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3293r2.html)
### [P3310R6 Solving issues introduced by relaxed template template parameter matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3310r6.html)
### [P3347R2 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r2.pdf)
### [P3375R3 Reproducible floating-point results](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3375r3.html)
### [P3385R5 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r5.html)
### [P3394R3 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r3.html)
### [P3395R4 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r4.html)
### [P3402R3 A Safety Profile Verifying Initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3402r3.html)
### [P3411R2 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r2.html)
### [P3412R2 String interpolation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3412r2.pdf)
### [P3439R2 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3439r2.pdf)
### [P3442R2 [[invalidate_dereferencing]] attribute](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3442r2.pdf)
### [P3480R5 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r5.pdf)
### [P3516R2 Uninitialized algorithms for relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r2.html)

リロケーション関連のライブラリAPIを整理する提案。

P2786R13ではリロケーションに関する言語規定と最小のライブラリAPIが導入され、P3516では未初期化メモリに対するリロケーションアルゴリズムが提案されています。P2786はすでにC++26にマージ済みで、P3516は（この提案が書かれた時点で）LEWGの設計承認を獲得しているようです。

ただし、P3516の導入によってP2786で導入されたライブラリAPIには不要になるものがあるため整理の必要が認識されていました。この提案はその整理を行うものです。

この提案無しの現状のリロケーション関連ライブラリAPIは次のようになっています

```cpp
// P2786 APIs (in draft)
template <class T>
T* trivially_relocate(T* first, T* last, T* result); // freestanding

template <class T>
constexpr T* relocate(T* first, T* last, T* result); // freestanding

// P3516 APIs (design approved)
template<class T>
 requires relocatable-from<T, T>
  constexpr T* relocate_at(T* dest, T* source)
    noexcept(is_nothrow_relocatable_v<T>);

template<class NoThrowForwardIterator1, class NoThrowForwardIterator2>
  constexpr NoThrowForwardIterator2
    uninitialized_relocate(NoThrowForwardIterator1 first,
                           NoThrowForwardIterator1 last,
                           NoThrowForwardIterator2 result); // freestanding

template<class NoThrowForwardIterator1, class Size, class NoThrowForwardIterator2>
  constexpr pair<NoThrowForwardIterator1, NoThrowForwardIterator2>
    uninitialized_relocate_n(NoThrowForwardIterator1 first,
                             Size n,
                             NoThrowForwardIterator2 result); // freestanding

template<class NoThrowBidirectionalIterator1, class NoThrowBidirectionalIterator2>
  constexpr NoThrowBidirectionalIterator2
    uninitialized_relocate_backward(NoThrowBidirectionalIterator1 first,
                                    NoThrowBidirectionalIterator1 last,
                                    NoThrowBidirectionalIterator2 result); // freestanding

// execution_policyを取るオーバーロード
...

namespace ranges {
  // range版オーバーロード
  ...
}
```

この提案ではこのうち`std::relocate()`を削除しようとしています。

この関数はP3516で提案されている未初期化メモリに対するアルゴリズムの機能制限版であり、P3516が提出されるよりも前に発明され残されていたものです。両者の違いは`std::relocate()`が入力範囲と出力範囲のオーバーラップチェックを行い、前方/後方のどちらにリロケーションすべきかを判定する点にありますが、P3516のアルゴリズムではリロケーションすべき方向の決定を`_backward`オーバーロードで指定しており、このAPIは既存の未初期化メモリに対するアルゴリズムと一貫しています。

- [P2786R13 Trivial Relocatability For C++26 - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2786R13-Trivial-Relocatability-For-C26)
- [P3516R1 Uninitialized algorithms for relocation - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3516R1-Uninitialized-algorithms-for-relocation)
- [P3516 進行状況](https://github.com/cplusplus/papers/issues/2193)

### [P3552R2 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r2.pdf)
### [P3556R1 Input files are source files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3556r1.pdf)
### [P3557R2 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r2.html)
### [P3560R1 Error Handling in Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3560r1.html)
### [P3565R1 Virtual floating-point values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3565r1.html)
### [P3566R1 You shall not pass `char*` - Safety concerns working with unbounded null-terminated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3566r1.pdf)
### [P3570R1 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r1.html)
### [P3588R1 Allow static data members in local and unnamed classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3588r1.html)
### [P3589R2 C++ Profiles: The Framework](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3589r2.pdf)
### [P3617R0 `std::meta::reflect_constant_{array,string}`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3617r0.html)

定数文字列・配列のリフレクションを返すAPIの提案。

この提案は以前にP3491で提案されていた`define_static_string()`/`define_static_array()`の拡張となる機能の提案です。

```cpp
// P3491で提案されているAPIの一部

template <ranges::input_range R> // only if the value_type is char or char8_t
consteval auto define_static_string(R&& r) -> ranges::range_value_t<R> const*;

template <ranges::input_range R>
consteval auto define_static_array(R&& r) -> span<ranges::range_value_t<R> const>;
```

まず、`define_static_string(r)`は文字範囲`r`から静的文字列を作成しその先頭ポインタを返す関数です。しかし、ポインタを返すことによってC++20からのNTTP文字列のパターンで使用できない問題が指摘されました

```cpp
// NTTPで使用可能な固定長文字列型
template <size_t N>
struct FixedString {
  char data[N] = {};

  constexpr FixedString(char const(&str)[N]) {
    std::ranges::copy(str, str+N, data);
  }
};

template <FixedString S>
struct Test { };
```

これの使用例と問題の例はつぎのものです

```cpp
using A = Test<"foo">;  // ok、文字列リテラルはそのまま渡せる
using B = [: substitute(^^Test, {reflect_constant("foo"sv)}) :];  // ng、string_viewはNTTPとして使用できない
using C = Test<define_static_string("foo")>;  // ng、define_static_string()の戻り値からだと長さが取得できない
using D = [: substitute(^^Test, {reflect_constant(define_static_string("foo"))}) :];  // ng、同じく長さが取得できない
```

`substitute(template_refr, refle...)`はテンプレートのリフレクション`template_refr`のテンプレート引数に対して`refle...`を順番に引数として与えてインスタンス化したもののリフレクションを返すもので、`reflect_constant(arg)`は`arg`による定数のリフレクションを返すものです。

ここでは、`substitute()`の戻り値をスプライス（`[: refl :]`）することでクラス型（ここではすべて`Test<"...">`型）として定義しようとています。

しかし、現状では`A`以外は全てエラーとなります。`define_static_string()`の問題点は文字列ポインタ（`const char*`）を返すために`FixedString`のCTADに失敗（文字列配列`char[N]`ではないため）することにあります。ここで重要なことは、`substitute`とスプライスを使用しているように、リフレクションによってこの`Test`型の実体を生成する、ような生成コードを書けないことにあります。

次に、`define_static_array(r)`は範囲`r`から静的配列を作成しその参照を返す関数です。

```cpp
template <class T>
auto f(const T& var) -> void {
  template for (constexpr auto M : define_static_array(nsdms(^^T))) {
    do_something_with(var.[:M:]);
  }
}
```

`nsdms(class_refl)`はクラス型のリフレクション`class_refl`から非静的メンバ変数のリフレクションの配列（`std::vector<std::meta::info>`）を得るものです（おそらくP2996R12の`nonstatic_data_members_of()`の略記）。展開ステートメントはその処理の都合上`nsdms()`の返す`std::vector`を直接イテレーションできないため、`define_static_array()`を通して静的配列に変換して展開しています（このような使い方がP3491のモチベーションです）。

このコードでは、`f()`内部で`T`の非静的メンバ変数全てによって`do_something_with()`を呼び出していくコードを生成します。

しかし、別の状況では1ステートメント内で全てのメンバ（`nsdms(^^T)`の戻り値）を処理したい場合があります。展開ステートメントはそのループの結果としてステートメントを生成していくため、このような用途に使用できません。この場合、C++26からの仕様である構造化束縛のパック導入と`constexpr`構造化束縛を使用するとシンプルに書くことができます。

```cpp
// 提案文書より、配列の構造体クラスの例
template <class T>
struct SoaVector {
  // 配列ストレージ
  Pointers pointers_;
  ...
  
  // Pointers型の非静的メンバ（=各配列）のリフレクションを列挙
  // これは`span<const info>`型になる
  static constexpr auto ptr_mems = define_static_array(nsdms(^^Pointers));
  ...

  auto operator[](size_t idx) const -> T {
    // 構造化束縛でのパック導入とconstexpr構造化束縛
    constexpr auto [...M] = [: ptr_mems :]; // ng、spanをパックに展開できない

    // メンバ配列からidx番目の要素を引き当てて配列で返す
    // 畳み込み式によって一文で展開する
    return T{pointers_.[:M:][idx]...};
  }
};
```

しかし、`define_static_array()`はリフレクションの配列の参照（`span<const info>`）を返してしまい、これはパックに変換できないため、この用途には使用できません。必要なのはリフレクションの配列のリフレクション（型としては`info`になる）を返す何かですが、P3491にはそれはありません。

この提案は、P3491をベースとしつつこれら2つの用途に沿うようなAPIを追加するものです。

```cpp
// P3491で提案されているAPIの一部

template <ranges::input_range R> // only if the value_type is char or char8_t
consteval auto define_static_string(R&& r) -> ranges::range_value_t<R> const*;

template <ranges::input_range R>
consteval auto define_static_array(R&& r) -> span<ranges::range_value_t<R> const>;

// この提案のAPI

template <ranges::input_range R>
consteval info reflect_constant_string(R&& r);

template <ranges::input_range R>
consteval info reflect_constant_array(R&& r);
```

どちらも、受け取った範囲`r`から生成した定数文字列/配列のリフレクションを返すものです。これらの関数を用いると先ほど問題として挙げた例をシンプルに解消することができます。

固定長文字列クラス型のNTTPをリフレクションによって生成する例

```cpp
using E = Test<[:reflect_constant_string("foo"):]>; // ok
using F = [:substitute(^^Test, {reflect_constant_string("foo")}):]; // ok
```

`reflect_constant_string()`は定数文字列へのリフレクションを返すため、それを用いて`Test`型を生成するリフレクションコードを記述することができます。

`SoaVector`の添え字演算子の実装例

```cpp
// 提案文書より、配列の構造体クラスの例
template <class T>
struct SoaVector {
  // 配列ストレージ
  Pointers pointers_;
  ...
  
  // Pointers型の非静的メンバ（=各配列）のリフレクションを列挙
  // これは`std::array<info, N>`型になる
  static constexpr auto ptr_mems = reflect_constant_array(nsdms(^^Pointers)); // 👈
  ...

  auto operator[](size_t idx) const -> T {
    // 構造化束縛でのパック導入とconstexpr構造化束縛
    constexpr auto [...M] = [: ptr_mems :]; // ok、std::arrayはタプルプロトコルによってパックへ変換できる

    // メンバ配列からidx番目の要素を引き当てて配列で返す
    // 畳み込み式によって一文で展開する
    return T{pointers_.[:M:][idx]...};
  }
};
```

`define_static_array()`がそうだったように、この関数もコンパイラの特別なサポートを必要とせずに手書きすることができます。しかも、`define_static_array()`の実装を少し移動するだけでよく、文言の変更的にも少なく済みます。

```cpp
template <typename T, T... Vs>
inline constexpr T __fixed_array[sizeof...(Vs)]{Vs...};

template <ranges::input_range R>
consteval auto reflect_constant_array(R&& r) -> meta::info {
  auto args = vector<meta::info>{
    ^^ranges::range_value_t<R>};
  for (auto&& elem : r) {
    args.push_back(meta::reflect_constant(elem));
  }
  return substitute(^^__fixed_array, args);
}

template <ranges::input_range R>
consteval auto define_static_array(R&& r)
    -> span<ranges::range_value_t<R> const>
{
  using T = ranges::range_value_t<R>;

  // produce the array
  auto array = reflect_constant_array(r);

  // turn the array into a span
  return span<T const>(
      extract<T const*>(array),
      extent(type_of(array)));
}
```

したがってC++26に必須の機能というわけではありません。それでも、このようなものは人々が再発明することが想定できることや、P3491の文言をベースに小さな変更で済むこと、コンパイラ支援によって`__fixed_array`のようなバック配列を（文字列リテラルや`initializer_list`のように）共通化することができるなどの理由によりC++26の機能として提案しています。

この提案はEWGのレビューで承認され、P3491R2にマージされています。そして、P3492R3は6月全体会議で承認されC++26にマージされています。

- [P3491R2 `define_static_{string,object,array}` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3491R2-define_static_stringobjectarray)
- [P3617 進行状況](https://github.com/cplusplus/papers/issues/2305)

### [P3631R0 Cleaning up the trivial relocation APIs in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3631r0.html)
### [P3649R0 A principled approach to safety profiles](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3649r0.html)
### [P3655R1 zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r1.html)
### [P3658R1 Adjust identifier following new Unicode recommendations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3658r1.pdf)
### [P3663R1 Future-proof `submdspan-mapping`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r1.html)
### [P3668R1 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r1.html)
### [P3669R1 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r1.html)
### [P3670R1 Pack Indexing for Template Names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3670r1.pdf)
### [P3676R0 Enhanced inline Keyword with Configurable Inlining Levels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3676r0.pdf)
### [P3677R0 Preserving LC_CTYPE at program start for UTF-8 locales](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3677r0.pdf)
### [P3678R0 Arbitrary attributes in define_aggregate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3678r0.html)
### [P3679R0 SFINAEable constexpr exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3679r0.html)
### [P3681R0 char_traits: Stop the bleeding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3681r0.pdf)
### [P3682R0 Remove std::execution::split](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3682r0.pdf)
### [P3685R0 Rename async_scope_token](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3685r0.pdf)
### [P3686R0 Allow named modules to export macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3686r0.html)
### [P3687R0 Final Adjustments to C++26 Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3687r0.html)
### [P3688R0 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r0.html)
### [P3689R0 Convenience functions for Random number generation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3689r0.pdf)
### [P3690R0 Consistency fix: Make simd reductions SIMD-generic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3690r0.pdf)
### [P3691R0 Reconsider naming of the namespace for “std::simd”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3691r0.pdf)
### [P3692R0 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r0.pdf)
### [P3693R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2025/04/09-2025/05/07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3693r0.pdf)
### [P3694R0 SG19: Machine Learning virtual Meeting Minutes to 2025/03/13-2025/05/08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3694r0.pdf)
### [P3695R0 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r0.html)
### [P3696R0 Discovering Header Units via Module Maps](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3696r0.html)
### [P3697R0 Minor additions to C++26 standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3697r0.html)
### [P3698R0 Cross-capacity comparisons for inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3698r0.html)
### [P3699R0 Rename `conqueue_errc`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3699r0.html)
### [P3700R0 Making Safe C++ happen](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3700r0.html)
### [P3701R0 Concepts for integer types, not integral types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3701r0.html)
### [P3702R0 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r0.html)
### [P3703R0 Constness and Locking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3703r0.pdf)
### [P3704R0 What are profiles?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3704r0.pdf)
### [P3705R0 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r0.html)
### [P3706R0 Rename join and nest in async_scope proposal](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3706r0.html)
### [P3707R0 A std::is_always_exhaustive trait](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3707r0.pdf)
### [P3709R0 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r0.html)
### [P3710R0 zstring_view: a string_view with guaranteed null termination](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3710r0.pdf)
### [P3711R0 Safer StringViewLike Functions for Replacing char* strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3711r0.pdf)
### [P3712R0 2025-05 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3712r0.html)
### [P3714R0 Virtual values have Virtual Value](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3714r0.pdf)
### [P3715R0 Tightening floating-point semantics for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3715r0.html)
### [P3716R0 Subsetting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3716r0.html)
### [P3717R0 Update Annex E onto Unicode 16](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3717r0.pdf)
