# ［C++］WG21月次提案文書を眺める（2025年01月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-01](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-01)

全部で122本あります。

もくじ

[:contents]

### [P0149R1 Generalised member pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0149r1.pdf)

メンバポインタの表現可能な範囲を拡張する提案。

現在のメンバポインタはあるクラス型の直接のメンバに対するもののみを表現することができ、これはクラスの先頭アドレスからのオフセットによって実装されています。

同様に、クラスの先頭からの固定のオフセットに存在しているもののメンバポインタで表現できないものとして、非仮想基底クラスとメンバのメンバ、メンバの非仮想基底クラスなどがあります。

この制限は以前にも何度か指摘されたものの、実装の制約などから来るものではなく誰も提案していないからそうなっていない、というだけの制限のようです。

この提案は、メンバポインタの現在の制限を緩和して、上記のものを表現できるようにしようとするものです。ここで提案されているのは次の3つです

1. メンバ変数型へのアップキャスト
2. メンバのメンバへのポインタの作成
3. 基底クラスサブオブジェクトへのポインタの作成

1つ目は、メンバポインタを、そのメンバの型の基底クラスにアップキャストするような変換を許可することです。次のコードの最後のものがそれにあたります

```cpp
struct A {};
struct B : A{};
struct C { B b; };


C c;
B*     to_b   = &c.b;   // OK、Normal pointer
B C::* c_to_b = &C::b;  // OK、C++98 member pointer
A*     to_a   = to_b;   // OK、C++98 implicit upcast
A C::* c_to_a = c_to_b; // NG、この提案ではok
```

ただし、キャスト先が仮想基底クラスの場合は実行時型情報の必要性やABI破壊の懸念などによってここでは提案していません。また、これに対応するダウンキャスト（`c_to_a` -> `c_to_b`のキャスト）も`static_cast`によって許可するようにすることを提案しています。

2つ目は、メンバのメンバへのポインタを取得するための構文を用意するものです。そのために、`.`・`[]`・`.*`の3つの演算子を拡張して、

- `.`: 「クラス型`T2`の`T1`型メンバへのポインタ」型の式と「型`T3`の`T2`型メンバ」を指定する識別子名、に対して`.`が適用された場合、「型`T3`の`T1`のメンバへのポインタ」型の値になる
    - `E1.*(E2.identifier)`という式は`(E1.*E2).identifier`と等価である必要がある
        - `E1, E2`は`T1, T2`型の式、式全体の型は`T3`
- `[]`: 「クラス型`T1`の型`T2`の配列メンバへのポインタ」型の式に対して`[]`が適用された場合、「クラス型`T1`の`T2`型メンバへのポインタ」型の値になる
    - `E1.*(E2[E3])`という式は`(E1.*E2)[E3]`と等価である必要がある
        - `E1, E2`は`T1, T2`型の式、`E3`は`T2`の有効なインデックス
- `.*`: 「クラス型`T2`の`T1`型メンバへのポインタ」型の式と「クラス型`T3`の`T2`型メンバへのポインタ」型の式、に対して`.*`が適用された場合、「クラス型`T3`の`T1`のメンバへのポインタ」型の値になる
    - `E1.*(E2.*E3)`という式は`(E1.*E2).*E3`と等価である必要がある
        - `E1, E2`は`T1, T2`型の式、式全体の型は`T3`

```cpp
struct A { int i; };
struct B {
  constexpr B(){};

  A a{};
  int is[42]{};
};

constexpr A B::* ap = &B::a;
constexpr int (B::*isp)[42] = &B::is;
constexpr int A::*ip = &A::i;
constexpr B b;

constexpr auto& i_1 = (b.*ap).i;      // OK, C++98
constexpr auto& i_2 = b.*(ap.i);      // NG、この提案ではok
constexpr auto& is7_1 = (b.*isp)[7];  // OK, C++98
constexpr auto& is7_2 = b.*(isp[7]);  // NG、この提案ではok
constexpr auto& i_3 = (b.*ap).*ip;    // OK, C++98
constexpr auto& i_4 = b.*(ap.*ip);    // NG、この提案ではok

static_assert(&i_1 == &i_2);          // NG、この提案ではok
static_assert(&i_1 == &i_3);          // NG、この提案ではok
static_assert(&i_1 == &i_4);          // OK, C++17
static_assert(&is7_1 == &is7_2);      // NG、この提案ではok
```

ここではメンバポインタの取得ではなくメンバポインタを介したオブジェクト参照の取得までやっているので、少しわかりづらいかもしれません。`.`の場合は`T2 = B, T1 = A, T3 = int`、`[]`の場合は`T2 = B, T1 = int`、`.*`の場合は`T2 = A, T1 = int, T3 = B`と読み替えると少しわかりやすいかもしれません・・・

最後は、クラス型の基底クラスサブオブジェクトを指すメンバポインタを生成する構文です。

```cpp
struct A {};

template <int N>
struct B : A {};

struct C : B<0>, B<1> {};
```

この場合に、`C`の基底クラス`A`のサブオブジェクトを指す`A C::*`のメンバポインタを作成できるようにしたいわけです。しかし、基底クラスのサブオブジェクトを指定する構文はないので、それを用意する必要があります。この提案ではそれを用意せずに、最初の場合のメンバポインタのアップキャストの場合の延長で、`this`のアップキャストによって基底クラスサブオブジェクトへのメンバポインタを生成することを提案しています。

そのための構文には`&T::this`というものを提案しており、これの結果は型`T`の`T`メンバへのポインタを形成し、それが暗黙的に`A C::*`などにアップキャストされることで基底クラスサブオブジェクトへのポインタを得ることができます。

```cpp
A    A::* a_to_a    = &A::this; // この提案のthisサブオブジェクトへのメンバポインタ取得
A B<1>::* b1_to_a   = a_to_a;   // C++98 class type downcast
A    C::* c_to_b1_a = b1_to_a;  // C++98 class type downcast

C    C::* c_to_c    = &C::this; // この提案のthisサブオブジェクトへのメンバポインタ取得
B<1> C::* c_to_b1   = c_to_c;   // この提案のメンバ型のアップキャスト
A    C::* c_to_b1_a = c_to_b1;  // この提案のメンバ型のアップキャスト

A    C::* c_to_b1_a = &B<1>::this; // 上記2つの提案機能の組み合わせ
```

当然ですが、これは仮想基底クラスに対しては使用できません。

現在のメンバポインタの実装は一般的に、クラス先頭アドレスからのオフセットとして表現されているため、これらの機能は比較的容易に実装できるはずだとしています。ただし、仮想基底クラスへのポインタは単なるオフセット以上のものを持つため、この方法では表現可能ではありません。

しかしなぜか、MSVCは仮想基底クラスへのメンバポインタ的な機能を実装しているようで、そこでは単なるオフセット以上の複雑な表現を持っています。そして、ここで提案されている機能とMSVCのこれは本質的に非互換なものなので、MSVCの機能に対して段階的な廃止を推奨しています。

- [Member access operators - cppreference.com](https://en.cppreference.com/w/cpp/language/operator_member_access)
- [P0149 進行状況](https://github.com/cplusplus/papers/issues/2223)

### [P0260R14 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r14.html)
### [P0876R19 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0876r19.pdf)
### [P1030R8 std::filesystem::path_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1030r8.pdf)
### [P1839R7 Accessing object representations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1839r7.html)
### [P2079R6 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r6.html)
### [P2414R5 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r5.pdf)
### [P2434R3 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2434r3.html)
### [P2654R1 Modules and Macros](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2654r1.pdf)
### [P2663R6 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2663r6.html)
### [P2664R9 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2664r9.html)
### [P2688R5 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2688r5.html)
### [P2719R2 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r2.html)
### [P2719R3 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r3.html)
### [P2746R7 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2746r7.pdf)
### [P2758R4 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2758r4.html)
### [P2806R3 do expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2806r3.html)
### [P2825R4 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2825r4.html)
### [P2830R8 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2830r8.html)
### [P2830R9 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2830r9.html)
### [P2841R6 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r6.pdf)
### [P2843R1 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r1.pdf)
### [P2883R1 `offsetof` Should Be A Keyword In C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2883r1.pdf)
### [P2899R0 Contracts for C++ - Rationale](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2899r0.pdf)

P2900のContracts提案に関する、議論の流れや設計根拠についてまとめた文書。

P2900では文言の他には、結果として決定された設計についての説明が記述されていますが、その設計に至った経緯などについてはほぼ記述されていません。それらは個別の提案とその議論および投票などに散らばっており、その数の多さも相まって追うのはかなり困難を極めます。

この文書は、P2900の設計に至るまでの提案とその議論の流れ、各提案や機能についての議論と投票結果などをまとめた文書です。

文書は"Overview"と"ProposedDesign"の2つのセクションに分かれています。

"Overview"では、Contractsのモチベーションや目標、契約プログラミングそのものについて、およびC++20以前からP2900（C++26 Contracts）に至るまでの提案と議論の流れがまとめられています。

"ProposedDesign"では、P2900の各セクション/サブセクションごとにその動機の要約や設計根拠の説明、設計上の決定の履歴、および関連する提案文書へのリンクがまとめられています。

また、この文書はP2900の今後の更新に追随して、その変更に関する同様のまとめを追記していく予定です。

かなり重厚な文書ですが、読み通すことでC++26のContractsの設計について理解することができるでしょう。

### [P2900R13 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2900r13.pdf)
### [P2933R3 Extend <bit> header function with overloads for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2933r3.html)
### [P2952R2 auto& operator=(X&&) = default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2952r2.html)
### [P2953R1 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r1.html)
### [P2971R3 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2971r3.pdf)
### [P2988R9 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r9.pdf)
### [P2996R9 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r9.html)
### [P3019R12 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3019r12.pdf)
### [P3045R5 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3045r5.html)
### [P3070R2 Formatting enums](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3070r2.html)
### [P3081R1 Core safety profiles for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3081r1.pdf)
### [P3086R3 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3086r3.pdf)
### [P3094R6 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3094r6.html)
### [P3111R3 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r3.html)
### [P3125R3 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3125r3.html)
### [P3139R1 Pointer cast for unique_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3139r1.html)
### [P3148R1 Formatting of chrono Time Values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3148r1.pdf)
### [P3164R3 Early Diagnostics for Sender Expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3164r3.html)
### [P3176R1 The Oxford variadic comma](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3176r1.html)
### [P3179R5 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r5.html)
### [P3206R0 A sender query for completion behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3206r0.pdf)

`sender`の完了動作についてのクエリ方法の提案。

P2300以前、P2257R0では`sender`に対するプロパティの指定とそのクエリに関する一般化された方法が提案されていました。P2300への移行の際に`sender`に対するプロパティ指定が削除されたことでそのクエリも同時に削除されていました。`sender`に対するプロパティとは例えば、処理の優先度やブロッキングの有無などです。

この提案は、そのような`sender`のプロパティの一つである完了に関する動作についてのクエリ方法を提案するものです。

完了に関する動作とは、`sender`を`execution::start()`したときにその`sender`で表現されている非同期操作がどのように完了するかということです。そのような動作には

- インライン: `start`としたのと同じスレッドで処理が完了する
- 同期: `start`がリターンする前に処理が完了する
- 非同期: 処理の完了は`start`のリターン以降かつ、それとは事なるスレッドで発生する

の3つがあります。

この3つの状態のいずれで完了するのかを静的に知ることができれば、`receiver`との接続後の`operation_state`の状態などを最適化できる可能性があります。例えば、インライン/同期のいずれかで完了することが分かっているのであれば、`start`の呼び出しに同期はいらず、`operation_state`の生存期間管理のための追加の作業が不要になります。

コルーチンの`awaitable`型は`await_ready()`が返す`bool`値によってこの情報を伝達するチャネルを持っていますが、`std::execution`にはそれがありません。この提案は、`sender`に対してそのようなクエリAPIを追加しようとするものです。

提案するAPIは、`execution::get_completion_behaviour(sndr,env)`です。これは`sender`（`sndr`）と接続する`receiver`の環境`env`によるカスタマイゼーションポイントであり、次のいずれかの値を返すものです

- `completion_behaviour::inline_completion`: インライン完了
    - 接続された`receiver`の完了シグナルは、`execution::start`呼び出しのリターン前に呼び出しスレッドで発生する
- `completion_behaviour::synchronous`: 同期完了
    - 接続された`receiver`の完了シグナルの発生と`execution::start`呼び出しのリターンの間には、happens-before関係が成立する
- `completion_behaviour::asynchronous`: 非同期完了
    - 接続された`receiver`の完了シグナルの発生は、`execution::start`呼び出しのリターン前に呼び出し元スレッドで発生することは無い
- `completion_behaviour::unknown`: 不明
    - 完了の動作は不明

このカスタマイズポイントとしては、`sender`型のメンバ関数として`env`を受け取る形で実装するか、型エイリアスとして定義するかの2つを提案しています。

```cpp
// メンバ関数として実装
template<class InputSender>
struct example_sender_adaptor {
  // [...]
  template <class Self,class...Env>
    requires (sizeof...(Env) <=1)
  constexpr auto get_completion_behaviour(this Self&& self,Env&&...env) noexcept {
    return execution::get_completion_behaviour(std::forward_like<Self>(self.sender), std::forward<Env>(env)...);
  }

  InputSender sender;
};

// 型エイリアスとして実装（環境に関係なくsender型のみで完了動作が決まる場合
struct example_sender1 {
  // [...]
  using completion_behaviour = constant<execution::completion_behaviour::asynchronous>;
};
```

`sender`に対して完了動作をクエリ可能（特に静的にクエリ可能）になることによって、例えば`sync_wait()`では同期プリミティブが不要になり、`repeat`の様なアルゴリズム（`sender`の処理を繰り返すアルゴリズム）では入力`sender`の完了（`set_value`）後にその`sender`の操作を呼び出すような`sender`を構成してそれを実行する必要がありますが、インライン/同期完了であることが分かっていれば、単なる`while`ループによって実行可能になります。

さらに、`sender`をコルーチンで扱うために`awaitable`に変換する`as_awaitable`においてはこれまで`sender`の完了動作について知る方法が無かったため、ネストしたコルーチン（`sender`）に対してsymmetric transferを適用することができませんでしたが、このクエリがあればそれを可能にする機会が得られるようになります。

また、提案では既存の`sender`アルゴリズムに対してこのクエリを実装した場合にどのような値を返すべきかの検討もしています。

- `sender`ファクトリ
    - `schedule(run_loop::scheduler)`
        - `asynchronous`
    - `just(), just_error(), just_stopped()`
        - `inline_completion`
    - `read_env()`
        - `inline_completion`
- `sender`アダプタ
    - `finally(sender1, sender2), continues_on(sender, scheduler), starts_on(scheduler, sender)`
        - `finally(sender1, sender2)`に対して、`min(get_completion_behaviour(sender1, env), get_completion_behaviour(sender2, env))`
    - `then(sender, fn), upon_error(sender, fn), upon_stopped(sender, fn)`
        - `get_completion_behaviour(sender, env)`
    - `let_value(sender, fn), let_error(sender, fn), let_stopped(sender, fn)`
        - ` min(get_completion_behaviour(sender, env), get_completion_behaviour(rs, env)...)`
          - `rs...`は`fn`が返しうる結果`sender`
    - `into_variant(sender), stopped_as_optional(sender)`
        - `get_completion_behaviour(sender, env)`
    - `bulk(sender, shape, fn)`
        - `get_completion_behaviour(sender, env)`
    - `when_all(senders...)`
        - `min(get_completion_behaviour(senders, env)...)`
    - `split(sender)`
        - 動的な値を返す
            - `split(sender)`の呼び出しが`split`の新しいコピーを返す前に入力操作が完了していれば、インライン完了
            - それ以外の場合、`get_completion_behaviour(sender, env)`

ここでは、`unknown < asynchronous < synchronous < always_inline`の順に順序付けしたうえで、`min`はこの順序の上で小さい方を返すものです。

- [P3206 進行状況](https://github.com/cplusplus/papers/issues/2185)

### [P3229R0 Making erroneous behaviour compatible with Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3229r0.pdf)
### [P3289R1 Consteval blocks](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3289r1.html)
### [P3347R1 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r1.pdf)
### [P3348R2 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r2.pdf)
### [P3351R2 views::scan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3351r2.html)
### [P3367R3 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3367r3.html)
### [P3373R1 Of Operation States and Their Lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3373r1.pdf)
### [P3374R1 Adding formatter for fpos](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3374r1.html)
### [P3375R2 Reproducible floating-point results](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3375r2.html)
### [P3385R3 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r3.html)
### [P3388R1 When Do You Know connect Doesn't Throw?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3388r1.pdf)
### [P3394R1 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r1.html)
### [P3395R0 Formatting of `std::error_code`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r0.html)

`std::error_code`をフォーマット可能にする提案。

`std::error_code`はostreamへの出力が可能です。

```cpp
std::error_code ec;
auto size = std::filesystem::file_size("nonexistent", ec);
std::cout << ec;
```
```
generic:2
```

しかし、`std::print`では出力できません。

しかし、ioマニピュレータが適用されるのはカテゴリ名の方だけであるなど、おかしな動作をする部分があります。

```cpp
std::cout << std::left << std::setw(12) << ec;
```
```
generic     :2
```

この提案は、`std::error_code`をフォーマット可能（`print`可能）にするとともに、より使いやすいフォーマット指定を可能にしようとするものです。

基本のフォーマットは`<<`と同じです

```cpp
std::print("{}\n", ec);
```
```
generic:2
```

しかし、フォーマットオプションの指定は文字列全体にかかります

```cpp
std::print("[{:>12}]\n", ec);
```
```
generic:2
```

そして、エラーメッセージを出力可能するオプションを用意しています

```cpp
std::print("{:s}\n", ec);
```
```
No such file or directory
```

ただし、エラーメッセージの実際の文字列は実装定義です。

このエラーメッセージ出力の最大の問題は、標準ライブラリ実装とそれが動作するプラットフォームによってメッセージのエンコーディングがまちまちであることです（標準の仕様では未規定）。次の表はそれを比較したものです

|プラットフォーム＼ライブラリ実装|libstdc++|libc++|Microsoft STL|
|---|---|---|---|
|POSIX|`strerror`|`strerror`|-|
|Windows|`strerror`/ACP|`strerror`|ordinary literals/ACP|

`strerror`はCロケールエンコーディングを表し、ACPはActive Code Pageの略です。

この表からも分かる通り、エンコーディングは異なる場合があり、実際に異なることが多いと思われます。この提案では、Cロケールエンコーディング（実行文字集合）を使用することを提案しています。

なお、この提案の内容は{fmt}ライブラリですでに実装されています。

- [P3395 進行状況](https://github.com/cplusplus/papers/issues/2187)

### [P3400R0 Specifying Contract Assertion Properties with Labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3400r0.pdf)
### [P3402R2 A Safety Profile Verifying Initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3402r2.html)
### [P3407R1 Make idiomatic usage of `offsetof` well-defined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3407r1.html)
### [P3411R1 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r1.html)
### [P3412R1 String interpolation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3412r1.pdf)
### [P3420R1 Reflection of Templates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3420r1.html)
### [P3423R1 Extending User-Generated Diagnostic Messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3423r1.html)
### [P3425R1 Reducing operation-state sizes for subobject child operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3425r1.html)
### [P3430R2 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3430r2.pdf)
### [P3431R0 Deprecate const-qualifier on begin/end of views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3431r0.html)

標準ライブラリの`view`の`const`-iterableを非推奨にする提案。

標準ライブラリの`view`型、特に`range`アダプタの結果型の`view`型の`begin()/end()`メンバ関数には`const`オーバーロードが用意されています。これによって、その`view`オブジェクトが`const`修飾されているときでもイテレーションが可能になります。この性質を`const`-iterableと呼びます。

しかし、`view`は参照セマンティクスを持つものであるため、その`const`性は要素の`const`を意味していません。また、一部の`view`型はその特有の事情から`const`-iterableではなく、通常`const`-iterableであるような`view`型でも`forward_range`ではない`input_range`に対しては`const`-iterableではなくなります。

これらの事によって、`view`の`const`-iterable性はしばしば落とし穴となります。

例えば次のコードのように、`const`参照によって`range`を受け取っている場合

```cpp
template <typename Rng>
void do_something(const Rng& rng) {
  for (auto& x : rng) {
    …
  }
}
```

これはふつうのコードであれば推奨されるスタイルですが、こと`range`に限ってはそうではなく、`const`-iterableではない`view`型を渡すと想定外にエラーとなります。正しくは次のように、`range`を転送参照で受け取って、イテレーション時に`const`参照で受けるのがベストです

```cpp
template <typename Rng>
void do_something(Rng&& rng) {
  for (const auto& x : rng) {
      …
  }
}
```

`view`の`const`-iterable性によって、このようなコードはおおむね正しく動くように見えてしまいます。しかし、`const`-iterableであっても要素は`const`とは限らないためいずれにせよそれは想定通りではなく、このような間違ったコードは早期にコンパイルエラーとなるべきです。

さらに、規格あるいは`view`の実装を見に行くと分かりますが、ほとんどの`view`型は`const`-iterableサポートのためにとても複雑な`begin()/end()`の実装を持っています。`const`-iterable性が不要になれば、それらはかなり簡易化されるはずです。

そして、`view`型が`const`でも`range`として扱える事のメリットはかなり小さい可能性があります。`view`の型はかなり複雑であり、入力の`range`やそのほかの引数によって容易に変化します。そのため、`view`オブジェクトに再代入したいケースというのはかなり少ないはずです（そもそも代入できないため）。また、`const`化することでスレッド間での共有アクセスが可能になると考える人がいるかもしれませんが、まず`const`-iterableは要素の`const`を意味しないためその期待はあまり満たされません。さらに、`view`の構築は通常かなり軽量であるため、各スレッドそれぞれで構築するようにしてもそれほどオーバーヘッドにはならないでしょう。

また、`view`オブジェクトはRangeアダプタの結果に代表されるようにごく短い間しか存在しないものであり、ローカル変数に保存されることがあってもその実体のスコープは狭く、クラスメンバやより広いスコープを持つ変数に保存されることはめったにありません。

これらの理由により、この提案では既存の標準ライブラリ`view`の`const`-iterable性を非推奨にしようとする提案です。

`view`から`const`-iterable性を取り除くことで、`view`を`const`にすることの是非や`const`-iterable性そのものについてなどを考える必要がなくなり、それについての利用者の混乱を解消することができます。

この提案では次のメンバ関数の`const`オーバーロードを

- `begin()`
- `end()`
- `empty()`
- `cbegin()`
- `cend()`
- `operator bool()`
- `data()`
- `size()`
- `front()`
- `back()`
- `operator[]`

次の`view`型に対して非推奨とすることを提案しています

- `std::ranges::ref_view`
- `std::ranges::owning_view`
- `std::ranges::as_rvalue_view`
- `std::ranges::transform_view`
- `std::ranges::take_view`
- `std::ranges::take_while_view`
- `std::ranges::drop_view`
- `std::ranges::drop_while_view`
- `std::ranges::join_view`
- `std::ranges::join_with_view`
- `std::ranges::lazy_split_view`
- `std::ranges::common_view`
- `std::ranges::reverse_view`
- `std::ranges::as_const_view`
- `std::ranges::elements_view`
- `std::ranges::enumerate_view`
- `std::ranges::zip_view`
- `std::ranges::zip_transform_view`
- `std::ranges::adjacent_view`
- `std::ranges::adjacent_transform_view`
- `std::ranges::chunk_view`
- `std::ranges::slide_view`
- `std::ranges::cartesian_product_view`
- `std::ranges::concat_view`

これ以外の`view`型

- `std::span/std::string_view`: `const`/非`const`で広く使用されており、再代入が有効な型であるため、破壊的変更になる
- `std::ranges::view_interface`: 下記の`view`で使用されている
- `std::ranges::iota_view`: 適切な型名を持つRangeファクトリである
- `std::ranges::repeat_view`: 適切な型名を持つRangeファクトリである
- `std::ranges::empty_view`: 全てのメンバ関数をは`static`
- `std::ranges::single_view`: 深い`const`性を持つ

に対しては`const`-iterable性を維持しようとしています。

とはいえ、この除外されているもの以外のものでも、現在`const`-iterableであるものについては`const`オーバーロードを削除してしまうと破壊的変更となるため、ここでは非推奨にとどめています。

- [P3431 進行状況](https://github.com/cplusplus/papers/issues/2188)

### [P3439R1 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3439r1.pdf)
### [P3475R1 Defang and deprecate memory_order::consume](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3475r1.pdf)
### [P3477R2 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r2.html)
### [P3480R3 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r3.pdf)
### [P3481R1 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r1.html)
### [P3491R1 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r1.html)
### [P3496R0 Immediate-Escalating Expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3496r0.html)

定数式における動的メモリ確保の制限を少しだけ緩和する提案。

この提案は、以前にP3032R2で提案されていた内容の一部を抽出したものです。P3032については以前の記事を参照

- [P3032R2 Less transient constexpr allocation - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3032R2-Less-transient-constexpr-allocation)

P3032では次の2つの事が提案されていました

1. 定数式にならない即時関数呼び出しが定数式になるように、それを含むより大きな式を定数式として扱う
2. 定数式における動的メモリ確保に関して、開放のタイミングが同じ評価内にある場合に加えて、同じ直接のコンテキスト内にある場合も許可する

この提案では、このうち1だけを改めて提案しなおしています。

そのモチベーションは共通しており、リフレクション機能で頻繁に問題になる事が想定されているので予め解決しておこうとするものです。

P3032での問題は次のようなコードでエラーが発生することでした

```cpp
enum E { a1, a2, a3 };

constexpr int f2() {
  return enumerators_of(^E).size(); // ng
}

int main() {
  constexpr int r2 = f2();
  return r2;
}
```

これは`enumerators_of(^E).size()`の式全体が`consteval`コンテキスト（即時コンテキスト）にならない（`enumerators_of(^E)`の呼び出しだけがなる）ことで、`enumerators_of`の戻り値の`std::vector`の解放がそのコンテキスト内で完了しないとみなされてしまうためにエラーになっています。

P3032及びここでの提案は、このような場合に`enumerators_of(^E).size()`全体が`consteval`コンテキストに昇格するようにしようとするものでした。

このような一部の定数式の特別扱いはルールが複雑になる割に回避が簡単であるとしてP3032の初期のリビジョンでは提案されていませんでした。この提案は、その実装経験のフィードバックとともに、現在の規格内での先行例を指摘しています。

すなわち、式`E1`が式`E2`の部分式であって`E1`は定数式ではないが`E2`は定数式である、ような場合に全体が定数式ではないとしてエラーにしないケースが規格上で2か所存在しています。

1つは、`consteval`関数の呼び出しそのものです。この場合、`consteval`関数の名前の使用そのものは定数式ではないものの、`consteval`関数の呼び出しは定数式になる場合があります。

```cpp
consteval int id(int i) { return i; }

/* not constexpr */ void f(int x) {
    auto a = id;    // error、名前の使用
    auto b = id(1); // ok、定数引数による呼び出し
    auto c = id(x); // error、非定数引数による呼び出し
}
```

`id`という式そのものは定数式ではありませんが、`id(1)`は定数式になります。

もう一つの例は、集成体においてデフォルトメンバ初期化子に非即時呼び出しな`consteval`関数呼び出しが含まれている場合、集成体初期化式が定数式であればデフォルトメンバ初期化子の`consteval`関数呼び出しも即時呼び出しになります。

```cpp
// id()は先穂の例と共通

struct A {
  int x;
  int y = id(x);  // 引数が非定数式なため即時呼び出しではない
};

template<class T>
constexpr int k(int) {  // A(42)は定数式ではあるものの即時呼び出しではないため、k<int>は即時関数ではない
  return A(42).y; // ok
}
```

`A::y`のデフォルトメンバ初期化子の`id(x)`は内部的に定数式ではないものの、それが呼ばれる`A(42)`は定数式であるため、その外側が`consteval`コンテキストではなくても定数式となり許可されています。

これらの事を根拠にこの提案ではimmediate-escalating expressionの規則を修正して、`consteval`関数呼び出しが定数式で囲まれていない場合にのみimmediate-escalating expressionとなるようにしようとしています。

式`enumerators_of(^E).size()`（現在この全体が`consteval`コンテキストではない）については

- `enumerators_of`はconsteval-only式（`consteval`関数であるため
- `^E`もconsteval-only式（`meta::info`がconsteval-only型であるため
- `enumerators_of(^E)`の呼び出しもconsteval-only式
    - ただし、戻り値の`vector`がこの`consteval`コンテキスト内で破棄されないため、これは定数式ではない
    - そのため即時呼び出しではない
- より大きな式`enumerators_of(^E).size()`は定数式であり、`consteval`な非定数式を部分式にもつため、この式は即時呼び出しとなる（ようになる
    - これにより、`enumerators_of(^E)`そのものはimmediate-escalating expressionではなくなる

のようにして許可されます。

かなり回りくどいですが、現在の仕様では`enumerators_of(^E)`の呼び出しだけがimmediate-escalating expressionになってしまい、そのコンテキスト内で戻り値の`std::vector`が破棄されなければならない、という制約が付加されてしまうことで問題が起きています。この提案後には、その制約が破られることで非定数式となった部分式かつ`consteeval`関数呼び出しを囲む定数式全体が即時呼び出しとなるようになることで、`enumerators_of(^E)`の戻り値の使用可能なスコープが囲む式全体まで広がり、これによってエラーが解消されます。

なお、この提案の内容はP2564R3（immediate-escalating expressionを導入した提案）に対するDR（すなわちC++23に対するDR）とすることを意図しています。

- [C++23 constexpr関数内でconsteval関数を呼び出せない問題を軽減 [P2564R3]](https://cpprefjp.github.io/lang/cpp23/consteval_needs_to_propagate_up.html)
- [P3496 進行状況](https://github.com/cplusplus/papers/issues/2189)

### [P3499R0 Exploring strict contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3499r0.pdf)

非緩和契約の設計についての提案。

非緩和契約（あるいは厳密な契約）とは、P2680R1やP3285R0で提案されている契約条件の評価において未定義動作を起こさないようにするための仕組みの事です。これは主に、未定義動作に繋がる操作を禁止するとともに、一部の未定義動作を定義済み動作にすることによって行われます。

非緩和契約のような制限の無い契約の事を緩和契約と呼んでおり、これはP2900R13の契約仕様のセマンティクスに合致しています。しかし、P2900R13のContracts仕様には非緩和契約は含まれておらず、そのことがEWGにおける継続的な反対の主な対象となっています。

現状の非緩和契約の概念はアイデアのみの段階でその仕様や実装が無く、実現可能性が不透明です。P3376R0およびP3386R0ではP3285R0の非緩和契約について検討を行っていますが、ほとんど実用的な契約条件を表現できない事などの問題が報告されており、SG21では非緩和契約は少なくともC++26に向けては追及しないことが決定されています。

この提案では、非緩和契約の設計について検討し、その最初の仕様の策定を目指そうとするものです。

まず出発点として、データ競合を除く未定義動作が確実に起こらないことが保証可能な述語を記述できる式を特定します

- 算術型または列挙型のリテラル。
- 算術型または列挙型の非`volatile`変数を指すid-expression（変数名を指定する式
    - ポインタや参照は含まれない
- 単項演算子`+, -, !`を使用した式（unary-expression）
- 二項演算子`+, -, /, %, *, !, ,, ^, |, ||, &, &&, <<, >>`を使用した式（binary-expression）
- 単項演算子`?, !`を使用した条件式（conditional-expression）
- `<, >, <=, >=`を使用した式（relational-expression）
- `==, !=`を使用した式（equality-expression）
- `<=>`を使用した式（compare-expression）
- 算術型または列挙型のコア定数式

かなり小さな集合ではありますが、将来的に拡張していくことができます。

これらの式による述語は予測不可能な未定義動作を起こさず、副作用を持たないものです。そのため、非緩和契約で使用可能な述語をこれら楽しきにのみ制限することで非緩和契約の一つの目標は達成されます。そして、これらの式で発生が予測される未定義動作は次のものに絞られます

- 符号付整数型のオーバーフロー/アンダーフロー
- 浮動小数点数値の、その値を表現できない型への変換
- ゼロ除算
- 負の値でのシフト
- 型のビット幅以上のシフト量によるシフト

非緩和契約ではこれらの未定義動作を定義済み動作に変換する必要があります。P3285R0で提案されていた飽和演算やラップアラウンド演算による動作の書き換えは、契約外での動作と異なることによってバグの隠蔽や見落としに繋がることが指摘されているため望ましい選択肢ではなく、この提案では未定義動作の発生を契約違反として扱うアプローチを推奨しています。

これは、P3100R1/P3229R0の方向性と合致しており、よりきめ細かい契約違反ハンドリングを可能にする方向性です。

最後に、非緩和契約の構文については、P2900の現在のデフォルトを変更せずに`pre strict (x)`のようにオプトインなものとすることを提案しています。これは、反対意見はあったもののEWGで合意済みの事です。

これらの事項を文言にエンコードすることによって非緩和契約の仕様は策定可能となりそうです。しかし、この仕様にはかなりの制限があります。例えば

- 組み込みの算術型・列挙型以外の値に対する演算は使用できない
- ポインタのデリファレンスはできない
- 参照を使用できない
- あらゆるオブジェクトに対するメンバ関数呼び出しはできない

結局この提案の結論としては、非緩和契約のの方向性が有効であるとは思えない、というものです。ただ、依然として求める声が多い非緩和契約がどのようなものになるのかについてのこれらの検討がP2900R13のコンセンサスを高めるものになることが期待されています。

- [P3499 進行状況](https://github.com/cplusplus/papers/issues/2140)

### [P3500R0 Are Contracts "safe"?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3500r0.pdf)
### [P3501R0 The ad-dressing of cats](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3501r0.html)

規格文書内でのアドレスという言葉の意味と使用を明確化する提案。

規格内ではアドレスという言葉には明確な定義がなく、暗黙的な定義の下で使用されています。それによって例えば、ある場所（[intro.memory]/1）では「全てのバイトは一意のアドレスを持つ」というように使用されている一方で、別の場所（[basic.compound]/3）ではポインタはメモリのバイトの「アドレスを表す」のように使用されています。他にも、`&`演算子の記述のために使用されていたり、ポインタそのものの事を指して使用されていたりしているようです。

そして、アドレスという単語を使用すべきなのに使用していないことによって導入されている欠陥が一つあります。[defns.order.ptr]では、`std::less<void*>`等で実装定義のポインタ値の狭義全順序による順序付けを許可することを指定していますが、アドレスという言葉を使用せずに曖昧に規定していることによって、これはライブラリサイドでは実装不可能になってしまっています。例えば

- `std::less<void*>`では、配列へのポインタとその配列の先頭要素のポインタを区別できない（比較不能）可能性がある
- `std::less<int*>`では、ある`int`オブジェクトの次を指すポインタ（`&x+1`）と、そのオブジェクトの直後に配置されている別の`int`オブジェクトへのポインタを区別できない可能性がある

実装定義の全順序によるポインタ値の順序付けがサポートされている場合、これらのケースでも比較可能であり、ライブラリの比較関数オブジェクトでも同様なはずです。しかし、アドレスという言葉の曖昧性やその順序付けの曖昧性により、それを正しく指定できていません。

この提案では、アドレスという言葉をしっかりと定義して、使用すべきところではその定義の下で使用しすべきでない所ではほかの適切な言葉におきかえるようにしようとするものです。

この提案ではまず、アドレスはメモリバイトに対する（実装定義の）全順序付きの不透明ラベルであるとして定義しています。そのうえで、全てのポインタ値（関数ポインタや`nullptr`を含む）をこの定義の下でのアドレスという言葉を関連付けるようにすることで、ポインタ値に対する（実装定義の）全順序を導入します。そして、ポインタに対する比較をこのアドレスという言葉を使用して定義することで、ポインタの順序付けを実装定義の全順序の上で定義し、同様にライブラリの比較関数オブジェクト（`std::less`等）における結果も実装定義の全順序の上で定義するようにします。

また、定数評価中に比較（`<`）が利用可能なポインタに対して“ordered”という言葉を導入し、比較の定義でこれを使用することで、定数式で使用できない比較とできる比較を区別するようにしています。

同時に、混同されていたポインタとアドレスという言葉の使用方法をこの定義の下で明確化し変更しています。

この提案はほとんど言葉の使用方法の調整のみですが、（意図するライブラリ比較と言語比較の不整合解消を除いて）唯一オブジェクトの一つ後ろを指すポインタに関する比較が未規定ではなくなった点だけはセマンティクスの変更となります。

- [P3501 進行状況](https://github.com/cplusplus/papers/issues/2191)

### [P3506R0 P2900 Is Still not Ready for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3506r0.pdf)

Microsoftによる、P2900R11のContracts仕様に対する反対意見の表明文書。

この文書はP3173R0での主張を現在の状況を踏まえて更新するものです。

P3173R0については以前の記事を参照

- [P3173R0 P2900R6 may be minimimal, but it is not viable - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3173R0-P2900R6-may-be-minimimal-but-it-is-not-viable)

P3173R0で主張されていた3点については状況はあまり変わっていません。仮想関数における契約のサポートは追加されていますが、この文書では複雑すぎであり仮想関数の長年の使用方法に則っていない、として不十分としています。

ここでは追加で

- コルーチンの契約サポートは実装と使用の経験が必要
- 標準ライブラリでの契約機能の使用については、既存のアサートを`contract_assert`に置き換えただけであり、事前条件や事後条件を使用していない
    - このため、実用性の懸念は未解決
- 契約条件の評価中に発生した例外を違反ハンドラがハンドリングしてしまうのは、多くの点で有害
    - 契約条件評価を`try-catch`で囲むことになるので、バイナリサイズや実行時コストの点で不利
    - 例外を自然に伝播させるためには違反ハンドラの置換が必要になる
- 契約注釈内での外部の変数の`const`化はそれ自体が問題を発生させる部分的な解決策でしかなく、混乱をもたらしている
    - より良い解決策は`const`化を削除すること

などの問題点を挙げています。

これらの問題点が解消されない限り、引き続きMicrosoftはC++26にP2900を組み込むのに反対する、としています。

- [P3506 進行状況](https://github.com/cplusplus/papers/issues/2192)

### [P3516R0 Uninitialized algorithms for relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r0.html)

未初期化メモリに対するリロケーションアルゴリズムのライブラリ機能の提案。

C++26に向けて、言語で（トリビアル）リロケーションの定義を提供するとともに、それを行うためのライブラリ操作を導入しようとしています（P2786/P1144）。その作業の最先端はP2786R11で行われていますが、そこでは最近機能のスコープを絞るためにライブラリのAPIの大半が分離されました。

この提案は、P2786が提供しようとしているリロケーションの概念を用いて、未初期化メモリに対するリロケーションによる初期化を行うアルゴリズムを提案するものです。

提案するのは主に次の3つの関数を基本としたものです

- `std::uninitialized_relocate()`
- `std::uninitialized_relocate_n()`
- `std::uninitialized_relocate_backward()`
- これらのRange版と並列版

これらのアルゴリズムは、ある未初期化なメモリ範囲を、別の範囲からそれぞれの要素をリロケートして初期化するものです。いずれの関数も入出力範囲のオーバーラップを許可し、途中で例外が送出された場合は入出力範囲のすべての要素が破棄されます。そして、このアルゴリズムが正常に完了した場合は入力の範囲に要素は含まれなくなり、未初期化状態になります。

この提案ではリロケーションという概念の定義などを提供しようとはしておらず、リロケーションをムーブ+破棄であると仮定してそのas-ifによってリロケーション動作を指定しています。これによって、P2786がマージされていない状況でもリロケーションAPIを提供することができ、P2786がマージされてもそのより高度なリロケーションの定義を自動で利用することができます。

提案文書より、`vector::erase()`で使用する例

```cpp
// 今まで
constexpr iterator
vector<T>::erase(iterator first, iterator last) {
  if (first == last)
    return last;

  auto new_end = std::move(last, end(), first);
  std::destroy(new_end, end());

  end_ -= (last - first);
  return first;
}
```
```cpp
 // この提案
constexpr iterator
vector<T>::erase(iterator first, iterator last) {
  if (first == last)
    return last;

  // Destroy the range being erased and relocate the
  // tail of the vector into the created gap.
  std::destroy(first, last);
  std::uninitialized_relocate(last, end(), first);  // 👈

  end_ -= (last - first);
  return first;
}
```

文書にはもう少し`std::vetor`で使用する例が載っています。

リロケーション操作は通常、単なるムーブ代入よりも効率的であるため、これをいれておくことでC++26以降のライブラリのパフォーマンスの最適化を図ることができます。

- [P2786R11 Trivial Relocatability For C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2786R11-Trivial-Relocatability-For-C26)
- [P3516 進行状況](https://github.com/cplusplus/papers/issues/2193)

### [P3527R1 Pattern Matching: *variant-like* and `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3527r1.html)
### [P3533R1 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3533r1.html)
### [P3534R0 Avoid UB When Compiling Code That Violates Library Specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3534r0.pdf)

コンパイル時に起こるタイプのライブラリのUBについて、IFNDRに置き換える提案。

標準ライブラリの仕様には、ライブラリが想定しないような使用方法がなされた場合にUBとなる規定が一部に存在しています。そのようなライブラリのUBのうち、一部のものは未定義動作が発生するのが実行時ではなくコンパイル時であることが分かっている場合があります。この提案は、そのようなケースのUBという言葉の使用を（ill-formed, no diagnostic required）に置き換えようとするものです。

その対象の例としては、ユーザーが標準ライブラリ内テンプレートの特殊化を追加することを禁止する規定です。これは現在UBとされていますが、このUBはコンパイル時に発生し、実行時に起こるわけではありません（それを追加することでどのテンプレート特殊化が選択されるか分からなくなることでUBとなるが、それが起こるのはコンパイル時のみ）。

実行時ではIFNDR（プログラム全体に対して一切要件を課さなくなる）よりもUB（違反が発生した部分のみの動作が未定義となる）の方が動作の指定としては優れているというか、マシなものです。しかし、コンパイル時は逆で、コンパイル時のUBはコンパイル処理そのものの動作を無制限のリスク要因としてしまうため、この様な規定方法はおそらく標準の意図するところではなく、通常必要とはされないはずです。そのためこの提案では、標準ライブラリのコンパイル時に発生するタイプのUBの使用をIFNDRに置き換えようとしています。

- [P3534 進行状況](https://github.com/cplusplus/papers/issues/2194)

### [P3541R1 Violation handlers vs `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3541r1.html)
### [P3546R0 Explicit return type deduction for std::numeric_limits and numbers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3546r0.pdf)

`std::numeric_limits`や`<numbers>`で型の指定を省略可能にする機能の提案。

`std::numeric_limits`によって何らかの定数を取得する時、典型的には次のようなコードを書くことになりますが、欲しい型名を2回書くことになります。

```cpp
float f1 = std::numeric_limits<float>::max();
```

変数宣言であれば、変数の型名は`auto`で受けることもできます。しかし、非静的メンバ変数の宣言や関数引数の宣言では`auto`を使用できないため2回書かざるをえません。

```cpp
/* (1)- For structs */
struct F {
  float f1 = std::numeric_limits<float>::max();
};

/* (2)- For functions */
void func1( float f = std::numeric_limits<float>::max());
```

この提案は`std::deduce`というタグ型を導入し、それを利用することによってこの2つ目の型の指定を省略可能にしようとするものです。

```cpp
/* (1)- For structs */
struct F {
  float f1 = std::numeric_limits<float>::max();       // Before
  float f2 = std::numeric_limits<std::deduce>::max(); // After
};

/* (2)- For functions */
void func1(float f = std::numeric_limits<float>::max());       // Before
void func2(float f = std::numeric_limits<std::deduce>::max()); // After
```

元の型名よりもたいていの場合長くなりますが、変数の型名を変更したくなった場合に両方とも変更する必要が無くなるメリットがあります。また、`std::deduce`という特徴的な名前はそれが使用されている個所を目立たせ検索しやすくする効果もあります。

この`std::deduce`は純粋なライブラリタグ型であり、`std::numeric_limits`の場合は例えば次のように実装できます

```cpp
namespace std {
  template<>
  struct numeric_limits<std::deduce> {
    struct max {

      // テンプレート型変換演算子
      template<typename Out>
      operator Out() {
        return numeric_limits< Out >::max();
      }

      /* ... */
    };
  };
}
```

変数テンプレートの場合も同様のテクニックによって実装可能です

```cpp
inline constexpr auto M_ONES = 1.111111111111111111111111111111111111111L;

template< typename T = double >
struct m_ones_v_c {
  constexpr operator T() const {
    return M_ONES;
  }
};

template<>
struct m_ones_v_c<std::deduce> {
  template< typename Out >
  constexpr operator Out() const {
    return M_ONES;
  }
};

template<typename T>
inline constexpr auto m_ones = m_ones_v_c<T>{};

inline constexpr auto m_ones = m_ones_v_c<double>{};
```

これらの実装はおそらく、既存の使用方法に対してAPIの破壊的変更を伴わないものです。

提案では`std::deduce`は`<utility>`に配置し、`std::numeric_limits`と`<numbers>`に対してこれを使用可能にする変更を適用しようとしています。

- [P3534 進行状況](https://github.com/cplusplus/papers/issues/2194)

### [P3547R0 Modeling Access Control With Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3547r0.html)
### [P3548R0 P1030 `std::filesystem::path_view` forward progress options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3548r0.pdf)

`path_view`に対する懸念に対しての解決の提案。

P2645では、提案中の`path_view`に対して標準化に当たってのいくつかの懸念点が指定されていました。これについてLEWGで活発な議論が行われ、そこでは問題は主に`path_view`が内部パス文字列表現のために`char`を使用することによってWindowsでANSIエンコーディングを使用してしまう事、に絞られたようです。

この問題によって`path/path_view` -> パス文字列 -> `path/path_view`のようなラウンドトリップを行った場合に、元に戻らなくなる（同じパスを表さなくなる）ことが懸念されています。

しかし、`std::filesystem::path`においては、内部パス表現は渡されたパスのビット列を正確にネイティブのAPIに渡すことを意図したものであり、そもそもラウンドトリップをサポートし切ることはあまり目指されてはいないようです。`path_view`においてもその設計を踏襲しており、内部ビット表現に`char`を使用するのは特定のエンコーディングを仮定するのではなく、渡されたパス文字列のビットを（システムにとって）正しく保持することを目的とするものです。

そして、`path_view`においては、保持するパス文字列ビットを人間にとってのパス文字列に変換する際には、それをUTF-8エンコーディングとして読み取るという設計になっており、これを`filesystem::path`にも適用すべきとしています。

この提案では、LEWGにおける議論及びその後の調査によって導かれた解決策を4つ提示しています。

1. ネイティブファイルシステムエンコーディングが`char`ではなないプラットフォームにおける`char`内部表現サポートを削除する
    - 利点
        - Windowsにおいて、ナロー文字列エンコーディングからの変換に伴うトラブルを回避できる
    - 欠点
        - Windows以外のプラットフォームで`path_view`に`char`文字列を入力しているコードはWindowsでコンパイルエラーを起こす
2. 全てのプラットフォームで`char`内部表現サポートを削除する
    - 利点
        - プラットフォーム間で`path_view`の一貫性を確保できる
    - 欠点
        - `path`への`char`文字列入力は可能だが、`path_view`ではできなくなる
        - `path`の内部表現が`char`である場合、`path`から`path_view`への変換は可能であるため、意外性がある
3. `path_view`の表現はそのままで、`path_view`のフォーマッターは`path`のフォーマッタと同じ動作をする
    - 利点
        - エンコード周りの処理は`path`と`path_view`で同程度の複雑さになり、これは一貫している
    - 欠点
        - これは過去の誤りを助長するもので、誤りを悪化させ続けることを解消するのに役立たない
    - 備考
      - Windowsにおけるエンコーディングの問題はMicrosoftによって引き起こされたものであるため、Microsoftによって解決されるべき（WG21が関与すべきでない）
      - MicrosoftはナローエンコーディングをUTF-8に転換するという長期計画を進めているため、10年ほどでこの問題は解決される
4. C++26（予定の）`path_view`の表現はそのままで、フォーマッタをC++29まで延期する
    - 利点
        - `path_view`はソースエンコーディングの認識を保持するのに対して、`path`は忘れるため、一部のコーナーケースにおいて人間にとっての最適性という意味でより優れたフォーマッタを設計できる可能性がある
    - 欠点
        - `path`と`path_view`のフォーマッタの一対一対応が損なわれる可能性がある

筆者の方は案3、すなわち現状維持を押しています。

また、P2645で別の懸念点であったパフォーマンスの問題について、ベンチマークが提供されています

- [P2645R0 `path_view`: a design that took a wrong turn - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2645R0-path_view-a-design-that-took-a-wrong-turn)
- [P3548 進行状況](https://github.com/cplusplus/papers/issues/2197)

### [P3549R0 Diverging expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3549r0.html)
### [P3550R0 Imports cannot ...](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3550r0.pdf)

Cの可変長引数機能をC++で使用できないようにする提案。

名前付きモジュールからはマクロはエクスポートされないため、`import std;`しただけではCの可変長引数にアクセスすることができません。

```cpp
import std;

void c_style_variadic_arg_func(int arg1, ...) {
  ::va_list arg_list; // ok、これはマクロではない
  va_start(arg_list, arg1); // ng、これはマクロ

  int arg2 = va_args(arg_list, int);  // ng、これもマクロ

  va_end(arg_list); // ng、これもマクロ
}
```

これを機能させるには`<cstdarg>`もしくは`<stdarg.h>`のどちらかのヘッダのインクルードが必要になります。

一方で、Cの可変長引数機能は上記例からも明らかなように、使用するのが難しく間違って使用するのが簡単な機能であり、この機能の使用にはセキュリティリスクがあります。そして、C++には可変引数テンプレートという完全かつ型安全な代替機能があり、もはやCの可変長引数機能を使用する理由はほとんどなくなっています。

この提案は、モジュールコードでCの可変長引数機能を使用できるようにするよりも、この機能のサポートを縮小あるいは削除することを提案するものです。主に次の2つの事を提案しています

- 関数がグローバル名前空間にあり、`extern "C"`リンケージを持たない場合、Cの可変長引数による関数宣言を非推奨とする
- C++標準ライブラリから、`<cstdarg>`と`<stdarg.h>`ヘッダを削除する

`printf()`や`scanf()`等の関数は非推奨としてサポートされ続けます。一方で、2つ目の変更によってC++プログラムがCの可変長引数機能を使用する能力が失われ、これによってC++でコンパイルできないCのコードが増加することになります。提案ではこれをC++のセキュリティを確保するためのコストであるとしています。ヘッダを削除せずに非推奨とする穏健なアプローチはセキュリティホールを開いたままにするとして推奨していません。

- [Standard library header <cstdarg> - cppreference.com](https://en.cppreference.com/w/cpp/header/cstdarg.html)
- [P3550 進行状況](https://github.com/cplusplus/papers/issues/2199)

### [P3552R0 Add a Coroutine Lazy Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r0.pdf)
### [P3554R0 Non-transient allocation with vector and basic_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3554r0.html)

`std::string`と`std::vector`に限定した、非一時的なメモリ割り当てを許可する提案。

現在、定数式で動的確保したメモリ領域は同じ定数式の中で解放しなければなりません。これによって、定数式で使用した`std::vector`や`std::string`を実行時に持ち越すことはできなくなっています。これは現在でも不便ですが、C++26でリフレクションが利用可能になるとさらに不便さが増大する事が予想されます。

定数式で確保したメモリ領域を実行時に持ち越せるようにする（Non-transient allocation: 非一時的なメモリ割り当て）事についてもC++20時点から議論されているものの、合意を得られた一般的な設計はまだ存在していません。この提案では、一般的な設計以前にとにかく`std::string`と`std::vector`だけをその制限から解放して、定数式で使用した`std::string`/`std::vector`オブジェクトをそのまま実行時でも利用できるようにしようとする提案です。

提案ではまず、次の条件を全て満たす場合のコア定数式`E`の評価中に発生するメモリ割り当て`A`を*constexpr-persistent*として定義します

1. `E`は定数式で使用可能なオブジェクト`O`の初期化するために使用されている
2. `A`は`E`の評価内で解放されない
3. `A`が*eligible for constexpr-persistent*である

そのうえで、定数式における`new`/`std::allocator<T>::alocate()`の規定にある「定数式の評価中に確保した領域はその評価の内部で解放されなければならい」という規定を「定数式の評価中に確保した領域は、それが*constexpr-persistent*であるか、（さもなければ）その評価の内部で解放されなければならい」のように緩和して指定しなおします。

そして、`std::vector`（特殊化）および`std::string`の要素をのために割り当てたメモリ領域を*eligible for constexpr-persistent*である、と規定します。

これにより、`std::string`/`std::vector`が定数式にで割り当てメモリ領域は*eligible for constexpr-persistent*となり、*eligible for constexpr-persistent*であるような割り当ては*constexpr-persistent*であるためその定数式の評価内で解放されている必要は無くなります。

そして、定数式で使用した`std::string`/`std::vector`オブジェクトは、追加の操作なくそのまま実行時に引き継ぐことができます。

将来より一般的な非一時的なメモリ割り当ての方法が導入された時でも、`std::string`/`std::vector`は間違いなくその対象になることが分かっています。しかし、それを待っているといつになるか分からないため、細かい規定を省略しつつ`std::string`/`std::vector`だけはとにかく定数式から実行時に引き継ぐことができるようにしようとしています。

- [P3554 進行状況](https://github.com/cplusplus/papers/issues/2201)

### [P3555R0 An infinite range concept](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3555r0.html)

終端の無い範囲を検出するためのコンセプトの提案。

`std::views::iota(1)`のように、終端の無い無限の範囲は割と簡単に得ることができます。このような範囲であってもRangeアダプタで使用することができるのですが、長さが無限であるという性質によって一部のアダプタがうまく動作しないことがあります。

```cpp
auto a = views::iota(0) | views::reverse;
a.begin(); // infinite loop
```

`views::iota(0)`は`common_range`ではないため番兵から逆に進行することができず、`views::reverse`による`view`からのイテレータ取得時（`begin()`呼び出し時）に先頭から終端までイテレータを進行させることによって最後の要素を検出しようとします。しかし、`views::iota(0)`は無限の範囲なのでそれは無限ループします。

このケースでは番兵型が`unreachable_sentinel_t`であることを検出することで回避可能ですが、これが別のアダプタで隠蔽されていると結局同じ問題が発生します（`views::zip(views::iota(0), views::iota(1))`など）。この場合に、範囲の無限性を検出することができれば、このようなバグを静的に回避することができます。

範囲の無限性を検出することのもう一つのモチベーションは、P3179R4で提案されている並列アルゴリズムによるバイナリ`transform`における入力範囲長の自由度の確保があります。バイナリ`transform`は`ranges::transform(execution::par, rng1, rng2, output, fn)`の様に2本の範囲を入力として使用する`transform`であり、この場合に両方の入力範囲が`sized_range`であることを要求します。これは安全のためとのことですが、どちらかの範囲に整数インデックス（すなわち`views::iota(1)`）や定数列を渡して、もう片方の入力データによって入力長を指定する、の様なユースケースが存在しているため、この仕様は少し物議を醸しています。

この場合にも、範囲の無限性を事前に検出できれば、安全に入力範囲の長さを計算することができるようになります。

最後に、範囲の無限性を検出できれば`infinite_range | views::take(n)`のような式を`infinite_range | views::unchecked_take(n)`（P3230R1で提案されているもの）に最適化するようなことが簡単にできるようになります（`take`される長さ`n`よりも入力範囲が長いことが分かるため）。

これらのモチベーションより、この提案では範囲の性質としての無限性を検出するための`infinite_range`コンセプトを提案しています。

この提案では、Range-v3で定義されている範囲の濃度の概念を簡易化したものによって、`infinite_range`を定義づけています。

- 既知の有限長: `sized_range`
- 無限長: `infinite_range`
- 不明: `!sized_range`かつ`!infinite_range`

濃度のモデルが簡略化されていることで`!infinite_range`は必ずしも有限長を意味しなくなっています（有限長 or 検出できなかった無限長、を表す）。一方で、`infinite_range`が満たされている場合はその範囲は確実に無限長であることを表しています。

範囲の無限性は必ずしも確実に検出できないので、`infinite_range`には何かしらのオプトインが必要になります。提案ではその2つのオプションを提示しています

1. `enable_infinite_range`
    - `enable_borrowed_range`と同様の方法
2. `size()`が特定のタグ型を返す
    - 無限範囲は`sized_range`ではないので整数値を返さなくても問題ない

1の方法の例

```cpp
namespace std::ranges {
  template <class R>
  constexpr bool enable_infinite_range = same_as<sentinel_t<R>, unreachable_sentinel_t>;

  template <class R>
  concept infinite_range = range<R> && enable_infinite_range<remove_cvref_t<R>>;
}

// ユーザーコードで
template <>
constexpr bool std::ranges::enable_infinite_range<my_infinite_range> = true;

template <class R>
constexpr bool std::ranges::enable_infinite_range<my_range_adaptor_that_does_not_affect_cardinality<R>> = std::ranges::infinite_range<R>;
```

2の方法の例

```cpp
namespace std { // or std::ranges
  struct infinite_tag_t {};
  inline constexpr infinite_tag_t infinite_tag;
}
namespace std::ranges {
  template <class R>
  concept infinite_range = range<R> && (
    same_as<seninel_t<R>, unreachable_sentinel_t>
    || requires(R&& r) { { r.size() } -> same_as<infinite_tag_t>; }
    || requires(R&& r) { { /*ADL*/size(r) } -> same_as<infinite_tag_t>; }
  );
}

// ユーザーコードで
class my_infinite_range {
public:
  auto size() const { return std::infinite_tag; }
};

template <class R>
class my_range_adaptor_that_does_not_affect_cardinality {
  R _r;

public:
  auto size() const requires std::ranges::sized_range<R> { return std::ranges::size(_r); }
  auto size() const requires std::ranges::infinite_range<R> { return std::infinite_tag; }
};
```

2の方法の方が、`view`型のように他の範囲をラップする場合にこの性質を伝播させやすいというメリットがあるため、ここでは2の方法を押しています。

```cpp
namespace detail {
  auto potentially_infinite_size(std::ranges::sized_range auto&& r) { return std::ranges::size(r); }
  auto potentially_infinite_size(std::ranges::infinite_range auto&&) { return std::infinite_tag; }

  template <class R>
  concept enable_size = requires(R&& r) { detail::potentially_infinite_size(r); };
}

template <class R>
class my_range_adaptor_that_does_not_affect_cardinality {
  R _r;

public:
  // size()をこのように定義することで伝播を自動化できる
  auto size() const requires detail::enable_size<R> { return detail::potentially_infinite_size(_r); }
};
```

ちなみにどの方法であっても、その番兵型が`unreachable_sentinel_t`であるような範囲は自動的に無限長であると識別されます。

現在のアダプタの中だと、次のものは基底の範囲が`infinite_range`ならば`infinite_range`になるようにオプトインが必要であるとしています

- `ref_view`
- `owning_view`
- `as_rvalue_view`
- `transform_view`
- `drop_view`
- `lazy_split_view`
- `split_view`
- `common_view`
- `reverse_view`
- `as_const_view`
- `elements_view`
- `enumerate_view`
- `adjacent_view`
- `adjacent_transform_view`
- `chunk_view`
- `slide_view`
- `chunk_by_view`
- `stride_view`
- `cache_latest_view`

そして、次のものに関しては濃度が不明であるか確実に有限であるため、変更は不要としています

- `filter_view` (unknown cardinality)
- `take_view` (finite)
- `take_while_view` (unknown cardinality)
- `drop_while_view` (unknown cardinality)

残ったもののうち

- `join_view`/`join_with_view`
    - 入力範囲の外側の範囲が`infinite_range`ならば`infinite_range`になるようにする
- `concat_view`
    - 少なくとも一つの範囲が`infinite_range`ならば`infinite_range`になるようにする
- `zip_view`/`zip_transform_view`
    - 全ての範囲が`infinite_range`ならば`infinite_range`になるようにする

とすることを提案しています。なお、言及されていないものは変更を提案していません。

- [LWG Issue 4019. Reversing an infinite range leads to an infinite loop](https://cplusplus.github.io/LWG/issue4019)
- [P3555 進行状況](https://github.com/cplusplus/papers/issues/2202)

### [P3557R0 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r0.html)
### [P3558R0 Core Language Contracts By Default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3558r0.pdf)

未定義動作のContractsによるハンドリングを将来のC++のデフォルトにする提案。

この提案はP3100R1で提示された未定義動作を契約違反として捉えることで契約プログラミング機能の枠組みで扱うようにする方向性を推進し、さらにそれを将来のC++におけるデフォルトとすることを提案しています。

P3100については以前の記事を参照

- [P3100R1 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3100R1-Undefined-and-erroneous-behaviour-are-contract-violations)

このメリットとしては次のことが挙げられています

- C++エコシステムはどんなプラットフォームでもそのまま安全に使用できる
    - 経験の浅い開発者や初学者が、複雑なコンパイラスイッチを学習することなく間違いが診断される
    - ユーザーの学習サイクルおよびソフトウェアのライフサイクルの早い段階で、様々な欠陥が明らかになる
    - このデフォルトの言語安全性は、必要に応じて無効化することもできる
- パフォーマンスが重要なプログラムにおいても、それが求められない場所で簡単にチェックを有効化できる
    - パフォーマンスが重要なプログラムを保守する人は、それを達成するためのコンパイラオプションに精通しているため、このデフォルトを無効化することも容易に行える
    - 一方で、パフォーマンスが求められない場所（デバッグ時や単体テストなど）においては逆にその無効化を行わない様にすることで簡単にチェックを有効化でき、最終的に出荷される高性能なリリースビルドにおける品質を向上させられる
- デフォルトでチェックを有効化されていれば、何もしなくてもバグを検出できる
    - バグがあるか分からない状況においては、追加のチェックを有効化するべき指示がない
    - デフォルトで有効化されていれば、その指示や判断無しにバグが検出される
    - 逆に、デフォルトで有効化されている場合、実行時パフォーマンスの低下という明確な証拠が示されることで無効化判断を行うことができる
- コードの変更が必要ない
    - 違反ハンドラの呼び出しおよびその動作を除いて、P3100R1で提案されている実行時チェックを有効化するためにソースコードに何らの変更も必要ない
    - C++26/29で記述される新しいプログラムだけでなく、このチェックがデフォルト化された新しいコンパイラで既存のコードをコンパイルするだけで、チェックが既存のプログラムにも適用される
- 違反ハンドラを活用できる
    - （実装がサポートしていれば）違反ハンドラの差し替えによってwell-definedなフォールバックを動作を指定できるため、ある実行時点でバグが検出されず修正されない場合でもリスクを軽減できる
    - ソースコードの変更を必要とせず、erroneous behaviorの恩恵を受けることができる
        - このEBは言語仕様において指定する必要がない

提案では懸念点についても考慮されています

- 実行時検査のオーバーヘッド
    - コア言語の事前条件をチェックするオーバーヘッドは一様ではなく、条件によって異なる
    - コンパイラで行われた/進行中の様々な実験によって、そのようなチェックのほとんどは典型的なプログラムの有用性に影響を与えるほどのものではない
    - チェックを現在のassumeセマンティクスに切り替える必要性の程度については実装経験によってのみ明らかになる
- 例外を送出しうる違反ハンドラ
    - 違反ハンドラが例外を送出できることによって、任意の契約注釈から例外送出される可能性が発生してしまい、コードを悪い状態にする可能性がある事が懸念されている
    - ただ、P3100R1のチェックで対処されない場合、その現在の状態は未定義動作であり、さらに悪い状態である
      - 多くの種類の未定義動作において実際に観測される動作範囲は実際には合理的に限定されており、未定義動作の結果として例外を送出することはまずありえない
          - そのため、例外を送出する状況は未定義動作よりも悪い状態ではない
    - 既存のコードが、nullptrデリファレンスからのコアダンプといったような未定義動作の特定の振る舞いに依存している可能性も指摘されており、このような動作を保証されたもの（あるいはそのように）のように扱うのは賢明ではないものの、ハイラむの法則からそのような動作の変更はある程度真剣に検討する必要がある
      - しかし一方で、この提案のデフォルト動作はまさにそのような動作を提供するものになる。例外を送出する違反ハンドラを選択するのは専門家ユーザーであり、そのようなユーザーこそがこのような違反ハンドラの柔軟性を最も必要としている
- 例外処理のオーバーヘッド
    - 違反ハンドラからの例外送出のために、例外を処理する追加のコードが生成される事もオーバーヘッドとなりうる
    - これについては、コンパイラが違反ハンドラの`noexcept`を要求するオプションを実装し、それによって関連するオーバーヘッドの無い翻訳単位を生成できるようにすることを強く推奨する
    - コンパイラとリンカは、この方法でビルドされた翻訳単位ではインストールされた違反ハンドラが`noexcept`であることを強制する必要がある

これらの事を踏まえて、ここでは次の3つの事を提案しています

1. プロファイル提案から、実行時チェックに関する機能を削除する
    - プロファイルが契約アサーションを導入したり、契約アサーションの評価セマンティクスを強制したりしないようにする
    - プロファイル機能は、特定の場所での言語機能の制限と未定義動作に繋がる操作の実行時検査、という二つのものを提供しようとしているが、その実行時検査の部分についてはこの提案およびP3100R1の方向性と衝突し、かつ領域が重複している
    - そのため、プロファイル提案の実行時検査に関する部分はこちらの提案に移管する
2. P3100R1の標準化を推進する
    - P3100R1の完全な仕様策定を継続し、P2900R13の後にこれを標準化する
3. *enforce*セマンティクスの推奨
    - P3100R1では、コア言語の事前条件について他の指定が無い場合、デフォルトの評価セマンティクスとして*enforce*を推奨する

対象にしているものが今日の未定義動作であるので、実際のところP3100及びこの提案の内容についてはすぐにでも作業を始めることができます。ひとまず必要な作業としては、プロファイル提案のように重複や衝突がある提案においてこのことを考慮するようにすることです。


- [P3558R0 進行状況](https://github.com/cplusplus/papers/issues/2204)

### [P3559R0 Trivial relocation: One trait or two?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3559r0.html)

P2786の提案する`is_trivially_relocatable`型特性の意味について反対する文書。

C++26に向けて、リロケーションという操作をサポートするための議論が進行しています。そのために、コア言語にてリロケーションという操作と型がリロケーション可能な場合の条件等を定義しようとしています。特に、トリビアルリロケーションというリロケーションの特別な場合の操作に重点が置かれています。

リロケーションとは、クラスオブジェクトのビット列を単にコピーすることによってオブジェクトの移動を行うことであり、それはムーブ+元オブジェクトの破棄と同等の操作として定義されます。トリビアルリロケーションはさらに、単なる`memcpy`のみによってリロケーションをすることを言います。どちらの場合でも、元のオブジェクトにもうアクセスしないような場合（例えば`std::vector`のキャパシティ伸長時など）に使用することで、ムーブよりもさらに効率的なオブジェクト移動を行うことができます。

C++26に向けたリロケーションの本命の提案はP2786R11であり、ここでは型がリロケーション可能かどうかを検出する型特性として2つのものが提案されています。

1. `std::is_replaceable_v<T>`: `T`のムーブ代入は、ムーブ構築+ムーブ元オブジェクトの破棄、によって行える
2. `std::is_trivially_relocatable_v<T>`: 上記操作は`memcpy`と同等である

一方で、P2786よりも前に最初にリロケーションを提案していたP1144では、同じ名前の型特性`std::is_trivially_relocatable_v<T>`を提供しているものの、その意味は`T`のムーブ代入が`memcpy`と同等であること、を表しています。すなわち、P1144の`std::is_trivially_relocatable_v<T>`はP2786のそれと異なる意味を持っており、`std::is_replaceable_v<T> && std::is_trivially_relocatable_v<T>`の両方を満たして初めて同等の意味になります（P2786では、`std::is_trivially_relocatable_v<T>`ならば`std::is_replaceable_v<T>`であるとは限らない）。

リロケーションの提案としてはP1144の方がかなり先行して公開（2018年）されていたため、リロケーションという最適化を独自に先んじて利用していた（当然未定義動作の危険性と隣り合わせですが）在野のライブラリはこのP1144のセマンティクスに基づく形で実装されている場合が多く、そこではライブラリ独自の`is_trivially_relocatable_v`を定義し、標準で利用可能になったら`std::is_trivially_relocatable_v`に切り替えるような実装が既に行われています。

```cpp
// 定義側
namespace lib {
  // Define a trait for property P,
  // by the name is_trivially_relocatable.
  template <class T>
  struct is_trivially_relocatable :
  #if __cpp_lib_trivially_relocatable // P1144
    std::is_trivially_relocatable<T> {};
  #else
    std::is_trivially_copyable<T> {};
  #endif
}

...

// 利用側
if constexpr (lib::is_trivially_relocatable<T>::value) {
  ~~~~ memcpy ~~~~
}
```

このような既存先行実装の`is_trivially_relocatable`のセマンティクスはP2786のものと異なっているため、このようなコードはP2786が今のまま採択された後ではその2つの型特性を用いて書き直す必要があります。

```cpp
// 定義側
namespace lib {
  // Define a trait for property P,
  // by the name is_trivially_relocatable.
  template <class T>
  struct is_trivially_relocatable :
  #if __cplusplus >= 20XXYYL  // P2786
    // Unfortunately the STL's version is weaker than ours
    std::bool_constant<std::is_trivially_relocatable_v<T> && std::is_replaceable_v<T>> {};
  #else
    std::is_trivially_copyable<T> {};
  #endif
}

...

// 利用側
if constexpr (lib::is_trivially_relocatable<T>::value) {
  ~~~~ memcpy ~~~~
}
```

あるいは利用側で2つの型特性を満たすように書き換えてもいいですが、これを行わないと異なる意味において型のトリビアルリロケーション可能性を判定してしまう可能性があり、それは未定義動作となるため対応されない場合既存の実装はそのままバグを抱えることになります。

そして、P2786の`is_trivially_relocatable`のセマンティクスは既存のライブラリが仮定するP1144のものとは異なっているため、このような対応は必須の作業となります。

この提案は、これらの問題からトリビアルリロケーションの型特性について、P2786のものではなくP1144のものを採用する事を主張するものです。

このことが問題となる既存のライブラリのほとんどはP1144の提供する`is_trivially_relocatable`のセマンティクスに基づいているため、P1144の型特性を採用すればこれらの問題はほぼ回避されます。

また、既存のライブラリ実装を見ても、P2786のようなセマンティクスで`is_trivially_relocatable`を定義しているライブラリはわずかであり、`is_replaceable`に至っては実装例がありません。このことからも、P1144の`is_trivially_relocatable`のセマンティクスが一般に望まれているものだと言えます。

- [P3559 進行状況](https://github.com/cplusplus/papers/issues/2205)

### [P3560R0 Error Handling in Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3560r0.html)

静的リフレクション機能におけるエラーハンドリング方法として例外を採用すべきとする提案。

C++26を目指してP2996で提案中の静的リフレクション機能においては、ライブラリの`consteval`メタ関数がエラーを報告する手段を決定する必要性が指摘されています。その方法として次の4つを提示していました

1. 無効なリフレクション（`std::meta::info`）を返す
2. 固有のエラー型`E`に対して、`std::expected<T, E>`を返す
3. 定数式ではなくする
4. `E`の例外を送出する

1は全てのメタ関数が`std::meta::info`を返すわけではない（`std::vector<std::meta::info>`や`string_view`を返すものがある）ため問題の解決にならず、2はハンドリングのためのコードの構文上の負担が大きいため最適ではなく、3はエラーから復帰するための方法が提供されない、といった難点があります。結局検討の末、定数式において例外を送出するのが最適であるとされました。

この決定がなされた当時（P2996R1）はまだ定数式で例外送出は許可されていなかったためP2996では3を採用していました。しかし、P3086R6がWDに採択されたことでそれが可能になったため、この提案はオプション4（例外）をリフレクションにおけるエラー報告メカニズムとして採用することを提案しています。

例外によってリフレクションのエラーを報告するようにする場合、メタ関数の戻り値型はそのままにしておくことができます。また、`std::expected<T, E>`のように案ラップにユーザーの手間をかける必要はなく、`catch`することでハンドリングすることができます。

実行時においてはバイナリサイズ増大やパフォーマンス低下のデメリットから例外は敬遠されがちですが、コンパイル時に使用する場合は例外のデメリットはほぼ関係なくなり、その他の方法と比較してメリットが勝ります。

提案では、リフレクション専用の例外型として次のような型を提案しています

```cpp
namespace std::meta {

  class exception {
  public:
      consteval exception(u8string_view what,
                          info from,
                          source_location where = source_location::current());

      // エラーに関する文字列
      consteval u8string_view what() const;

      // エラーが発生した関数/関数テンプレートのリフレクション
      consteval info from() const;

      // エラーが発生した関数の呼び出し位置
      consteval source_location where() const;
  };
}
```

コンパイル時にリフレクションのためのエラー報告として使用され、実行時に使用されないことから、この例外型は`std::exception`の派生クラスではなく、その必要がありません。

エラー文字列として`u8string_view`を使用しているのは、ソースコードで使用されうる識別子をすべて表現するためにエンコーディングとしてUTF-8を使用し、なおかつそれを型システムで表現するためです。ただし、`char8_t`型のライブラリサポートが万全ではないため、これによってエラーメッセージ文字列の生成方法が難しくなるという欠点もあります。

しかし、`std::string_view`を使用するようにする場合、識別子名の表現可能性によって別の問題が生じてしまいます。例えば`std::meta::identifier_of(x)`の実装において例外を使用するようにし、`std::meta::exception`が`string_view`しかサポートしていないとすると

```cpp
consteval string_view identifier_of(info x) {
  // xは識別子を反映していない
  if( !has_identifier(x) ) {
    throw meta::exception(u8"entity has no identifier", ^^identifier_of, ...);
  }

  auto id = u8identifier_of(x);

  // 識別子がリテラルエンコーディングで表現可能ではない
  if( !is_representable(id) ) {
    throw meta::exception(u8"identifier '"s + id + u8"'is not representable", ^^identifier_of, ...);
  }

  // convert id to the literal encoding and return it
}
```

この時、2つ目のエラーケースにおいてエラーメッセージにエラーを起こした識別子を入れようとするのは自然ですが、そもそもそれができないからエラーを報告しようとしているため、これは結局不可能です。

標準ライブラリが`char8_t`をサポートしていないという問題はサポートするようにすれば解決できるため、`u8string_view`を採用するのが現在のP2996R8の設計と一貫していて最適だとしています。

提案文書より、クラス型のリフレクションのみを受け入れるようにする例

```cpp
consteval auto user_fn(info type, source_location where = source_location::current()) {
  if( !is_class_type(type) ) {
    throw std::meta::exception(u8"not a class type", ^^user_fn, where);
  }

  // carry on
}
```

提案では、P2996R8にあるメタ関数でエラーを報告する必要があるものは基本的に例外を使用するように変更していますが、`std::meta::define_aggregate()`だけはエラーからの復帰が困難（そのために必要な保証を提供するコストに見合わない）であるとして、現状のままエラーは非定数式になるとしています。

- [P2996R1 Reflection for C++26 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2996R1-Reflection-for-C26)
- [P3560 進行状況](https://github.com/cplusplus/papers/issues/2206)

### [P3561R0 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r0.pdf)

`std::variant`に対してインデックスに基づく`visit()`操作を追加する提案。

`std::variant`の`visit()`操作は`variant`の候補型に同じ型が2つ以上あると上手く動作しません。`visit()`は関数オーバーロードとその解決によって静的に内包する値に応じた処理の呼び分けを行うため、異なる候補型に対しては同じオーバーロードがマッチングしてしまいます。

```cpp
std::variant<int, int, int> v{std::in_place_index<0>, 10}; // ok

// 候補型毎の呼び分けができない（どのintの値も同じ関数を呼び出す）
std::visit(v, [](int i) { ... });  // ok

// これは曖昧になりエラー
std::visit(v, overloaded{
                [](int i) { ... },
                [](int j) { ... },
                [](int k) { ... }
              });  // ng
```

このように、`variant`の候補型に同じ型が含まれていてもその型毎に個別の処理を行いたいような場合、`visit()`を使用することはできず、一番良い方法は`switch`分を使用することです。

```cpp
std::variant<int, int, int> v{std::in_place_index<0>, 10}; // ok

switch (v.index()) {
  case 0: a = std::get<0>(v); break;
  case 1: a = std::get<1>(v); break;
  case 2: a = std::get<2>(v); break;
  default: throw std::bad_variant_access();
}
```

これは大分煩雑なコードですが、現状これよりもきれいな形で記述することができません。

この提案では、それに対してインデックスベースのケースマッチングを行う操作を提案しています。この操作においては、呼び出す対象の型のインデックス（`variant`テンプレートパラメータの先頭からのインデックス）とその型のための処理を組にしたものを用いて`visit()`することによって、`variant`が2つ以上の同じ型を候補型として持っていたとしても呼び分けることを可能にします。

```cpp
std::variant<int, int, int> v{std::in_place_index<0>, 10}; // ok

// variantの候補型毎に呼び出す処理をその順番で指定して、それによるオーバーロード関数オブジェクトを返す
auto compute = invoke_cases(
  [](int i) -> int { return i; },
  [](std::string const &s) -> int { return s.length(); },
  [](int j) -> int { return j + 100; }
);

std::println("result: {}", compute(v));
```

`invoke_cases()`はここで提案されている操作の一つで、ある`variant`に対してその値に応じて適用したい処理を渡して、`variant`オブジェクトを受けてそれらの呼び出しを適切にディスパッチする関数オブジェクトを返します。この時、後から渡される`variant`オブジェクトの実行時の状態に応じて呼び出す関数を決定するのはインデックスベースであり、`.index()`に対して`invoke_cases()`に渡した関数の先頭からのインデックスと（両方0-indexed）一致する関数を選択して、その値を渡す形で呼び出します。

`variant<T0, T1, ..., Tn>`に対して`invoke_cases(f0, f1, ..., fn)`は`fi`が`Ti`の値で呼び出し可能である必要があります。`invoke_cases()`では渡された関数の引数順でのインデックスを暗黙的に対象`variant`でのテンプレートパラメータ順の指定と見做すことで、処理とインデックスの紐づけを自動化しています。

この提案では、このような操作を微妙な性質の違いから次の6種類提案しています

- `visit_invoke()`
    - 対象の`variant`オブジェクトと、その各候補型に対して呼び出す処理をまとめた`tuple`を受け取り、`variant`のアクティブなインデックスに対応する値と処理（`tuple`の先頭からのインデックスでマッチング）を呼び出す
- `visit_apply()`
    - 対象の`variant`オブジェクトと、その各候補型に対して呼び出す処理をまとめた`tuple`を受け取り、`variant`のアクティブなインデックスに対応する値と処理（`tuple`の先頭からのインデックスでマッチング）を呼び出す
    - この時、呼び出しには`std::apply()`を使用する
        - `variant`の候補型は`tuple`-likeでなければならない
- `visit_apply_cases()`
    - 対象の`variant`オブジェクトと、その各候補型に対して呼び出す処理をその候補型の数受け取り、受け取った処理を`tuple`にまとめて`visit_apply()`を呼び出す
- `apply_cases()`
    - 対象の`variant`オブジェクトの各候補型に対して呼び出す処理をその候補型の数受け取り、`variant`オブジェクトを引数に取り受け取った処理によって`visit_apply()`を呼び出す呼び出し可能ラッパオブジェクトを返す
- `visit_invoke_cases()`
    - 対象の`variant`オブジェクトと、その各候補型に対して呼び出す処理をその候補型の数受け取り、受け取った処理を`tuple`にまとめて`visit_invoke()`を呼び出す
- `invoke_cases()`
    - 対象の`variant`オブジェクトの各候補型に対して呼び出す処理をその候補型の数受け取り、`variant`オブジェクトを引数に取り受け取った処理によって`visit_invoke()`を呼び出す呼び出し可能ラッパオブジェクトを返す

これらの関数の命名は、渡す関数が単一の引数を取るものである場合に`invoke`、複数の引数を取る場合は`apply`を使用しており、可変長引数によって処理を受けるラッパである場合は`cases`を使用しています。`visit`は呼び出し対象の`variant`オブジェクトを直接取るものに対して使用されます（`visit`ではないものは関数オブジェクトを返す）。

|関数|処理の引数の数|`variant`を受け取る|処理の渡し方|結果|
|---|:-:|:-:|:-:|:-:|
|`visit_invoke()`|1|yes|`tuple`|呼び出し結果|
|`visit_apply()`|複数|yes|`tuple`|呼び出し結果|
|`visit_apply_cases()`|複数|yes|可変長引数|呼び出し結果|
|`apply_cases()`|複数|no|可変長引数|関数オブジェクト|
|`visit_invoke_cases()`|1|yes|可変長引数|呼び出し結果|
|`invoke_cases()`|1|no|可変長引数|関数オブジェクト|

少し順番は前後しますが、サンプルコード

```cpp
std::variant<int, int, int> v{std::in_place_index<0>, 10}; // ok

// 対象variantオブジェクトと、候補型毎の処理をその順番で渡してvisit
auto result = visit_invoke_cases(
  v,
  [](int i) -> int { return i; },
  [](std::string const &s) -> int { return s.length(); },
  [](int j) -> int { return j + 100; }
);

std::println("result: {}", result);
```
```cpp
std::variant<int, int, int> v{std::in_place_index<0>, 10}; // ok

// 対象variantオブジェクトと、候補型毎の処理をその順番でtupleに詰めて渡してvisit
auto result = visit_invoke(
  v,
  std::make_tuple(
    [](int i) -> int { return i; },
    [](std::string const &s) -> int { return s.length(); },
    [](int j) -> int { return j + 100; }
  )
);

std::println("result: {}", result);
```

```cpp
using message = std::tuple<int, int>;
using message2 = std::pair<int, std::string>;

std::variant<message, message2> args{
  std::in_place_index<0>, std::make_tuple(3, 4)
};

std::variant<message, message2> args2{
  std::in_place_index<1>, std::make_pair(3, "teststring")
};

// variantの候補型毎に呼び出す処理をその順番で指定して、それによるオーバーロード関数オブジェクトを返す
// 候補型はtuple-likeであり、処理はその要素を全て順序通りに受け取れる必要がある
auto analyze = apply_cases(
  [](int x, int y) -> int { return x + y; },
  [](int x, std::string const &y) -> int { return x + y.length(); }
);

int result = analyze(args);
int result2 = analyze(args2);
```

```cpp
using message = std::tuple<int, int>;
using message2 = std::pair<int, std::string>;

std::variant<message, message2> args{
  std::in_place_index<0>, std::make_tuple(3, 4)
};

std::variant<message, message2> args2{
  std::in_place_index<1>, std::make_pair(3, "teststring")
};

// 対象variantオブジェクトと、候補型毎の処理をその順番で渡してvisit
// 候補型はtuple-likeであり、処理はその要素を全て順序通りに受け取れる必要がある
int result = visit_apply_cases(
  args,
  [](int x, int y) -> int { return x + y; },
  [](int x, std::string const &y) -> int { return x + y.length(); }
);
```

```cpp
using message = std::tuple<int, int>;
using message2 = std::pair<int, std::string>;

std::variant<message, message2> args{
  std::in_place_index<0>, std::make_tuple(3, 4)
};

std::variant<message, message2> args2{
  std::in_place_index<1>, std::make_pair(3, "teststring")
};

auto tup = std::make_tuple(
  [](int x, int y)-> int { return x + y; },
  [](int x, std::string const &y)-> int { return x + y.length(); }
);

// 対象variantオブジェクトと、候補型毎の処理をその順番でtupleに詰めて渡してvisit
// 候補型はtuple-likeであり、処理はその要素を全て順序通りに受け取れる必要がある
int result4 = visit_apply(args, tup);
int result5 = visit_apply(args2, tup);
```

このような操作は圏論における余積（coproduct）から来ているものの様で、それについての数学的な対応付けの説明が提案ではなされています。

- [P3560 進行状況](https://github.com/cplusplus/papers/issues/2207)

### [P3564R0 Make the concurrent forward progress guarantee usable in `bulk`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3564r0.html)
### [P3565R0 Virtual floating-point values](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3565r0.html)

C++における浮動小数点数演算のセマンティクスについての提案。

現在のC++の規定では、浮動小数点数演算の結果についてほぼ何も保証していません。演算の精度は実装定義とされており、さらには浮動小数点数オペランドや演算結果がその型の値ではない場合もあるという規定もあります。このような規定は実際に、浮動小数点数演算を含む式を数式として解釈して最適化を行うことで、計算性能や精度を向上させることの根拠となってもいます。

一方で、well-definedな浮動小数点数演算を厳密に（コードの通りに）適用することは、一部の数値アルゴリズムにとって極めて重要な場合があります。

現在のC++のこのような規定はCから受け継いだものであり、Cが`FLT_EVAL_METHOD`等のマクロによってこの自由度から実装が何を選択しているのかを表明する方法を提供しているように、C++においてもC++特有の事情を考慮したうえでこの自由度をより一貫して解釈する方法についてを模索する試みが始まっています。しかし、それはまだ成果を伴うものではありません。

この提案は、そのようなセマンティクスの一案を提示するものです。ここで提案されているのは次の事です

- トリビアルコピー可能な型の定義の変更
    - 浮動小数点数型はある一つの値表現に対して複数の値を持つことを許可する
    - そのような値集合のうち一つは標準的な値（*canonical*）である
- 浮動小数点数型がある値表現を取得すると、そのオブジェクトは対応する標準的な値を持つ
- より高い精度と範囲の規定（[expr.pre]/6）を、丸め処理の文脈依存性に関する注記に置き換える
- 単項+演算子と`static_cast`は、浮動小数点数値を対応する標準的な値に丸める

これは、浮動小数点数型の値の集合を、その型がメモリ上で占有する領域に格納可能な値の範囲を超えて拡張するというアプローチを採用した場合の仕様の提案です。このセマンティクスによって、浮動小数点数値は浮動小数点数型の値表現に対して多対一で対応を関係を持つものの、あらゆる浮動小数点数演算および浮動小数点数型オブジェクトは依然として単一の値を持つ、事になります。

これにより、`a * b + c`という式（全て`double`値とする）の部分式の結果は`double`の表現可能な値の範囲外の値を取ることができ、この式の結果の値の選択はFMA命令によって実装されている丸めによって行われます。

このようなセマンティクスによって、FMAのような浮動小数点数演算を数式として解釈する最適化は依然として許可されるものの、その結果は実装定義なものではなくなり、最適化の境界を越えて伝播する値はその型によって制限され、標準的な値という単一の値を取るようになります。この提案では仮想的な値を取っている浮動小数点数値を明示的に標準的な値に丸めるための方法として`static_cast`（と単項`+`）を採用しています。

単なる代入操作は標準的な値への丸めを実行するポイントではなく、これは浮動小数点数型のラッパ型においても同様のセマンティクスを適用するためです。

- [P3565 進行状況](https://github.com/cplusplus/papers/issues/2209)

### [P3566R0 You shall not pass `char*` - Safety concerns working with unbounded null-terminated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3566r0.pdf)

その長さが静的に既知ではない文字列（`const char*`）を受け取る`std::string`/`std::string_view`のコンストラクタを置き換える提案。

`std::string`/`std::string_view`はどちらにも、`const char*`を受け取るコンストラクタが存在します。これは、実行時に受け取った文字列ポインタから文字列を取得する関数ですが、その終端は渡されるまで未知のため構築時に`\0`を探して終端を決定します。しかしこの動作は、間違ったポインタが渡された場合などに無制限にメモリ空間を探索してしまう（当然UB）という問題があります。

```cpp
auto f(const char* ntbs) {
  std::string str{ntbs};        // ntbsがnull終端文字列でない場合UB
  std::string_view strv{ntbs};  // 同上
}
```

この提案は、C++の安全性向上の一環として、そのようなコンストラクタをより安全な動作をするものと明示的なもので置き換えようとする提案です。

提案では、`std::stirng`と`std::string_view`の`const char*`を取る現在のコンストラクタを非推奨にしたうえで、`const char(&)[N]`（配列参照）を取るコンストラクタを追加し、`const char*`から構築するコンストラクタを`std::unsafe_length_t`タグを明示的に取るコンストラクタとして追加します。

`string_view`で単純に例示すると次のようになります

```cpp
// 現在のコンストラクタ
constexpr string_view(const char *p) noexcept
  : _data(p), _size(Traits::length(p)) {...}
```

```cpp
// この提案による変更
[[deprecated]]
constexpr string_view(const char *p) noexcept
  : _data(p), _size(Traits::length(p)) {...} 

template<size_t N> 
string_view(const char (&p)[N]) noexcept 
  : _data(p), _size(Traits::length_s(p, N)) noexcept {...} 

explicit constexpr string_view(unsafe_length_t, const char *p) noexcept
  : _data(p), _size(Traits::length(p)) {...} 
```

同様に、引数に`cosnt char*`を渡させるインターフェースのうちで安全ではないもの（無制限の探索を行いうるもの）を非推奨とするとともにコンストラクタと同様の引数を取る新しいオーバーロードを追加します。

- 両方
    - `find_first_of, find_last_of, find_first_not_of, find_last_not_of`
- `std::string`のみ
    - `insert`
    - `append, operator+=`
    - `replace`
    - 非メンバ`operator+`
      - タグ付きオーバーロードはなし

そして、`std::char_traits`に`length_s`を追加して最大文字数を指定しながら文字列長の計算（文字列終端の探索）を行えるようにします

```cpp
template<size_t N> 
size_t length_s(const char_type (&s)[N]) {...} 

size_t length_s(const char_type* s, size_t N) {...} 
```

これは`strnlen_s()`と同様に動作し、長さ`N`内でnull文字が見つかる場合はその前の文字数を返し、見つからない場合は`N`を返します。

ここでは`std::stirng`と`std::string_view`で例示しましたが、これらの変更は`std::basic_string`および`std::basic_string_view`に対して行われます。

```cpp
auto example1(const char* ntbs) {
  std::string str1{ntbs};        // コンストラクタは非推奨
  std::string_view strv1{ntbs};  // コンストラクタは非推奨

  std::string str2{std::unsafe_length, ntbs};        // ok
  std::string_view strv2{std::unsafe_length, ntbs};  // ok
}

template<std::size_t N>
auto example1(const char(&ntbs)[N]) {
  std::string str{ntbs};        // ok、最大でもN文字の範囲内で終端チェックを行う
  std::string_view strv{ntbs};  // ok、最大でもN文字の範囲内で終端チェックを行う
}
```

- [P3566 進行状況](https://github.com/cplusplus/papers/issues/2210)

### [P3567R0 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r0.html)

`flat_xxx`な連想コンテナに対するバグフィックス提案。

この提案はlibc++での実装経験をベースとした`std::flat_map`をはじめとする`flat_xxx`なコンテナに対する修正提案です。

同様の提案は以前にP2762R2でも提出されていましたが、そちらはより影響の大きい設計変更を含んでいたため合意に至ることができませんでした。libc++における`std::flat_map`等連想コンテナのリリースが完了したことに伴って、改めてその経験から得られたより純粋な問題点についてここでは報告されています。

修正は次のものです

- `flat_map::insert_range()`で挿入する範囲の要素型が`pair`であることを明確にする
    - 効果を指定する式において要素型を`auto`で受けており、これだと`tuple`等も使用可能だったものの、明らかに`std::pair`だけを対象にしていた
    - 要素型を明確に`value_type`（`std::pair<Key, Value>`）で取るとともに、他のコンテナとの一貫性向上のために`ranges::for_each`を使用するように修正する
- `swap`の条件付き`noexcept`指定
    - `flat`なコンテナの`swap`はすべて無条件`noexcept`指定されているが、使用するコンテナの`swap`が例外を送出した場合に不変条件を保護しながら取れることは次の2つしかなかった
        - 例外を握り潰し、不変条件を復元する（内部コンテナをクリアする）
        - `std::terminate()`
    - 不変条件を復元しながら例外を伝播させることを許可するために、`swap()`を条件付き`noexcept`にする
- `insert_range(sorted_unique, rg)`の欠如
    - `flat`なコンテナはいずれも`insert_range()`によって任意の範囲を挿入できるが、複数の要素を一度に挿入できるその他の方法（イテレータペア/初期化子リスト）ではサポートされているソート済み範囲からの挿入がサポートされていない
    - `flat_map`/`flat_multimap`の`insert_range()`には`sorted_unique`を取るオーバーロードを追加し、`flat_set`/`flat_multiset`の`insert_range()`には`sorted_equivalent`を取るものを追加する
- `flat_set::insert_range()`におけるコピーの回避
    - `flat_set::insert_range()`では入力範囲の要素型が`Key`型（に変換可能な型）であればいいため、可能ならムーブすることができるが、現在の規定はそれを妨げている
    - 効果を指定する式において`auto&&`で受けて完全転送するように指定する
- 特殊メンバ関数が規定されていない
    - `flat`なコンテナはいずれも特殊メンバ関数（コピー/ムーブ コンストラクタ/代入演算子）が明示的に指定されていない
      - `= default`定義してしまうと、ムーブやコピー時に例外が送出された場合に不変条件が保護されなくなる
    - 特殊メンバ関数の宣言とその動作を明確に指定することで、その実行中に例外が送出された場合でも不変条件が保たれる事を規定する

なお、`flat`な連想コンテナの不変条件とは、内部コンテナがソート済みであることと、`map`の場合は2つのコンテナの要素数が一致し、なおかつ`Key`のコンテナと`Value`のコンテナで同じインデックス位置にあるものは`Key`-`Value`ペアの対応付けされた要素であること、です。

- [P2762R2 `flat_map/flat_set` omnibus - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2767R2-flat_mapflat_set-omnibus)
- [LWG Issue 4000. flat_map::insert_range's Effects is not quite right](https://cplusplus.github.io/LWG/issue4000)
- [P3567 進行状況](https://github.com/cplusplus/papers/issues/2211)

### [P3568R0 break label; and continue label;](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3568r0.html)
### [P3569R0 Split `define_aggregate` from Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3569r0.pdf)

`define_aggregate()`をP2996のリフレクション提案から外す提案。

`define_aggregate()`はその名の通り集成体型を定義するためのリフレクションメタ関数です。例えば次のように使用できます

```cpp
// タプル型を実装する例
template<typename... Ts>
struct Tuple {
  struct storage;
  consteval {
    define_aggregate(^^storage, {data_member_spec(^^Ts)...})
  }
  storage data;

  Tuple(): data{} {}
  Tuple(Ts const& ...vs): data{ vs... } {}
};
```

1つ目に不完全クラス型（もしくは共用体型）を受け取り、2つ目の引数で受け取ったデータメンバのリフレクションの列を受け取って、そのクラス型に対して指定されたデータメンバを集成体型として実装する形の定義のリフレクションを返す関数です。

この`define_aggregate()`は非常に便利な機能ではあるもののその設計に関してはこれまで二転三転してきており、P2996の他の部分の安定性と比較すると明確に不安定かつリスクのある機能になっています。

その理由の1つは*complete-class context*（完全クラスコンテキスト）という概念についてのものです。完全クラスコンテキストの概念はP2996R9を見ても明確ではないですが、どうやら定数評価中に`define_aggregate()`で定義することで完全型となったクラス型について、その完全性が観測可能になる場所とタイミングについてを規定しようとしているものの様です。

もう一つは、到達可能性（*reachability*）の新しい形式を導入しようとしていることです。到達可能性はモジュールの採択時に導入されたあるコンテキストからの宣言の利用可能性についての規格用語ですが、`define_aggregate()`によって生成された定義がいつどこで到達可能になるかを規定するために到達可能性の定義を拡張し用としています。

どちらの問題も設計や問題解消方法がまだ固まっておらず、この提案の提出時点でC++26のタイムフレーム内で解決できるか見通しが立っていない状況です。

それを受けてこの提案では、C++26にリフレクション機能を確実に間に合わせるために、P2996からこの`define_aggregate()`を取り除くことを提案しています。

リフレクション機能のほとんどの部分はコンパイラが内部に持っているASTの状態をクエリする事で成り立っており、これは現在の型特性機能が行っていることでもあるため実装はそれを認識し、専用のインターフェースを用意しています。一方で`define_aggregate()`は定数評価中にASTを書き換えることができる機能であるため、実装にとっても標準にとっても新たな試みであり、多くの課題があります。

このようなコード生成に関する機能は最終的にはリフレクション機能の一部として必要であるものの、現時点の他の部分のリフレクション機能（クエリ関連機能）だけでも十分に有用性があり、なおかつCWG内でもほとんど異論がありません。

このため、`define_aggregate()`を切り離すことでリフレクション機能全体がC++26に間に合わなくなるリスクを大きく低減することができるとともに、`define_aggregate()`の実装と規定に関しての探求作業を集中的に行うことができるようになります。

どうやら、この提案はEWGにてコンセンサスを得られなかったようです。

- [P3569 進行状況](https://github.com/cplusplus/papers/issues/2213)

### [P3572R0 Pattern matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3572r0.pdf)
### [P3573R0 Contract concerns](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3573r0.pdf)
### [P3574R0 Constexpr Callables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3574r0.pdf)
### [P3575R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2024/11/13](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3575r0.pdf)
### [P3576R0 SG19: Machine Learning virtual Meeting Minutes to 2024/11/14-2024/12/12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3576r0.pdf)
### [P3577R0 Require a non-throwing default contract-violation handler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3577r0.pdf)
### [P3578R0 Language Safety and Grandma Safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3578r0.pdf)
### [P3579R0 Fix matching of non-type template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r0.html)
### [P3580R0 The Naming of Things](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3580r0.pdf)
### [P3581R0 No, inplace_vector shouldn't have an Allocator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3581r0.pdf)
### [P3582R0 Observed a contract violation? Skip subsequent assertions!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3582r0.html)
### [P3583R0 Contracts, Types & Functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3583r0.pdf)
### [P3584R0 Enrich Facade Creation Facilities for the Pointer-Semantics-Based Polymorphism Library - Proxy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3584r0.pdf)
### [P3585R0 allocator_traits::is_internally_relocatable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3585r0.html)
### [P3586R0 The Plethora of Problems With Profiles](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3586r0.html)
### [P3587R0 Reconsider reflection access for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3587r0.html)
### [P3588R0 Allow static data members in local and unnamed classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3588r0.html)
### [P3589R0 C++ Profiles: The Framework](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3589r0.pdf)
### [P3590R0 Constexpr Coroutines Burdens](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3590r0.pdf)
