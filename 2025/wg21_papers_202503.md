# ［C++］WG21月次提案文書を眺める（2025年03月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-03](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-03)

全部で164本あります。

もくじ

[:contents]

### [N5004 2025 Sofia Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5004.pdf)

2025年6月にブルガリアのソフィアで行われる全体会議のインフォメーション。

予定（2025年6月16日～21日）と場所、ホテルの案内などが記載されています。

### [N5005 WG21 2025-01 Hagenberg Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5005.pdf)

2025年1月27日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Hagenberg会議で何をするかなどの報告がなされています。

### [N5006 2025 WG21 admin telecon meetings (revised 2025-02-20)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5006.pdf)

今後のWG21管理者ミーティングのインフォメーション。

### [N5007 WG21 02/2025 Hagenberg Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5007.pdf)

2025年2月にHagenbergで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N5008 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf)

C++26のワーキングドラフト第7弾

### [N5009 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5009.html)

↑の変更点をまとめた文書。

### [P0260R15 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r15.html)
### [P0260R16 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r16.html)
### [P0876R20 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0876r20.pdf)
### [P1494R5 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1494r5.html)
### [P1967R14 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1967r14.html)
### [P2079R7 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r7.html)
### [P2287R4 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2287r4.html)
### [P2414R6 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r6.pdf)
### [P2663R7 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2663r7.html)
### [P2719R4 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r4.html)
### [P2758R5 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2758r5.html)
### [P2781R6 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r6.html)
### [P2781R7 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r7.html)
### [P2781R8 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r8.html)
### [P2786R12 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r12.html)
### [P2786R13 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r13.html)
### [P2825R5 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2825r5.html)
### [P2830R10 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2830r10.html)
### [P2841R7 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf)
### [P2843R2 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r2.pdf)
### [P2846R6 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2846r6.pdf)
### [P2863R9 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2863r9.html)
### [P2873R3 Remove Deprecated locale category facets for Unicode from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2873r3.pdf)
### [P2876R2 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2876r2.html)
### [P2899R1 Contracts for C++ - Rationale](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2899r1.pdf)
### [P2900R14 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2900r14.pdf)
### [P2933R4 Extend <bit> header function with overloads for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2933r4.html)
### [P2988R10 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r10.pdf)
### [P2988R11 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r11.pdf)
### [P2996R10 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r10.html)
### [P3008R4 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r4.html)
### [P3016R6 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
### [P3019R13 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3019r13.html)
### [P3019R14 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3019r14.pdf)
### [P3060R2 Add std::views::indices(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3060r2.html)
### [P3070R3 Formatting enums](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3070r3.html)
### [P3074R6 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r6.html)
### [P3074R7 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r7.html)
### [P3081R2 Core safety profiles for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3081r2.pdf)
### [P3096R6 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r6.pdf)
### [P3096R7 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r7.pdf)
### [P3104R3 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3104r3.html)
### [P3111R4 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r4.html)
### [P3111R5 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r5.html)
### [P3137R3 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3137r3.html)
### [P3149R9 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r9.html)
### [P3161R3 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r3.html)
### [P3179R6 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r6.html)
### [P3179R7 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r7.html)
### [P3229R1 Making erroneous behaviour compatible with Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3229r1.pdf)
### [P3230R2 views::unchecked_(take|drop)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3230r2.html)
### [P3242R1 Copy and fill for mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3242r1.html)
### [P3248R3 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3248r3.html)
### [P3284R3 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3284r3.html)
### [P3287R3 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3287r3.pdf)
### [P3296R4 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3296r4.html)
### [P3319R3 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r3.pdf)
### [P3319R4 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r4.pdf)
### [P3319R5 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r5.pdf)
### [P3331R1 Accessing The First and Last Elements in Associative Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3331r1.pdf)
### [P3349R1 Converting contiguous iterators to pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3349r1.html)
### [P3365R1 Remove the Deprecated iterator Class Template from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3365r1.pdf)
### [P3366R1 Remove Deprecated Atomic Initialization API from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3366r1.pdf)
### [P3367R4 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3367r4.html)
### [P3372R3 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3372r3.html)
### [P3378R2 constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3378r2.html)
### [P3383R2 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3383r2.html)
### [P3385R4 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r4.html)
### [P3394R2 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r2.html)
### [P3395R1 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r1.html)
### [P3395R2 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r2.html)
### [P3400R1 Specifying Contract Assertion Properties with Labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3400r1.pdf)
### [P3417R1 Handling exceptions thrown from contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3417r1.pdf)
### [P3430R3 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3430r3.pdf)
### [P3441R1 Rename simd_split to simd_chunk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3441r1.html)
### [P3441R2 Rename simd_split to simd_chunk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3441r2.html)
### [P3442R1 [[invalidate_dereferencing]] attribute](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3442r1.pdf)
### [P3471R3 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r3.html)
### [P3471R4 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r4.html)
### [P3472R1 Make fiber_context::can_resume() const](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3472r1.html)
### [P3475R2 Defang and deprecate memory_order::consume](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3475r2.pdf)
### [P3477R3 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r3.html)
### [P3477R4 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r4.html)
### [P3477R5 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r5.html)
### [P3480R4 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r4.pdf)
### [P3481R2 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r2.html)
### [P3482R1 Design for C++ networking based on IETF TAPS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3482r1.html)
### [P3491R2 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r2.html)
### [P3492R1 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3492r1.html)
### [P3492R2 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3492r2.html)
### [P3499R1 Exploring strict contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3499r1.pdf)
### [P3500R1 Are Contracts "safe"?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3500r1.pdf)
### [P3503R1 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r1.html)
### [P3503R2 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r2.html)
### [P3505R0 Fix the default floating-point representation in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3505r0.html)

`std::format()`における浮動小数点数出力時のデフォルトの表現（`g`オプション）を修正する提案。

`std::format()`の浮動小数点数出力時のフォーマット方法は`std::to_chars`を用いて指定されており、これはCロケールと同じ出力を規定するために実質的にCの標準によって指定されています。

Cロケールによるデフォルトの出力では、出力後の浮動小数点数表現が短くなるように指数表記と固定小数表記を切り替えますが、この「短くなる」の意味が出力文字数によるものであると誤解されて実装されてしまう場合があることによって、`std::format()`のデフォルトの浮動小数点数出力も間違った表現を選択する場合があるようです。

たとえば、`100000.0`と`120000.0`は本来同じ形式で出力される必要があります（たとえば`python`の例）

```python
>>> 100000.0
100000.P3526R0 
>>> 120000.0
120000.0
```

しかし、`std::format()`の場合異なった形式によって出力されます

```cpp
auto s1 = std::format("{}", 100000.0);  // s1 == "1e+05"
auto s2 = std::format("{}", 120000.0);  // s2 == "120000"
```

これによって、本来の意味の可能な限り短い表記が順守されず、表現可能な精度の外の値（garbage digits）が出力されてしまいます

```cpp
auto s = std::format("{}", 1234567890123456700000.0);
// s == "1234567890123456774144"
```

最後の5桁`74144`は意味のない値であり、現代の一般的な浮動小数点数フォーマットでは出力されることがないはずの値です。例えば、pythonはこの場合に指数表記を選択することでこれを回避します

```cpp
>>> 12345678901234567800000.0
1.2345678901234568e+22
```

正しい浮動小数点数出力を行うことのできる既存の実装ではこのような意味のない桁を出力できないため、`std::format()`の実装に当たってはこのような下位桁を計算するための特別な実装を必要としており、それによってフォーマットパフォーマンスの低下を招いています。

正しい浮動小数点数表現とは Steele & White (1990) で定義されたものをベースとしているようで、そこではそのような出力アルゴリズムの特性として次の4点を指摘しています

1. 情報の損失が発生しない
    - 出力値の丸めによって、元の値を正確に復元できる
2. 無意味な桁（"garbage digits"）が生成されない
3. 出力値は適切に丸められる
4. 丸め処理の際に桁を繰り返す必要がない

重要なのはこの2番目の項目で、これは簡潔性（"shortness"）の保証と呼ばれているようです。簡潔性保証はアルゴリズムが他の要件（特にラウンドトリップ保証）を満たすために必要な最小の桁数で出力するべき、という意味であり、これは仮数の小数点以下の桁数にのみ着目したもので、指数や小数点などは考慮されないものののようです。

前述のように、C++においてはこの簡潔性についての言及を出力文字数の短さと解釈してしまっていることで、現在の`std::format()`の浮動小数点数出力に問題が起きています。

この提案では、本来の意味での簡潔性を指定するように規定を修正することで、`std::format()`の浮動小数点数出力を正しいものに修正しようとしています。

具体的には、フォーマット対象の浮動小数点数値が$[10^{-4}, 10^n)$の範囲にある場合は固定小数形式を使用し、そうでなければ指数形式を使用する、ように明示的に指定しています。なお、ここでの$10^n$は、浮動小数点数型を`FP`、`m = std::numeric_limits<FP>::digits + 1`として、$2^m$を最も近い10の累乗値に丸め下げたものです。

例えば`double`型の場合`std::numeric_limits<FP>::digits`は`53`となり、$2^54$となり、これを最も近い10の累乗値に丸め下げたものは$10^16$となります。これらの値はpythonやrust、swiftやjava等と同じ値になっているようです。

この下限値は絶対値が小さい値の出力について固定少数形式を回避し、上限値は大きい値の出力について固定少数形式を回避しようとするものです。

これによって、ほかの主要なプログラミング言語における出力と同等の出力得るようになるとともに、無意味な桁を出力するためのパフォーマンス低下を回避することができます。また、これは`{fmt}`ライブラリにおいて少なくとも6年前から実装され出荷されているとのことです。

この変更は破壊的変更となるものの、ABIやラウンドトリップの保証には影響がなく、浮動小数点数の正確な表現への依存は通常推奨されないため、影響は中程度であるとしています。

- [Guy L. Steele Jr.; Jon L White. How to Print Floating-Point Numbers Accurately. 1990.](https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf)
- [P3505 進行状況](https://github.com/cplusplus/papers/issues/2245)

### [P3516R1 Uninitialized algorithms for relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r1.html)
### [P3526R0 Container truncation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3526r0.html)
### [P3533R2 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3533r2.html)
### [P3537R1 Presentation on Concurrent Queue API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3537r1.pdf)
### [P3540R1 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3540r1.html)
### [P3544R0 `ranges::to<view>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3544r0.html)

`ranges::to`が変換先として`view`を指定できない制約を取り除く提案。

`ranges::to<C>(...)`は変換先の型`C`に対して`view`ではない事だけを要求しています。これによって例えば、分割文字列を`std::string_view`を要素とするコンテナに詰めていく様な使用法が阻害されています。

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | ranges::to<vector<string_view>>(); // error
```

`ranges::to`の入力範囲が`range`の`range`になっている場合、`ranges::to`は内部で内側の範囲に対して再帰的に`ranges::to`を呼び、その際に入力の内側範囲が`C`の内側範囲に変換可能ではない場合（`views::split`の内側範囲は`std::string_view`に暗黙変換できない）、`ranges::to<range_value_t<C>>`のように呼ぶため`C`も`range`の`range`になっている場合は内側の範囲も`view`であってはなりません。

この例は内側の`std::string_view`が`view`であるためにエラーになっています。ただし、次のように`C`の内側の型を指定しなければ動作します

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | ranges::to<vector>(); // ok
```

この場合、入力の内側範囲は`subrange`が使用されているため、`C`の内側範囲も`subrange`になることによって上手くいきます。ただし、この場合の`subrange`は`view`のはずです。そこで同様に、ラムダ式を用いて`C`の内側範囲を指定しない形で呼び出すと動作するようになります

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | views::transform([](auto r) { return string_view(r); })
          | ranges::to<vector>(); // ok
```

これは、`ranges::to<vector>`への入力範囲の内側範囲が`std::string_view`になることによって、推論される出力範囲の要素型（内側範囲）と一致することで変換可能になり、その際の処理パスでは`C`の内側範囲型に対する`view`の制約チェックが行われないためです。

そしてさらに、これと似た理由によって次のコードは動作してしまいます

```cpp
auto ints = "1.2.3.4"sv
              | views::split('.')
              | ranges::to<vector<span<const char>>>(); // ok in the current standard!!!
```

これは、`std::span`の`range`コンストラクタが`explciit`指定されないことによって入力の内側範囲（`views::split`の要素型）が出力の内側範囲（`span<const char>`）に変換可能になることで、同様に`span<const char>`が`view`であるというチェックがスキップされるためです。

文字列を`split, slide, chunk, chunk_by`などのアダプタを使用して処理した結果を`string_view`のコンテナに入れることはかなり一般的なワークロードと思われるため、これらはもっと簡易に実行できる（最初のコードが動作する）必要があります。

そもそも`ranges::to`のターゲット型が`view`であってはならない理由を考えると、2つの理由がありそうです

1. ユーザーが`view`から`view`を作成できないようにするため
2. 安全性への懸念から

前者の場合、`<range>`ヘッダにある`view`型については理に適っているかもしれません（アダプタを使わない理由が無いため）が、`ranges::to<string_view>`のように`std::string_view`/`std::span`についてはあてはまりません。また、`views::take`の代わりに`ranges::to<take_view>`をわざわざやりたがる人もいないと思われるものの、禁止するほどの悪影響があるわけでもなさそうです。

後者の理由は説得力があります。実際、`std::string_view`は右辺値文字列から構築できるため、単純に許可してしまうと`ranges::to<string_view>(string("abc"))`の様な変換が可能になってしまいます（これはダングリング状態になる）。しかしこれは、入力範囲に`borrowed_range`を要求することで簡単に解決することができます。

この提案は`ranges::to<C>`の`C`が`view`であっても、入力範囲が`borrowed_range`であれば変換を許可するようにしようとするものです。ただし、この制約は単なるConstraints（SFINAE可能条件）ではなく、Mandates（満たさなければコンパイルエラー）にすることを提案しています。

入力範囲型を`R`とすると、`range::to<C>`のMandatesは次のようになります

1. `C`がCV修飾の無いクラス型であること
2. 次のどちらか
    - `C`が`view`ではない
    - `C`が`view`ならば、`R`が`borrowed_range`のモデルである

提案文書より、サンプルコード

```cpp
auto sv1 = ranges::to<string_view>("abc"s );      // error  
auto sv2 = ranges::to<string_view>("abc"sv);      // error -> ok 

array arr{...};
auto sp1 = ranges::to<span<int>>(std::move(arr)); // error
auto sp2 = ranges::to<span<int>>(arr);            // error -> ok 

auto take = views::iota(0)
         | ranges::to<ranges::take_view>(5);     // error -> ok, CTAD via ranges::to, but meh  

auto drop = vector<int>{...}
         | ranges::to<ranges::drop_view>(5);     // error 

auto ints = "1.2.3.4"sv  
            | views::split('.')
            | ranges::to<vector<string_view>>();    // error -> ok

int numbers[] = {...};
auto groups1 = numbers 
            | views::slide(3)
            | ranges::to<vector<span<int>>>();    // ok
auto groups2 = numbers 
            | views::slide(3)
            | ranges::to<vector<span<int, 3>>>(); // error -> ok, recursively via ranges::to 

auto views = vector<int>{...}
             | views::transform([](int x) { return to_string(x); })
             | ranges::to<vector<string_view>>();    // ok, but dangling（変換なし
```

この例において、末尾のコメントで`error -> ok`となっているところだけがこの提案によって許可される部分で、それ以外は変化のない部分です。

この提案はC++23へのDRとすることが提案されており、SG9では合意されています。

- [P3544 進行状況](https://github.com/cplusplus/papers/issues/2247)

### [P3547R1 Modeling Access Control With Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3547r1.html)
### [P3552R1 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r1.pdf)
### [P3556R0 Input files are source files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3556r0.pdf)

規格中の入力C++ソースファイルに関する用語を整理する提案。

現在のC++規格文書中では、入力ファイルを指す言葉として*input file*と*source file*という2修理の用語が使用されています。しかし、*source file*はその定義がなされているのに対して、*input file*は明確な定義がされないままP2995R6にて導入されたようです。

この2つの言葉の間には何かしらの関連性が定義されているわけではないが、使用法から見るに*input file*は*source file*の部分集合になっているようです。

このような状況の修正のため、この提案では*input file*という言葉の使用を廃止して、*source file*に統一しようとしています。

さらに、統一後の*source file*という言葉も、物理的なファイルの内容を指している場合と、そこからプログラムテキストを読み取ってコピーしコンパイラによって保持されているものを指している場合の2つの使われ方があります。前者はコンパイラによって更新されるべきではない不変のものであり、コンパイラは翻訳フェーズ2以降では後者のコピーしたものを適宜編集しながらコンパイルを行っていくことになります（提案では、両者の違いを画像を*source file*として扱う処理系がwell-formedであるはず、という主張によってこれを説明しています）。

そのためこの提案では、統一後の*source file*という言葉の使用をさらに2種類に分け、ファイルから読み取った内容を保持するコピーの意味で使用されている*source file*という用語を*source text*に置き換えることを提案しています。

*source file*の定義はすでになされており、*source text*の定義は「翻訳フェーズ1終了時に生成される翻訳文字集合の要素のシーケンス」として定義します。

どうやら、この変更によってC++コンパイラの入力（*source file*）として正しいものは必ずしもテキストファイルだけではなく、ソースコードを写した画像のようなものもカバーされることになります。

- [P3556 進行状況](https://github.com/cplusplus/papers/issues/2248)

### [P3557R1 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r1.html)
### [P3558R1 Core Language Contracts By Default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3558r1.pdf)
### [P3561R1 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r1.pdf)
### [P3568R1 break label; and continue label;](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3568r1.html)
### [P3570R0 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r0.html)

並行キューの`async_pop()`の最適な戻り値型を探る提案。

P0260R13で提案中の並行キュークラスは、そのレビューの中で`.async_pop()`の戻り値型についてが議論の的になっているようです。それは、`.async_pop()`がコルーチンとしても`sender`としても使用でき使用されることが想定されていて、その際の使用パターンに若干の違いがあるためです。

```cpp
// コルーチンでの使用パターン
auto coro_grep(stdx::coqueue<std::fs::path>& file_queue, std::string needle) 
  -> stdp::task<void> 
{
  while (auto fname = co_await file_queue.async_pop()) {
    grep_file(*fname, needle);              // queue has data
  }
                              // queue closed
  co_return;
}

// std::executionでの使用パターン
stdexec::sender auto sr_grep(auto scheduler
              , stdx::coqueue<std::fs::path>& file_queue, std::string needle) 
{
  return stdexec::repeat_effect_until(
    stdexec::starts_on(scheduler, files.async_pop()                                  
      | stdp::overload(
        []() -> bool { return true; },                  // queue closed
        [needle](std::fs::path const& fname) -> bool {  // queue has data
          return grep_file(fname, needle);
        });
    ));
}
```

`.async_pop()`自体は`sender`を返しますが、その`sender`の完了シグネチャ（`set_value()`チャネルの型）が問題となります。コルーチンの使用パターンの場合、その完了シグネチャは`set_value_t(std::optional<T>)`となる必要があります。一方`std::execution`の場合、`set_value_t(), set_value_t(T)`となる必要があります。どちらを選択したとしても、もう一方のパターンの使用方法が妨げられます。

この提案は、この2つの使用パターンの両方を満たすことのできるような`.async_pop()`の戻り値型の実現可能性を探るものです。そして、この提案ではこの解決策として大まかに次の3つの3ことを挙げています。

1. カスタム`awaiter`の利用
2. 汎用的な値の変換
    - a1: 常に変換する
    - a2: オプトアウト
    - b: オプトイン

オプション1は、`execution::as_awaitable`のカスタマイゼーションポイント（`sender`をコルーチンの`awaitable`変換するもの）を利用して、`co_await`された場合に独自のカスタム`awaiter`型を返すようにする方法です。これは実装が簡単で両方の場合で理想的なインターフェースを提供できる方法ですが、これによる`.async_pop()`が返す`sender`だけがコルーチンで使用でき、任意のアダプタを介すとその能力が失われます。

オプション2は、`execution::as_awaitable`による変換プロセスに介入して、単一値完了シグネチャをコルーチンの`awaitable`に変換する際に、その直後にもう一段の変換を行うことによって別の変換先へと変換します。このアプローチはP3552R0でも検討されており、そこで`into_optional()`として挙げられていた変換アダプタを採用します。

この上で、`into_optional()`をどう適用するかによってさらに3つの選択肢があります。

a1（常に変換）は、`as_awaitable`内部に`into_optional()`適用を組み込むことでデフォルトで常に変換するようにします。互換性があれば、任意の`sender`がコルーチンでより使用しやすくなりますが、ユーザーがこの変換をカスタマイズすることができません（例えば`into_variant()`等を使用できない）。

a2（オプトアウト）は、a1同様にデフォルト動作として組み込むものの、`sender`の環境を通じて`get_await_completion_adapter`プロパティを`false_type`で伝播することでこの変換をオフにできます。`a1`の利点を享受しつつ欠点を補うことができるものの、環境をセットアップしない場合自動で変換されてしまうため問題がある場合があります。

b（オプトイン）はa2とは逆に、デフォルトではこの変換をオフにしつつ、`get_await_completion_adapter`プロパティが伝播している場合にオンにするものです。なおかつ、変換の方法は`get_await_completion_adapter`クエリの結果によって制御することができ、`into_optional`に固定されません。a1の利点を享受しつつa1/a2の欠点を補えますが、利用するにはオプトインが必要となるため少し面倒さがあります。

この中から、この提案としては2-bのオプトインによるものを提案しています。

オプション2-bの場合の`sender`型におけるオプトイン環境定義例

```cpp
struct env {
  auto query(get_await_completion_adapter_t) const -> into_optional_t { 
    return {};
  }
};

auto get_env() const noexcept -> env {
  return {};
}
```

提案のapendixには、ここで提案しているものの実装や、並行キューにおける利用例の実装などが記載されています。

- [P0260R13 C++ Concurrent Queues - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P0260R13-C-Concurrent-Queues)
- [P3552R0 Add a Coroutine Lazy Type - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3552R0-Add-a-Coroutine-Lazy-Type)
- [`std::execution::as_awaitable` - cpprefjp](https://cpprefjp.github.io/reference/execution/execution/as_awaitable.html)
- [P3570 進行状況](https://github.com/cplusplus/papers/issues/2249)

### [P3579R1 Fix matching of non-type template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r1.html)
### [P3589R1 C++ Profiles: The Framework](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3589r1.pdf)
### [P3591R0 Contextualizing Contracts Concerns](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3591r0.pdf)
### [P3592R0 Resolving Concerns with const-ification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3592r0.pdf)
### [P3599R0 Initial Implicit Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3599r0.pdf)

暗黙の契約アサーション機能の初期セットの提案。

暗黙の契約アサーションとは、P3100R1で提唱されたコア言語中の未定義動作に繋がりうる操作について、暗黙的に事前/事後条件を持つものとして扱うことで、実行時の未定義動作ハンドリングをContractsフレームワークによって行おうとするものです。暗黙の契約アサーションは、プログラムコード中にそのアサーションに対応するコード表現が存在しないという点を除いて、ユーザーが記述可能な契約アサーション（明示的な契約アサーション）とほとんどすべての点において同一の扱いとなります。

P3100については以前の記事を参照

- [P3100R1 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3100R1-Undefined-and-erroneous-behaviour-are-contract-violations)

この提案は暗黙の契約アサーションを言語に導入するための最初のステップとして、その最小サブセットとなる機能と対象のコア言語未定義動作の初期セットを提案するものです。

提案しているセマンティクスに変更はなく、ここではまだ自動フォールバック動作（整数オーバーフローをラップアラウンドや飽和演算などで処理する）を導入していないため、P3100で提案されているassumeセマンティクスはまだありません。

各セマンティクスの動作は次のようになります（通常の契約アサーションと変わりありません）

- quick enforce: 診断メッセージの出力や違反ハンドラ呼び出しな度を行わずにすぐ終了する
- enforce: 診断メッセージの発行後、プログラムを終了する
    - これをデフォルトとすることを提案している
- ignore: これまでと同様の動作
- observe: 診断メッセージを発行して、プログラムを継続する
    - 契約アサーション自体がobservable checkpointになっているため、UB起因のタイムトラベル最適化で削除されない

ユーザー定義の違反ハンドラのサポートも通常通り可能であり、enforce/observeセマンティクスの場合に呼び出されます。その際、`kind`プロパティは`implicit`、`detection_mode`がUBに応じた列挙値（後述）になります。

評価セマンティクスの選択も通常通り実装定義（コンパイラオプションを想定）とされます。

この提案で暗黙の契約アサーションを挿入する対象としている操作は次のものです

- 組み込みの配列添字演算子
    - 配列引数の境界が既知であり`N`、実行時インデックス引数が`x`であるとき
    - 暗黙の事前条件として、`0 <= x && x < N`を持つ
    - 違反した場合の`std::contracts::detection_mode`は`bounds`になる
- 組み込みの間接参照演算子
    - ポインタ引数を`p`として、暗黙の事前条件`p != nullptr`を持つ
    - 違反した場合の`std::contracts::detection_mode`は`dereference`になる
- 符号付整数の算術演算
    - その型の範囲内の値を生成するという事前条件を持つ

これらは初期セットであり、現在確実に検査可能と思われるもののうちの最小限のものです。将来的にこのセットは拡張され、実行時UBのさらに多くのものを補足可能になることが想定されます。

この提案が採択されると、次のようなコードは

```cpp
int main(int argc, char *argv[]) {
  int a[10] = { /* ... */ };
  std::size_t i = (argc > 1) ? std::atoi(argv[1]) : 0;

  // argv[1]に10以上の値がセットされているとUB
  return a[i];
}
```

次のようなコードと等価になります

```cpp
int main(int argc, char *argv[]) {
  int a[10] = { /* ... */ };
  
  std::size_t i = (argc > 1) ? std::atoi(argv[1]) : 0;

  // 暗黙の契約アサーションが挿入される
  contract_assert( i < (sizeof(a) / size(*a)) );
  return a[i];
}
```

また、この提案およびP3100の内容はプロファイル機能の実行時検査を行う部分と重複や衝突があります。ここでは、プロファイル機能の実行時検査の部分はこの提案やP3100の方向性に統一して、プロファイル機能は静的検査に制限する事を提案しています。

この提案は機能を最小のサブセットに限定することでC++26への導入を目指していました。どうやら、重複するプロファイル機能がC++26への導入を急いでいたことを受けて急いでいたようで（重複する部分があるためプロファイル機能が先に入ると影響がある）、プロファイル機能がC++26への導入を急がない（ホワイトペーパーの仕組みを利用する）事になったことを受けてこちらの提案もC++29以降を目指すことになったようです。その検討はP3100で行われるためこの提案は一旦クローズになっています。

- [P3599 進行状況](https://github.com/cplusplus/papers/issues/2252)

### [P3603R0 Consteval-only Values and Consteval Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3603r0.html)
### [P3605R0 `isqrt`: A function to calculate integer square root of the nonnegative integer](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3605r0.pdf)

非負整数の整数平方根を計算するための`isqrt`関数の提案。

ここで提案されている`isqrt()`は、非負の整数に対してその平方根以下の最大の整数を返すような平方根計算を行うものです。数学的には次のように定義されます

$$
isqrt(n) = \lfloor \sqrt{n} \rfloor = max \{ k \in N: k^2 \leq n \}, for \space n \in N, where \space N = \{ 0, 1, 2, 3, ...\}
$$

このような計算は数論アルゴリズムで頻出する（素数判定や因数分解、暗号アルゴリズムなど）ものの、浮動小数点数の扱いによって正しい実装が難しいという問題があります。

この`isqrt()`の結果が欲しい場合によく使用される`uintmax_t(sqrt(n))`という方法は、小さな整数値に対しては正しいものの大きな整数値（仮数部のビット数が3桁以上）に対して不正確な結果を返します。これは、`n`の値が`double`型で正確に表現できる場合でも、`sqrt(n)`の結果が浮動小数点数の精度限界により、真の平方根に最も近い`double`値として丸められるためです

例えば

$$
n = 67108865^2 = 4503599761588224 = 2^52 + 2^27
$$

この値は`double`型で正確に表現でき、`n`の平方根は次のようになります

$$
\sqrt{n} = \sqrt{4503599761588224} = 67108864.9999999925494195…
$$

先ほどの定義による`isqrt(n)`はこの値の小数点以下を切り捨てたものになります

$$
isqrt(n) = \lfloor \sqrt{n} \rfloor = \lfloor \sqrt{4503599761588224} \rfloor = \lfloor 67108864.9999999925494195… \rfloor = 67108864
$$

この$\sqrt{n}$は`double`型で正確に表現できないため、`sqrt(n)`の結果は`double`型で表現可能な最も近い値を丸めによって返します。$\sqrt{n}$に隣接する2つの`double`値は次の2つです

$$
67108865-2^{-26} = 67108864.99999998509883880615234375 < \sqrt{n} < 67108865
$$

|値|$\|value-\sqrt{(n)}\|$|
|---|---|
|`67108864.99999998509883880615234375`|$7.4505807079461285 \times 10^{-9}$|
|`67108865.0`|$7.4505804859015277 \times 10^{-9}$|

`67108865.0`の方が$\sqrt{n}$の真値に近いため、`sqrt(n)`の結果はこの値に丸められます。よって`uintmax_t(sqrt(n)) = 67108865`になります。

より一般に、整数$i$に対して$n = i^2 -1$となるような整数$n$に対して、この問題が発生します。この例の`4503599761588224`はそのような`n`の最小のものです（`double`型において）。

`long double`型が80ビットの浮動小数点数型として実装されていればこの問題は解消されるものの、`int128_t`のようなより幅の広い整数型が追加されると同様の問題が発生するため、より広い浮動小数点数型を使用するだけではこの問題を解決できません。

`isqrt()`という命名については、`sqrt()`のオーバーロードが追加できない（既に整数型に対するオーバーロードが存在しているため）ことやISO/IEC 10967-2:2001規格に準拠した命名であることからこの名前を提案しています。

```cpp
// 提案している宣言
namespace std {
  template<class T>
  constexpr T isqrt(T n) noexcept;
}
```

また、`isqrt()`は非負整数だけを引数に取るものの、冗長なキャストを回避するために、関数テンプレート自体は任意の整数型を受け取れるようにすることを提案しています。引数が正であることは関数の事前条件とされます。

- [P3605 進行状況](https://github.com/cplusplus/papers/issues/2254)

### [P3606R0 On Overload Resolution, Exact Matches and Clever Implementations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3606r0.html)

関数テンプレートを含めた関数オーバーロードの解決において、GCCの実装戦略を標準化する提案。

次のようなコードにおいて

```cpp
template<typename T>
decltype([] { return T::x;}) f(T); // #1

void f(int) {} // #2

int main() {
  f(0);
}
```

GCCは`f(0)`の呼び出しにおいて完全にマッチしている`#2`を選択し、`#1`のインスタンス化を行いません。一方その他の実装ではまず`#1`のインスタンス化を先に行うためエラーになります（戻り値型の`decltype`内のラムダ式内部の`T::x`がエラーになるものの、ここは即時コンテキストではないためハードエラーになる）。

すなわち、GCCは関数テンプレートが含まれるオーバーロード解決において候補の中に全ての引数に対して完全にマッチする候補が存在する場合、テンプレート候補は一切考慮されずインスタンス化も発生しません。

この挙動は標準の 13.9.2 [temp.inst]/9 にある

> If the function selected by overload resolution can be determined without instantiating a class template definition, it is unspecified whether that instantiation actually takes place.

の解釈によって許可されている振る舞いではあるものの、CWGの見解としては文言そのものには準拠していないようです。

この振る舞いは一方で、非即時コンテキスト（SFINAEしないコンテキスト）におけるエラー診断をしないということでもあります。しかし、別の例を見てみると

```cpp
struct S {
  template <typename T>
    requires std::copyable<T>
  explicit S(T op) noexcept; // #1

  S(const S&) noexcept = default; // #2
};

static_assert(std::copyable<S>);
```

この例において`S`が`copyable`であるかを調べるには、`S(declval<const S&>())`が有効な式であるかをチェックする必要があります。そのためには`T = S`として`#1`をインスタンス化して、`#1`と`#2`の間でオーバーロード解決を行う必要があります。しかし、`#1`は再び`std::copyable<S>`で制約されています。すなわち、`S`が`copyable`であるかを調べるには、まず`S`が`copyable`であるかを調べる必要があります。このような制約の再帰はill-formedとなります。

しかし、GCCは先ほどと同じ理由によって`#2`を選択し、`#1`はインスタンス化も発生しません。このように、再帰を引き起こすコンセプトの制約チェックについては、非即時コンテキストのエラー診断を考慮しなくても、GCCの最適化の恩恵が明確になります。

これはこの提案のモチベーションの一つです。

もう一つは、CWG2369をclangで実装するためにこの実装戦略が必要となったためです。

CWG2369は、SFINAEとコンセプトによってテンプレートのインスタンス化結果が異なることがあるのを修正するために、テンプレート引数の置換と制約チェックの順序を逆にしようとするものです。

次のようなコードにおいて

```cpp
template <typename U>
struct B { static_assert(false); };

template <typename T>
  requires (sizeof(B<T>) == 1)
void f(T, typename T::foo = 0) {} // #1

void f(int) {} // #2

f(0);
```

GCCは前述のように、`#2`を選択し`#1`はインスタンス化されません。

Clang（CWG2369実装前）では、`#1`をインスタンス化しようとしてまず引数の`T::foo`の置換を行い、`int::foo`が有効ではないためSFINAEにより`#2`が選択されます。

結果として起こる事は同じであっても、ClangとGCCでは異なる理由でそれが起きています。そして、CWG2369を実装すると置換の前に制約チェックを行うため、`#1`の制約式内の`B<int>`の定義内`static_assert`でハードエラーを起こし、コンパイルエラーとなります（GCCは変わらない）。

したがって、Clangにおいては後方互換性の観点から、CWG2369を実装することができなくなっています。

ClangにおいてCWG2369を実装するためにはGCCの実装戦略を取り入れる必要があり、そのためにはその実装戦略が規格に準拠したものであることを確認する必要があります。この提案はそのために提出されたものです。

GCCの動作を採択することにはいくつかの利点があります

- オーバーロード解決時の作業量を軽減させられるため、コンパイル時間を減らせる
- CWG2369の採用による影響を軽減できる
- テンプレートコンストラクタに`same_as`制約を忘れる
    - 2つめの例のGCC以外での回避策

一方欠点は、テンプレート候補の即時コンテキストではない部分のエラーが診断されなくなる点です。これが許容可能かどうかは判然としておらず、この提案はその確認も兼ねています。

そして、GCCのこの実装戦略もまたCWG2369の採用による影響を軽減しようとするものだったようです。

なお、ここで挙げているものも含めて、提案文書にあるサンプルコードは実際のバグレポートから収集されたものを単純化したものです。したがって、これらの問題は実際出会わないようなコードで起こるだけのものではありません。

- [CWG Issue 2369. Ordering between constraints and substitution](https://cplusplus.github.io/CWG/issues/2369.html)
- [P3606 進行状況](https://github.com/cplusplus/papers/issues/2255)

### [P3608R0 Contracts and profiles: what can we reasonably ship in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3608r0.html)

プロファイル機能や暗黙の契約アサーションに関連する機能のC++26リリースを延期することを推奨する提案。

この提案では斬新なアイデアについてC++29自体をターゲットとするか、C++29以前にリリースされるホワイトペーパーに先送りにすることを提案するとともに、次のものについてはC++26に導入することを提案しています。

- 汎用プロファイルフレームワーク（P3589）
- 標準ライブラリの堅牢化（P3471）
- 標準ライブラリの堅牢化を有効にし、堅牢化された事前条件違反が発生した場合に無条件でプログラムを終了させるだけの具体的なプロファイル
    - C++26時点では追加の柔軟性を提供しない
    - 実装ベンダに対しては、将来的に他の違反処理方法を有効化する可能性を閉ざさないように推奨する

斬新なアイデアとはどうやら、暗黙の契約アサーションに関するContracts関連の機能提案や、より具体的な安全性プロファイルの提案の事を指しているようです。

その理由としては、どちらのものにも未解決の問題や合意が得られていない部分が存在しているため、締切に終われて未完成の機能をユーザーに押し付けることを避けるべき、としています。

プロファイルと契約の間にある重複・衝突しうる部分についてはさらに検討を進めて問題を解消し、コンセンサスを改善したうえで、全ての機能が一貫した全体として動作するようになってからリリースすべき、と指摘しています。

- [P3608 進行状況](https://github.com/cplusplus/papers/issues/2256)

### [P3611R0 Dealing with pointer errors: Separating static and dynamic checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3611r0.pdf)
### [P3613R0 On the beating of horses, and other matters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3613r0.html)
### [P3614R0 Do not remove nor postpone access_context::unchecked](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3614r0.html)
### [P3615R0 C++ Standard Library Ready Issues to be moved in Hagenberg, Feb. 2025](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3615r0.html)
### [P3616R0 Remove contracts on virtual functions for now](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3616r0.html)
### [P3618R0 Allow attaching main to the global module](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3618r0.html)
### [P3619R0 Counter-examples for P2688R5 <../2025/p2688r5.html>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3619r0.pdf)
### [P3619R1 Counter-examples for P2688R5 <../2025/p2688r5.html>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3619r1.pdf)
### [P3620R0 Concerns with the proposed addition of fibers to C++ 26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3620r0.pdf)
### [P3623R0 Add noexcept to [iterator.range] (LWG 3537)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3623r0.html)
### [P3625R0 either neither](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3625r0.pdf)
### [P3626R0 Make predicate exceptions propagate by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3626r0.pdf)
### [P3627R0 Easy-to-adopt security profiles for preventing RCE (remote code execution) in existing C++ code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3627r0.pdf)
### [P3628R0 break label; and continue label;, tl; dr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3628r0.html)
### [P3630R0 Slides for P3568R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3630r0.pdf)
### [P3632R0 P3564R0: Make the concurrent forward progress guarantee usable in bulk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3632r0.pdf)
### [P3632R1 P3564R0: Make the concurrent forward progress guarantee usable in bulk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3632r1.pdf)
### [P3633R0 A Byte is a Byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3633r0.pdf)
### [P3635R0 We shouldn't rush to require either CHAR_BIT==8 or (u)intNN_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3635r0.pdf)
### [P3636R0 LEWG Hagenberg presentation for P3581 No, inplace_vector shouldn't have an Allocator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3636r0.pdf)
### [P3637R0 Inherit std::meta::exception from std::exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3637r0.pdf)
### [P3638R0 Core Language Working Group "ready" Issues for the February, 2025 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3638r0.html)
### [P3639R0 The _BitInt Debate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3639r0.html)
### [P3640R0 Make contracts reliable by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3640r0.pdf)
### [P3641R0 Rename std::observable to std::observable_checkpoint, and add a feature-test macro](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3641r0.html)
### [P3642R0 Carry-less product: std::clmul](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r0.html)
### [P3643R0 std::to_signed and std::to_unsigned](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r0.html)
### [P3650R0 21st Century C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3650r0.pdf)
### [P3651R0 Note to the C++ standards committee members](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3651r0.pdf)
### [P3652R0 Constexpr floating-point <charconv> functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r0.html)
### [P3654R0 Slides for P3516](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3654r0.pdf)
### [P3655R0 zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r0.html)
### [P3656R0 Initial draft proposal for core language UB white paper: Process and major work items](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3656r0.pdf)
### [P3657R0 A Grammar for Whitespace Characters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3657r0.pdf)
### [P3658R0 Adjust identifier following new Unicode recommendations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3658r0.pdf)
### [P3660R0 Improve `reference_wrapper` Ergonomics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3660r0.html)
### [P3661R0 Attributes, annotations, labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3661r0.html)
### [P3662R0 Improve Increment and Decrement Operator Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3662r0.html)
### [P3663R0 Future-proof `submdspan-mapping`?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r0.html)
### [P3664R0 Make variant_size SFINAE friendly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3664r0.html)
