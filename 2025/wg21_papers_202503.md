# ［C++］WG21月次提案文書を眺める（2025年03月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-03](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-03)

全部で164本あります。

もくじ

[:contents]

### [N5004 2025 Sofia Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5004.pdf)

2025年6月にブルガリアのソフィアで行われる全体会議のインフォメーション。

予定（2025年6月16日～21日）と場所、ホテルの案内などが記載されています。

### [N5005 WG21 2025-01 Hagenberg Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5005.pdf)

2025年1月27日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Hagenberg会議で何をするかなどの報告がなされています。

### [N5006 2025 WG21 admin telecon meetings (revised 2025-02-20)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5006.pdf)

今後のWG21管理者ミーティングのインフォメーション。

### [N5007 WG21 02/2025 Hagenberg Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5007.pdf)

2025年2月にHagenbergで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N5008 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf)

C++26のワーキングドラフト第7弾

### [N5009 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5009.html)

↑の変更点をまとめた文書。

### [P0260R15 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r15.html)
### [P0260R16 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r16.html)
### [P0876R20 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0876r20.pdf)
### [P1494R5 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1494r5.html)
### [P1967R14 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1967r14.html)
### [P2079R7 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r7.html)
### [P2287R4 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2287r4.html)
### [P2414R6 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r6.pdf)
### [P2663R7 Proposal to support interleaved complex values in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2663r7.html)
### [P2719R4 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2719r4.html)
### [P2758R5 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2758r5.html)
### [P2781R6 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r6.html)
### [P2781R7 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r7.html)
### [P2781R8 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r8.html)
### [P2786R12 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r12.html)
### [P2786R13 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2786r13.html)
### [P2825R5 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2825r5.html)
### [P2830R10 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2830r10.html)
### [P2841R7 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf)
### [P2843R2 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r2.pdf)
### [P2846R6 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2846r6.pdf)
### [P2863R9 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2863r9.html)
### [P2873R3 Remove Deprecated locale category facets for Unicode from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2873r3.pdf)
### [P2876R2 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2876r2.html)
### [P2899R1 Contracts for C++ - Rationale](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2899r1.pdf)
### [P2900R14 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2900r14.pdf)
### [P2933R4 Extend <bit> header function with overloads for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2933r4.html)
### [P2988R10 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r10.pdf)
### [P2988R11 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r11.pdf)
### [P2996R10 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r10.html)
### [P3008R4 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r4.html)
### [P3016R6 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3016r6.html)
### [P3019R13 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3019r13.html)
### [P3019R14 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3019r14.pdf)
### [P3060R2 Add std::views::indices(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3060r2.html)
### [P3070R3 Formatting enums](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3070r3.html)
### [P3074R6 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r6.html)
### [P3074R7 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3074r7.html)
### [P3081R2 Core safety profiles for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3081r2.pdf)
### [P3096R6 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r6.pdf)
### [P3096R7 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r7.pdf)
### [P3104R3 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3104r3.html)
### [P3111R4 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r4.html)
### [P3111R5 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r5.html)
### [P3137R3 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3137r3.html)
### [P3149R9 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r9.html)
### [P3161R3 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r3.html)
### [P3179R6 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r6.html)
### [P3179R7 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r7.html)
### [P3229R1 Making erroneous behaviour compatible with Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3229r1.pdf)
### [P3230R2 views::unchecked_(take|drop)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3230r2.html)
### [P3242R1 Copy and fill for mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3242r1.html)
### [P3248R3 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3248r3.html)
### [P3284R3 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3284r3.html)
### [P3287R3 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3287r3.pdf)
### [P3296R4 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3296r4.html)
### [P3319R3 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r3.pdf)
### [P3319R4 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r4.pdf)
### [P3319R5 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3319r5.pdf)
### [P3331R1 Accessing The First and Last Elements in Associative Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3331r1.pdf)
### [P3349R1 Converting contiguous iterators to pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3349r1.html)
### [P3365R1 Remove the Deprecated iterator Class Template from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3365r1.pdf)
### [P3366R1 Remove Deprecated Atomic Initialization API from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3366r1.pdf)
### [P3367R4 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3367r4.html)
### [P3372R3 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3372r3.html)
### [P3378R2 constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3378r2.html)
### [P3383R2 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3383r2.html)
### [P3385R4 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r4.html)
### [P3394R2 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r2.html)
### [P3395R1 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r1.html)
### [P3395R2 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r2.html)
### [P3400R1 Specifying Contract Assertion Properties with Labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3400r1.pdf)
### [P3417R1 Handling exceptions thrown from contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3417r1.pdf)
### [P3430R3 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3430r3.pdf)
### [P3441R1 Rename simd_split to simd_chunk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3441r1.html)
### [P3441R2 Rename simd_split to simd_chunk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3441r2.html)
### [P3442R1 [[invalidate_dereferencing]] attribute](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3442r1.pdf)
### [P3471R3 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r3.html)
### [P3471R4 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r4.html)
### [P3472R1 Make fiber_context::can_resume() const](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3472r1.html)
### [P3475R2 Defang and deprecate memory_order::consume](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3475r2.pdf)
### [P3477R3 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r3.html)
### [P3477R4 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r4.html)
### [P3477R5 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3477r5.html)
### [P3480R4 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r4.pdf)
### [P3481R2 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r2.html)
### [P3482R1 Design for C++ networking based on IETF TAPS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3482r1.html)
### [P3491R2 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r2.html)
### [P3492R1 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3492r1.html)
### [P3492R2 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3492r2.html)
### [P3499R1 Exploring strict contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3499r1.pdf)
### [P3500R1 Are Contracts "safe"?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3500r1.pdf)
### [P3503R1 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r1.html)
### [P3503R2 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r2.html)
### [P3505R0 Fix the default floating-point representation in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3505r0.html)

`std::format()`における浮動小数点数出力時のデフォルトの表現（`g`オプション）を修正する提案。

`std::format()`の浮動小数点数出力時のフォーマット方法は`std::to_chars`を用いて指定されており、これはCロケールと同じ出力を規定するために実質的にCの標準によって指定されています。

Cロケールによるデフォルトの出力では、出力後の浮動小数点数表現が短くなるように指数表記と固定小数表記を切り替えますが、この「短くなる」の意味が出力文字数によるものであると誤解されて実装されてしまう場合があることによって、`std::format()`のデフォルトの浮動小数点数出力も間違った表現を選択する場合があるようです。

たとえば、`100000.0`と`120000.0`は本来同じ形式で出力される必要があります（たとえば`python`の例）

```python
>>> 100000.0
100000.P3526R0 
>>> 120000.0
120000.0
```

しかし、`std::format()`の場合異なった形式によって出力されます

```cpp
auto s1 = std::format("{}", 100000.0);  // s1 == "1e+05"
auto s2 = std::format("{}", 120000.0);  // s2 == "120000"
```

これによって、本来の意味の可能な限り短い表記が順守されず、表現可能な精度の外の値（garbage digits）が出力されてしまいます

```cpp
auto s = std::format("{}", 1234567890123456700000.0);
// s == "1234567890123456774144"
```

最後の5桁`74144`は意味のない値であり、現代の一般的な浮動小数点数フォーマットでは出力されることがないはずの値です。例えば、pythonはこの場合に指数表記を選択することでこれを回避します

```cpp
>>> 12345678901234567800000.0
1.2345678901234568e+22
```

正しい浮動小数点数出力を行うことのできる既存の実装ではこのような意味のない桁を出力できないため、`std::format()`の実装に当たってはこのような下位桁を計算するための特別な実装を必要としており、それによってフォーマットパフォーマンスの低下を招いています。

正しい浮動小数点数表現とは Steele & White (1990) で定義されたものをベースとしているようで、そこではそのような出力アルゴリズムの特性として次の4点を指摘しています

1. 情報の損失が発生しない
    - 出力値の丸めによって、元の値を正確に復元できる
2. 無意味な桁（"garbage digits"）が生成されない
3. 出力値は適切に丸められる
4. 丸め処理の際に桁を繰り返す必要がない

重要なのはこの2番目の項目で、これは簡潔性（"shortness"）の保証と呼ばれているようです。簡潔性保証はアルゴリズムが他の要件（特にラウンドトリップ保証）を満たすために必要な最小の桁数で出力するべき、という意味であり、これは仮数の小数点以下の桁数にのみ着目したもので、指数や小数点などは考慮されないものののようです。

前述のように、C++においてはこの簡潔性についての言及を出力文字数の短さと解釈してしまっていることで、現在の`std::format()`の浮動小数点数出力に問題が起きています。

この提案では、本来の意味での簡潔性を指定するように規定を修正することで、`std::format()`の浮動小数点数出力を正しいものに修正しようとしています。

具体的には、フォーマット対象の浮動小数点数値が$[10^{-4}, 10^n)$の範囲にある場合は固定小数形式を使用し、そうでなければ指数形式を使用する、ように明示的に指定しています。なお、ここでの$10^n$は、浮動小数点数型を`FP`、`m = std::numeric_limits<FP>::digits + 1`として、$2^m$を最も近い10の累乗値に丸め下げたものです。

例えば`double`型の場合`std::numeric_limits<FP>::digits`は`53`となり、$2^54$となり、これを最も近い10の累乗値に丸め下げたものは$10^16$となります。これらの値はpythonやrust、swiftやjava等と同じ値になっているようです。

この下限値は絶対値が小さい値の出力について固定少数形式を回避し、上限値は大きい値の出力について固定少数形式を回避しようとするものです。

これによって、ほかの主要なプログラミング言語における出力と同等の出力得るようになるとともに、無意味な桁を出力するためのパフォーマンス低下を回避することができます。また、これは`{fmt}`ライブラリにおいて少なくとも6年前から実装され出荷されているとのことです。

この変更は破壊的変更となるものの、ABIやラウンドトリップの保証には影響がなく、浮動小数点数の正確な表現への依存は通常推奨されないため、影響は中程度であるとしています。

- [Guy L. Steele Jr.; Jon L White. How to Print Floating-Point Numbers Accurately. 1990.](https://lists.nongnu.org/archive/html/gcl-devel/2012-10/pdfkieTlklRzN.pdf)
- [P3505 進行状況](https://github.com/cplusplus/papers/issues/2245)

### [P3516R1 Uninitialized algorithms for relocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3516r1.html)
### [P3526R0 Container truncation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3526r0.html)
### [P3533R2 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3533r2.html)
### [P3537R1 Presentation on Concurrent Queue API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3537r1.pdf)
### [P3540R1 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3540r1.html)
### [P3544R0 `ranges::to<view>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3544r0.html)

`ranges::to`が変換先として`view`を指定できない制約を取り除く提案。

`ranges::to<C>(...)`は変換先の型`C`に対して`view`ではない事だけを要求しています。これによって例えば、分割文字列を`std::string_view`を要素とするコンテナに詰めていく様な使用法が阻害されています。

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | ranges::to<vector<string_view>>(); // error
```

`ranges::to`の入力範囲が`range`の`range`になっている場合、`ranges::to`は内部で内側の範囲に対して再帰的に`ranges::to`を呼び、その際に入力の内側範囲が`C`の内側範囲に変換可能ではない場合（`views::split`の内側範囲は`std::string_view`に暗黙変換できない）、`ranges::to<range_value_t<C>>`のように呼ぶため`C`も`range`の`range`になっている場合は内側の範囲も`view`であってはなりません。

この例は内側の`std::string_view`が`view`であるためにエラーになっています。ただし、次のように`C`の内側の型を指定しなければ動作します

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | ranges::to<vector>(); // ok
```

この場合、入力の内側範囲は`subrange`が使用されているため、`C`の内側範囲も`subrange`になることによって上手くいきます。ただし、この場合の`subrange`は`view`のはずです。そこで同様に、ラムダ式を用いて`C`の内側範囲を指定しない形で呼び出すと動作するようになります

```cpp
auto ints = "1.2.3.4"sv
          | views::split('.')
          | views::transform([](auto r) { return string_view(r); })
          | ranges::to<vector>(); // ok
```

これは、`ranges::to<vector>`への入力範囲の内側範囲が`std::string_view`になることによって、推論される出力範囲の要素型（内側範囲）と一致することで変換可能になり、その際の処理パスでは`C`の内側範囲型に対する`view`の制約チェックが行われないためです。

そしてさらに、これと似た理由によって次のコードは動作してしまいます

```cpp
auto ints = "1.2.3.4"sv
              | views::split('.')
              | ranges::to<vector<span<const char>>>(); // ok in the current standard!!!
```

これは、`std::span`の`range`コンストラクタが`explciit`指定されないことによって入力の内側範囲（`views::split`の要素型）が出力の内側範囲（`span<const char>`）に変換可能になることで、同様に`span<const char>`が`view`であるというチェックがスキップされるためです。

文字列を`split, slide, chunk, chunk_by`などのアダプタを使用して処理した結果を`string_view`のコンテナに入れることはかなり一般的なワークロードと思われるため、これらはもっと簡易に実行できる（最初のコードが動作する）必要があります。

そもそも`ranges::to`のターゲット型が`view`であってはならない理由を考えると、2つの理由がありそうです

1. ユーザーが`view`から`view`を作成できないようにするため
2. 安全性への懸念から

前者の場合、`<range>`ヘッダにある`view`型については理に適っているかもしれません（アダプタを使わない理由が無いため）が、`ranges::to<string_view>`のように`std::string_view`/`std::span`についてはあてはまりません。また、`views::take`の代わりに`ranges::to<take_view>`をわざわざやりたがる人もいないと思われるものの、禁止するほどの悪影響があるわけでもなさそうです。

後者の理由は説得力があります。実際、`std::string_view`は右辺値文字列から構築できるため、単純に許可してしまうと`ranges::to<string_view>(string("abc"))`の様な変換が可能になってしまいます（これはダングリング状態になる）。しかしこれは、入力範囲に`borrowed_range`を要求することで簡単に解決することができます。

この提案は`ranges::to<C>`の`C`が`view`であっても、入力範囲が`borrowed_range`であれば変換を許可するようにしようとするものです。ただし、この制約は単なるConstraints（SFINAE可能条件）ではなく、Mandates（満たさなければコンパイルエラー）にすることを提案しています。

入力範囲型を`R`とすると、`range::to<C>`のMandatesは次のようになります

1. `C`がCV修飾の無いクラス型であること
2. 次のどちらか
    - `C`が`view`ではない
    - `C`が`view`ならば、`R`が`borrowed_range`のモデルである

提案文書より、サンプルコード

```cpp
auto sv1 = ranges::to<string_view>("abc"s );      // error  
auto sv2 = ranges::to<string_view>("abc"sv);      // error -> ok 

array arr{...};
auto sp1 = ranges::to<span<int>>(std::move(arr)); // error
auto sp2 = ranges::to<span<int>>(arr);            // error -> ok 

auto take = views::iota(0)
         | ranges::to<ranges::take_view>(5);     // error -> ok, CTAD via ranges::to, but meh  

auto drop = vector<int>{...}
         | ranges::to<ranges::drop_view>(5);     // error 

auto ints = "1.2.3.4"sv  
            | views::split('.')
            | ranges::to<vector<string_view>>();    // error -> ok

int numbers[] = {...};
auto groups1 = numbers 
            | views::slide(3)
            | ranges::to<vector<span<int>>>();    // ok
auto groups2 = numbers 
            | views::slide(3)
            | ranges::to<vector<span<int, 3>>>(); // error -> ok, recursively via ranges::to 

auto views = vector<int>{...}
             | views::transform([](int x) { return to_string(x); })
             | ranges::to<vector<string_view>>();    // ok, but dangling（変換なし
```

この例において、末尾のコメントで`error -> ok`となっているところだけがこの提案によって許可される部分で、それ以外は変化のない部分です。

この提案はC++23へのDRとすることが提案されており、SG9では合意されています。

- [P3544 進行状況](https://github.com/cplusplus/papers/issues/2247)

### [P3547R1 Modeling Access Control With Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3547r1.html)
### [P3552R1 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r1.pdf)
### [P3556R0 Input files are source files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3556r0.pdf)

規格中の入力C++ソースファイルに関する用語を整理する提案。

現在のC++規格文書中では、入力ファイルを指す言葉として*input file*と*source file*という2修理の用語が使用されています。しかし、*source file*はその定義がなされているのに対して、*input file*は明確な定義がされないままP2995R6にて導入されたようです。

この2つの言葉の間には何かしらの関連性が定義されているわけではないが、使用法から見るに*input file*は*source file*の部分集合になっているようです。

このような状況の修正のため、この提案では*input file*という言葉の使用を廃止して、*source file*に統一しようとしています。

さらに、統一後の*source file*という言葉も、物理的なファイルの内容を指している場合と、そこからプログラムテキストを読み取ってコピーしコンパイラによって保持されているものを指している場合の2つの使われ方があります。前者はコンパイラによって更新されるべきではない不変のものであり、コンパイラは翻訳フェーズ2以降では後者のコピーしたものを適宜編集しながらコンパイルを行っていくことになります（提案では、両者の違いを画像を*source file*として扱う処理系がwell-formedであるはず、という主張によってこれを説明しています）。

そのためこの提案では、統一後の*source file*という言葉の使用をさらに2種類に分け、ファイルから読み取った内容を保持するコピーの意味で使用されている*source file*という用語を*source text*に置き換えることを提案しています。

*source file*の定義はすでになされており、*source text*の定義は「翻訳フェーズ1終了時に生成される翻訳文字集合の要素のシーケンス」として定義します。

どうやら、この変更によってC++コンパイラの入力（*source file*）として正しいものは必ずしもテキストファイルだけではなく、ソースコードを写した画像のようなものもカバーされることになります。

- [P3556 進行状況](https://github.com/cplusplus/papers/issues/2248)

### [P3557R1 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r1.html)
### [P3558R1 Core Language Contracts By Default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3558r1.pdf)
### [P3561R1 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r1.pdf)
### [P3568R1 break label; and continue label;](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3568r1.html)
### [P3570R0 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r0.html)

並行キューの`async_pop()`の最適な戻り値型を探る提案。

P0260R13で提案中の並行キュークラスは、そのレビューの中で`.async_pop()`の戻り値型についてが議論の的になっているようです。それは、`.async_pop()`がコルーチンとしても`sender`としても使用でき使用されることが想定されていて、その際の使用パターンに若干の違いがあるためです。

```cpp
// コルーチンでの使用パターン
auto coro_grep(stdx::coqueue<std::fs::path>& file_queue, std::string needle) 
  -> stdp::task<void> 
{
  while (auto fname = co_await file_queue.async_pop()) {
    grep_file(*fname, needle);              // queue has data
  }
                              // queue closed
  co_return;
}

// std::executionでの使用パターン
stdexec::sender auto sr_grep(auto scheduler
              , stdx::coqueue<std::fs::path>& file_queue, std::string needle) 
{
  return stdexec::repeat_effect_until(
    stdexec::starts_on(scheduler, files.async_pop()                                  
      | stdp::overload(
        []() -> bool { return true; },                  // queue closed
        [needle](std::fs::path const& fname) -> bool {  // queue has data
          return grep_file(fname, needle);
        });
    ));
}
```

`.async_pop()`自体は`sender`を返しますが、その`sender`の完了シグネチャ（`set_value()`チャネルの型）が問題となります。コルーチンの使用パターンの場合、その完了シグネチャは`set_value_t(std::optional<T>)`となる必要があります。一方`std::execution`の場合、`set_value_t(), set_value_t(T)`となる必要があります。どちらを選択したとしても、もう一方のパターンの使用方法が妨げられます。

この提案は、この2つの使用パターンの両方を満たすことのできるような`.async_pop()`の戻り値型の実現可能性を探るものです。そして、この提案ではこの解決策として大まかに次の3つの3ことを挙げています。

1. カスタム`awaiter`の利用
2. 汎用的な値の変換
    - a1: 常に変換する
    - a2: オプトアウト
    - b: オプトイン

オプション1は、`execution::as_awaitable`のカスタマイゼーションポイント（`sender`をコルーチンの`awaitable`変換するもの）を利用して、`co_await`された場合に独自のカスタム`awaiter`型を返すようにする方法です。これは実装が簡単で両方の場合で理想的なインターフェースを提供できる方法ですが、これによる`.async_pop()`が返す`sender`だけがコルーチンで使用でき、任意のアダプタを介すとその能力が失われます。

オプション2は、`execution::as_awaitable`による変換プロセスに介入して、単一値完了シグネチャをコルーチンの`awaitable`に変換する際に、その直後にもう一段の変換を行うことによって別の変換先へと変換します。このアプローチはP3552R0でも検討されており、そこで`into_optional()`として挙げられていた変換アダプタを採用します。

この上で、`into_optional()`をどう適用するかによってさらに3つの選択肢があります。

a1（常に変換）は、`as_awaitable`内部に`into_optional()`適用を組み込むことでデフォルトで常に変換するようにします。互換性があれば、任意の`sender`がコルーチンでより使用しやすくなりますが、ユーザーがこの変換をカスタマイズすることができません（例えば`into_variant()`等を使用できない）。

a2（オプトアウト）は、a1同様にデフォルト動作として組み込むものの、`sender`の環境を通じて`get_await_completion_adapter`プロパティを`false_type`で伝播することでこの変換をオフにできます。`a1`の利点を享受しつつ欠点を補うことができるものの、環境をセットアップしない場合自動で変換されてしまうため問題がある場合があります。

b（オプトイン）はa2とは逆に、デフォルトではこの変換をオフにしつつ、`get_await_completion_adapter`プロパティが伝播している場合にオンにするものです。なおかつ、変換の方法は`get_await_completion_adapter`クエリの結果によって制御することができ、`into_optional`に固定されません。a1の利点を享受しつつa1/a2の欠点を補えますが、利用するにはオプトインが必要となるため少し面倒さがあります。

この中から、この提案としては2-bのオプトインによるものを提案しています。

オプション2-bの場合の`sender`型におけるオプトイン環境定義例

```cpp
struct env {
  auto query(get_await_completion_adapter_t) const -> into_optional_t { 
    return {};
  }
};

auto get_env() const noexcept -> env {
  return {};
}
```

提案のapendixには、ここで提案しているものの実装や、並行キューにおける利用例の実装などが記載されています。

- [P0260R13 C++ Concurrent Queues - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P0260R13-C-Concurrent-Queues)
- [P3552R0 Add a Coroutine Lazy Type - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3552R0-Add-a-Coroutine-Lazy-Type)
- [`std::execution::as_awaitable` - cpprefjp](https://cpprefjp.github.io/reference/execution/execution/as_awaitable.html)
- [P3570 進行状況](https://github.com/cplusplus/papers/issues/2249)

### [P3579R1 Fix matching of non-type template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r1.html)
### [P3589R1 C++ Profiles: The Framework](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3589r1.pdf)
### [P3591R0 Contextualizing Contracts Concerns](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3591r0.pdf)
### [P3592R0 Resolving Concerns with const-ification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3592r0.pdf)

契約注釈内での変数の`const`化についての懸念を緩和するための提案。

P2900で提案中のContractsでは、契約注釈内から参照されるローカル変数等が暗黙的に`const`化されます。これは契約述語を介した副作用の影響を低減するためのものですが、C++の他の場所との一貫性がないことなどから懸念が燻っています。

例えば、同じ式でも契約注釈内とその後の関数本文内で意味が変わる場合があり得ます。

```cpp
struct X {
  bool is_const() { return false; }
  bool is_const() const { return true; }
};

void g(X& x)
  pre( x.is_const() ) // constオーバーロードが呼ばれる
{
  // 非constオーバーロードが呼ばれる
  if (x.is_const()) {
    // This branch is never taken.
  }
}
```

逆に、契約注釈内と同じセマンティクスで述語を表現する簡単な方法が用意されていない点も問題となっています。

契約注釈内であえて非`const`な変数を使用したい場合にも簡易な方法がなく、一般的に使用が忌避される`const_cast`を使用する必要があります。

```cpp
// legacy API
struct X;
bool check_valid(X& x); // 引数を変更しないがconstを忘れている

void f(X& x)
  pre(check_valid(x)); // ill-formed
void g(X& x)
  pre(check_valid(const_cast<X&>(x))); // OK
```

これらの問題は既存のコードに存在しているものと思われるため、このようなコードをContractsへ移行使用とする際のブロッキング要因になってしまいます。

この提案では、このような懸念を解消するための3つの機能の追加提案を行っています

1. 契約注釈内と同じ意味の術語をその外で再現するための`contract_predicate(expr)`演算子の追加
    - `contract_predicate`内部の式は契約注釈内と同じ`const`化が行われる
2. 局所的に`const`化を無効化するための`noconst`演算子の追加
    - 契約注釈内のid式に指定して、その変数に対する`const`化を解除する
3. 契約注釈の`const`化を無効化するための`mutable`指定の追加
    - `pre mutable (pred)`のように使用する

`contract_predicate`は契約注釈内でしか得られない`const`化を他の場所他の式に対して再現するものです。

```cpp
struct X {
  bool is_const() { return false; }
  bool is_const() const { return true; }
};

void g(X& x)
  pre( x.is_const() ) // constオーバーロードが呼ばれる
{
  // constオーバーロードが呼ばれる
  if (contract_predicate(x.is_const())) {
    // This branch is never taken.
  }
}
```

提案では述語のみならず任意の式に対して適用可能で、`contract_predicate`式の型と値カテゴリは指定された式（`const`化後の）の型と値カテゴリを持つようにすることを提案しています。

`contract_predicate`という名前はキーワードにすることを提案しています。Githubでの検索では使用例は見つからなかったようです。

代替の提案として、`contract_predicate`を採用したうえで契約注釈の`const`化を有効にするために、`contract_predicate`の指定を必須にすることを提案しています。

```cpp
int f(const int x)
  pre contract_predicate (x != 1) // a precondition assertion
  post contract_predicate (r : r == x && r != 2) // a postcondition assertion
{
  contract_assert contract_predicate (x != 3); // an assertion statement
  return x;
}
```

この場合、`contract_predicate`の指定が必須となる（提案では外した状態を提案していない）ため煩わしさがかなり増すものの、短い代わりのキーワードの捜索は困難としています。

`noconst`は契約注釈内で使用して、`const`化を解除するためのものです。

```cpp
struct X {
  bool is_const() { return false; }
  bool is_const() const { return true; }
}

void f(X& x, const X& y)
  pre( x.is_const() )
  pre( y.is_const() )
  pre( !noconst(x).is_const() ) // type of noconst(x) is X
  pre( noconst(y).is_const() )  // type of noconst(y) is still const X
  pre( ![]() {
    X z;
    return z.is_const();
  }())
  pre( ![]() {
    X z;
    return noconst(z).is_const(); // error: zはconst化の対象ではない
  }());
```

`noconst`演算子は契約注釈内でのみ使用できます。


3つ目の`mutable`指定は、契約注釈自体の`cosnt`化を無効化するための追加の指定です。

```cpp
struct X {
  bool is_const() { return false; }
  bool is_const() const { return true; }
}

void f(X& x)
  pre(x.is_const())
  pre mutable (!x.is_const())
{}
```

`mutable`指定された契約注釈内では、id式の結果が`const`化されなくなります。ただ、指定するキーワードの選択には異論が出ているようです（ラムダ式の`mutable`指定と意味が若干異なり、付与された対象が変更可能になるわけではないため）。

提案1と2は実装経験がありませんが、提案3はGCCにおいて実装経験があります。

この提案は結局P2900R14（C++26最終版）には導入されずにクローズされています。どうやら、この提案抜きでも一定のコンセンサスを得ることができたようです。

- [P3261R2 Revisiting `const`-ification in Contract Assertions - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3261R2-Revisiting-const-ification-in-Contract-Assertions)
- [P3592 進行状況](https://github.com/cplusplus/papers/issues/2251)

### [P3599R0 Initial Implicit Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3599r0.pdf)

暗黙の契約アサーション機能の初期セットの提案。

暗黙の契約アサーションとは、P3100R1で提唱されたコア言語中の未定義動作に繋がりうる操作について、暗黙的に事前/事後条件を持つものとして扱うことで、実行時の未定義動作ハンドリングをContractsフレームワークによって行おうとするものです。暗黙の契約アサーションは、プログラムコード中にそのアサーションに対応するコード表現が存在しないという点を除いて、ユーザーが記述可能な契約アサーション（明示的な契約アサーション）とほとんどすべての点において同一の扱いとなります。

P3100については以前の記事を参照

- [P3100R1 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3100R1-Undefined-and-erroneous-behaviour-are-contract-violations)

この提案は暗黙の契約アサーションを言語に導入するための最初のステップとして、その最小サブセットとなる機能と対象のコア言語未定義動作の初期セットを提案するものです。

提案しているセマンティクスに変更はなく、ここではまだ自動フォールバック動作（整数オーバーフローをラップアラウンドや飽和演算などで処理する）を導入していないため、P3100で提案されているassumeセマンティクスはまだありません。

各セマンティクスの動作は次のようになります（通常の契約アサーションと変わりありません）

- quick enforce: 診断メッセージの出力や違反ハンドラ呼び出しな度を行わずにすぐ終了する
- enforce: 診断メッセージの発行後、プログラムを終了する
    - これをデフォルトとすることを提案している
- ignore: これまでと同様の動作
- observe: 診断メッセージを発行して、プログラムを継続する
    - 契約アサーション自体がobservable checkpointになっているため、UB起因のタイムトラベル最適化で削除されない

ユーザー定義の違反ハンドラのサポートも通常通り可能であり、enforce/observeセマンティクスの場合に呼び出されます。その際、`kind`プロパティは`implicit`、`detection_mode`がUBに応じた列挙値（後述）になります。

評価セマンティクスの選択も通常通り実装定義（コンパイラオプションを想定）とされます。

この提案で暗黙の契約アサーションを挿入する対象としている操作は次のものです

- 組み込みの配列添字演算子
    - 配列引数の境界が既知であり`N`、実行時インデックス引数が`x`であるとき
    - 暗黙の事前条件として、`0 <= x && x < N`を持つ
    - 違反した場合の`std::contracts::detection_mode`は`bounds`になる
- 組み込みの間接参照演算子
    - ポインタ引数を`p`として、暗黙の事前条件`p != nullptr`を持つ
    - 違反した場合の`std::contracts::detection_mode`は`dereference`になる
- 符号付整数の算術演算
    - その型の範囲内の値を生成するという事前条件を持つ

これらは初期セットであり、現在確実に検査可能と思われるもののうちの最小限のものです。将来的にこのセットは拡張され、実行時UBのさらに多くのものを補足可能になることが想定されます。

この提案が採択されると、次のようなコードは

```cpp
int main(int argc, char *argv[]) {
  int a[10] = { /* ... */ };
  std::size_t i = (argc > 1) ? std::atoi(argv[1]) : 0;

  // argv[1]に10以上の値がセットされているとUB
  return a[i];
}
```

次のようなコードと等価になります

```cpp
int main(int argc, char *argv[]) {
  int a[10] = { /* ... */ };
  
  std::size_t i = (argc > 1) ? std::atoi(argv[1]) : 0;

  // 暗黙の契約アサーションが挿入される
  contract_assert( i < (sizeof(a) / size(*a)) );
  return a[i];
}
```

また、この提案およびP3100の内容はプロファイル機能の実行時検査を行う部分と重複や衝突があります。ここでは、プロファイル機能の実行時検査の部分はこの提案やP3100の方向性に統一して、プロファイル機能は静的検査に制限する事を提案しています。

この提案は機能を最小のサブセットに限定することでC++26への導入を目指していました。どうやら、重複するプロファイル機能がC++26への導入を急いでいたことを受けて急いでいたようで（重複する部分があるためプロファイル機能が先に入ると影響がある）、プロファイル機能がC++26への導入を急がない（ホワイトペーパーの仕組みを利用する）事になったことを受けてこちらの提案もC++29以降を目指すことになったようです。その検討はP3100で行われるためこの提案は一旦クローズになっています。

- [P3599 進行状況](https://github.com/cplusplus/papers/issues/2252)

### [P3603R0 Consteval-only Values and Consteval Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3603r0.html)

`consteval`変数の提案。

C++26にはコンパイル時にのみ存在が許されている値というものが、定式化されてはいないものの2種類存在しています。

1. `consteval`関数の関数ポインタ/参照
2. `std::meta::info`オブジェクト

```cpp
consteval int add(int x, int y) {
    return x + y;
}

// consteval関数ポインタそのものは存在するものの、永続化できない
constexpr auto ptr = add; // error

// meta::infoオブジェクトも永続化できない
constexpr auto refl = ^^int;
```

これら2つのものは、どちらも同じように永続化（実行時に持ち越すこと）出来ないようになっていますが、規格におけるその禁止の仕方はかなり異なっています。

1. `consteval`関数の関数ポインタ/参照
    - “permitted result”と呼ばれていたルールを使用して、`ptr`の使用を禁止する
        - “permitted result”: 定数式で許可されること（あるいはしてはいけないこと）を列挙したルール
2. `std::meta::info`オブジェクト
    - `refl`の宣言そのものは許可されるが、`consteval`のみの型と即時エスカレーションによって、`refl`を含むコンテキストが必ず定数式内であることを保証する

このような同じ要件を指定するために異なる規則・規定を使用している現状は、規定が複雑になるとともに文章に重複が生じており、双方の一貫性を確保し続けるのに保守コストがかかります。実際、`consteval`関数ポインタは定数式内では使用できるものの`constexpr`変数には入れられないという差異が生じています（`consteval`関数内であれば`constexpr`無しの変数には入れられる）。

`std::meta::info`の場合は型だけでそれが定数式のみ使用可能か分かりますが、`consteval`関数ポインタはあくまでただの関数ポインタであるため型だけからは判断できません。

この提案ではます、定数式でのみ使用可能な値という概念を定式化して使用することで、このような規定の重複・並立・複雑化を解消しようとしています。

そのためにまず、`consteval`変数を新たに導入します。`consteval`変数はコンパイル時にのみ存在可能な変数であり、その使用は全て定数式である必要がある変数です。

```cpp
consteval int add(int x, int y) {
  return x + y;
}

constexpr auto p1 = add;  // ng

consteval auto p2 = add;  // ok

int main(int argc, char**) {
  return p2(argc, 1); // ng、`p2`はconsteval変数であり、その使用は定数式でなければならない
                      //     main()は即時エスカレーションしないため、ここは定数式ではない
}
```

現在この`p2`の様な変数を取る方法はありませんが、これによってそれが提供されるようになります。また、`consteval`変数は実行時に必ず参照されないため、実行時に余分な領域を占有しません。`constexpr`は必ずしもそれが保証されていないので、`consteval`変数には単体で便利なものです。

この`p1`と`p2`の初期化式の振る舞いの際を定義するために、`consteval`のみの値を明確化します。式が`consteval`のみの値を持つとは、次のいずれかの場合となります

- 式のいずれかの構成要素が、`consteval`変数を指しているか参照している
- 式のいずれかの構成要素が、`consteval`関数を指しているか参照している
- 式のいずれかの構成要素が、`consteval`のみの型である

`consteval`変数を初期化できるのは任意の定数式ですが、`consteval`のみの値で初期化できる変数は`consteval`変数となります（前述のように、定数式内では普通に使用可能です）。

`consteval`のみの値の概念は、関数/式の即時エスカレーションの規定のために使用できる便利な概念です。特に、P3496R0で提案されている式の即時エスカレーションのために使用可能です。

さらに、これらの`consteval`変数/`consteval`のみの値を用いることで、LWG Issue 4197で報告されている既知のイシューを解決することができます。LWG Issue 4197のイシューは、`consteval`ラムダ式を`std::variant`の`visit()`で使用しようとするとコンパイルエラーになるバグレポート（libc++/libstdc++）からのもので、`consteval`関数の関数ポインタをコンパイル時テーブルに保存することができないために起きているものです。この制限によって、`std::visit()`の定数時間での関数呼び出しの要件を満たす実装が不可能になると報告されています。

`variant`の簡易実装と疑似再現コードで書くと、次のようなことが起きています

```cpp
#include <array>

template <class T, class U>
struct Variant {
  union {
    T t;
    U u;
  };
  int index;

  constexpr Variant(T t) : t(t), index(0) { }
  constexpr Variant(U u) : u(u), index(1) { }

  template <int I> requires (I < 2)
  constexpr auto get() const -> auto const& {
    if constexpr (I == 0) return t;
    else if constexpr (I == 1) return u;
  }
};


// visit()呼び出しを定数時間で解決するためのvtable
template <class R, class F, class V0, class V1>
struct binary_vtable_impl {
  template <int I, int J>
  static constexpr auto visit(F&& f, V0 const& v0, V1 const& v1) -> R {
    // ここでfが呼び出されていることによって、この関数は即時エスカレーションされconsteval関数となる
    return f(v0.template get<I>(), v1.template get<J>());
  }

  // テーブルの初期化処理
  static constexpr auto get_array() {
    return std::array{
      std::array{
        &visit<0, 0>, // consteval関数のポインタを取っている
        &visit<0, 1>
      },
      std::array{
        &visit<1, 0>,
        &visit<1, 1>
      }
    };
  }

  // テーブル本体の静的constexpr変数
  static constexpr std::array fptrs = get_array();  // consteval関数のポインタをconstexpr変数に保存しようとしていることでエラーが起こる
};

// 簡易variantのvisit()実装
template <class R, class F, class V0, class V1>
constexpr auto visit(F&& f, V0 const& v0, V1 const& v1) -> R {
  // 2次元のテーブルで呼び出す関数を引くことで定数時間で呼び出し先を解決する
  using Impl = binary_vtable_impl<R, F, V0, V1>;

  return Impl::fptrs[v0.index][v1.index]((F&&)f, v0, v1); // ng
}

consteval auto func(const Variant<int, long>& v1, const Variant<int, long>& v2) {
  // constevalラムダでvisit()を呼ぶ
  return visit<int>([](auto x, auto y) consteval { return x + y; }, v1, v2);
}

static_assert(func(Variant<int, long>{42}, Variant<int, long>{1729}) == 1771);
```

これは実際の`std::variant`と`std::visit()`実装の簡易な再現コードであり、非現実的なコードではありません。

とはいえ、`consteval`変数/`consteval`のみの値を直接用いただけではこの問題を解決できません。提案では、`consteval`変数への昇格という仕組みよってこれを解決しようとしています。

上記コードは`consteval`のみの値を持つ`get_array()`の結果を用いて`static constexpr`変数を初期化しようとしていることで起きています。例えば、このコードを動かすためだけであれば、`static constexpr`変数が`static consteval`変数になれば解決します。とはいえ、そうすると今度はふつうのラムダ式などを渡した際に動作しなくなります。

そこで、初期化式が`consteval`のみの値を持つ式である`static constexpr`変数を`consteval`変数に自動でエスカレートする、という仕組みを導入します。この例の場合

```cpp
// 簡易variantのvisit()実装
template <class R, class F, class V0, class V1>
constexpr auto visit(F&& f, V0 const& v0, V1 const& v1) -> R {
  // 2次元のテーブルで呼び出す関数を引くことで定数時間で呼び出し先を解決する
  using Impl = binary_vtable_impl<R, F, V0, V1>;

  return Impl::fptrs[v0.index][v1.index]((F&&)f, v0, v1); // ok。consteval変数`Impl::fptrs`の使用により、この関数はconsteval関数へエスカレートする
}
```

`consteval`変数エスカレーションによって、`Impl::fptrs`は`consteval`変数になっています。`consteval`変数が使用されている`constexpr`関数は即時エスカレーションの対象であり、暗黙的に`consteval`関数となるため、このコードは問題なく動作するようになります。もちろん、非`consteval`ラムダを渡した時（実行時）でも動作します。

この修正は何より、ライブラリの変更を必要としません。

結局この提案では

1. `consteval`のみの値（consteval-only value）の概念の導入
2. `consteval`変数の導入
3. 特定の`constexpr`変数（`consteval`のみの値を持つ変数）を、`consteval`変数にエスカレートできるようにする

の3点を提案しています。

- [LWG Issue 4197. Complexity of std::visit with immediate functions](https://cplusplus.github.io/LWG/issue4197)
- [P3603 進行状況](https://github.com/cplusplus/papers/issues/2253)

### [P3605R0 `isqrt`: A function to calculate integer square root of the nonnegative integer](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3605r0.pdf)

非負整数の整数平方根を計算するための`isqrt`関数の提案。

ここで提案されている`isqrt()`は、非負の整数に対してその平方根以下の最大の整数を返すような平方根計算を行うものです。数学的には次のように定義されます

$$
isqrt(n) = \lfloor \sqrt{n} \rfloor = max \{ k \in N: k^2 \leq n \}, for \space n \in N, where \space N = \{ 0, 1, 2, 3, ...\}
$$

このような計算は数論アルゴリズムで頻出する（素数判定や因数分解、暗号アルゴリズムなど）ものの、浮動小数点数の扱いによって正しい実装が難しいという問題があります。

この`isqrt()`の結果が欲しい場合によく使用される`uintmax_t(sqrt(n))`という方法は、小さな整数値に対しては正しいものの大きな整数値（仮数部のビット数が3桁以上）に対して不正確な結果を返します。これは、`n`の値が`double`型で正確に表現できる場合でも、`sqrt(n)`の結果が浮動小数点数の精度限界により、真の平方根に最も近い`double`値として丸められるためです

例えば

$$
n = 67108865^2 = 4503599761588224 = 2^52 + 2^27
$$

この値は`double`型で正確に表現でき、`n`の平方根は次のようになります

$$
\sqrt{n} = \sqrt{4503599761588224} = 67108864.9999999925494195…
$$

先ほどの定義による`isqrt(n)`はこの値の小数点以下を切り捨てたものになります

$$
isqrt(n) = \lfloor \sqrt{n} \rfloor = \lfloor \sqrt{4503599761588224} \rfloor = \lfloor 67108864.9999999925494195… \rfloor = 67108864
$$

この$\sqrt{n}$は`double`型で正確に表現できないため、`sqrt(n)`の結果は`double`型で表現可能な最も近い値を丸めによって返します。$\sqrt{n}$に隣接する2つの`double`値は次の2つです

$$
67108865-2^{-26} = 67108864.99999998509883880615234375 < \sqrt{n} < 67108865
$$

|値|$\|value-\sqrt{(n)}\|$|
|---|---|
|`67108864.99999998509883880615234375`|$7.4505807079461285 \times 10^{-9}$|
|`67108865.0`|$7.4505804859015277 \times 10^{-9}$|

`67108865.0`の方が$\sqrt{n}$の真値に近いため、`sqrt(n)`の結果はこの値に丸められます。よって`uintmax_t(sqrt(n)) = 67108865`になります。

より一般に、整数$i$に対して$n = i^2 -1$となるような整数$n$に対して、この問題が発生します。この例の`4503599761588224`はそのような`n`の最小のものです（`double`型において）。

`long double`型が80ビットの浮動小数点数型として実装されていればこの問題は解消されるものの、`int128_t`のようなより幅の広い整数型が追加されると同様の問題が発生するため、より広い浮動小数点数型を使用するだけではこの問題を解決できません。

`isqrt()`という命名については、`sqrt()`のオーバーロードが追加できない（既に整数型に対するオーバーロードが存在しているため）ことやISO/IEC 10967-2:2001規格に準拠した命名であることからこの名前を提案しています。

```cpp
// 提案している宣言
namespace std {
  template<class T>
  constexpr T isqrt(T n) noexcept;
}
```

また、`isqrt()`は非負整数だけを引数に取るものの、冗長なキャストを回避するために、関数テンプレート自体は任意の整数型を受け取れるようにすることを提案しています。引数が正であることは関数の事前条件とされます。

- [P3605 進行状況](https://github.com/cplusplus/papers/issues/2254)

### [P3606R0 On Overload Resolution, Exact Matches and Clever Implementations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3606r0.html)

関数テンプレートを含めた関数オーバーロードの解決において、GCCの実装戦略を標準化する提案。

次のようなコードにおいて

```cpp
template<typename T>
decltype([] { return T::x;}) f(T); // #1

void f(int) {} // #2

int main() {
  f(0);
}
```

GCCは`f(0)`の呼び出しにおいて完全にマッチしている`#2`を選択し、`#1`のインスタンス化を行いません。一方その他の実装ではまず`#1`のインスタンス化を先に行うためエラーになります（戻り値型の`decltype`内のラムダ式内部の`T::x`がエラーになるものの、ここは即時コンテキストではないためハードエラーになる）。

すなわち、GCCは関数テンプレートが含まれるオーバーロード解決において候補の中に全ての引数に対して完全にマッチする候補が存在する場合、テンプレート候補は一切考慮されずインスタンス化も発生しません。

この挙動は標準の 13.9.2 [temp.inst]/9 にある

> If the function selected by overload resolution can be determined without instantiating a class template definition, it is unspecified whether that instantiation actually takes place.

の解釈によって許可されている振る舞いではあるものの、CWGの見解としては文言そのものには準拠していないようです。

この振る舞いは一方で、非即時コンテキスト（SFINAEしないコンテキスト）におけるエラー診断をしないということでもあります。しかし、別の例を見てみると

```cpp
struct S {
  template <typename T>
    requires std::copyable<T>
  explicit S(T op) noexcept; // #1

  S(const S&) noexcept = default; // #2
};

static_assert(std::copyable<S>);
```

この例において`S`が`copyable`であるかを調べるには、`S(declval<const S&>())`が有効な式であるかをチェックする必要があります。そのためには`T = S`として`#1`をインスタンス化して、`#1`と`#2`の間でオーバーロード解決を行う必要があります。しかし、`#1`は再び`std::copyable<S>`で制約されています。すなわち、`S`が`copyable`であるかを調べるには、まず`S`が`copyable`であるかを調べる必要があります。このような制約の再帰はill-formedとなります。

しかし、GCCは先ほどと同じ理由によって`#2`を選択し、`#1`はインスタンス化も発生しません。このように、再帰を引き起こすコンセプトの制約チェックについては、非即時コンテキストのエラー診断を考慮しなくても、GCCの最適化の恩恵が明確になります。

これはこの提案のモチベーションの一つです。

もう一つは、CWG2369をclangで実装するためにこの実装戦略が必要となったためです。

CWG2369は、SFINAEとコンセプトによってテンプレートのインスタンス化結果が異なることがあるのを修正するために、テンプレート引数の置換と制約チェックの順序を逆にしようとするものです。

次のようなコードにおいて

```cpp
template <typename U>
struct B { static_assert(false); };

template <typename T>
  requires (sizeof(B<T>) == 1)
void f(T, typename T::foo = 0) {} // #1

void f(int) {} // #2

f(0);
```

GCCは前述のように、`#2`を選択し`#1`はインスタンス化されません。

Clang（CWG2369実装前）では、`#1`をインスタンス化しようとしてまず引数の`T::foo`の置換を行い、`int::foo`が有効ではないためSFINAEにより`#2`が選択されます。

結果として起こる事は同じであっても、ClangとGCCでは異なる理由でそれが起きています。そして、CWG2369を実装すると置換の前に制約チェックを行うため、`#1`の制約式内の`B<int>`の定義内`static_assert`でハードエラーを起こし、コンパイルエラーとなります（GCCは変わらない）。

したがって、Clangにおいては後方互換性の観点から、CWG2369を実装することができなくなっています。

ClangにおいてCWG2369を実装するためにはGCCの実装戦略を取り入れる必要があり、そのためにはその実装戦略が規格に準拠したものであることを確認する必要があります。この提案はそのために提出されたものです。

GCCの動作を採択することにはいくつかの利点があります

- オーバーロード解決時の作業量を軽減させられるため、コンパイル時間を減らせる
- CWG2369の採用による影響を軽減できる
- テンプレートコンストラクタに`same_as`制約を忘れる
    - 2つめの例のGCC以外での回避策

一方欠点は、テンプレート候補の即時コンテキストではない部分のエラーが診断されなくなる点です。これが許容可能かどうかは判然としておらず、この提案はその確認も兼ねています。

そして、GCCのこの実装戦略もまたCWG2369の採用による影響を軽減しようとするものだったようです。

なお、ここで挙げているものも含めて、提案文書にあるサンプルコードは実際のバグレポートから収集されたものを単純化したものです。したがって、これらの問題は実際出会わないようなコードで起こるだけのものではありません。

- [CWG Issue 2369. Ordering between constraints and substitution](https://cplusplus.github.io/CWG/issues/2369.html)
- [P3606 進行状況](https://github.com/cplusplus/papers/issues/2255)

### [P3608R0 Contracts and profiles: what can we reasonably ship in C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3608r0.html)

プロファイル機能や暗黙の契約アサーションに関連する機能のC++26リリースを延期することを推奨する提案。

この提案では斬新なアイデアについてC++29自体をターゲットとするか、C++29以前にリリースされるホワイトペーパーに先送りにすることを提案するとともに、次のものについてはC++26に導入することを提案しています。

- 汎用プロファイルフレームワーク（P3589）
- 標準ライブラリの堅牢化（P3471）
- 標準ライブラリの堅牢化を有効にし、堅牢化された事前条件違反が発生した場合に無条件でプログラムを終了させるだけの具体的なプロファイル
    - C++26時点では追加の柔軟性を提供しない
    - 実装ベンダに対しては、将来的に他の違反処理方法を有効化する可能性を閉ざさないように推奨する

斬新なアイデアとはどうやら、暗黙の契約アサーションに関するContracts関連の機能提案や、より具体的な安全性プロファイルの提案の事を指しているようです。

その理由としては、どちらのものにも未解決の問題や合意が得られていない部分が存在しているため、締切に終われて未完成の機能をユーザーに押し付けることを避けるべき、としています。

プロファイルと契約の間にある重複・衝突しうる部分についてはさらに検討を進めて問題を解消し、コンセンサスを改善したうえで、全ての機能が一貫した全体として動作するようになってからリリースすべき、と指摘しています。

- [P3608 進行状況](https://github.com/cplusplus/papers/issues/2256)

### [P3611R0 Dealing with pointer errors: Separating static and dynamic checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3611r0.pdf)

ポインタのエラーに関する安全性を確保するための仕組みをC++26に導入する提案。

この提案では、静的検査と動的検査を一つのソリューションで担うのではなく、それぞれ別の現在利用可能なソリューションで対応することによってC++26でポインタのエラーにある程度の対応をしようとしています。ポインタのエラーとは、無効なポインタのデリファレンスと配列外参照を指しています。

- 動的検査: 標準ライブラリの堅牢化（P3471）
- 静的検査: type/boundsプロファイル（P3038、P3274など）

動的検査によって実行時のエラーを検出し（スーパーセット化）、静的検査によってポインタのエラーに繋がる操作を禁止（サブセット化）することで、ポインタのエラーに関する安全性を確保しようとしています。

この提案がどうなったのかはよく分からないのですが、C++26に対しては標準ライブラリの堅牢化が導入され、プロファイル関連の機能についてはホワイトペーパーを利用してC++26以降に漸次導入しようとしているようです。

- [P3611 進行状況](https://github.com/cplusplus/papers/issues/2257)

### [P3613R0 On the beating of horses, and other matters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3613r0.html)

P3329R0の修正に反対する提案。

P3329R0では、`std::filter_view`に対する破壊的な修正を行うことで、`filter_view`をより安全かつ使いやすいものにすることを提案しています。

P3329R0については以前の記事を参照

- [P3329R0 Healing the C++ Filter View - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3329R0-Healing-the-C-Filter-View)

この提案は、それに対して反対するものです。

P3329R0で報告されている問題は設計意図に沿わないようなものや意図しないバグではなくDRとして適切ではない、設計変更を支持する要素が弱い、破壊的変更の影響の見積もりが甘い、などを理由に挙げています。

提案では、P3329R0で提案されている修正がいかに間違っているかについて項目ごとに歴史的経緯や理由などを述べています。

- [P3613 進行状況](https://github.com/cplusplus/papers/issues/2258)

### [P3614R0 Do not remove nor postpone access_context::unchecked](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3614r0.html)

P3547R0の提案において、`access_context::unchecked`を削除しないことを推奨する提案。

P3547R0では、クラス内エンティティに対するリフレクションを用いて何かをする際に、アクセスコンテキストを指定することでデフォルトでクラスのアクセス指定を無視したアクセスが可能であることを修正しようとしています。

P3547については以前の記事を参照

- [P3547R0 Modeling Access Control With Reflection - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3547R0-Modeling-Access-Control-With-Reflection)

提案中では、従来のデフォルトであった無条件のアクセス許可を指定するためのコンテキストを表現する`access_context::unchecked`というものがありました。SG7の初期投票では、これを含めることに対して懸念の声がありました。この提案はその結果に対して反論し、`access_context::unchecked`を遅らせないことを推奨するものです。

リフレクション機能はC++をプラグラム可能なプラグラミング言語にするものであり、リフレクション機能だけで新しい言語機能を作成できるようにするもので、そのような新しい機能はクラスメンバにアクセスする必要がある場合、アクセス検眼や型の協力なしでアクセスできるべきであり、`access_context::unchecked`がそれを可能にする、としています。`access_context::unchecked`は十分に目立つため、コードの中に埋もれづらいともしています。

- [P3615 進行状況](https://github.com/cplusplus/papers/issues/2259)

### [P3615R0 C++ Standard Library Ready Issues to be moved in Hagenberg, Feb. 2025](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3615r0.html)
### [P3616R0 Remove contracts on virtual functions for now](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3616r0.html)
### [P3618R0 Allow attaching main to the global module](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3618r0.html)
### [P3619R0 Counter-examples for P2688R5](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3619r0.pdf)

↓

### [P3619R1 Counter-examples for P2688R5](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3619r1.pdf)

P2688R5のパターンマッチング機能が有用ではない例を挙げるスライド。

P2688については以前の記事を参照。

- [P2688R5 Pattern Matching: `match` Expression - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2688R5-Pattern-Matching-match-Expression)

このスライドでは、P2688R5の`match`式によるパターンマッチングが既存の同等機能と比較して分かりやすくも使いやすくもならないような例を挙げています。説明文書がほとんどないので主張が分かりづらいですが、パターンマッチングによる書き方が説明なしだと良くわからず直観的とは言えないことを暗に主張しているものと思われます。

### [P3620R0 Concerns with the proposed addition of fibers to C++ 26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3620r0.pdf)

現在の`fiber`提案についての問題を指摘する文書。

`fiber`（軽量スレッド）を可能にするための`fiber_context`の提案がP0876で議論されています。`fiber_context`は特定のスケジューラに依存せず、その部分を抽象化して扱うことで、その上に`fiber`を構成できるようにすることを目指すものです。

P0876については以前の記事を参照。

- [P0876R19 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P0876R18-fiber_context---fibers-without-scheduler)

この提案は、`fiber_context`が抽象化しようとしているスケジューラ（コンテキストスイッチ）に関する部分の実装が困難かつ多くの問題があるとして、P0876に反対するものです。

- コンテキストの定義
    - ファイバーはユーザー空間におけるコンテキストスイッチを行うものであるが、コンテキストの定義が重要となる
    - レジスタファイルの内容やスタックポインタは当然として、現在のシグナルマスク、保留中のシグナルや非同期コールバック、進行中の非同期I/Oなど、含めるべきものは多数あるがどこまでを含めるべきかの定義が困難であり、なされていない
- スレッドローカルストレージの使用
    - ファイバーでTLSが使用されると、ユーザーのTLSの仮定が崩れる
    - 通常TLSはスレッドでプライベートなものであるが、ファイバー間では共有される
    - その最たる利用者が例外機構であり、ファイバー内での例外送出は例外機構の破損に繋がる
- 偶発的なデッドロック
    - ファイバー対応スケジューラを持たないシステムでは、偶発的なデッドロックが発生する
- レイヤーの問題
    - `fiber_context`は標準ライブラリという比較的高いレイヤに配置されようとしているが、その本質はスレッドと同等程度には低レベルに配置されるべき機能である
    - プラットフォームによって必ずしも提供されないこのような低レベルな機能を標準ライブラリとして持つことには前例がない

等を挙げています。総じて、`fiber_context`の抽象化対象であるスケジューラとコンテキストスイッチ実装の困難さや標準ライブラリに適さない低レベルさを問題としています。

代替案や今後の方向性などを特に示しておらず、P0876の標準化に反対するもののようです。

- [P3620 進行状況](https://github.com/cplusplus/papers/issues/2263)

### [P3623R0 Add noexcept to [iterator.range] (LWG 3537)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3623r0.html)

イテレータの範囲アクセス関数に`noexcept`指定を追加する提案。

この提案は、P3010R5（`valarray`と`initializer_list`の`begin/end`等の専用オーバーロードを削除する）のレビュー中に見つかった、`std::data()`の専用オーバーロードを削除した後汎用版にフォールバックすると、`noexcept`指定が変化する（`noexcept`ありから無しになる）問題を解決するためのものです。

P3016R5については以前の記事を参照

- [P3016R5 Resolve inconsistencies in begin/end for valarray and braced initializer lists - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3016R5-Resolve-inconsistencies-in-beginend-for-valarray-and-braced-initializer-lists)

例えば`std::initializer_list`と`std::data()`の場合、次のようにオーバーロードセットは次のようになっています

```cpp
// 汎用オーバーロード（noexceptなし
template<class C> constexpr auto data(C& c) -> decltype(c.data());
template<class C> constexpr auto data(const C& c) -> decltype(c.data());

// std::arrray用オーバーロード
template<class T, size_t N> constexpr T* data(T (&array)[N]) noexcept;

// initializer_list用オーバーロード（P3016で削除しようとしている
template<class E> constexpr const E* data(initializer_list<E> il) noexcept;
```

このように、専用オーバーロードには`noexcept`が指定されているものの、汎用オーバーロードは基本`noexcept`が指定されていません。これによって、`std::initializer_list`の専用オーバーロードを削除すると`noexcept`演算子によってそれが可視になります。

```cpp
// P3016前後で結果が異なる
bool f(std::initializer_list<int> il) { return noexcept(std::data(il)); }
```

この提案はこの問題に対処するために、`initializer_list`の`std::data()`オーバーロードを`<iterator>`に移して`noexcept`を維持するとともに、汎用の`std::data`に対しても条件付き`noexcept`（`noexcept(noexcept(c.data()))`）を付加するようにするものです。

そして、P3016R5の目的がコンテナとの一貫性の向上のためだったこともあり、そのほかの範囲アクセス関数に対してもそれぞれ`noexcept`を付加するようにすることを提案しています。ただし一様ではなく、それぞれ次のような変更が提案されています

- `begin()/end()`: 汎用オーバーロードに条件付き`noexcept`を追加
- `rbegin()/rend()`: 汎用オーバーロードに条件付き`noexcept`を追加、配列オーバーロードに`noexcept`を追加あ
- `crbegin()/crend()`: 汎用オーバーロードに条件付き`noexcept`を追加
- `size()`: 汎用オーバーロードに条件付き`noexcept`を追加
- `data(), empty()`: : 汎用オーバーロードに条件付き`noexcept`を追加

`std::cbegin()/cend()`に関しては既に条件付き`noexcept`指定されていましたがその他のものは特にされていなかったため、それを付加しています。

この提案の内容はすでにMSVC STLにおいて実装されており、一部はlibstdc++でも利用可能になっています。

- [P3623 進行状況](https://github.com/cplusplus/papers/issues/2264)

### [P3625R0 either neither](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3625r0.pdf)

どれか、どれでもない、を簡単に表現可能なコンセプトの提案。

この提案は、型のリストとの単純なマッチングを行うための2つのコンセプト、`either<T, Ts...>`と`neither<T, Ts...>`を提案しています。

```cpp
namespace std {
  template<class T, class... U> 
  concept either = (same_as<T, U> || ...); 

  template<class T, class... U> 
  concept neither = !either<T, U...>; 
}
```

`either<T, Ts...>`は`Ts...`の中に`T`と同じ型がある場合に満たされ、`neither<T, Ts...>`は`Ts...`の中に`T`と同じ型が無い場合に満たされます。

筆者の方の経験において、複数のプロジェクトでこのようなコンセプトの必要性に遭遇したことや、cppreferenceの[`same_as`のページ](https://en.cppreference.com/w/cpp/concepts/same_as)やstackoverflowにおける質問などから、このようなコンセプトの必要性を提案しています。


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
template<typename T> 
  requires(same_as<T, char> or same_as<T, short>) 
void func(T) { … }
```

</td>
<td valign="top">

```cpp
template<either<char, short> T> 
void func(T) { … } 
// or just: 
void func(either<char, short> auto) { … }
```

</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
template<typename T> 
  requires(not same_as<T, short> and not same_as<T, int>) 
void func(T) { … }
```

</td>
<td valign="top">

```cpp
template<neither<short, int> T> 
void func(T) { … } 
// or just: 
void func(neither<short, int> auto) { … }
```

</td>
</tr>
</table>

- [P3625 進行状況](https://github.com/cplusplus/papers/issues/2265)

### [P3626R0 Make predicate exceptions propagate by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3626r0.pdf)

契約注釈の評価時に、その条件式から送出された例外を契約機構がハンドルしないのをデフォルトにする提案。

P2900R14で提案中のContracts機能においては、契約条件式を評価した際に例外が送出されるとそれも契約違反の一部として扱って、observe/enforceセマンティクスでは違反ハンドラが呼ばれます。例外処理のためのオーバーヘッドが増えることなどからこの動作については異論があり、通常のハンドルされない例外と同様にスタックを伝播させるべきという意見があるようです。

この提案は、その方向性のための文言を提供するものです。

そのため、厳密にいえばこの提案はそのことを提案しているわけではありません（が、他に明示的にそれを提案している提案もないはずです）。

- [P3626 進行状況](https://github.com/cplusplus/papers/issues/2266)

### [P3627R0 Easy-to-adopt security profiles for preventing RCE (remote code execution) in existing C++ code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3627r0.pdf)
### [P3628R0 break label; and continue label;, tl; dr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3628r0.html)
### [P3630R0 Slides for P3568R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3630r0.pdf)
### [P3632R0 P3564R0: Make the concurrent forward progress guarantee usable in bulk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3632r0.pdf)
### [P3632R1 P3564R0: Make the concurrent forward progress guarantee usable in bulk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3632r1.pdf)

P3564R0の説明スライド。

P3564R0については以前の記事を参照

- [P3564R0 Make the concurrent forward progress guarantee usable in bulk - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3564R0-Make-the-concurrent-forward-progress-guarantee-usable-in-bulk)

このスライドでは、P3564R0のモチベーションや理由、やろうとしていることが簡潔にまとめられています。

### [P3633R0 A Byte is a Byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3633r0.pdf)

C++標準として1バイトを8ビットとして規定することに反対する提案。

この提案は、1バイトを8ビットとして規定しようとしているP3477に反対するものです。

P3477については以前の記事を参照

- [P3477R2 There are exactly 8 bits in a byte - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3477R2-There-are-exactly-8-bits-in-a-byte)

提案では次のようなことが述べられています

- 一部のDSPでは1バイト=16ビットや24ビットが珍しくなく、そのような環境でもC++11がサポートされている
    - オーディオを扱う場合は24ビットバイトが自然な設計選択となることがある
    - これらのDSPは10億台以上出荷され、現役である
        - 1バイトを8ビットに規定するということはこれらのデバイスのサポートを標準として打ち切り、メーカーにC++の使用を打ち切らせることになる
- 組み込み開発の現場からのフィードバックに時間がかかる
    - C++の標準化委員会には組み込み開発者の声が届きづらい現状がある
    - C++の標準化プロセスは長く複雑で、通常の提案でさえもフィードバックを得るのに時間がかかる
    - 組み込み開発ではその特性上ISOの標準化プロセスと同じくらいの厳格さがあり、言語のアップデートには時間がかかる
        - 組み込み製品は必ずしも後からアップデートできないことや、すでに動いているデバイスにアップデートを適用しても壊さないようにするために、慎重な検討が行われる
    - このため、組み込み分野では特に、C++におけるアップデートの効果が検証・確認されフィードバックされるまでにかなり時間がかかる
        - C++20の`volatile`非推奨化の折も、組み込み分野からのフィードバックはC++23のサイクル中だった
    - 組み込みベンダが標準仕様への追随に消極的なわけではない
        - 組み込みプラットフォームが最新のC++をサポートしないからサポートする必要がないという意見は、自己成就的な予言であり、その変更によってそれが達成される
- C++を過剰に標準化すべきではない
    - 近年は、現在有名なコンパイラによる実装容易性のために言語を過剰に標準化する傾向にある
    - 将来のアーキテクチャのために厳密に定義すべきではないものがある
    - C++の標準化プロセスは、ドメインエキスパートによって推進され、設計哲学と進化ポリシーに基づいた言語を段階的に進化させていくべき
        - 既存のコードを破壊することなく、より下位のレベルの言語の必要性を残さない
        - C++の使命は、あらゆる開発者にとっての汎用言語となること
- その変更は誰のためのものか
    - P3477ではモチベーションの一つとして、ほとんどのプログラマにとっては何も変更されないと主張しているが、何も変更されないなら修正の必要はない
    - 利便性を無視した標準化は背後にあるハードウェアの現実を無視している
        - 提案された修正の利点が何で、誰のためのものなのかが不明

P3477の採択はC++標準が組み込み業界を切り捨てる判断をするのと同義であり、C++が多様なハードウェアで利用され続けることを拒否するものとなる、ということに強く警鐘を鳴らしています。

- [P3633 進行状況](https://github.com/cplusplus/papers/issues/2271)

### [P3635R0 We shouldn't rush to require either `CHAR_BIT==8` or `(u)intNN_t`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3635r0.pdf)

C++標準として1バイトを8ビットとして規定することに反対する提案。

この提案も一つ前のP3633と同様に、1バイトを8ビットとして規定しようとしているP3477に反対するものです。

こちらでの反対理由はP3633とは少し異なった方向からのもので

- 動機づけが弱い
    - 議論をするたびに新しい情報が明らかになる
    - にもかかわらず、提出されたタイミングが新規提案をC++26へ進める事の出来る最後のタイミング
- `CHAR_BIT==8`を規定しても、`(u)intNN_t`型が必須の型として定義できるようになるわけではない
    - `CHAR_BIT==8`だとしても、他の2のべき乗サイズの型が存在するとは限らない
- `(u)intNN_t`型が拡張整数型として定義されているプラットフォームが存在する
  - つまり、標準の`int`等の基本型のエイリアスではないため、基本型との互換性が基本的にない
  - P3477によって`(u)intNN_t`型が必須型となるとすると、標準ライブラリに拡張整数型のサポートが必要になる
      - そのような考慮は現在全く行われていないため、多くの検討作業が必要
  - ライブラリ側に変更が及ばないという前提が崩れている
- ネットワークライブラリのために必須というわけでもない
  - 単に、ネットワークライブラリが`CHAR_BIT==8`の環境でのみ有効である、ように規定すればいい

そのほか、P3477の動機について一つ一つ反対意見をあげており、C++26ではリジェクトすべきとしています（時間の無駄とまで述べています）。

- [Standard library header <cstdint> (C++11) - cppreference.com](https://en.cppreference.com/w/cpp/header/cstdint.html)
- [P3635 進行状況](https://github.com/cplusplus/papers/issues/2272)

### [P3636R0 LEWG Hagenberg presentation for P3581 No, inplace_vector shouldn't have an Allocator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3636r0.pdf)

P3581の紹介スライド。

P3581については以前の記事を参照

- [P3581R0 No, `inplace_vector` shouldn't have an Allocator - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3581R0-No-inplace_vector-shouldnt-have-an-Allocator)

このスライドでは、`inplace_vector`をアロケータ対応させる議論の変遷をまとめています。特に、関連提案がいつの全体会議でどのように進行していったのかについて記載しています。

### [P3637R0 Inherit `std::meta::exception` from `std::exception`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3637r0.pdf)

`std::meta::exception`を`std::exception`から派生させるようにする提案。

P3560では静的リフレクションにおけるエラー報告とハンドリングの方法として例外を使用することを提案しています。そこでは、専用の例外型として`std::meta::exception`を使用することを提案しているものの、これは`std::exception`から派生するものではありません。

この提案はこの設計選択に反対し、`std::meta::exception`も`std::exception`の派生クラスであるべきとするものです。

P3560でそのような選択がなされたのはどうやら、LWG Issue 4087で報告された古い情報に基づく`.what()`のエンコーディングの制約に関する懸念によるものだったようで、現在それは解消されています。したがって`std::exception`からの派生を避ける理由はもはやないとのことです。

一貫性以外の理由としても、コンパイル時に送出される例外は`std::exception`の派生型のものもあり得るため、コンパイル時のテストを行うような場合に少なくとも2つの例外をキャッチするコードを書かなければならなくなります。`std::meta::exception`が`std::exception`から派生することで1種類のみを考慮すればよくなります。

ただし、提案では`std::meta::exception`のコンストラクタに渡されるエラー文字列（UTF-8）の内容が`char`のエンコーディングで表現可能な場合にのみ、UTF-8から変換した文字列を返し、そうでないならばコンパイルエラー（定数式で実行できない）にすることを提案しています。

この提案はLEWGのレビューで承認され、P3560へ適用されています。

- [P3560R0 Error Handling in Reflection - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3560R0-Error-Handling-in-Reflection)
- [LWG Issue 4087. Standard exception messages have unspecified encoding](https://cplusplus.github.io/LWG/issue4087)
- [P3637 進行状況](https://github.com/cplusplus/papers/issues/2274)

### [P3638R0 Core Language Working Group "ready" Issues for the February, 2025 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3638r0.html)

2025年01月に行われたHagenberg会議でWDに適用されたコア言語に対するIssue報告の一覧。

- [2549. Implicitly moving the operand of a throw-expression in unevaluated contexts](https://cplusplus.github.io/CWG/issues/2549)
- [2703. Three-way comparison requiring strong ordering for floating-point types, take 2](https://cplusplus.github.io/CWG/issues/2703)
- [2943. Discarding a void return value](https://cplusplus.github.io/CWG/issues/2943)
- [2970. Races with volatile sig_atomic_t bit-fields](https://cplusplus.github.io/CWG/issues/2970)
- [2990. Exporting redeclarations of namespaces](https://cplusplus.github.io/CWG/issues/2990)

### [P3639R0 The _BitInt Debate](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3639r0.html)

C23の`_BitInt`をC++ではライブラリ型として導入すべきとする提案。

`_BitInt`はC23で導入された、任意の`N`ビット（正確に`N`ビット）幅の整数型を得るための機能です。

```cpp
// 8ビット符号なし整数型を255で初期化
unsigned _BitInt(8) x = 0xFFwb; // wbリテラルはこのケースでは必要ない
```

見た目はマクロっぽいですがどうやらマクロではないようで、この`_BitInt`は簡単に次のような性質があります

- `int`型への昇格は行われない
- 混合符号比較や暗黙変換、その他整数に関する柔軟性を高める機能がサポートされる
- 標準整数よりも変換ランクが低いため、標準整数との間の演算では標準整数型に暗黙変換される
    - `_BitInt(8) op int` -> `int` 
    - `_BitInt(32) op int` -> `int`
        - `int`型の幅が32ビットの場合
    - ただし、`_BitInt<N>`の`N`が他方の標準整数型のビット幅よりも大きい場合は変換ランクが高くなる

このように、`_BitInt`は標準整数を補完するものであり、より安全な振る舞いをする整数型で置き換えるための機能ではありません。

CとC++は多くの部分で相互運用が可能なコードを記述することができるため、Cでサポートされる機能はC++でもサポートすることが可能であり`_BitInt`もC++でもサポートしてほしいという需要が生じるのは自然なことです（この提案のモチベーションがまさにそこにあります）。その場合はC++でもCと同様に標準整数型を補完するものとして導入し、Cの`_BitInt`とABI互換があるべきです。しかしそこには、`_BitInt`（あるいは同等の型）を基本型として導入するか、ライブラリ型として導入するか、選択肢があります。

この提案はこれらの利点や欠点について検討し、この方向性についての合意を促すことを目的とするものです。

基本型として導入する場合のC++での実装例
```cpp
template <size_t N>
using bit_int_t = _BitInt(N);

template <size_t N>
using bit_uint_t = unsigned _BitInt(N)
```

ライブラリ型として導入する場合の実装例
```cpp
template <size_t N>
class bit_int {
  private:
    _BitInt(N) _M_value;
  public:
    // constructors, operator overloads, ...
};

// bit_uintも同様にunsigned _BitIntをラップする形で実装する
```

どちらを選択するにせよ、このような前例は`complex `や`_Atomic`、`_Float128`などがあります（`_BitInt`を直接利用することはこれらと一貫していません）。

そのうえで、提案では両者の利点を比較しています

基本型の利点

- Cの機能との完全な互換性
    - Cでは`_BitInt`を`switch`文やビットフィールドで使用できるが、C++のライブラリ型では不可能
    - ❌ 反論: クラス型であっても条件付きサポートの例外を設けることは可能な可能性がある
      - しかし、これは`bit_int`が`_BitInt`のラッパーである場合にのみ可能であり、純粋にライブラリで実装されている場合は不可能
- `unsigned _BitInt`
    - もし`class bit_int`があり、Cとの相互運用性のために`_BitInt`互換マクロが存在する場合、`unsigned _BitInt`は`unsigned bit_int`に展開されるため機能しない
    - なおこの問題は、`_Atomic`や`_Float128`、`complex`では発生せず、`_BitInt`に固有の問題
- `_BitInt`と`class bit_int`はうまく共存できない
    - `bit_int`がクラステンプレートの場合、一般的な実装は`_BitInt`をそのテンプレートでラップすることであり、その場合一部の実装では`class bit_int`と`_BitInt`の両方が存在するが、インクルード順序によって問題を引き起こす可能性がある
    - ❌ 反論: `<stdint.h>`が互換マクロを定義していれば、ユーザーは`api.h`にそのヘッダーを含めることでこの問題を解決できる
- `_BitInt`はC++に関係なくCでは必須の機能である
    - 現代のC++コンパイラはCコンパイラでもあるため、C23がサポートされていれば`_BitInt`の基本的な仕組みはすでに存在している。基本型にすることでそれらを活用できる
        - ライブラリ型にしてしまうと、それらの機能を棄てることに等しい
    - ライブラリ型にすると、言語間でコードの互換性が低下する
    - ❌ 反論: C23での`_BitInt`の最小サポートは非常に限定的であり、移植性がない
        - C++開発者に提供したい機能や保証には不十分
        - また、MSVCが`_BitInt`をいつサポートするかは不明
- `_BitInt`はコンパイルが速い
    - 基本型は定数評価時のコストが非常に低く、テンプレート機構も不要なため、ライブラリ型と比較してコンパイル速度が大幅に向上する可能性がある
    - ❌ 反論: `std::array`と同様に、`bit_int`がコンパイラ拡張型の単なるラッパーであれば、このコストは比較的低くなる可能性がある
- 純粋なライブラリ実装は一時的な解決策に過ぎない
    - 現在のコンパイラ技術では特定の最適化は基本型に対してのみしか期待できない。純粋なライブラリ実装はコンパイラにとって透過的ではなく、多くの最適化を妨げる
    - ❌ 反論: すべてのユースケースでこれらの最適化や整数除算が必要なわけではない。多倍長ライブラリは`_BitInt`が生まれる前から存在しており、ユーザーが手動で多くの巧妙なコード変換を行うことができる
- `_BitInt`はオーバーロード解決の柔軟性を提供する
    - ライブラリ型では、オーバーロード解決で特定の動作を達成することが難しい場合がある
        - 例えば、`bit_int_t<20>`で呼び出されたときに、ロスレス変換である`f(bit_int_t<32>)`が選択されるようなオーバーロードセットを作成するのは、クラス型では困難または不可能
    - ❌ 反論: このアイデアは新しいもので、これが望ましいかどうかは明らかではない
        - `bit_int_t`は整数幅を明示的にすることに重点を置いており、柔軟な暗黙の変換は「テーマに合わない」
- `_BitInt`は特別な推論能力を持つ可能性がある
    - `foo(0);`のように、標準整数を渡したときに`bit_int_t<N>`の特殊な推論ルールが許可される可能性がある。これはクラステンプレートでは不可能
    - ❌ 反論: この問題はより一般的であり、通常の回避策はCTAD（Class Template Argument Deduction）に依存すること
        - 特別な推論ルールを設けるよりも、一般的に解決することが望ましい

ライブラリ型の利点

- `_BitInt`は移植性がないが、`class bit_int`は移植性がある
    - `_BitInt`の最大の欠点の一つは、事実上オプションの型であること
        - `N <= BITINT_MAXWIDTH`に制限されており、その最大値は実装定義（すでにGCCとClangで異なっている）
    - C++開発者に移植性のある多倍長整数を提供することが主な目的である場合、`_BitInt`はこの目標を達成できない
        - ライブラリ型であれば最大幅が非常に大きなフリースタンディングかつ必須の型として提供できる
    - ❌ 反論: この懸念はほとんど理論的なもので、実装が`_BitInt(64)`のみを提供する動機はほとんどない
        - 実際には、GCCとClangはすでに非常に広い幅の`_BitInt`を提供している
- `_BitInt`は多くの不適切なCの整数機能を継承する
    - Cの`_BitInt`は、他の標準整数から多くの不適切で非常に寛容な機能を継承している。例えば、符号なしと符号付きの混合暗黙的変換や比較、縮小変換などが許容される
        - C++26が安全性に焦点を当てていることを考えると、この動作をC++に引き継ぐべきかは疑問
    - ❌ 反論: このような誤用はCから継承される可能性があるが、C++29ではプロファイルによって診断される
        - また、C++の`_BitInt`はこの動作の一部を禁止するように制限することも可能
- `class bit_int`の方が実装が容易
    - Boost.Multiprecisionなど、すでに多くのC++用多倍長整数実装が存在し、それらを標準ライブラリに統合できる。基本型として標準化すると、ABIを確定させる必要があり、その影響は大きい
    - ❌ 反論: 実装の労力は特にそれが高品質/高性能でなければならない場合、いずれにしても必要になる
        - ライブラリ実装であっても、intrinsicsやインラインアセンブリの形でアーキテクチャの知識を利用する必要がある
- 移植性のある`class bit_int`がより早く手に入る可能性が高い
    - MSVCがC23の`_BitInt`をいつ実装するかは不明
    - 基本型を要求するとこの機能がずっと遅れるか、あるいは手に入らない可能性がある
    - ❌ 反論: すべてのコンパイラが広い幅の`_BitInt(N)`をサポートするようになれば、この点はそれほど重要ではなくなる
- `class bit_int`は教えやすい
    - 一般的に、新しい基本型はライブラリ型よりもC++ユーザーにとって習得が難しくなる傾向にある
      - 例えば、`_BitInt`は整数昇格の対象ではないが整数変換の対象となるなど
    - `class bit_int`であれば、動作についてはcppreference等を参照してコンストラクタと演算子オーバーロードを見れば一目瞭然
    - ❌ 反論: この点はやや主観的で推測的
        - いずれにせよ、言語には新しい型のセットが登場し、使用したいユーザーはそれらを学ぶ必要がある
- `class bit_int`は文言への影響が少なく、落とし穴も少ない
    - 言語に新しいクラス型を導入するだけなら、コアの文言に全く影響を与えず、文言のバグや微妙なABI破壊を引き起こすことはない
        - 例えば、`iota_view`の`difference_type`の定義など、基本型を追加することには大きな文言への影響が伴う
    - ❌ 反論: これは本末転倒なもの。委員会時間という貴重なリソースは存在するが、文言への影響が設計を決定すべきではない

この提案の結論としては、好みは無いとしながらもライブラリ型として導入することを推奨しています。

SG22/EWGのレビューと投票では、一貫して基本型とすべきというコンセンサスがありました。そのため、その方向で議論されていくと思われます（P3666で提案していくようです）。

- [P3639 進行状況](https://github.com/cplusplus/papers/issues/2276)

### [P3640R0 Make contracts reliable by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3640r0.pdf)

契約注釈のデフォルトセマンティクスをenforceにしておく提案。

この提案では、observe/ignoreセマンティクスの場合の契約注釈が実際には危険であると指摘しています。例えば次のようなコードでは

```cpp
int ddref(int** p)
  pre(p)
  pre(*p)
{ 
  return **p;
}
```

事前条件が破られない場合関数本体内および事後条件において未定義動作が発生します。enforce/quick_enforceセマンティクスではプログラム終了などによって起こらないようにすることができますが、observe/ignoreセマンティクスでは契約違反後も継続されるため回避できません。

このようなContracts機能の危険性を回避するために、契約注釈のデフォルトセマンティクスをenforceにしておくことを提案しています。

またさらに、ラベル指定がC++26に間に合わずそれが来ても上記のような問題の回避に信頼できないとして、enforce系以外のセマンティクスを選択するには追加のアノテーションを必須とすることも提案しています。

なお、この提案はSG21のレビューで否決されています。そもそも、上記の主張がContractsおよび契約プログラミングを正しく理解していないもので、提案の前提が間違っているためだと思われます。

- [P3640 進行状況](https://github.com/cplusplus/papers/issues/2277)

### [P3641R0 Rename std::observable to std::observable_checkpoint, and add a feature-test macro](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3641r0.html)
### [P3642R0 Carry-less product: `std::clmul`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r0.html)

整数のキャリーレス乗算を行う関数の提案。

キャリーレス乗算は、二進数値の乗算において各桁の桁上がりを考慮しない乗算です。

2つのビット列`a, b`に対するキャリーレス乗算`c`は次のように定義されます

$$
c_i = \bigoplus_{j=0}^i a_j \And b_{i-j}
$$

ここで、`\bigoplus`はXORによる総和を表し、下付きの`i, j`は0始まりのビットインデックス（右->左）の指定を表し、$\And$はビット積（ビット値と`bool`値を同一視した時の論理積）を表します。

別の説明をすると、乗算を筆算で書いた時に、各桁の積を求めた後に各桁毎に足していく際に加算の代わりにXORによって各桁の値を求めることに相当します。例えば、`10100010`と`10010110`の2つの二進数値のキャリーレス乗算は次のようになります

```
       10100010
       10010110
       --------
       00000000
      10100010|
     10100010||  ↓への可算はXORで行う
    00000000|||
   10100010||||
  00000000|||||
 00000000||||||
10100010|||||||
---------------
101100011101100
```

キャリーレス乗算はまた、XOR multiplication や polynomial multiplication（各ビットが係数であるガロア体GF(2)における2つの多項式の乗算に等しいため）とも呼ばれるようです。

このキャリーレス乗算はCRC、暗号計算、ビット演算などにおいてよく使用されており、CPUの命令によるHWサポートがあります。そのため、`<bit>`の各関数と同様に標準で提供するようにしておく提案です。

ここで提案しているのはキャリーレス乗算を単純に行う`std::clmul()`と、オーバーフロー検知機能付きの`std::clmul_wide()`の2つです。

```cpp
namespace std {
  template<unsigned_integral T> // constraint is exposition-only
  constexpr T clmul(T x, T y) noexcept;

  template<class T>
  struct mul_wide_result {
      T low_bits;
      T high_bits;
  };

  template<unsigned_integral T>
  constexpr mul_wide_result<T> clmul_wide(T x, T y) noexcept;
}
```

`clmul_wide()`はP3161R2で提案されている`mul_wide()`に倣ったオーバーフロー検知版の関数で、キャリーレス乗算を無限精度で行った後に結果の値の上位と下位の`N`ビット（`N`は`T`のビット数）を`high_bits, low_bits`にそれぞれ返すものです。

提案文書より、2次元のヒルベルト曲線を計算する例

```cpp
pos hilbert_to_xy(uint32_t i) {
  // De-interleave the bits of i.
  uint32_t i0 = std::bit_compress(i, 0x55555555u); // abcdefgh -> bdfh
  uint32_t i1 = std::bit_compress(i, 0xaaaaaaaau); // abcdefgh -> aceg
  
  // Undo the permutation that Hilbert curves apply on top of Z-order curves.
  uint32_t A = i0 & i1;
  uint32_t B = i0 ^ i1 ^ 0xffffu;
  uint32_t C = std::clmul(A, -1u) >> 16;  // 👈
  uint32_t D = std::clmul(B, -1u) >> 16;  // 👈
  
  uint32_t a = C ^ (i0 & D);
  return { .x = a ^ i1, .y = a ^ i0 ^ i1 };
}
```

ヒルベルト曲線では、配列の1次元インデックスを特定の2x2行列内の2次元インデックスにマッピングしますが、その際に隣接する2つの要素の間のインデックス距離が0になるようなマッピングを行うものです。例えば、`i = 0, 1, 2 ... 0xe, 0xf`に対しては次のようなマッピングを返します

```
0 1 e f
3 2 d c
4 7 8 b
5 6 9 a
```

- [Carry-less product - Wikipedia](https://en.wikipedia.org/wiki/Carry-less_product)
- [P3161R2 Unified integer overflow arithmetic - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3161R2-Unified-integer-overflow-arithmetic)
- [P3639 進行状況](https://github.com/cplusplus/papers/issues/2279)

### [P3643R0 `std::to_signed` and `std::to_unsigned`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r0.html)

整数型を対応する符号付/符号なしの整数型に簡易に変換する関数の提案。

整数数値の処理やビット操作等ではな、入力整数値をまず対応する符号付/符号なしの型に変換してから処理する事が良くあります。現在、それを最も簡易に実行できるのは関数スタイルキャストです。

```cpp
template<class T>
T arithmetic_shift_right(T x, int s) {
  return T(std::make_signed_t<T>(x) >> s);
}

template<class T>
T wrapping_add(T x, T y) {
  constexpr unsigned to_int_promotion_defense = 0;
  return T(to_int_promotion_defense
         + std::make_unsigned_t<T>(x)
         + std::make_unsigned_t<T>(y));
}
```

これは冗長性が高くバグらせやすかったり（`x`の型が`T`であることを要求していない）、関数スタイルキャストはほぼCのキャストであるためプロジェクトによってはスタイルで禁止されている場合があります。

上記の場合には`staic_cast<std::make_signed_t<T>>(x)`のように書くのが正しいですが、これはコードを複雑化します。あるいは、`std::make_signed_t<decltype(x)>(x)`のように書くのも適切ですが、これもあまり改善にはなっていません。

この提案は、この手の変換を簡単に書くための関数を用意することでこのような問題の解決を図るものです。

```cpp
// 宣言と実装の例
namespace std {
  template<class T>
  constexpr std::make_signed_t<T> to_signed(T x) noexcept {
    return static_cast<std::make_signed_t<T>>(x);
  }

  template<class T>
  constexpr std::make_unsigned_t<T> to_unsigned(T x) noexcept {
    return static_cast<std::make_unsigned_t<T>>(x);
  }
}
```

GIthubのコードの検索では、同名の関数または`make_signed/make_unsigned`への`static_cast`のようなコードの使用例がおよそ1万3千件のC++ファイルで見つかったとのことです。関数の命名はそれらの既存の使用例を根拠にしています。

- [P3643 進行状況](https://github.com/cplusplus/papers/issues/2280)

### [P3650R0 21st Century C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3650r0.pdf)

ビャーネ・ストラウストラップによって書かれた、現在のC++によるプログラミングを紹介する文書。

この文書では、C++の基礎知識を持ちながら古いスタイルのプログラミングから脱却できないような開発者を対象に、現在のC++プログラミングにおける重要な概念について説明しています。ここで説明されているのは次の項目です

- リソース管理
- ライフタイム管理
- エラー処理
- モジュール
- ジェネリックプログラミング

そして、これらに加えてガイドラインとプロファイルについての紹介もしています。

### [P3651R0 Note to the C++ standards committee members](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3651r0.pdf)
### [P3652R0 Constexpr floating-point <charconv> functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r0.html)
### [P3654R0 Slides for P3516](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3654r0.pdf)
### [P3655R0 zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r0.html)
### [P3656R0 Initial draft proposal for core language UB white paper: Process and major work items](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3656r0.pdf)
### [P3657R0 A Grammar for Whitespace Characters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3657r0.pdf)
### [P3658R0 Adjust identifier following new Unicode recommendations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3658r0.pdf)
### [P3660R0 Improve `reference_wrapper` Ergonomics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3660r0.html)
### [P3661R0 Attributes, annotations, labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3661r0.html)
### [P3662R0 Improve Increment and Decrement Operator Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3662r0.html)
### [P3663R0 Future-proof `submdspan-mapping`?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r0.html)
### [P3664R0 Make variant_size SFINAE friendly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3664r0.html)
