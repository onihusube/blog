# ［C++］[class.temporary]/3の意味について

[[class.temporary]/3](https://timsong-cpp.github.io/cppwp/n4950/class.temporary#3) とは、規格書のある一節を指すタグです（なんか呼び方があった気がしたのですが忘れました）。そこに書かれているのは、関数へ値を渡す際あるいは関数から値をリターンする際に、一時オブジェクトを生成してもよいというようなことです。

これには明確な意味があるのですが、この一文を読むだけだと今一意味が分からないので、理解を覚えているうちにメモしておきます。

[:contents]

### [class.temporary]/3に書いてあること

C++23 DIS相当であるN4950から抜粋すると

> When an object of class type X is passed to or returned from a function, if X has at least one eligible copy or move constructor ([special]), each such constructor is trivial, and the destructor of X is either trivial or deleted, implementations are permitted to create a temporary object to hold the function parameter or result object. The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the eligible trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).  
> [Note 4: This latitude is granted to allow objects of class type to be passed to or returned from functions in registers. — end note]

と書いてあります。

日本語にすると

> クラス型`X`のオブジェクトが関数に渡されるか関数から返されるとき、`X`が少なくとも一つの資格のあるコピーコンストラクタもしくはムーブコンストラクタを持ち、それらのコンストラクタは全てトリビアルであり、`X`のデストラクタがトリビアルもしくは削除されている場合、実装は関数の引数または戻り値オブジェクトを保持するために一時オブジェクトを作成してもよい。  
> そのような一時オブジェクトは、保持する値の対象に応じてそれぞれ関数の実引数もしくは戻り値の値から構築され、対応する関数仮引数もしくは戻り値オブジェクトは、資格のあるトリビアルコピーコンストラクタによって、あたかもその一時オブジェクトをコピーしたかのように初期化される（そのコピーコンストラクタがアクセスできないか、実際にコピーもしくはムーブを行う際のオーバーロード解決によって選択されない場合であっても、このように初期化される）。  
> [注記4: この自由度は、クラス型のオブジェクトをレジスタ経由で関数に渡したり関数から返したりすることができるようにするために実装に与えられている。]

みたいな意味です。

注記（Note）に書かれているように、これは条件を満たすクラス型の値をレジスタ経由で関数とやり取りすることを許可するための規定であるのですが、なぜ一時オブジェクトを作成してもいいということがそれに繋がるのでしょうか？よくわかりません・・・

### トリビアルコピー可能

この規定の前段の

> クラス型`X`のオブジェクトが関数に渡されるか関数から返されるとき、`X`が少なくとも一つの資格のあるコピーコンストラクタもしくはムーブコンストラクタを持ち、それらのコンストラクタは全てトリビアルであり、`X`のデストラクタがトリビアルもしくは削除されている場合、実装は関数の引数または戻り値オブジェクトを保持するために一時オブジェクトを作成してもよい。

のうち、

> `X`が少なくとも一つの資格のあるコピーコンストラクタもしくはムーブコンストラクタを持ち、それらのコンストラクタは全てトリビアルであり、`X`のデストラクタがトリビアルもしくは削除されている場合

という条件は、細部は異なるもののほとんど`X`がトリビアルコピー可能（*trivially copyable*）であることを指定しています。

異なるのは、代入演算子を無視することと、デストラクタが削除されていることを許容する点です。これはおそらく、この規定の目的に代入演算子とデストラクタは重要ではないための差異だと思われます（詳細は後述）。

良く知られていることですが、トリビアルコピー可能なクラス型のオブジェクトは、単なる`memcpy`によって（値だけでなく）そのオブジェクトを複製することができます。また、ムーブも単なるコピーと等価になります。

以下、この記事内ではこの条件を満たしていることを指してトリビアルコピー可能である、と言います。

### レジスタ渡しとC++オブジェクトモデル

C++のオブジェクトモデルにおいては、オブジェクトにアクセスするためにはそのオブジェクトがメモリ上に存在している必要がある、という大前提があります。そして、レジスタに配置されて渡されている引数、およびレジスタに配置されて返されている戻り値、はメモリ上に存在しているわけではありません。例えば、レジスタのアドレスを取得することはできません。

従って、レジスタに配置されているオブジェクトへのアクセスのためにはレジスタから一旦メモリに持ってこなければなりません。すなわちコピーする必要があるわけですが、クラス型の場合はコピーに伴ってコピーコンストラクタを呼ばなければならず、それらの物を使用した後には2つ分のオブジェクトを破棄するためのデストラクタ呼び出しが必要になります。

当然、こんなことを一々してたらレジスタ渡し/返しを使わない方が常に効率的になるため、レジスタ経由の関数との値のやり取りは実質的に禁止されます。しかし、これも当然、そういう面倒なことなくレジスタ経由でやり取りできるならそうしたほうが効率的であるはずです。

ところで、クラス型の中でもトリビアルコピー可能なクラス型のオブジェクトであれば、そういう面倒なこととは無縁にオブジェクトのコピーと破棄を行うことができます。C++仕様とABIのどちらの要求が先かは知りませんが、トリビアルコピー可能性はこのような場合のための性質です。

このようなことを踏まえると、問題の記述の前段

> クラス型`X`のオブジェクトが関数に渡されるか関数から返されるとき、`X`が少なくとも一つの資格のあるコピーコンストラクタもしくはムーブコンストラクタを持ち、それらのコンストラクタは全てトリビアルであり、`X`のデストラクタがトリビアルもしくは削除されている場合、実装は関数の引数または戻り値オブジェクトを保持するために一時オブジェクトを作成してもよい。  

の意味は分かってきます。

すなわち、クラス型`X`がトリビアルコピー可能ならば、レジスタ経由でやり取りしている引数/戻り値オブジェクトへのアクセスのために、それをコピーしたものを用意してそれを使用する（してもよい）ということです。

このことは逆説的には、クラス型`X`がトリビアルコピー可能でなければ、関数とのやり取りにレジスタを使用できないとも言えます。

#### オブジェクトがメモリ上に存在している事の要求について

このことは規格で明示的に指定されているわけではなく（少なくともそういう記述を見つけていない）、おそらくメモリとかアドレスみたいな具体的な言葉を使用しないようにしているため、明確にこのような要求がなされてはいないようです。ただし、オブジェクトがアドレスを取得できる必要がある、のような事実は良く知られているほか、規格の記述の至る所でもそうした仮定の存在を感じることができます。

関連する記述としては、「オブジェクトへのアクセスには（スカラ型の）glvalueのみが使用できる」（[[defns.access]](https://timsong-cpp.github.io/cppwp/n4950/defns.access)）という定義と、「glvalueはその評価によってオブジェクト（または関数）の*identity*が決定される式」（[[basic.lval]/1.1](https://timsong-cpp.github.io/cppwp/n4950/basic.lval#1.1)）という記述があります。

このオブジェクトの*identity*というのもまた曖昧なものですが、これの一つの実体がメモリ上にストレージを持っている事の要求だと思われます。そして、オブジェクトがメモリ上にストレージを持っていれば、必然的にそのアドレスを取得することができます。

ここを深堀すると戻ってこられなくなるのでここではこれくらいにとどめておきます・・・

### レジスタに配置されたオブジェクトとその一時コピーオブジェクトの関係

残った後段の記述

> そのような一時オブジェクトは、保持する値の対象に応じてそれぞれ関数の実引数もしくは戻り値の値から構築され、対応する関数仮引数もしくは戻り値オブジェクトは、資格のあるトリビアルコピーコンストラクタによって、あたかもその一時オブジェクトをコピーしたかのように初期化される（そのコピーコンストラクタがアクセスできないか、実際にコピーもしくはムーブを行う際のオーバーロード解決によって選択されない場合であっても、このように初期化される）。 

を読み解いていきましょう。

この部分は非常にわかりづらいのですが、まず一時オブジェクトが「それぞれ関数の実引数もしくは戻り値の値から構築され」とあるところの「実引数もしくは戻り値の値」とは、関数内部から見た引数もしくは関数呼び出し側から見た戻り値、のオブジェクトの事ではなく、呼び出し側が関数に渡している引数の値および関数内で関数が返そうとしている戻り値の値、のことです。

続く「対応する関数仮引数もしくは戻り値オブジェクト」とは、前者は関数内から見た引数であり、後者は関数呼び出し側から見た戻り値のことを言っています。

すなわち、順序としては一時オブジェクトが作成されてから、その一時オブジェクトをコピーする形でレジスタ上のオブジェクトが構築される、ということです。

とはいえ、直観的な想定と主従が逆なだけで起こることはあまり変わらないはずです。レジスタ渡しという言葉の使用を回避しつつC++の関数に関する規定との整合を取った結果こういう記述になっただけな感じがあります。

結局、2つのオブジェクトはほぼほぼ同じものになることを重ねて指定しているだけだと思われます。

#### 一時オブジェクトの数

明示的には指定されていませんが、レジスタ渡しされる引数および戻り値1つにつき、一時オブジェクトの数は最大1つになるでしょう。つまり、レジスタに配置されて関数とやり取りされている変数が何回使用されていたとしても、その変数名が参照する一時オブジェクトは同じものになります。

これは次のようなコードが当然動作する事から明らかでしょう

```cpp
struct X {
  int n;
};

void f(X x) {
  int n = x.n;

  x.n += 1;

  assert(x.n == (n + 1));  // 当然パスする
  
  x.n += 10;

  assert(x.n == (n + 1 + 10));  // 当然パスする
}
```

もし変数`x`の使用ごとに異なる一時オブジェクトが参照されていたとすると、このような当たり前の仮定が成り立たなくなります（そういうことは起こりえないので、一時オブジェクトは最大1つということになります）。

### 実際どうなるのか

こういう一時コピーがレジスタ配置で関数とやり取りするたびにされていたとしたら結局効率は下がるのではないかという気がしますが、この規定は理想（C++の理論オブジェクトモデル）と現実（レジスタという配置場所）の間でつじつまを合わせるための規定であり、現実に逐一コピーが行われることは無いと思われます。

そもそもCPUがメモリ上の値にアクセスするときはレジスタに持ってこなければならないので、関数呼び出し境界で一部のクラス型の値がレジスタに置かれていたとしたらその状態が最初から達成されているだけで、最適化を有効にせずともこの規定にあるようなことは起こらないでしょう（もしかしたらそうする実装もあるかもしれませんが）。

### 観測

この規定による関数呼び出し境界でのオブジェクトの分岐ような挙動は、現在のC++コード上からは極々僅かな場所を除いて観測することはできません。なので、このような変な規定は実際たいした問題をもたらさず、問題になることはありません。

極々僅かな場所とは、トリビアルコピー可能なクラス型であってもユーザー定義のコンストラクタおよびメンバ関数を持つことはできるので、それらの間で`this`のアドレスの観測を通してこのことが観測可能となります。

```cpp
#include <print>
#include <type_traits>

struct X {
  std::ptrdiff_t this_addr;

  X() {
    this_addr = reinterpret_cast<std::ptrdiff_t>(this);
  }

  void print_this() {
    std::println("this = {} in print_this()", reinterpret_cast<std::ptrdiff_t>(this));
  }
};

static_assert(std::is_trivially_copyable_v<X>);

void f(X x) {
  std::println("this = {}", x.this_addr);
  std::println("&x   = {}", reinterpret_cast<std::ptrdiff_t>(&x));

  x.print_this();
}

int main() {
  f({});
}
```

この出力は例えば次のようになります

```
this = 140721695189400
&x   = 140721695189320
this = 140721695189320 in print_this()
```

[[C++] gcc HEAD 16.0.0 20250423 (experimental) - Wandbox](https://wandbox.org/permlink/dtaEBPRlZ2z0XSlH)

なお、C++26 Contractsの影響でより簡単？に観測できる場所が増えるという話があります・・・。

### 参考文献

- [P3487R0 Postconditions odr-using a parameter that may be passed in registers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3487r0.pdf)
- [［C++］トリビアルってトリビアル？](https://onihusube.hatenablog.com/entry/2021/08/20/002116)
- [`std::is_trivially_copyable` - cpprefjp](https://cpprefjp.github.io/reference/type_traits/is_trivially_copyable.html)
- [c++ - Do Temporary Objects have identity? - Stack Overflow](https://stackoverflow.com/questions/52318426/do-temporary-objects-have-identity?noredirect=1&lq=1)
- [[defns.access] [basic.lval] Clarify what and how can be accessed by languagelawyer · Pull Request #4777 · cplusplus/draft](https://github.com/cplusplus/draft/pull/4777)
- [language lawyer - What's the meaning of "identity" in the definition of value categories in C++ - Stack Overflow](https://stackoverflow.com/questions/53443234/whats-the-meaning-of-identity-in-the-definition-of-value-categories-in-c)

[この記事のMarkdownソース](https://github.com/onihusube/blog/blob/master/2025/20250503_class_temporary_3_memo.md)
