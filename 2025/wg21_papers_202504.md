# ［C++］WG21月次提案文書を眺める（2025年04月）

#### 文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-04)

全部で34本あります。

#### もくじ

[:contents]

### [P0260R17 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r17.html)
### [P1789R1 Library Support for Expansion Statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1789r1.pdf)
### [P2019R8 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2019r8.pdf)
### [P2902R1 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2902r1.pdf)
### [P2988R12 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r12.pdf)
### [P2996R11 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r11.html)
### [P3037R5 constexpr std::shared_ptr and friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3037r5.pdf)
### [P3096R8 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r8.pdf)
### [P3126R3 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3126r3.pdf)
### [P3127R1 Graph Library: Background and Terminology](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3127r1.pdf)
### [P3128R3 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3128r3.pdf)
### [P3129R1 Graph Library: Views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3129r1.pdf)
### [P3130R3 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3130r3.pdf)
### [P3131R3 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3131r3.pdf)
### [P3161R4 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r4.html)
### [P3295R3 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3295r3.html)
### [P3312R1 Overload Set Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf)
### [P3348R3 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r3.pdf)
### [P3371R4 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3371r4.html)
### [P3388R2 When Do You Know connect Doesn't Throw?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3388r2.pdf)
### [P3391R1 constexpr std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3391r1.html)
### [P3395R3 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r3.html)
### [P3481R3 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r3.html)
### [P3514R0 "RFC 3514: The Security Flag" for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3514r0.html)

RFC 3514に倣ったジョーク提案。

これはエイプリルフールネタです。

- [悪意ビット - Wikipedia](https://ja.wikipedia.org/wiki/%E6%82%AA%E6%84%8F%E3%83%93%E3%83%83%E3%83%88)

### [P3561R2 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r2.pdf)
### [P3652R1 Constexpr floating-point <charconv> functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r1.html)
### [P3656R1 Initial draft proposal for core language UB white paper: Process and major work items](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3656r1.pdf)
### [P3665R0 Vertical Text Processing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3665r0.html)

C++で縦書きコードをサポートする提案。

これはエイプリルフールネタです。

### [P3667R0 Extending range-for loop with an expression statement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3667r0.pdf)

範囲`for`で通常の`for`と同じような更新処理を記述できるようにする提案。

C++20で範囲`for`に初期化を書けるようになったことで、範囲`for`でイテレーションしながらインデックスを使用するようなコードを書きやすくなりました。

```cpp
std::array arr {2, 4, 6};

for (int i = 0; auto x : arr) {
  std::println(”v[{}] = {}”, i, x);
  ++i;
}
```

このように、範囲`for`の内部で使用する変数の初期化が`for`の外で行われなくなり、丁度良いスコープで変数を管理できるようになりました。しかし、そのような変数の更新処理は`for`の中で手動で管理する必要があります。コードを拡張しているうちに誤って更新処理を削除してしまったり、忘れてしまうことが起こりえます。

この提案は、範囲`for`にループごとの変数の更新処理を記述できるようにすることで、そのような問題を防止しようとしています。

```cpp
// これを
for (int i = 0; auto x : e) {
  f(x, i);
  ++i;
}

// こう書けるようにする
for (int i = 0; auto x : e; ++i) {
  f(x, i);
}
```

このように、この提案後の範囲`for`はかなり通常の`for`に近い形になり、より規則的になるため教えやすさが向上します。

サンプルコードのように単純にインデックスが欲しい場合は、C++23以降`std::views::enumerate`を使用できます。

```cpp
std::array v{2.5, 3.0, 4.5, 5.0, 5.5};

for (auto [i, x] : std::views::enumerate(v)) {
  std::println(”v[{}] = {}”, i, x);
}
```

ただし、この方法にはいくつか欠点があります。

1. インデックスの型を指定できない
2. 初期値を変更できない（0固定）

また、この提案のソリューションは整数インデックスの更新に限定されておらず、通常の`for`同様に任意の式を更新処理として記述できるため、より汎用的になります。

- [P3667 進行状況](https://github.com/cplusplus/papers/issues/2297)

### [P3668R0 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r0.html)
### [P3669R0 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r0.html)
### [P3670R0 Pack Indexing for Template Names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3670r0.pdf)

テンプレートパックに対するインデックスアクセスを許可する提案。

C++26ではP2662R3によってパラメータパックに対するインデックスアクセスが可能になっています。

```cpp
template <typename... T>
constexpr auto first_plus_last(T... values) -> T...[0] {
  return T...[0](values...[0] + values...[sizeof...(values)-1]);
}

int main() {
  //first_plus_last(); // ill formed
  static_assert(first_plus_last(1, 2, 10) == 11);
}
```

このように、ほとんどのパラメータパックに対してインデックスアクセスが可能になっていますが、唯一それが認められていなかったのがパラメータパックがテンプレートになっているようなパラメータパックに対してです。より具体的には、テンプレートテンプレートパラメータが可変長になっているような場合に現れるパックの事です。

```cpp
template < template <typename> typename... TT>
struct S {
  using First = TT...[0]; // テンプレートパックのインデックスアクセス
};
```

この提案は、この`TT...[0]`のようなテンプレートパックに対するインデックスアクセスを許可しようとしています。

テンプレートパックの各要素は型でも何らかのオブジェクトでもなく、テンプレートです。さらに、P2989R2の採択によってこのテンプレートは型テンプレートだけでなくコンセプトあるいは変数テンプレートも含むことができるようになっており、この提案ではその要素に関係なくテンプレートパックのインデックスアクセスを許可しようとしています。

```cpp
template <
  typename T, 
  template <typename> concept... C
>
struct S2 {
  static constexpr bool First = C...[0]<T>; // コンセプトテンプレートパックのインデックスアクセス
};

template <
  template <typename T> auto... V
>
struct S3 {
  static constexpr std::size_t L = sizeof(V...[0]); // 変数テンプレートパックのインデックスアクセス
};
```

- [P2662R3 Pack Indexing - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2662R3-Pack-Indexing)
- [P2841R7 Concept and variable-template template-parameters -  WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2841R7-Concept-and-variable-template-template-parameters)
- [P3670 進行状況](https://github.com/cplusplus/papers/issues/2300)

### [P3671R0 Clarifying the interaction of the literal and execution encodings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3671r0.pdf)
### [P3672R0 On Windows, Systems APIs, Text Encodings, and Pragmatism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3672r0.pdf)
