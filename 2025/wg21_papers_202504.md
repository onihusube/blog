# ［C++］WG21月次提案文書を眺める（2025年04月）

#### 文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-04)

全部で34本あります。

#### もくじ

[:contents]

### [P0260R17 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r17.html)
### [P1789R1 Library Support for Expansion Statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1789r1.pdf)

`std::integer_sequence`を構造化束縛および展開ステートメントで使用できるようにする提案。

構造化束縛でのパック展開（P1061R10）と展開ステートメント（P1306R3）はどちらもC++26で導入される新機能です。これらの機能では、畳み込み式や`for`ループの様な機構を利用して構造化束縛可能な型をコンパイル時にイテレーションすることができます。

しかし、これらの新しい機能で使用可能なコンパイル時整数シーケンスを得る簡易な方法は提供されていません。現在はそのような用途のためにラムダ式とその呼び出し時の型推論を利用して所望の長さの整数パックを得るパターンが良く使用されます。

```cpp
[]<std::size_t ...INDEX>(std::index_sequence<INDEX...>) {
  // 整数パックを使用する処理をここに記述する... 
} (std::make_index_sequence<COUNT>());
```

これは、回りくどい構文に加えて関数内に余計なネストを導入してしまうという微妙さもあります。リフレクションの導入に伴ってメタプログラミングが活発になり、このようなパターンの使用機械が増加することを考えると、このようなパターンをより使いやすくする必要があります。

この提案ではそのために、`std::integer_sequence`を構造化束縛可能にすることを提案しています。これによって、整数シーケンスのパックを簡単に得ることができるようになり、またそれによるループを簡単に記述できるようになります。

```cpp
// 構造化束縛によるパック導入
constexpr auto [...INDEX] = std::make_index_sequence<COUNT>();
// 整数パック`INDEX`を直接使用できる
...
```
```cpp
// 展開ステートメントによる整数パックのイテレーション
template for (constexpr size_t INDEX : std::make_index_sequence<COUNT>()) {
  ...
}
```

`std::integer_sequence`を構造化束縛対応させる方法としては、タプルプロトコルを実装するようにしようとしています。

提案文書より、サンプル実装

```cpp
template<class T, T ...VALUES>
struct tuple_size<integer_sequence<T, VALUES...>>
  : integral_constant<size_t, sizeof...(VALUES)>
{};

template<size_t INDEX, class T, T ...VALUES>
  requires (INDEX < sizeof...(VALUES))
struct tuple_element<INDEX, integer_sequence<T, VALUES...>> {
  using type = T;
};

template<size_t INDEX, class T, T ...VALUES>
  requires (INDEX < sizeof...(VALUES))
constexpr T get(integer_sequence<T, VALUES...>) noexcept {
  return VALUES...[INDEX];
}
```

タプルの比較演算子実装のサンプルコード

```cpp
// ラムダによる実装
template<class...TTypes, class...UTypes>
  requires(sizeof...(TTypes) ==sizeof...(UTypes))
constexpr bool operator==(tuple<TTypes...> const &lhs,tuple<UTypes...> const& rhs) {
  return [&, this]<size_t ...INDEX>(index_sequence<INDEX...>){
    return ((get<INDEX>(lhs) == get<INDEX>(rhs)) && ...);
  }(index_sequence_for<TTypes...>());
}

// この提案による畳み込み式での実装
template<class...TTypes, class...UTypes>
  requires(sizeof...(TTypes) ==sizeof...(UTypes))
constexpr bool operator==(tuple<TTypes...> const &lhs,tuple<UTypes...> const& rhs) {
  constexpr auto [...INDEX] = index_sequence_for<TTypes...>{};

  return ((get<INDEX>(lhs)== get<INDEX>(rhs)) && ...);
}
```

関数引数リフレクション（P3096R5）による引数の転送の記述サンプル

```cpp
// ラムダによる実装（間違い
void foo(int x, char c) {
  [:expand(parameters_of(^^foo)):]
  >> []<auto ...parameters>(){
    bar([:parameters:]...); // oops
  }
}

// この提案による構造化束縛でのパック導入による実装
void foo(int x, char c) {
  constexpr auto [...INDEX] = std::make_index_sequence<parameters_of(^^foo).size()>();
  bar([:parameters_of(^^foo)[INDEX]:]...);
}
```

この`expand`はP2996R7で使用されている`template for`の代わりとなる機能です。関数引数リフレクションは取得した関数内部でのみスプライスすることができますが、ラムダによって関数スコープを導入するとこれが問題になります。`template for`はこの問題を軽減するものの、畳み込み式を使用したり（下の例のように）引数リストとして展開したい場合に使用できません。

- [P1061R10 Structured Bindings can introduce a Pack - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P1061R10-Structured-Bindings-can-introduce-a-Pack)
- [P1306R3 Expansion statements - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P1306R3-Expansion-statements)
- [P3096R5 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3096R5-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P1789 進行状況](https://github.com/cplusplus/papers/issues/535)

### [P2019R8 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2019r8.pdf)
### [P2902R1 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2902r1.pdf)
### [P2988R12 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r12.pdf)
### [P2996R11 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r11.html)
### [P3037R5 constexpr std::shared_ptr and friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3037r5.pdf)
### [P3096R8 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r8.pdf)
### [P3126R3 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3126r3.pdf)
### [P3127R1 Graph Library: Background and Terminology](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3127r1.pdf)
### [P3128R3 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3128r3.pdf)
### [P3129R1 Graph Library: Views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3129r1.pdf)
### [P3130R3 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3130r3.pdf)
### [P3131R3 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3131r3.pdf)
### [P3161R4 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r4.html)
### [P3295R3 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3295r3.html)
### [P3312R1 Overload Set Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf)
### [P3348R3 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r3.pdf)
### [P3371R4 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3371r4.html)
### [P3388R2 When Do You Know connect Doesn't Throw?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3388r2.pdf)
### [P3391R1 constexpr std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3391r1.html)
### [P3395R3 Fix encoding issues and add a formatter for std::error_code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r3.html)
### [P3481R3 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r3.html)
### [P3514R0 "RFC 3514: The Security Flag" for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3514r0.html)

RFC 3514に倣ったジョーク提案。

これはエイプリルフールネタです。

- [悪意ビット - Wikipedia](https://ja.wikipedia.org/wiki/%E6%82%AA%E6%84%8F%E3%83%93%E3%83%83%E3%83%88)

### [P3561R2 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r2.pdf)
### [P3652R1 Constexpr floating-point <charconv> functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r1.html)
### [P3656R1 Initial draft proposal for core language UB white paper: Process and major work items](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3656r1.pdf)
### [P3665R0 Vertical Text Processing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3665r0.html)

C++で縦書きコードをサポートする提案。

これはエイプリルフールネタです。

### [P3667R0 Extending range-for loop with an expression statement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3667r0.pdf)

範囲`for`で通常の`for`と同じような更新処理を記述できるようにする提案。

C++20で範囲`for`に初期化を書けるようになったことで、範囲`for`でイテレーションしながらインデックスを使用するようなコードを書きやすくなりました。

```cpp
std::array arr {2, 4, 6};

for (int i = 0; auto x : arr) {
  std::println(”v[{}] = {}”, i, x);
  ++i;
}
```

このように、範囲`for`の内部で使用する変数の初期化が`for`の外で行われなくなり、丁度良いスコープで変数を管理できるようになりました。しかし、そのような変数の更新処理は`for`の中で手動で管理する必要があります。コードを拡張しているうちに誤って更新処理を削除してしまったり、忘れてしまうことが起こりえます。

この提案は、範囲`for`にループごとの変数の更新処理を記述できるようにすることで、そのような問題を防止しようとしています。

```cpp
// これを
for (int i = 0; auto x : e) {
  f(x, i);
  ++i;
}

// こう書けるようにする
for (int i = 0; auto x : e; ++i) {
  f(x, i);
}
```

このように、この提案後の範囲`for`はかなり通常の`for`に近い形になり、より規則的になるため教えやすさが向上します。

サンプルコードのように単純にインデックスが欲しい場合は、C++23以降`std::views::enumerate`を使用できます。

```cpp
std::array v{2.5, 3.0, 4.5, 5.0, 5.5};

for (auto [i, x] : std::views::enumerate(v)) {
  std::println(”v[{}] = {}”, i, x);
}
```

ただし、この方法にはいくつか欠点があります。

1. インデックスの型を指定できない
2. 初期値を変更できない（0固定）

また、この提案のソリューションは整数インデックスの更新に限定されておらず、通常の`for`同様に任意の式を更新処理として記述できるため、より汎用的になります。

- [P3667 進行状況](https://github.com/cplusplus/papers/issues/2297)

### [P3668R0 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r0.html)

後置インクリメント/デクリメント演算子を`default`定義できるようにする提案。

前置ではなく後置のインクリメント/デクリメント演算子には、多くの場合に共通するデフォルトの実装があります。それは、`*this`のコピーと前置インクリメント演算子を用いた次のような実装です。

```cpp
struct C {

  // 前置インクリメント演算子
  C& operator++() {
    ...
  }

  // 後置インクリメント演算子
  C operator++(int) {
    auto copy{*this};
    ++*this;
    return copy;
  }
};
```

イテレータの定義や整数ラッパなどのインクリメント演算子の定義時にはこのような典型的な実装を取ることがほとんどで、おおむね同じ実装になります。この提案は、この実装をデフォルト動作として、後置インクリメント/デクリメント演算子の`default`実装を可能にするものです。

```cpp
struct C {

  // 前置インクリメント演算子
  C& operator++() {
    ...
  }

  // 後置インクリメント演算子
  C operator++(int) = default;  // この提案
};
```

これにより、典型的な実装によるボイラープレートコードを削減でき、それによって手書き時のユーザーエラーや必要テスト数の削減などが見込まれます。また、標準ライブラリ内部にもこれを活用できるケースが多くあり（主にイテレータ）、この提案による仕様を活用するとライブラリの仕様の分量を圧縮することができます（とはいえこれはここではまだ提案されていません）。

さらに、クラス内定義のメンバ関数だけではなくフリー関数および明示的オブジェクト引数を持つ関数としての定義においても`default`実装を許可することを提案しています。

```cpp
struct S0 {
  int v;
  S0& operator++() { ++v; return *this; }
  S0 operator++(int) = default; // ok、メンバ関数
};

struct S1 {
  int v;
  S1& operator++() { ++v; return *this; }
  S1 operator++(this S1&, int) = default; // ok、deducing this関数
};

struct S2 {
  int v;
  S2& operator++() { ++v; return *this; }
};
S2 operator++(S2&, int) = default;  // ok、フリー関数
```

いずれの場合においても、デフォルト実装の関数本体のコンテキストからコピーコンストラクタと対応する前置演算子にアクセスできない場合、暗黙的に`delete`されます。

また、明示的オブジェクト引数を持つ関数として`default`実装しようとする場合は、明示的オブジェクト引数型がそのクラス型`C`に対して`C&`/`const C&`である必要があります（すなわち、`this C&`/`this const C&`のどちらかの宣言）。これは、クラスの特殊メンバ関数の`default`定義時の現在の制約と同じものです。

- [P3668 進行状況](https://github.com/cplusplus/papers/issues/2298)

### [P3669R0 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r0.html)

`operation_state`の開始操作がブロッキングするかどうかを取得するインターフェースを追加する提案。

`std::execution`において、`sender`と`receiver`を`connect`して得られる`operation_state`は`start`関数によって開始されます。この`start`関数がどう実行されるか（非同期or同期、あるいは呼び出し元をブロックするかしないか）は実行コンテキスト（`scheduler`）によって決まります。

```cpp
using ex = std::execution;

ex::scheduler sched = ...;
ex::sender work = ex::schedule(sched) | ...;
ex::operation_state op = ex::connect(work, receiver{...});

ex::start(op); // start()が直ぐ帰るかどうかは分からない
```

そして、現在のところ`start`関数が呼び出し元をブロックするかどうかを知る手段はありません。

このことは並行キューの提案（P0260）において問題となり、非ブロッキングの`try_pop()/try_push()`インターフェースを`std::execution`と連携させようとしたときに奇妙なインターフェースとなっています。しかし、この問題は並行キューに限定されるものではありません。

この提案は、`operation_state`に対して`try_start()`インターフェースを追加することで、`start`のブロッキングに関する情報を取得できるようにしようとしています。

```cpp
using ex = std::execution;

ex::concurrent_scheduler sched = ...;
ex::sender work = ex::schedule(sched) | ...;
ex::operation_state op = ex::connect(work, receiver{...});

bool is_blocking = op.try_start();  // trueが帰った場合ブロッキングせずに開始されている（非同期的に実行されている）
```

`try_start()`はブロッキングするかどうかを取得するだけではなく、操作を開始した上で操作の実行がブロッキングしているかどうかを帰すものです。

`concurrent_scheduler`コンセプトは一緒に追加しようとしているコンセプトで、`concurrent_scheduler`である`scheduler`は`connect`された`operation_state`から`try_start()`を呼び出すことができます。

- [P3669 進行状況](https://github.com/cplusplus/papers/issues/2299)

### [P3670R0 Pack Indexing for Template Names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3670r0.pdf)

テンプレートパックに対するインデックスアクセスを許可する提案。

C++26ではP2662R3によってパラメータパックに対するインデックスアクセスが可能になっています。

```cpp
template <typename... T>
constexpr auto first_plus_last(T... values) -> T...[0] {
  return T...[0](values...[0] + values...[sizeof...(values)-1]);
}

int main() {
  //first_plus_last(); // ill formed
  static_assert(first_plus_last(1, 2, 10) == 11);
}
```

このように、ほとんどのパラメータパックに対してインデックスアクセスが可能になっていますが、唯一それが認められていなかったのがパラメータパックがテンプレートになっているようなパラメータパックに対してです。より具体的には、テンプレートテンプレートパラメータが可変長になっているような場合に現れるパックの事です。

```cpp
template < template <typename> typename... TT>
struct S {
  using First = TT...[0]; // テンプレートパックのインデックスアクセス
};
```

この提案は、この`TT...[0]`のようなテンプレートパックに対するインデックスアクセスを許可しようとしています。

テンプレートパックの各要素は型でも何らかのオブジェクトでもなく、テンプレートです。さらに、P2989R2の採択によってこのテンプレートは型テンプレートだけでなくコンセプトあるいは変数テンプレートも含むことができるようになっており、この提案ではその要素に関係なくテンプレートパックのインデックスアクセスを許可しようとしています。

```cpp
template <
  typename T, 
  template <typename> concept... C
>
struct S2 {
  static constexpr bool First = C...[0]<T>; // コンセプトテンプレートパックのインデックスアクセス
};

template <
  template <typename T> auto... V
>
struct S3 {
  static constexpr std::size_t L = sizeof(V...[0]); // 変数テンプレートパックのインデックスアクセス
};
```

- [P2662R3 Pack Indexing - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2662R3-Pack-Indexing)
- [P2841R7 Concept and variable-template template-parameters -  WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2841R7-Concept-and-variable-template-template-parameters)
- [P3670 進行状況](https://github.com/cplusplus/papers/issues/2300)

### [P3671R0 Clarifying the interaction of the literal and execution encodings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3671r0.pdf)

リテラルエンコーディングと実行エンコーディングが異なる環境について、標準仕様としてのプログラムの動作についての推論の保証をしないようにする提案。

リテラルエンコーディングと実行エンコーディングはどちらも`char`のエンコーディングの事を言っており、リテラルエンコーディングは文字列リテラルのエンコーディングを、実行エンコーディングは実行時の`char`のエンコーディングを指します。Windows以外のプラットフォームでは基本的にこの二つは一致しています。

この二つの言葉は標準文書で使用されているものの既に混同されて使用されており、`char`文字列を使用するライブラリ機能の検討時に度々問題になってきました。

この提案は、この二つのエンコーディングが一致していない場合のプログラムの動作は推論できないとして、そのような環境におけるプログラムの結果を保証しないようにしようとするものです。

変更としては、リテラルエンコーディングと実行エンコーディングが異なる場合、他方を期待するライブラリ機能にもう片方による文字列を渡すと「予期しない結果が生じるたり、未定義動作が発生する可能性がある」という一文を追加します。

なお、ここでの未定義動作とは主に文字化けの事を指しています。

ただし、この変更は規範的な注釈を追加するだけであり、何らかの動作変更を伴うものではありません。なぜなら、そのようなプラットフォームも含めても、現在の仮定（二つのエンコーディングが一致している）の下での規定による実行結果よりも悪くはならないためです。例えば、このことは既に`std::print`によって仮定されていますが、Windowsプラットフォームにおいても`std::print`はそのように動作するように実装されています。

Windows環境ではこの仮定は成り立たない場合が良くありますが、Windows環境におけるユニコードサポートの改善やユーザーの慣熟（非ASCII文字を扱う場合にロケール関連標準機能を使用しない）などによって、大多数のユーザーにとって支障がない程度にはうまく動作しているため、このような注釈を追加しても問題ないとしています。

- [Character sets and encodings - cppreference.com](https://en.cppreference.com/w/cpp/language/charset.html)
- [P3671 進行状況](https://github.com/cplusplus/papers/issues/2301)

### [P3672R0 On Windows, Systems APIs, Text Encodings, and Pragmatism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3672r0.pdf)

パス文字列とユニコードの扱いについての設計指針文書。

この文書は何かを提案するものではなく、標準ライブラリ機能がファイルパスとそのエンコーディングをどのように考慮し、どのように扱うのか、についての基礎知識や設計の方向性・推奨事項などがまとめられた文書です。

特にWindowsというある種特異なプラットフォームの対応をどのように行うべきか、についてがメインの内容です。

パスやそれに近しい文字列（システムインターフェース）を扱うクラスプラットフォームライブラリ的なコードを書く場合に参考になるかもしれません。
