# ［C++］WG21月次提案文書を眺める（2025年04月）

#### 文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-04](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-04)

全部で34本あります。

#### もくじ

[:contents]

### [P0260R17 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r17.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P0260R7-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)
- [P0260R9 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P0260R9-C-Concurrent-Queues)
- [P0260R10 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P0260R10-C-Concurrent-Queues)
- [P0260R11 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P0260R11-C-Concurrent-Queues)
- [P0260R13 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P0260R13-C-Concurrent-Queues)
- [P0260R14 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P0260R14-C-Concurrent-Queues)
- [P0260R16 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P0260R16-C-Concurrent-Queues)

このリビジョンでの変更は

- 待機中の処理のブロック解除を明示する文言を追加
- `busy_async`の説明を充実

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P1789R1 Library Support for Expansion Statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1789r1.pdf)

`std::integer_sequence`を構造化束縛および展開ステートメントで使用できるようにする提案。

構造化束縛でのパック展開（P1061R10）と展開ステートメント（P1306R3）はどちらもC++26で導入される新機能です。これらの機能では、畳み込み式や`for`ループの様な機構を利用して構造化束縛可能な型をコンパイル時にイテレーションすることができます。

しかし、これらの新しい機能で使用可能なコンパイル時整数シーケンスを得る簡易な方法は提供されていません。現在はそのような用途のためにラムダ式とその呼び出し時の型推論を利用して所望の長さの整数パックを得るパターンが良く使用されます。

```cpp
[]<std::size_t ...INDEX>(std::index_sequence<INDEX...>) {
  // 整数パックを使用する処理をここに記述する... 
} (std::make_index_sequence<COUNT>());
```

これは、回りくどい構文に加えて関数内に余計なネストを導入してしまうという微妙さもあります。リフレクションの導入に伴ってメタプログラミングが活発になり、このようなパターンの使用機械が増加することを考えると、このようなパターンをより使いやすくする必要があります。

この提案ではそのために、`std::integer_sequence`を構造化束縛可能にすることを提案しています。これによって、整数シーケンスのパックを簡単に得ることができるようになり、またそれによるループを簡単に記述できるようになります。

```cpp
// 構造化束縛によるパック導入
constexpr auto [...INDEX] = std::make_index_sequence<COUNT>();
// 整数パック`INDEX`を直接使用できる
...
```
```cpp
// 展開ステートメントによる整数パックのイテレーション
template for (constexpr size_t INDEX : std::make_index_sequence<COUNT>()) {
  ...
}
```

`std::integer_sequence`を構造化束縛対応させる方法としては、タプルプロトコルを実装するようにしようとしています。

提案文書より、サンプル実装

```cpp
template<class T, T ...VALUES>
struct tuple_size<integer_sequence<T, VALUES...>>
  : integral_constant<size_t, sizeof...(VALUES)>
{};

template<size_t INDEX, class T, T ...VALUES>
  requires (INDEX < sizeof...(VALUES))
struct tuple_element<INDEX, integer_sequence<T, VALUES...>> {
  using type = T;
};

template<size_t INDEX, class T, T ...VALUES>
  requires (INDEX < sizeof...(VALUES))
constexpr T get(integer_sequence<T, VALUES...>) noexcept {
  return VALUES...[INDEX];
}
```

タプルの比較演算子実装のサンプルコード

```cpp
// ラムダによる実装
template<class...TTypes, class...UTypes>
  requires(sizeof...(TTypes) ==sizeof...(UTypes))
constexpr bool operator==(tuple<TTypes...> const &lhs,tuple<UTypes...> const& rhs) {
  return [&, this]<size_t ...INDEX>(index_sequence<INDEX...>){
    return ((get<INDEX>(lhs) == get<INDEX>(rhs)) && ...);
  }(index_sequence_for<TTypes...>());
}

// この提案による畳み込み式での実装
template<class...TTypes, class...UTypes>
  requires(sizeof...(TTypes) ==sizeof...(UTypes))
constexpr bool operator==(tuple<TTypes...> const &lhs,tuple<UTypes...> const& rhs) {
  constexpr auto [...INDEX] = index_sequence_for<TTypes...>{};

  return ((get<INDEX>(lhs)== get<INDEX>(rhs)) && ...);
}
```

関数引数リフレクション（P3096R5）による引数の転送の記述サンプル

```cpp
// ラムダによる実装（間違い
void foo(int x, char c) {
  [:expand(parameters_of(^^foo)):]
  >> []<auto ...parameters>(){
    bar([:parameters:]...); // oops
  }
}

// この提案による構造化束縛でのパック導入による実装
void foo(int x, char c) {
  constexpr auto [...INDEX] = std::make_index_sequence<parameters_of(^^foo).size()>();
  bar([:parameters_of(^^foo)[INDEX]:]...);
}
```

この`expand`はP2996R7で使用されている`template for`の代わりとなる機能です。関数引数リフレクションは取得した関数内部でのみスプライスすることができますが、ラムダによって関数スコープを導入するとこれが問題になります。`template for`はこの問題を軽減するものの、畳み込み式を使用したり（下の例のように）引数リストとして展開したい場合に使用できません。

- [P1061R10 Structured Bindings can introduce a Pack - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P1061R10-Structured-Bindings-can-introduce-a-Pack)
- [P1306R3 Expansion statements - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P1306R3-Expansion-statements)
- [P3096R5 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3096R5-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P1789 進行状況](https://github.com/cplusplus/papers/issues/535)

### [P2019R8 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2019r8.pdf)

`std::thread/std::jthread`において、そのスレッドのスタックサイズとスレッド名を実行開始前に設定できるようにする提案。

以前の記事を参照

- [P2019R1 Usability improvements for `std::thread` - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P2019R1-Usability-improvements-for-stdthread)
- [P2019R2 Usability improvements for `std::thread` - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2019R2-Usability-improvements-for-stdthread)
- [P2019R3 Thread attributes - ［C++］WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2019R3-Thread-attributes)
- [P2019R4 Thread attributes - ［C++］WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2019R4-Thread-attributes)
- [P2019R5 Thread attributes - ［C++］WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2019R5-Thread-attributes)
- [P2019R6 Thread attributes - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2019R6-Thread-attributes)
- [P2019R7 Thread attributes - ［C++］WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P2019R7-Thread-attributes)

このリビジョンでの変更は

- `name_hint`クラステンプレートの制約を`char`のみを取るように修正
- `name_hint`のエンコーディングがリテラルエンコーディングであることを指定

などです。

- [P2019 進行状況](https://github.com/cplusplus/papers/issues/817)

### [P2902R1 constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2902r1.pdf)

並列アルゴリズムを定数式で使用できるようにする提案。

以前の記事を参照

- [P2902R0 constexpr 'Parallel' Algorithms - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2902R0-constexpr-Parallel-Algorithms)

このリビジョンでの変更は

- モチベーションを大きく拡張
    - C++26以降の`constexpr`対応機能のリスト
    - 賛成と反対のケースについてより詳細な分析を提示
- コンパイル時のアクセラレーションの可能性の影響について議論を追加
- 最新のWDにリベース

などです。

- [P2902 進行状況](https://github.com/cplusplus/papers/issues/1593)

### [P2988R12 `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2988r12.pdf)

`std::optional`が参照を保持することができるようにする提案。

以前の記事を参照

- [P2988R0 `std::optional<T&>` - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2988R0-stdoptionalT)
- [P2988R1 `std::optional<T&>` - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2988R1-stdoptionalT)
- [P2988R3 `std::optional<T&>` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2988R3-stdoptionalT)
- [P2988R4 `std::optional<T&>` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2988R4-stdoptionalT)
- [P2988R5 `std::optional<T&>` - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2988R5-stdoptionalT)
- [P2988R6 `std::optional<T&>` - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P2988R6-stdoptionalT)
- [P2988R7 `std::optional<T&>` - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P2988R7-stdoptionalT)
- [P2988R8 `std::optional<T&>` - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2988R8-stdoptionalT)
- [P2988R11 `std::optional<T&>` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2988R11-stdoptionalT)

このリビジョンでの変更は、LWGレビューに基づく文言の修正です。

この提案は、2025年2月の全体会議でC++26に向けて採択されました。

- [P2988 進行状況](https://github.com/cplusplus/papers/issues/1661)

### [P2996R11 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r11.html)

値ベースの静的リフレクションの提案。

以前の記事を参照

- [P2996R0 Reflection for C++26 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2996R0-Reflection-for-C26)
- [P2996R1 Reflection for C++26 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2996R1-Reflection-for-C26)
- [P2996R2 Reflection for C++26 - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2996R2-Reflection-for-C26)
- [P2996R3 Reflection for C++26 - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2996R3-Reflection-for-C26)
- [P2996R4 Reflection for C++26 - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P2996R4-Reflection-for-C26)
- [P2996R5 Reflection for C++26 - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P2996R5-Reflection-for-C26)
- [P2996R7 Reflection for C++26 - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2996R7-Reflection-for-C26)
- [P2996R8 Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2996R8-Reflection-for-C26)
- [P2996R10 Reflection for C++26 - WG21月次提案文書を眺める（2025年01月）](ttps://onihusube.hatenablog.com/entry/2025/08/30/234243#P2996R9-Reflection-for-C26)

このリビジョンでの変更は

- `has_complete_definition()`をより限定的な`is_enumerable_type()`に置換
- コア言語の文言の変更
- ライブラリの文言変更

などです。

- [P2996 進行状況](https://github.com/cplusplus/papers/issues/1668)

### [P3037R5 constexpr `std::shared_ptr` and friends](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3037r5.pdf)

`std::shared_ptr`を定数式でも使える様にする提案。

以前の記事を参照

- [P3037R0 `constexpr std::shared_ptr` - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P3037R0-constexpr-stdshared_ptr)
- [P3037R1 `constexpr std::shared_ptr` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3037R1-constexpr-stdshared_ptr)
- [P3037R2 `constexpr std::shared_ptr` - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3037R2-constexpr-stdshared_ptr)
- [P3037R3 `constexpr std::shared_ptr` - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3037R3-constexpr-stdshared_ptr)
- [P3037R4 `constexpr std::shared_ptr` - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3037R4-constexpr-stdshared_ptr)

このリビジョンでの変更は

- 提案タイトルの変更
- `std::shared_ptr`/`std::weak_ptr`に対する`std::atomic`部分特殊化をサポートに入れていた
- 文言の一部の詳細な文脈を追加

などです。

- [P3037 進行状況](https://github.com/cplusplus/papers/issues/1713)

### [P3096R8 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r8.pdf)

C++26に向けた静的リフレクションに対して、関数仮引数に対するリフレクションを追加する提案。

以前の記事を参照

- [P3096R0 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3096R0-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R1 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3094R2-stdbasic_fixed_string)
- [P3096R2 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3096R3-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R3 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3096R5-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R3 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3096R7-Function-Parameter-Reflection-in-Reflection-for-C26)

このリビジョンでの変更は、P2996R11と文言をそろえたことなどです。

- [P3096 進行状況](https://github.com/cplusplus/papers/issues/1764)

### [P3126R3 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3126r3.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案の概要をまとめた文書。

以前の記事を参照

- [P3126R0 Graph Library: Overview - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3126R0-Graph-Library-Overview)
- [P3126R1 Graph Library: Overview - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3126R1-Graph-Library-Overview)
- [P3126R2 Graph Library: Overview - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3126R2-Graph-Library-Overview)

このリビジョンでの変更は

- リファレンス実装の名前空間を`std::graph`から`graph`へ変更
- より汎用性の高いBFS/DFSのサポート状況を更新
- Overviewセクションに、グラフライブラリ導入の動機を追加
- "Six Degrees of Kevin Bacon exampl"を拡張し、出力と追加の説明を追加
- この提案では、スタック/キュー及び多くのアルゴリズムで発生する可能性のある`bad_alloc`例外への対応の必要性によって、スタンドアロンのグラフライブラリをサポートできないことを注記
- "Open Design Issues"と"Open Reported Issues"セクションを更新し、提案の現在の状況を反映
    - `boost::graph`-likeのdescriptorの導入と、BFS/DFS及びトポロジカルソートアルゴリズムの改善などが変更点

などです。

- [P3126 進行状況](https://github.com/cplusplus/papers/issues/1782)

### [P3127R1 Graph Library: Background and Terminology](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3127r1.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案の概要をまとめた文書。

以前の記事を参照

- [P3127R0 Graph Library: Background and Terminology - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3127R0-Graph-Library-Background-and-Terminology)

このリビジョンでの変更は

- P3126のMotivationセクションのテキストをOverviewセクションに移動
- P3126の"Six Degrees of Kevin Bacon exampl"の例と重複していたのでこちらからは削除
- C++コード例を追加して、"Direct Representation"を更新
    - 自己ループ、マルチグラフ、サイクル、ツリーなど、グラフで発生する特殊な状況についての内容を追加
- "Incident Matrices"、"Regarding Algorithms"のセクションを追加

などです。

- [P3127 進行状況](https://github.com/cplusplus/papers/issues/1783)

### [P3128R3 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3128r3.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案のうち、提案するグラフアルゴリズムについてまとめた文書。

- [P3128R0 Graph Library: Algorithms - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3128R0-Graph-Library-Algorithms)
- [P3128R2 Graph Library: Algorithms - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3128R2-Graph-Library-Algorithms)

このリビジョンでの変更は

- この提案では、スタック/キュー及び多くのアルゴリズムで発生する可能性のある`bad_alloc`例外への対応の必要性によって、スタンドアロンのグラフライブラリをサポートできないことを注記
- フリースタンディング実装をサポートできないため、アルゴリズムで例外の使用を復元
- "Traversal"セクションに深さ優先探索アルゴリズムを追加
- 深さ優先探索アルゴリズムにビジターイベントを追加
- ダイクストラアルゴリズムとベルマンフォードアルゴリズムに加えられた変更（ビジター引数追加、複数ソースのオーバーロードなど）に合わせて、幅優先探索アルゴリズムとトポロジカルソートアルゴリズムを更新

などです。

- [P3127 進行状況](https://github.com/cplusplus/papers/issues/1783)

### [P3129R1 Graph Library: Views](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3129r1.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案のうち、提案するビューについてまとめた文書。

以前の記事を参照

- [P3129R0 Graph Library: Views - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3129R0-Graph-Library-Views)

このリビジョンでの変更は

- 隣接リストのピアとして、抽象データ構造としてエッジリストを追加
    - `edgelist_view`によって返される範囲は`basic_sourced_index_edgelist`コンセプトに準拠し、`evf(uv)`関数が渡された場合は`has_edge_value`コンセプトに準拠する
    - これは、BFS、DFS及びトポロジカルソートビューのすべてのソースバージョン適用される
- BFS、DFS及びトポロジカルソートビューのアロケータ引数を復元
- この提案では、スタック/キュー及び多くのアルゴリズムで発生する可能性のある`bad_alloc`例外への対応の必要性によって、スタンドアロンのグラフライブラリをサポートできないことを注記
- 新しいBGL風のdescriptorに対応するために、descriptor構造体をinfo構造体に改名

などです。

- [P3129 進行状況](https://github.com/cplusplus/papers/issues/1785)

### [P3130R3 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3130r3.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案のうち、グラフの実体となるコンテナのインターフェースについてまとめた文書。

以前の記事を参照

- [P3130R0 Graph Library: Graph Container Interface - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3130R0-Graph-Library-Graph-Container-Interface)
- [P3130R1 Graph Library: Graph Container Interface - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3130R1-Graph-Library-Graph-Container-Interface)
- [P3130R2 Graph Library: Graph Container Interface - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3130R2-Graph-Library-Graph-Container-Interface)

このリビジョンでの変更は

- `boost::graph`-likeのdescriptorの導入に関する変更
    - グラフコンテナで定義される具体的な頂点型と辺型は、抽象的な点型と辺型のdescriptorに置き換えられた
    - descriptorは、以前のバージョンのインターフェースのidとreference引数の組み合わせを置き換えた
      - これにより、`vertex_id-only`コンセプトから`basic`名前修飾を持つものが削除され、数が削減された
      - P3129のビューを統合することも可能になり、`basic`ビューも不要になったため、ビューの数も削減された
    - P3129のビューの以前のdescriptor構造体は名前の衝突を回避するためにinfo構造体に改名
      - referenceがdescriptorに置き換えられ、descriptorがコピー可能になったため、info構造体のコピー可能な型エイリアスは不要になった

などです。

- [P3130 進行状況](https://github.com/cplusplus/papers/issues/1786)

### [P3131R3 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3131r3.pdf)

グラフアルゴリズムとデータ構造のためのライブラリ機能の提案のうち、グラフの実体となるコンテナ実体についてまとめた文章。

以前の記事を参照

- [P3131R0 Graph Library: Graph Containers - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3130R0-Graph-Library-Graph-Container-Interface)
- [P3131R1 Graph Library: Graph Containers - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3131R1-Graph-Library-Containers)
- [P3131R2 Graph Library: Graph Containers - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3131R1-Graph-Library-Containers)

このリビジョンでの変更は

- P3130R3で導入された`boost::graph`-likeのdescriptorに関する変更
    - descriptor構造体は名前の衝突を回避するためにinfo構造体に改名
    - descriptorは常にコピー可能であるため、`compressed_graph`の制約から`copyable_vertex`と`copyable_edge`を削除

などです。

- [P3131 進行状況](https://github.com/cplusplus/papers/issues/1787)

### [P3161R4 Unified integer overflow arithmetic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3161r4.html)

オーバーフローを処理可能な整数演算の提案。

以前の記事を参照

- [P3161R1 Unified integer overflow arithmetic - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3161R1-Unified-integer-overflow-arithmetic)
- [P3161R2 Unified integer overflow arithmetic - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3161R2-Unified-integer-overflow-arithmetic)
- [P3161R3 Unified integer overflow arithmetic - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3161R2-Unified-integer-overflow-arithmetic)

このリビジョンでの変更は

- 機能テストマクロの置換を削除
- 最新のドラフトにリベース
- 文言の修正

などです。

- [P3161 進行状況](https://github.com/cplusplus/papers/issues/1825)

### [P3295R3 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3295r3.html)

フリースタンディング環境の定数式において、`std::vector`等を使用可能にする提案。

以前の記事を参照

- [P3295R0 Freestanding constexpr containers and constexpr exception types - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3295R0-Freestanding-constexpr-containers-and-constexpr-exception-types)
- [P3295R1 Freestanding constexpr containers and constexpr exception types - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3295R1-Freestanding-constexpr-containers-and-constexpr-exception-types)
- [P3295R2 Freestanding constexpr containers and constexpr exception types - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3295R2-Freestanding-constexpr-containers-and-constexpr-exception-types)

このリビジョンでの変更は

- `vector`/`string`のすべてを`freestanding-consteval`にする
- `<exceptions>`と`<stdexcept>`に関してはすでに標準に含まれているためここからは削除
- `<memory>`と`string_view`の機能テストマクロを更新

などです。

- [P3295 進行状況](https://github.com/cplusplus/papers/issues/1947)

### [P3312R1 Overload Set Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3312r1.pdf)

関数のオーバーロード集合型を導入する提案。

以前の記事を参照

- [P3312R0 Overload Set Types - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3312R0-Overload-Set-Types)

このリビジョンでの変更は

- 以前のリビジョンでは関数名をバッククォートで囲むことで、「可視なオーバーロードセットが1つしかない場合でもオーバーロード集合型を作成する」と「バッククォート内の演算子シンボルを使用して、メンバスコープと名前空間スコープの両方の演算子を含むオーバーロード集合を作成できるようにする」という2つの機能が提案されていた
    - このリビジョンでは、前者の機能は将来の検討とし、後者の機能は削除
- P0119R2とP0382R0におけるその反論を説明するセクションを追加
    - この提案では、オーバーロード集合をジェネリックラムダとして定義していないので、P0119の様な動作変更は発生しない
    - ADL動作が必要な場合は現在同様ラムダ式が使用できる

などです。

この提案はEWGのレビューで更なる作業をする合意が得られず、リジェクトされています。

- [P3312 進行状況](https://github.com/cplusplus/papers/issues/1963)

### [P3348R3 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r3.pdf)

Cへの参照をC17からC23へ更新する提案。

以前の記事を参照

- [P3348R0 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3348R0-C26-should-refer-to-C23-not-C17)
- [P3348R1 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3348R1-C26-should-refer-to-C23-not-C17)
- [P3348R2 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3348R2-C26-should-refer-to-C23-not-C17)

このリビジョンでの変更は

- `nextup, nextdown`とその関連関数を追加
- `bsearch`の正しい`const`オーバーロードを追加
- `memalignment`をフリースタンディング指定
- subclauseの番号付けを修正
- `__STDC_VERSION_xxx_H__`機能テストマクロのサブセットを追加
- `va_start`の文言を追加

などです。

- [P3348 進行状況](https://github.com/cplusplus/papers/issues/2020)

### [P3371R4 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3371r4.html)

`<linalg>`の一部の関数を対応するBLAS関数の仕様と整合させる提案。

以前の記事を参照

- [P3371R0 Fix C++26 by making the symmetric and Hermitian rank-k and rank-2k updates consistent with the BLAS - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3371R0-Fix-C26-by-making-the-symmetric-and-Hermitian-rank-k-and-rank-2k-updates-consistent-with-the-BLAS)
- [P3371R1 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3371R1-Fix-C26-by-making-the-rank-1-rank-2-rank-k-and-rank-2k-updates-consistent-with-the-BLAS)
- [P3371R2 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3371R2-Fix-C26-by-making-the-rank-1-rank-2-rank-k-and-rank-2k-updates-consistent-with-the-BLAS)
- [P3371R3 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3371R3-Fix-C26-by-making-the-rank-1-rank-2-rank-k-and-rank-2k-updates-consistent-with-the-BLAS)

このリビジョンでの変更は

- 文言の差分を簡潔にするために書式を改善
- “Implementation status”セクションを更新
- LWG4137を前提とするようにリベース
    - これが提案にどのような影響を与えるかの説明を追加

などです。

現在のリビジョンでは次の4つの事を提案しています

1. rank-1, rank-2, rank-k, rank-2k update系関数に、更新オーバーロードを追加
    - 追加される関数は、`matrix_product()`の更新オーバーロードと類似している
2. 現在のrank-1, rank-2, rank-k, rank-2k update系関数の動作を、無条件更新から上書きに変更
3. `hermitian_rank_1_update()`, `hermitian_rank_k_update()`においては、`Scalar`テンプレートパラメータを非複素数になるように制限する
    - これにより、このupdate動作がエルミートになることが数学的に保証される
    - この変更はLWG4136の修正と整合している
4. rank-1, rank-k update系関数、および対称・エルミート系update関数のオーバーロードのうち、`Scalar alpha`引数を持たないものを削除
    - `Scalar alpha`引数を持つもののみが残される
    - これらのオーバーロードが後日追加されることを考慮して、線形代数数値型（linear algebra value type）が`mdspan`でも実行ポリシー型でもないことを制約
        - 線形代数数値型は、スカラ型および、行列・ベクトル型の単一の要素を表現する型のこと。単純には、整数型や浮動小数点数型

このうち2~4は破壊的変更となります。

この提案はLEWGのレビューにおいて

- [LWG Issue 4137. Fix Mandates, Preconditions, and Complexity elements of [linalg] algorithms](https://cplusplus.github.io/LWG/issue4137)
- [P3371 進行状況](https://github.com/cplusplus/papers/issues/2028)

### [P3388R2 When Do You Know connect Doesn't Throw?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3388r2.pdf)

`execution::conect`による操作が例外を送出するかどうかを早期に判定できるようにする提案。

以前の記事を参照

- [P3388R0 When Do You Know connect Doesn't Throw? - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3388R0-When-Do-You-Know-connect-Doesnt-Throw)
- [P3388R1 When Do You Know connect Doesn't Throw? - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3388R0-When-Do-You-Know-connect-Doesnt-Throw)

このリビジョンでの変更は

- typoの修正
- LEWGのフィードバックによる文言の更新

などです。

- [P3388 進行状況](https://github.com/cplusplus/papers/issues/2043)

### [P3391R1 constexpr `std::format`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3391r1.html)

`std::format()`を`constexpr`化する提案。

以前の記事を参照

- [P3391R0 `constexpr std::format` - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3391R0-constexpr-stdformat)

このリビジョンでの変更は

- ロケール指定`L`オプションを使用すると定数式で使用できないことを明確化
- 機能テストマクロを追加

などです。

- [P3391 進行状況](https://github.com/cplusplus/papers/issues/2046)

### [P3395R3 Fix encoding issues and add a formatter for `std::error_code`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3395r3.html)

`std::error_code`をフォーマット可能にする提案。

以前の記事を参照

- [P3395R0 Formatting of `std::error_code` - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3395R0-Formatting-of-stderror_code)
- [P3395R2 Formatting of `std::error_code` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3395R2-Fix-encoding-issues-and-add-a-formatter-for-stderror_code)

このリビジョンでの変更は、P2930への参照を追加しこの提案との違いの説明を追加したことです。

- [P2930R0 Formatter specializations for the standard library - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2930R0-Formatter-specializations-for-the-standard-library)
- [P3395 進行状況](https://github.com/cplusplus/papers/issues/2187)

### [P3481R3 `std::execution::bulk()` issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r3.html)

`std::execution::bulk()`の改善提案。

以前の記事を参照

- [P3481R0 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3481R0-Summarizing-stdexecutionbulk-issues)
- [P3481R1 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3481R1-stdexecutionbulk-issues)
- [P3481R2 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3481R2-stdexecutionbulk-issues)

このリビジョンでの変更は、文言の改善のみです。

- [P3481 進行状況](https://github.com/cplusplus/papers/issues/2135)

### [P3514R0 "RFC 3514: The Security Flag" for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3514r0.html)

RFC 3514に倣ったジョーク提案。

これはエイプリルフールネタです。

- [悪意ビット - Wikipedia](https://ja.wikipedia.org/wiki/%E6%82%AA%E6%84%8F%E3%83%93%E3%83%83%E3%83%88)

### [P3561R2 Index based coproduct operations on variant, and library wording](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3561r2.pdf)

`std::variant`に対してインデックスに基づく`visit()`操作を追加する提案。

以前の記事を参照

- [P3561R0 Index based coproduct operations on variant, and library wording - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3561R0-Index-based-coproduct-operations-on-variant-and-library-wording)
- [P3561R1 Index based coproduct operations on variant, and library wording - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3561R1-Index-based-coproduct-operations-on-variant-and-library-wording)

このリビジョンでの変更は

- `valueless_by_exception() == true`の時のセマンティクスを記述
- 圏論的な意味論についての記述中のインデックスに関する修正
- 未解決事項のリストを追加

などです。

- [P3560 進行状況](https://github.com/cplusplus/papers/issues/2207)

### [P3652R1 Constexpr floating-point <charconv> functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3652r1.html)

`std::to_chars`/`std::from_chars`の浮動小数点数版オーバーロードを`constexpr`指定する提案。

以前の記事を参照

- [P3652R0 Constexpr floating-point <charconv> functions - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3652R0-Constexpr-floating-point-functions)

このリビジョンでの変更は

- P3391R0（`constexpr std::format`）をモチベーションに追加
- 実装経験に`{fmt}`と`musl_from_chars`を追加

などです。

- [P3652 進行状況](https://github.com/cplusplus/papers/issues/2283)

### [P3656R1 Initial draft proposal for core language UB white paper: Process and major work items](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3656r1.pdf)

コア言語のUBに対策するための言語機能に関するホワイトペーパーのための作業や手順についての提案。

以前の記事を参照

- [P3656R0 Initial draft proposal for core language UB white paper: Process and major work items - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3656R0-Initial-draft-proposal-for-core-language-UB-white-paper-Process-and-major-work-items)

このリビジョンでの変更は

- 対象にはIFNDRも含まれる
- EWGはgithubのPRではなく公開された提案文書をレビューする
- UBに対処するための初期オプションは網羅的なものではなく、非決定性ルールのようなものは提案が必要

などです。

- [P3656 進行状況](https://github.com/cplusplus/papers/issues/2286)

### [P3665R0 Vertical Text Processing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3665r0.html)

C++で縦書きコードをサポートする提案。

これはエイプリルフールネタです。

### [P3667R0 Extending range-for loop with an expression statement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3667r0.pdf)

範囲`for`で通常の`for`と同じような更新処理を記述できるようにする提案。

C++20で範囲`for`に初期化を書けるようになったことで、範囲`for`でイテレーションしながらインデックスを使用するようなコードを書きやすくなりました。

```cpp
std::array arr {2, 4, 6};

for (int i = 0; auto x : arr) {
  std::println(”v[{}] = {}”, i, x);
  ++i;
}
```

このように、範囲`for`の内部で使用する変数の初期化が`for`の外で行われなくなり、丁度良いスコープで変数を管理できるようになりました。しかし、そのような変数の更新処理は`for`の中で手動で管理する必要があります。コードを拡張しているうちに誤って更新処理を削除してしまったり、忘れてしまうことが起こりえます。

この提案は、範囲`for`にループごとの変数の更新処理を記述できるようにすることで、そのような問題を防止しようとしています。

```cpp
// これを
for (int i = 0; auto x : e) {
  f(x, i);
  ++i;
}

// こう書けるようにする
for (int i = 0; auto x : e; ++i) {
  f(x, i);
}
```

このように、この提案後の範囲`for`はかなり通常の`for`に近い形になり、より規則的になるため教えやすさが向上します。

サンプルコードのように単純にインデックスが欲しい場合は、C++23以降`std::views::enumerate`を使用できます。

```cpp
std::array v{2.5, 3.0, 4.5, 5.0, 5.5};

for (auto [i, x] : std::views::enumerate(v)) {
  std::println(”v[{}] = {}”, i, x);
}
```

ただし、この方法にはいくつか欠点があります。

1. インデックスの型を指定できない
2. 初期値を変更できない（0固定）

また、この提案のソリューションは整数インデックスの更新に限定されておらず、通常の`for`同様に任意の式を更新処理として記述できるため、より汎用的になります。

- [P3667 進行状況](https://github.com/cplusplus/papers/issues/2297)

### [P3668R0 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r0.html)

後置インクリメント/デクリメント演算子を`default`定義できるようにする提案。

前置ではなく後置のインクリメント/デクリメント演算子には、多くの場合に共通するデフォルトの実装があります。それは、`*this`のコピーと前置インクリメント演算子を用いた次のような実装です。

```cpp
struct C {

  // 前置インクリメント演算子
  C& operator++() {
    ...
  }

  // 後置インクリメント演算子
  C operator++(int) {
    auto copy{*this};
    ++*this;
    return copy;
  }
};
```

イテレータの定義や整数ラッパなどのインクリメント演算子の定義時にはこのような典型的な実装を取ることがほとんどで、おおむね同じ実装になります。この提案は、この実装をデフォルト動作として、後置インクリメント/デクリメント演算子の`default`実装を可能にするものです。

```cpp
struct C {

  // 前置インクリメント演算子
  C& operator++() {
    ...
  }

  // 後置インクリメント演算子
  C operator++(int) = default;  // この提案
};
```

これにより、典型的な実装によるボイラープレートコードを削減でき、それによって手書き時のユーザーエラーや必要テスト数の削減などが見込まれます。また、標準ライブラリ内部にもこれを活用できるケースが多くあり（主にイテレータ）、この提案による仕様を活用するとライブラリの仕様の分量を圧縮することができます（とはいえこれはここではまだ提案されていません）。

さらに、クラス内定義のメンバ関数だけではなくフリー関数および明示的オブジェクト引数を持つ関数としての定義においても`default`実装を許可することを提案しています。

```cpp
struct S0 {
  int v;
  S0& operator++() { ++v; return *this; }
  S0 operator++(int) = default; // ok、メンバ関数
};

struct S1 {
  int v;
  S1& operator++() { ++v; return *this; }
  S1 operator++(this S1&, int) = default; // ok、deducing this関数
};

struct S2 {
  int v;
  S2& operator++() { ++v; return *this; }
};
S2 operator++(S2&, int) = default;  // ok、フリー関数
```

いずれの場合においても、デフォルト実装の関数本体のコンテキストからコピーコンストラクタと対応する前置演算子にアクセスできない場合、暗黙的に`delete`されます。

また、明示的オブジェクト引数を持つ関数として`default`実装しようとする場合は、明示的オブジェクト引数型がそのクラス型`C`に対して`C&`/`const C&`である必要があります（すなわち、`this C&`/`this const C&`のどちらかの宣言）。これは、クラスの特殊メンバ関数の`default`定義時の現在の制約と同じものです。

- [P3668 進行状況](https://github.com/cplusplus/papers/issues/2298)

### [P3669R0 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r0.html)

`operation_state`の開始操作がブロッキングするかどうかを取得するインターフェースを追加する提案。

`std::execution`において、`sender`と`receiver`を`connect`して得られる`operation_state`は`start`関数によって開始されます。この`start`関数がどう実行されるか（非同期or同期、あるいは呼び出し元をブロックするかしないか）は実行コンテキスト（`scheduler`）によって決まります。

```cpp
using ex = std::execution;

ex::scheduler sched = ...;
ex::sender work = ex::schedule(sched) | ...;
ex::operation_state op = ex::connect(work, receiver{...});

ex::start(op); // start()が直ぐ帰るかどうかは分からない
```

そして、現在のところ`start`関数が呼び出し元をブロックするかどうかを知る手段はありません。

このことは並行キューの提案（P0260）において問題となり、非ブロッキングの`try_pop()/try_push()`インターフェースを`std::execution`と連携させようとしたときに奇妙なインターフェースとなっています。しかし、この問題は並行キューに限定されるものではありません。

この提案は、`operation_state`に対して`try_start()`インターフェースを追加することで、`start`のブロッキングに関する情報を取得できるようにしようとしています。

```cpp
using ex = std::execution;

ex::concurrent_scheduler sched = ...;
ex::sender work = ex::schedule(sched) | ...;
ex::operation_state op = ex::connect(work, receiver{...});

bool is_blocking = op.try_start();  // trueが帰った場合ブロッキングせずに開始されている（非同期的に実行されている）
```

`try_start()`はブロッキングするかどうかを取得するだけではなく、操作を開始した上で操作の実行がブロッキングしているかどうかを帰すものです。

`concurrent_scheduler`コンセプトは一緒に追加しようとしているコンセプトで、`concurrent_scheduler`である`scheduler`は`connect`された`operation_state`から`try_start()`を呼び出すことができます。

- [P3669 進行状況](https://github.com/cplusplus/papers/issues/2299)

### [P3670R0 Pack Indexing for Template Names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3670r0.pdf)

テンプレートパックに対するインデックスアクセスを許可する提案。

C++26ではP2662R3によってパラメータパックに対するインデックスアクセスが可能になっています。

```cpp
template <typename... T>
constexpr auto first_plus_last(T... values) -> T...[0] {
  return T...[0](values...[0] + values...[sizeof...(values)-1]);
}

int main() {
  //first_plus_last(); // ill formed
  static_assert(first_plus_last(1, 2, 10) == 11);
}
```

このように、ほとんどのパラメータパックに対してインデックスアクセスが可能になっていますが、唯一それが認められていなかったのがパラメータパックがテンプレートになっているようなパラメータパックに対してです。より具体的には、テンプレートテンプレートパラメータが可変長になっているような場合に現れるパックの事です。

```cpp
template < template <typename> typename... TT>
struct S {
  using First = TT...[0]; // テンプレートパックのインデックスアクセス
};
```

この提案は、この`TT...[0]`のようなテンプレートパックに対するインデックスアクセスを許可しようとしています。

テンプレートパックの各要素は型でも何らかのオブジェクトでもなく、テンプレートです。さらに、P2989R2の採択によってこのテンプレートは型テンプレートだけでなくコンセプトあるいは変数テンプレートも含むことができるようになっており、この提案ではその要素に関係なくテンプレートパックのインデックスアクセスを許可しようとしています。

```cpp
template <
  typename T, 
  template <typename> concept... C
>
struct S2 {
  static constexpr bool First = C...[0]<T>; // コンセプトテンプレートパックのインデックスアクセス
};

template <
  template <typename T> auto... V
>
struct S3 {
  static constexpr std::size_t L = sizeof(V...[0]); // 変数テンプレートパックのインデックスアクセス
};
```

- [P2662R3 Pack Indexing - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2662R3-Pack-Indexing)
- [P2841R7 Concept and variable-template template-parameters -  WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2841R7-Concept-and-variable-template-template-parameters)
- [P3670 進行状況](https://github.com/cplusplus/papers/issues/2300)

### [P3671R0 Clarifying the interaction of the literal and execution encodings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3671r0.pdf)

リテラルエンコーディングと実行エンコーディングが異なる環境について、標準仕様としてのプログラムの動作についての推論の保証をしないようにする提案。

リテラルエンコーディングと実行エンコーディングはどちらも`char`のエンコーディングの事を言っており、リテラルエンコーディングは文字列リテラルのエンコーディングを、実行エンコーディングは実行時の`char`のエンコーディングを指します。Windows以外のプラットフォームでは基本的にこの二つは一致しています。

この二つの言葉は標準文書で使用されているものの既に混同されて使用されており、`char`文字列を使用するライブラリ機能の検討時に度々問題になってきました。

この提案は、この二つのエンコーディングが一致していない場合のプログラムの動作は推論できないとして、そのような環境におけるプログラムの結果を保証しないようにしようとするものです。

変更としては、リテラルエンコーディングと実行エンコーディングが異なる場合、他方を期待するライブラリ機能にもう片方による文字列を渡すと「予期しない結果が生じるたり、未定義動作が発生する可能性がある」という一文を追加します。

なお、ここでの未定義動作とは主に文字化けの事を指しています。

ただし、この変更は規範的な注釈を追加するだけであり、何らかの動作変更を伴うものではありません。なぜなら、そのようなプラットフォームも含めても、現在の仮定（二つのエンコーディングが一致している）の下での規定による実行結果よりも悪くはならないためです。例えば、このことは既に`std::print`によって仮定されていますが、Windowsプラットフォームにおいても`std::print`はそのように動作するように実装されています。

Windows環境ではこの仮定は成り立たない場合が良くありますが、Windows環境におけるユニコードサポートの改善やユーザーの慣熟（非ASCII文字を扱う場合にロケール関連標準機能を使用しない）などによって、大多数のユーザーにとって支障がない程度にはうまく動作しているため、このような注釈を追加しても問題ないとしています。

- [Character sets and encodings - cppreference.com](https://en.cppreference.com/w/cpp/language/charset.html)
- [P3671 進行状況](https://github.com/cplusplus/papers/issues/2301)

### [P3672R0 On Windows, Systems APIs, Text Encodings, and Pragmatism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3672r0.pdf)

パス文字列とユニコードの扱いについての設計指針文書。

この文書は何かを提案するものではなく、標準ライブラリ機能がファイルパスとそのエンコーディングをどのように考慮し、どのように扱うのか、についての基礎知識や設計の方向性・推奨事項などがまとめられた文書です。

特にWindowsというある種特異なプラットフォームの対応をどのように行うべきか、についてがメインの内容です。

パスやそれに近しい文字列（システムインターフェース）を扱うクラスプラットフォームライブラリ的なコードを書く場合に参考になるかもしれません。
