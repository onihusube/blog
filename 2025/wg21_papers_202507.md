# ［C++］WG21月次提案文書を眺める（2025年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-07)

全部で143本あります。

もくじ

[:contents]

### [N5012 WG21 2025-06 Sofia Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5012.pdf)
### [N5016 WG21 June 2025 Sofia Hybrid meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5016.pdf)
### [P0085R2 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r2.html)
### [P0085R3 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r3.html)
### [P0260R18 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r18.html)
### [P0260R19 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r19.html)
### [P0870R6 A proposal for a type trait to detect narrowing conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0870r6.html)
### [P0870R7 A proposal for a type trait to detect narrowing conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0870r7.html)
### [P0876R21 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0876r21.pdf)
### [P1040R8 std::embed and #depend](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1040r8.html)
### [P1306R5 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1306r5.html)
### [P2079R9 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r9.html)
### [P2079R10 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r10.html)
### [P2319R5 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2319r5.html)
### [P2414R8 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r8.pdf)
### [P2414R9 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r9.pdf)
### [P2664R11 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2664r11.html)
### [P2781R9 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r9.html)
### [P2876R3 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2876r3.html)
### [P2929R1 simd_invoke](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2929r1.html)
### [P2996R13 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r13.html)
### [P3008R6 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r6.html)
### [P3044R2 sub-string_view from string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3044r2.pdf)
### [P3045R6 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3045r6.html)
### [P3060R3 Add std::views::indices(n)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3060r3.html)
### [P3091R4 Better lookups for map , unordered_map, and flat_map](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3091r4.html)
### [P3096R10 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r10.pdf)
### [P3096R11 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r11.pdf)
### [P3096R12 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r12.pdf)
### [P3100R3 Implicit contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r3.pdf)
### [P3104R4 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3104r4.html)
### [P3111R7 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r7.html)
### [P3111R8 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r8.html)
### [P3149R11 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)
### [P3179R9 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)
### [P3211R1 views::flat_map](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3211r1.html)
### [P3216R1 views::slice](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3216r1.html)
### [P3220R1 views::take_before](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3220r1.html)
### [P3223R2 Making std::istream::ignore less surprising](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3223r2.html)
### [P3248R4 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3248r4.html)
### [P3290R3 Integrating Existing Assertions With Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3290r3.pdf)
### [P3293R3 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3293r3.html)
### [P3347R3 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r3.pdf)
### [P3348R4 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r4.pdf)
### [P3383R3 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3383r3.html)
### [P3394R4 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r4.html)
### [P3411R3 any_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r3.html)
### [P3433R1 Allocator Support for Operation States](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3433r1.pdf)
### [P3439R3 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3439r3.pdf)
### [P3440R1 Add n_elements named constructor to std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3440r1.html)
### [P3480R6 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r6.pdf)
### [P3481R4 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r4.html)
### [P3481R5 std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r5.html)
### [P3491R3 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r3.html)
### [P3503R3 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r3.html)
### [P3540R2 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3540r2.html)
### [P3552R3 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r3.html)
### [P3557R3 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r3.html)
### [P3560R2 Error Handling in Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3560r2.html)
### [P3566R2 You shall not pass char* - Safety concerns working with unbounded null-terminated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3566r2.pdf)
### [P3570R2 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r2.html)
### [P3601R0 Slides for P3407R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3601r0.pdf)

P3407R1の紹介スライド。

P3407R1については以前の記事を参照

- [P3407R1 Make idiomatic usage of `offsetof` well-defined - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3407R1-Make-idiomatic-usage-of-offsetof-well-defined)

P34701R1のモチベーションなどが簡単に紹介されています。

### [P3642R1 Carry-less product: std::clmul](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r1.html)
### [P3642R2 Carry-less product: std::clmul](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r2.html)
### [P3647R0 Slides for P3642R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3647r0.html)

P3642R1の紹介スライド。

P3642R1(R2)に関してはすぐ上をご覧ください。

キャリーレス乗算機能のの必要性などが簡単に説明されています。

### [P3655R2 zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r2.html)
### [P3663R2 Future-proof submdspan-mapping](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r2.html)
### [P3668R2 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r2.html)
### [P3669R2 Non-Blocking Support for std::execution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r2.html)
### [P3687R1 Final Adjustments to C++26 Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3687r1.html)
### [P3688R1 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r1.html)
### [P3690R1 Consistency fix: Make simd reductions SIMD-generic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3690r1.pdf)
### [P3691R1 Reconsider naming of the namespace for "std::simd"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3691r1.pdf)
### [P3692R1 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r1.pdf)
### [P3697R1 Minor additions to C++26 standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3697r1.html)
### [P3699R1 Rename conqueue_errc](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3699r1.html)
### [P3705R1 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r1.html)
### [P3705R2 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r2.html)
### [P3709R1 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r1.html)
### [P3709R2 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)
### [P3711R1 Safer StringViewLike Functions for Replacing char* strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3711r1.pdf)
### [P3713R0 2025-05 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3713r0.html)
### [P3718R0 Fixing Lazy Sender Algorithm Customization, Again](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3718r0.html)

`std::excecution`に対するP2999R3の問題点を修正する提案。

P2999については以前の記事を参照

- [P2999R3 Sender Algorithm Customization - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2999R3-Sender-Algorithm-Customization)

ここでは主に、`continues_on`と`schedule_from`の扱うドメイン（`sender`アルゴリズムがカスタマイズの探索を行う範囲・環境、あるいは`sender`の完了地点の宣言そのもの）に関する問題の修正が提案されています。

1. `get-domain-late()`における`continues_on`と`schedule_from`の取り違え
    - その説明の中で`continues_on`と`schedule_from`の役割が逆になって扱われている
2. 遅延カスタマイズの場合のドメインの問い合わせ先の間違い
    - ある`sender`が`connect`された時、ドメインの問い合わせ先をその`sender`に対して行っていた
    - ある`sender`自身のドメインと先行`sender`のドメインが一致する場合は問題ないものの一致しない場合に問題になる
        - `continues_on`は自身の完了地点と先行`sender`の完了地点が異なる（=ドメインが異なる）可能性があるため、問題が起こりうる
3. `get-domain-late()`が優先使用するドメインが誤っている
    -  `get-domain-late()`は渡された`sender`のドメインを、`receiver`のドメインよりも優先する
    -  `sender`は自身がどこで完了するかを知ることができ、`receiver`は処理（後続`sender`）がどこで開始されるかを知っている
    -  `sender`が開始される場所に基づいてディスパッチを行う場合、`sender`ではなく`receiver`に問い合わせるべき

`continues_on`と`schedule_from`はコンテキストの遷移を扱う`sender`アルゴリズムであるため、ドメインの取得に関して他の一般の`sender`アルゴリズムと異なる特別な対応が必要になります。

ここでは次の解決策を提案しています

1. デフォルト実装を持たない非転送のクエリを行う、`get_domain_override`クエリを追加
2. `get_scheduler`クエリに意味を持たせるため、操作の作成に使用した`receiver`の環境に関連付けられた`scheduler`の実行エージェント上で操作を開始することを要求する
3. `SCHED-ATTRS`と`SCHED-ENV`の定義を調整し、`get_domain`クエリの転送を回避する
4. 説明専用の`completion-domain`ヘルパの定義をを簡素化し、設定可能なデフォルトを不要にする
5. `get_domain_override(get_env(schedule_from(sch, sndr)))`が`sch`のドメインを返すことを規定
6. `get_domain_override(get_env(continues_on(sndr, sch)))`が`sndr`のドメインを返すことを規定
7. `get_domain_override(get_env(starts_on(sch, sndr)))`が`sch`のドメインを返すことを規定
8. `get-domain-late(sndr, env, def)`は次のいずれかと等価である必要がある
    - `get_domain_override(get_env(sndr))`: この式がwell-formedの場合
    - `get_domain(env)`: そうではなく、この式がwell-formedの場合
    - `get_domain(get_scheduler(env))`: そうではなく、この式がwell-formedの場合
    - それ以外の場合: `def`
9.  `sync_wait`および`sync_wait_with_variant`はカスタマイズを探索する際に`get-domain-late(sndr, sync-wait-env{}, get-domain-early(sndr))`を使用することを指定

これらの事は、NVIDIAのCCCLというライブラリ向けのGPUスケジューラを再実装している際に発見されたもののようで、CCCLライブラリおよびstdexecにおいてこれらの設計は実装済みであるようです。

- [P3718 進行状況](https://github.com/cplusplus/papers/issues/2350)

### [P3719R0 `std::is_vector_bool_reference`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3719r0.html)

`std::vector<bool>`を検出する型特性を追加する提案。

例えば次のようにある関数のオーバーロードを特定の型ごとに用意しなければならない場合

```cpp
// シリアライズライブラリなど、型ごとのread()関数オーバーロードが大量にある
void read(bool& b);
void read(int& b);
void read(long& b);
void read(long long& b);
// ... many more
```

このとき、`std::vector<bool>`（の要素型）にも対応する必要があることに気づきます。移植性のある方法として次のように書くとおおむねうまくいきます

```cpp
void read(std::vector<bool>::reference b);
```

しかし、アロケータがカスタマイズされた`std::vector<bool, MyAllocator>`のようなものにこれでは対応できないことがあります。なぜなら、`std::vector<bool, MyAllocator>::reference`と`std::vector<bool>::reference`が実装によっては異なる型である場合もそうでない場合もあるためです。実際、libstdc++では同じ型であり、MSVC STLでは異なる型になります。

このような場合にアロケータをテンプレート化するだけではこれを解決できません。

```cpp
template <typename Alloc>
void read(std::vector<bool, Alloc>::reference b);
```

このような関数テンプレートにおいては、`Alloc`は推論できないコンテキストにあるため推論に失敗します。

この提案では、`std::vector<bool>::reference`をアロケータ型によらずに識別するために、`std::is_vector_bool_reference<T>`型特性を追加することを提案しています。このような型特性は標準においても説明専用の`is-vector-bool-reference`として存在しているため、これをユーザーが使用できるようにするだけです。

`std::is_vector_bool_reference<T>`は、`T`が任意のアロケータ型`Alloc`に対する`std::vector<bool, Alloc>::reference`型を示しており、かつ`std::vector<bool, Alloc>`がプログラム定義の特殊化（ユーザー定義特殊化）ではない場合に`true`を返すものです。

これを用いると、先ほどのオーバーロードの問題はシンプルに書くことができるようになります

```cpp
template <typename BitReference>
    requires std::is_vector_bool_reference_v<BitReference>
void read(BitReference b);
```

- [P3719 進行状況](https://github.com/cplusplus/papers/issues/2351)

### [P3721R0 Slides for P3639R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3721r0.html)

P3639R0の紹介スライド。

P3639R0については以前の記事を参照

- [P3639R0 The _BitInt Debate - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3639R0-The-_BitInt-Debate)

P3639R0の内容が簡単に解説されています。

### [P3722R0 Slides for P3568R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3722r0.html)
### [P3724R0 Integer division](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3724r0.html)

商と剰余を様々な丸めモードで計算するライブラリ関数の提案。

C++の現在の`/`は切り捨て除算を行います。しかし、丸めモードは切り捨てだけではなく他のものも有用と思われます。また、標準の丸め方法では割られる数が負の場合などに剰余が負の値になる場合もあり、この動作も望ましくありません。

このような問題を回避するのは非常に単純に思えますが、実際には`/`に存在する未定義動作を回避しながら丸め方法を変更するのは驚くほど難しく、少し調べて出てくるような方法はほとんどが間違っているか、問題を抱えています（提案文書にはその例がいくつか掲載されています）。さらに、剰余に関しても整数オーバーフローを回避する必要性によってセロ方向以外の丸めモードで正しく計算するのは困難です。

この提案は丸め方法を指定して商と剰余を求めるライブラリ関数を追加することで、現在の`/`および`%`に代わって所望の丸め方法で商と剰余を求める方法を提供しようとするものです。

提案文書より、サンプルコード

```cpp
const int bucket_size = 1000;
int elements = 100;

int buckets_required = elements / bucket_size; // WRONG, zero
int buckets_required = std::div_to_inf(elements, bucket_size); // OK, one bucket
```

提案している関数は、その名前が商を計算するものは`div_`、剰余を計算するものは`div_rem_`で始まり、それに続いて丸め方法が指定される形の命名になっています。

```cpp
namespace std {
  template<class T>
    constexpr T div_to_zero(T x, T y);
  template<class T>
    constexpr T div_away_zero(T x, T y);
  template<class T>
    constexpr T div_to_inf(T x, T y);
  template<class T>
    constexpr T div_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_to_odd(T x, T y);
  template<class T>
    constexpr T div_to_even(T x, T y);
  template<class T>
    constexpr T div_ties_to_zero(T x, T y);
  template<class T>
    constexpr T div_ties_away_zero(T x, T y);
  template<class T>
    constexpr T div_ties_to_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_odd(T x, T y);
  template<class T>
    constexpr T div_ties_to_even(T x, T y);

  template<class T>
    constexpr div_result<T> div_rem_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_even(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_even(T x, T y);
}
```

`div_rem_`関数の戻り値型の`div_result<T>`は商と剰余の値を同時に保持している集成体型です。

```cpp
namespace std {
  template<class T>
  struct div_result {
    T quotient;
    T remainder;

    friend auto operator<=>(const div_result&, const div_result&) = default;
  };
}
```

非常にたくさんの関数がありますが、`div_`と`div_rem_`で変種は共通しており、それはすべて丸めモードの違いです。

- `to_zero`
    - ゼロ方向丸め
    - `/`と同じ動作
- `away_zero`
    - ゼロと逆方向への丸め
- `to_inf`
    - 正の無限大方向への丸め（切り上げ
- `to_neg_inf`
    - 負の無限大方向への丸め（切り捨て
- `to_odd`
    - 奇数丸め
- `to_even`
    - 偶数丸め
- `ties_to_zero`
    - 最近接丸め（最も近い整数への丸め
    - 最も近い整数が2つある場合はゼロ方向（絶対値の小さいほう）へ丸める
- `ties_away_zero`
    - 最近接丸め
    - 最も近い整数が2つある場合は絶対値の大きいほうへ丸める
- `ties_to_inf`
    - 最近接丸め
    - 最も近い整数が2つある場合は正の無限大方向（大きいほう）へ丸める
- `ties_to_neg_inf`
    - 最近接丸め
    - 最も近い整数が2つある場合は負の無限大方向（小さいほう）へ丸める
- `ties_to_odd`
    - 最近接丸め
    - 最も近い整数が2つある場合は奇数のほうへ丸める
- `ties_to_even`
    - 最近接丸め
    - 最も近い整数が2つある場合は偶数のほうへ丸める

これに加えて、除算の剰余を常に負の無限大方向へ丸める`std::mod()`も用意しています。

```cpp
namespace std{
  template<class T>
    constexpr T mod(T x, T y);
}
```

これは、剰余の符号が割る数と同じになり、モジュラー演算を意図するところで有効に使用できるため専用の関数として用意されています。

- [P3724 進行状況](https://github.com/cplusplus/papers/issues/2354)

### [P3725R0 Filter View Extensions for Input Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3725r0.pdf)

↓

### [P3725R1 Filter View Extensions for Input Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3725r1.pdf)

`views::filter`の問題点を軽減しようとする提案。

P3329R0で指摘されているように、`views::filter`には落とし穴がいくつかあります。

- [P3329R0 Healing the C++ Filter View - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3329R0-Healing-the-C-Filter-View)

この提案でもいくつか新しいサンプルが提供されていますが、この提案はそれらの問題を緩和しようとするものです。

ここでの変更は

- `filter_view`に`begin()/end()`の`const`オーバーロードを追加
    - 使用可能なのは、入力範囲（`const`化したもの）が`input_range`でしかない場合
- `views::filter`の入力範囲が`input_range`でしかない場合は、フィルタ結果要素の変更を許可する
    - 現在は未定義動作
- `views::input_filter`アダプタの追加
    - 入力範囲に`views::to_input`を適用して使用する`views::filter`
    - 他の変更と合わせて、`input_range`にしかならないことで要素の変更（ムーブ）を許可するなど、既知の問題を緩和する

などです。

提案文書より、サンプルコード

```cpp
auto large = [](const auto& s) { return s.size() > 5; }; 
auto sub = coll1 | std::views::filter(large) 
                 | std::views::reverse 
                 | std::views::as_rvalue 
                 | std::ranges::to<std::vector>(); 
```

このコードは、`as_rvalue`によってフィルタ後要素をムーブしていることによって未定義動作となっています。実装が同じフィルタ後イテレータを2回以上間接参照したりすると問題が起こります。

```cpp
auto large = [](const auto& s) { return s.size() > 5; }; 
auto sub = coll1 | std::views::input_filter(large) 
                 | std::views::reverse 
                 | std::views::as_rvalue 
                 | std::ranges::to<std::vector>();  // コンパイルエラー
```

`views::filter`を使用したままではこの提案でもこの問題は緩和されませんが、`views::input_filter`を使用する場合コンパイルエラーとして問題が報告されるようになります。

```cpp
void constIterate(const auto& coll);  // 引数をconstで受ける

std::vector<std::string> coll3{"Amsterdam", "Berlin", "Cologne", "LA"};

auto large = [](const auto& s) { return s.size() > 5; };
constIterate(coll3 | std::views::filter(large));  // コンパイルエラー
```

現在の`views::filter`はconst-iterableではないためエラーになりますが、`views::input_filter`を使用することで使用できるようになります。

SG9のレビューにおいては大きな反対意見はなかったようで、LEWGに転送されることが投票で可決されています。

- [P3725 進行状況](https://github.com/cplusplus/papers/issues/2355)

### [P3726R0 Adjustments to Union Lifetime Rules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3726r0.html)
### [P3727R0 Update Annex E based on Unicode 15.1 UAX #31](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3727r0.pdf)

C++標準文書のAnnex E（UAX31への参照）の記述ををUnicode 15.1に合わせて更新する提案。

背景等はP3717R0を参照

- [P3717R0 Update Annex E onto Unicode 16 - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3717R0-Update-Annex-E-onto-Unicode-16)

この提案では、P3717とは異なり、Unicode 16ではなくUnicode 15.1でのUAX31の形式に合わせて更新しようとしています。主な変更はP3717同様に「UAX31-R1a Restricted Format Characters」に関する記述を削除することで、こちらの提案は[CWG Issue 2843](https://cplusplus.github.io/CWG/issues/2843.html)の解決のみを（Unicode 15.1で）行うことを意図したものの様です。

SG16などでのレビューの結果、結局[CWG Issue 2843](https://cplusplus.github.io/CWG/issues/2843.html)の変更を採用することになったようです。

- [CWG Issue 2843. Undated reference to Unicode makes C++ a moving target](https://cplusplus.github.io/CWG/issues/2843.html)
- [P3727 進行状況](https://github.com/cplusplus/papers/issues/2357)

### [P3729R0 Aligning span and string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3729r0.pdf)

`std::span`と`std::string_view`のインターフェース共通化を図る提案。

`std::span`と`std::string_view`はそれぞれ、配列/文字列のビューとなるクラスです。とはいえ、`std::string_view`が文字列に特化しているだけで、二つのクラスの実装はほぼ同じになり、その扱いや性質もかなり共通しています。

しかし、`std::span`と`std::string_view`は標準コンテナのインターフェースに準拠したインターフェースについては共通しているものの、それ以外の部分はそれほど共通のインターフェースにはなっていません。

この提案は、`std::span`と`std::string_view`からそれぞれにだけしかないインターフェースについて、特にサブセット化APIの共通化を行おうとするものです。

提案するインターフェースの追加は次のようになります

```cpp
template<typename charT, typename traits = char_traits<charT>> 
struct basic_string_view { 
  ...

  // runtime subsetting: 
  constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view subview(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view first(size_type count) const; // この提案
  constexpr basic_string_view last(size_type count) const;  // この提案
  
  // in place shrinking: 
  constexpr void remove_prefix(size_type n); 
  constexpr void remove_suffix(size_type n); 

  ...
};

template<typename T, size_type E = dynamic_extent> 
struct span { 
  ...

  // compile-time subsetting: 
  template<size_t Offset, size_t Count = dynamic_extent> 
  constexpr span<T, /*see below*/> subspan() const; 
  template<size_t Count> 
  constexpr span<T, Count> first() const; 
  template<size_t Count> 
  constexpr span<T, Count> last() const; 

  // runtime subsetting: 
  constexpr span subspan(size_type pos = 0, size_type n = dynamic_extent) const; 
  constexpr span first(size_type count) const; 
  constexpr span last(size_type count) const; 

  // in place shrinking: 
  constexpr void remove_prefix(size_type n) requires(E == dynamic_extent); // この提案
  constexpr void remove_suffix(size_type n) requires(E == dynamic_extent); // この提案

  ...
};
```

すなわち、`std::span` -> `std::string_view`には

- `.first(n)` : 先頭`n`文字の`string_view`を返す
- `.last(n)` : 後ろ`n`文字の`string_view`を返す

が移植され、`std::string_view` -> `std::span`には

- `.remove_prefix(n)` : 先頭`n`要素の`span`を返す
- `.remove_suffix(n)` : 後ろ`n`要素の`span`を返す

が移植されます。

さらに、`std::string_view`に関する変更は`std::string`に対しても適用されます

```cpp
template<typename charT, typename traits = char_traits<charT>, typename Allocator = allocator<charT>> 
struct basic_string { 
  ...

  //runtime subsetting: 
  constexpr basic_string substr(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view<charT, traits> subview(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view<charT, traits> first(size_type count) const; // この提案
  constexpr basic_string_view<charT, traits> last(size_type count) const;  // この提案
  
  ...
};
```

`std::string_view v`、`std::span<T> p`、`std::string s`があるとして

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// removing leading elements 
v.remove_prefix(5); 
p = p.subspan(5); 
s.erase(s.begin(), s.begin() + 5); 

// removing trailing elements 
v.remove_suffix(3); 
p = p.subspan(0, p.size() - 3); 
s.erase(s.end() - 3, s.end());
```

</td>
<td valign="top">

```cpp
// removing leading elements 
v.remove_prefix(5); 
p.remove_prefix(5); 
//s.remove_prefix(5); 提案しない

// removing trailing elements 
v.remove_suffix(3); 
p.remove_suffix(3); 
//s.remove_suffix(3); 提案しない
```

</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// getting leading elements 
auto l4v = v.subview(0, 4);
auto l4p = p.first(4);
auto l4s = s.subview(0, 4);

// getting trailing elements 
auto t2v = v.subview(v.size() - 2);
auto t2p = p.last(2);
auto t2s = s.subview(s.size() - 2);
```

</td>
<td valign="top">

```cpp
// getting leading elements 
auto l4v = v.first(4);
auto l4p = p.first(4);
auto l4s = s.first(4);

// getting trailing elements 
auto t2v = v.last(2);
auto t2p = p.last(2);
auto t2s = s.last(2);
```

</td>
</tr>
</table>

- [P3729 進行状況](https://github.com/cplusplus/papers/issues/2358)

### [P3730R0 Slides for P3104R3 <../2025/p3104r3.html>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3730r0.html)
### [P3731R0 `#embed` Preprocessor Parameter Order](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3731r0.html)

`#embed`ディレクティブの引数指定について順番を指定するようにする提案。

`#embed`ディレクティブは読み込むバイナリリソースについて、読み込みの仕方などについてを指定する4つのオプションがあります。そのうち`limit`オプションは読み込むサイズを制限するものです。

```cpp
constexpr const unsigned char sound_signature[] = {
// a hypothetical resource
#embed <sdk/jump.wav> limit(2+2)
};
```

また、P3540で提案中のオプションとして`offset`があり、これは読み取るバイナリリソースの開始位置を指定するものです。

```cpp
constexpr const unsigned char truncated_sound_signature[] = {
// a hypothetical resource
#embed <sdk/jump.wav> offset(2) limit(2)
};
```

このオプションは排他的ではなく、同時に指定して効果を重複させることができます。その際、オプションの指定順には意味がなく、どのような順序で指定しても同じ動作をします。

しかし、（おそらくP3540の議論中に）このオプションの指定順序、特に`limit`と`offset`の順序が混乱をもたらす可能性があるとの指摘があったようです。その際寄せられた意見の中には、`limit`の後に`offset`を指定された場合にコンパイルエラーを出すべき、というものもあったようです。

この提案はそれを受けて、オプションの順番を規定するための文言を提供しようとするものです。ここでは、次の二種類の文言が用意されています

1. オプションの順番を規定し、違反をコンパイルエラーとする文言
2. オプションの順番を規定し、違反を警告とすることを推奨する文言

提案ではこの選択を委員会の決定に委ねています。

いずれの文言でも、ここで提案している順序付けは次のようなものです

- `offset`は`limit`の前
- `limit`は`if_empty, prefix, suffix`の前
- `limit`がない場合でも、`offset`は`if_empty, prefix, suffix`の前

`#embed`はC23で先んじて採択されているため、clang/gccの新しいものであれば実装済みです。さらにそこでは、実装定義のオプションとして`offset`オプション（`gnu::offset`/`clang::offset`）が実装されていますが、現在の`#embed`が意図するようにオプションの指定順によらず正しく動作しています。

- [P3540R1 #embed Parameter offset - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3540R1-embed-Parameter-offset)
- [#embedディレクティブ - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20220915/p1)
- [P3731 進行状況](https://github.com/cplusplus/papers/issues/2360)

### [P3732R0 Numeric Range Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3732r0.html)
### [P3733R0 More named universal character escapes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3733r0.html)
### [P3734R0 Not all predicates must be regular](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3734r0.html)
### [P3735R0 partial_sort_n, nth_element_n](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3735r0.html)
### [P3736R0 Slides against P2971R3 <../2025/p2971r3.pdf> - No implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3736r0.html)
### [P3737R0 std::array is a wrapper for an array!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3737r0.html)
### [P3738R0 Make std::make_from_tuple SFINAE friendly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3738r0.pdf)
### [P3739R0 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r0.html)
### [P3739R1 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r1.html)
### [P3740R0 Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3740r0.html)
### [P3740R1 Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3740r1.html)
### [P3741R0 views::set_operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3741r0.html)
### [P3742R0 C++ Standard Library Ready Issues to be moved in Sofia, Jun. 2025](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3742r0.html)
### [P3745R0 Rebuttal to P1144R13 <../2025/p1144r13.html>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3745r0.pdf)
### [P3746R0 LEWG Slides for P3637R0 <../2025/p3637r0.pdf> Inherit std::meta::exception from std::exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3746r0.pdf)
### [P3747R0 Call side return type deduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3747r0.pdf)
### [P3748R0 Inspecting exception_ptr works should be constexpr.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3748r0.html)
### [P3749R0 Slides in response to P3655R2 <../2025/p3655r2.html> - Concerns regarding std::zstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3749r0.html)
### [P3752R0 Core Language Working Group "ready" Issues for the June, 2025 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3752r0.html)
### [P3753R0 Slides for P3740R0 <../2025/p3740r0.html> - Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3753r0.html)
### [P3753R1 Slides for P3740R1 <../2025/p3740r1.html> - Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3753r1.html)
### [P3754R0 Slides for P3100R2 <../2025/p3100r2.pdf> presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r0.pdf)
### [P3757R0 Remove value-type invocability requirement from indirect unary callable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3757r0.html)
### [P3760R0 Presentation: constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3760r0.pdf)
### [P3763R0 Remove redundant reserve_hint members from view classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3763r0.html)
### [P3764R0 A utility function for propagating the most significant bit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3764r0.html)
### [P3765R0 Deprecate implicit conversion from bool to character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3765r0.html)
### [P3769R0 Clarification of placement new deallocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3769r0.html)
### [P3771R0 constexpr mutex, locks, and condition variable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3771r0.html)
### [P3772R0 std::simd overloads for bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3772r0.html)
### [P3774R0 Rename std::nontype, and make it broadly useful](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3774r0.html)
### [P3778R0 Fixing type_order template definition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3778r0.html)
### [P3780R0 Detecting bitwise trivially relocatable types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3780r0.html)
### [P3781R0 is_*_type should imply is_type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3781r0.html)
### [P3784R0 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r0.pdf)
### [P3785R0 Library Wording Changes for Defaulted Postfix Increment and Decrement Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3785r0.html)
### [P3787R0 Adjoints to "Enabling list-initialization for algorithms": uninitialized_fill](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3787r0.html)
### [P3788R0 Fixing std::complex binary operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3788r0.html)
### [P3790R0 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r0.pdf)
### [P3791R0 constexpr deterministic random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3791r0.html)
### [P3792R0 Why constant_wrapper is not a usable replacement for nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3792r0.html)
### [P3793R0 Better shifting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3793r0.html)
### [P3794R0 An idea or two on renaming the nontype tag](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3794r0.html)
### [P3795R0 Miscellaneous Reflection Cleanup](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3795r0.html)
### [P3796R0 Coroutine Task Issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3796r0.html)
### [P3798R0 The unexpected in std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3798r0.html)
### [P3799R0 2025-07 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3799r0.html)
### [P3801R0 Concerns about the design of std::execution::task](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3801r0.html)
### [P3802R0 Poor Functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3802r0.pdf)
