# ［C++］WG21月次提案文書を眺める（2024年10月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-10)

全部で151本あります。

もくじ

[:contents]

### [N4991 2025 Sofia Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4991.pdf)

2025年6月16～21日にかけてブルガリアのソフィアで行われる予定の、WG21ミーティングのインフォメーション。

### [N4993 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4993.pdf)

C++26のワーキングドラフト第6弾

### [N4994 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4994.html)

↑の変更点をまとめた文書。

### [P0260R11 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r11.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)
- [P0260R9 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P0260R9-C-Concurrent-Queues)
- [P0260R9 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P0260R10-C-Concurrent-Queues)

このリビジョンでの変更は

- St. Louis会議におけるLEWG/SG1からのフィードバックを実装
- コンセプトを説明専用にする
- 非同期操作は、操作の`receiver`の`scheduler`で実行することを要求する
- キューがcloseの場合は、非同期操作に対して`set_error`を呼び出す
- R9で誤って削除されていた、data-race freenessを復帰
- `bounded_queue`にsequential constistentセマンティクスを要求する
- experimental leftoversを削除

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0707R5 Metaclass functions for generative C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0707r5.pdf)

リフレクション機能をベースとした、メタクラスの提案。

P2996R5（とP3294R1）ではコード要素のクエリとコード生成の両面から静的リフレクションの基本機能が整備されつつあります。そこでは、型のプロトタイプを作成してそれをベースに別の型をつくる、といったことが既に可能になっています。

```cpp
// __prototype::widgetをベースにwidget型を生成する例
namespace __prototype { class widget { /*...*/ }; } 
consteval{ metafunc( ^^__prototype::widget ); } 
```

ここでの`metafunc`は指定された型（のリフレクション）をベースに追加の指定を加えたうえで改めて`widget`型の宣言を生成するようなメタ関数です。この提案では、このようなクラスの基本定義や制約をベースとしたクラス型そのものを構築するメタクラス機能を、この構文の構文糖として提供しようとするものです。

提案するメタクラス機能によって、上記コードは次のように簡潔に書くことができるようになります

```cpp
// metafuncの指定する制約等によって、widget型を生成する
class(metafunc) widget{ /*...*/ }; 
```

これによるメリットは次のようなものです

- 単なるクラスではなく特定の種類のクラスを書いている、という意図をより直接的に表現している
- プロトタイプ型（最初の例の`__prototype::widget`）が不要になる

より具体的な例としては、インターフェースクラスの定義があります。インターフェースクラスの定義にはボイラープレートが多くあります。たとえば

```cpp
// IFooインターフェースの手動定義
class IFoo { 
public: 
  virtual int f() = 0; 
  virtual void g(std::string) = 0; 
  virtual ~IFoo() = default; 
  IFoo() = default; 
  IFoo(IFoo const&) = delete; 
  void operator=(IFoo const&) = delete; 
};
```

インターフェース独自の関数のシグネチャ宣言を除いて、他のすべての部分はボイラープレートコードです。この手のボイラープレートコードを削減するのにリフレクションは非常に効力を発揮します。P2996R5とP3294R1でこのような同じ`IFoo`インターフェースを定義するコードは次のようになります

```cpp
namespace __proto { 
  class IFoo { 
    int  f(); 
    void g(std::string); 
  }; 
}

consteval { interface(^^__proto::IFoo); }
```

`interface()`はこのために定義されたリフレクション関数ですが、これも含めてユーザー定義することができます。

（`widget`の例にはなりますが、すでにCompiler Explorerで動作するリンクがあります: [godbolt](https://godbolt.org/z/rvdabTb5M)）

この提案のメタクラス機能でこの`IFoo`インターフェース定義を書き直すと、次のようになります

```cpp
class(interface) IFoo { 
  int  f(); 
  void g(std::string); 
};
```

よりシンプルであり、制約を表すメタ関数名によって宣言的になっています。

なお、提案しているメタクラス構文では`class(...)`のかっこの中にカンマ区切りで複数の関数を指定できます。これにより、複数の制約によるクラス定義生成が可能です

```cpp
class(xxx, yyy, zzz) Widget { /*...*/ };
```

元々この提案は、リフレクション機能の部分も含めた機能としてのメタクラスの機能を提案していましたが、それはP2996R5とP3294R1でほぼ達成されているので、この提案ではそれらのリフレクションの上に構築するメタクラス機能を提案するようになっています。結果、この提案では次の2つのことのみを提案しています

- クラス構文: `class(xxx,yyy)`
- 制約を表す`consteval`ライブラリ関数群（こちらの事をメタクラスと呼んでいる）
    - `interface`: 純粋仮想関数のみを持つ抽象クラス型
    - `polymorphic_base`: コピーもムーブもできず、デストラクタが public + virtual または protected + 非仮想である純粋なポリモーフィック基底型
    - `ordered`: 全順序で順序付け可能な型であり、`strong_ordering`となる`operator<=>`を持つ
        - 他に: `weakly_ordered、partially_ordered`
    - `copyable`: コピー/ムーブ コンストラクタ/代入演算子を持つ型
    - `basic_value`: `copyable`であり、デフォルト構築可能かつデフォルトデストラクタを持ち、`protected`や`virtual`な関数を持たない
    - `value`: `ordered`かつ`basic_value`
    - `struct`: `public`なメンバだけを持つ`basic_value`。仮想関数やカスタム代入演算子を持たない
    - `enum`: 全てのメンバが`publidecであり、``ordered`かつ`basic_value`である
    - `flag_enum`: `enum`であり、各メンバはビット単位のsets/testが可能
    - `union`: 安全なタグ付き共用体
    - `regex`: リフレクション機能を用いた、CRTEスタイルのコンパイル時正規表現型
    - `print`: リフレクションをソースコードとしてコンパイル時に出力する

ただし、ライブラリ関数群は将来の提案としています。

この提案による別の恩恵として、特殊な型を追加したい場合に言語機能ではなくライブラリ機能として追加できるようになることがあります（例えば、`enum class`などのような）。それにより、コア言語で標準化するには動機づけが弱いような型（影響範囲がごく小さいなど）をごく小さい変更でライブラリ機能として追加できるようになる可能性が開けます。また同時に、そのような特殊な型をユーザーが簡単に定義できるようになります。

- [P0707 進行状況](https://github.com/cplusplus/papers/issues/403)

### [P0876R18 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0876r18.pdf)
### [P1144R12 `std::is_trivially_relocatable`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r12.html)

オブジェクトの再配置（*relocation*）という操作を定義し、それをサポートするための基盤を整える提案。

以前の記事を参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R7 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年04月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P1144R7-stdis_trivially_relocatable)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P1144R9 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P1144R9-stdis_trivially_relocatable)
- [P1144R10 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P1144R10-stdis_trivially_relocatable)
- [P1144R11 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P1144R11-stdis_trivially_relocatable)

このリビジョンでの変更は

- proseセクションの書き直し
- 文言に不足していた前方宣言を追加
- P2422を受けて、`relocate(T*)`から`[[nodiscard]]`を削除
- [concept.relocatable]の修正
    - `u2`はオーバーラップする可能性のあるサブオブジェクトであってはならない
- [uninitialized.relocate]と[specialized.relocate]の更新
    - "side effects might not happen,"から "do not happen"へ書き換え
    - memmove最適化が必須になった
      - これにより、trivially relocatableな型の`relocate`が例外を送出しない事が保証される

などです。

- [P1144 進行状況](https://github.com/cplusplus/papers/issues/43)

### [P1255R14 A view of 0 or 1 elements: views::nullable And a concept to constrain maybes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1255r14.pdf)

任意のオブジェクトや`std::optional`等のmaybeモナドな対象を要素数0か1のシーケンスに変換するRangeアダプタ`views::maybe`/`views::nullable`の提案。

以前の記事を参照

- [P1255R6 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R7 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1255R7-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R8 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P1255R8-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R9 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P1255R9-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R10 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P1255R10-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R12 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P1255R12-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R13 A view of 0 or 1 elements: views::nullable And a concept to constrain maybes - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P1255R13-A-view-of-0-or-1-elements-viewsnullable-And-a-concept-to-constrain-maybes)

このリビジョンでの変更は、提案するフリー関数の文言を追加したことです。

- [P1255 進行状況](https://github.com/cplusplus/papers/issues/60)

### [P1306R3 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1306r3.pdf)

コンパイル時にステートメントをループ生成することのできる、展開ステートメントの提案。

以前の記事を参照

- [P1306R2 Expansion statements - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P1306R2-Expansion-statements)

このリビジョンでの変更は

- `range`の展開は定数式に限ることを要求
- `break`/`continue`による制御フローのサポートを追加

などです。

`break`/`continue`は`template for`内部の生成コードで使用可能になるということではなく、`template for`による展開ループの展開後のコードに対して作用します。`break`は最後の展開の直後にジャンプし、`continue`は次の展開（ある場合）の先頭にジャンプします。

```cpp
template for (auto v : {1,2,3,4,5,6,7,8,9}) {
  if (v % 2 == 0) continue;
  std::println("v: {} ", v);
  if (v % 5 == 0) break;
}
```

このコードのコンパイル結果は、実行すると次のような出力を行うコードを生成します

```
v: 1
v: 3
v: 5
```

少しイメージしづらいですが、`template for`内の`break`/`continue`は展開を行うループ（実際にループしているわけではないが）をスキップするのではなく、展開後の各展開要素の前後に対してジャンプするものです。`goto`を使って無理やり書くと上記のコードは次のような展開結果を生成します

```cpp
{
  {
    if (1 % 2 == 0) goto expansion_1;
    std::println("v: {} ", 1);
    if (1 % 5 == 0) goto template_for_end;
  }
expansion_1:
  {
    if (2 % 2 == 0) goto expansion_2;
    std::println("v: {} ", 2);
    if (2 % 5 == 0) goto template_for_end;
  }
expansion_2:
  {
    if (3 % 2 == 0) goto expansion_3;
    std::println("v: {} ", 3);
    if (3 % 5 == 0) goto template_for_end;
  }
expansion_3:
  {
    if (4 % 2 == 0) goto expansion_4;
    std::println("v: {} ", 4);
    if (4 % 5 == 0) goto template_for_end;
  }
expansion_4:
  {
    if (5 % 2 == 0) goto expansion_5;
    std::println("v: {} ", 5);
    if (5 % 5 == 0) goto template_for_end;
  }

expansion_5:
  // 以下略
  {
    ...
  }
  ...

template_for_end:
}
```

当然、実際に`goto`が使用されるわけではありません。

この提案は、2025年1月の全体会議で採択され、C++26に導入されています。

- [Expansion statement for C++ - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20250228/p1)
- [P1306 進行状況](https://github.com/cplusplus/papers/issues/156)

### [P1494R4 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1494r4.html)

因果関係を逆転するような過度な最適化を防止するためのバリアである`std::observable()`の提案。

以前の記事を参照

- [P1494R2 Partial program correctness - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1494R2-Partial-program-correctness)
- [P1494R3 Partial program correctness - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P1494R3-Partial-program-correctness)

このリビジョンでの変更は

- I/Oは自動的にobservable checkpointになる
- 不足しているerroneous behaviorコンテキストを追加
- 古い記述の削除
- 文書の簡素化、明確化、修正

などです。

- [P1494 進行状況](https://github.com/cplusplus/papers/issues/376)

### [P1708R9 Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1708r9.pdf)
### [P1729R5 Text Parsing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1729r5.html)
### [P1839R6 Accessing object representations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1839r6.html)
### [P1928R12 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r12.pdf)
### [P2079R5 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2079r5.html)
### [P2319R2 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r2.html)
### [P2392R3 Pattern matching using is and as](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2392r3.pdf)
### [P2434R2 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r2.html)
### [P2645R0 `path_view`: a design that took a wrong turn](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2645r0.html)

提案中の`path_view`の問題点を指摘する提案。

`path_view`は`std::filesystem::path`の`view`（`std::string`に対する`std::string_view`のようなクラス）となるクラス型です。この型は目下P1030で提案され議論中です。この提案は、その現在の設計について、今のまま標準化してしまうと過去の設計の失敗が永続化し修正不可能になるとして、問題点を指摘するものです。

具体的な問題点とは

1. エンコーディングの問題
    - パス文字列のエンコーディングを採用し、内部表現にも使用している。これは`filesystem::path`とすら互換性が無い
    - P2319の提案では（主にwindowsの）コードページに依存する問題のあるAPIを削除しているが、`path_view`は逆の事を行っている
    - これにより、`std::format/std::print`などとの相互運用が困難になる
2. 実装と使用の経験の不足
    - リファレンス実装には、提案されている新しいオーバーロードの多くが未実装
      - かつ、提案ではそれらの関数に対する文言が欠けている
3. パフォーマンスの問題
    - `path_view`を取るオーバーロードはオプトインしなければ使用可能ではないため、パフォーマンスの恩恵をそのままでは得られない
    - 遅延transcodingによって、複数回の呼び出しを行う場合にパフォーマンスへの影響が大きい
4. フォーマットと出力の問題
    - `path_view`はフォーマッタを提供していない
    - その設計によって、その実装には困難がある
        - `path_view`は異なるエンコーディングによる複数の表現を使用しうるため、`path_view`がどのエンコーディングで構築されたのかを知る方法がない
        - `path_view`のバイナリ表現についての仕様が不十分であり、1つの実装内でもラウンドトリップが困難
5. 複雑さ
    - 提案では、`std::filesystem::path`を受け取る既存の関数に対して、`path-view-like`を受け取るオーバーロードを追加するため、APIの数を単純に2倍にする
    - `path_view`は`filesystem::path`を構築できるものの直和的な型であり、`view`ではない

などを挙げており、これらの問題が解決されるまでは標準化すべきではない、としています。

- [P2645 進行状況](https://github.com/cplusplus/papers/issues/2056)

### [P2664R8 Proposal to extend std::simd with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2664r8.html)
### [P2688R3 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r3.html)
### [P2719R1 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2719r1.html)
### [P2728R7 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2728r7.html)
### [P2746R6 Deprecate and Replace Fenv Rounding Modes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2746r6.pdf)
### [P2769R3 get_element customization point object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2769r3.html)
### [P2786R8 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r8.pdf)
### [P2841R5 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r5.pdf)
### [P2846R4 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r4.pdf)
### [P2900R9 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r9.pdf)
### [P2900R10 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r10.pdf)
### [P2933R2 std::simd overloads for <bit> header](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2933r2.html)
### [P2957R2 Contracts and coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2957r2.html)
### [P2977R2 Build database files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2977r2.html)
### [P2988R8 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r8.pdf)
### [P2996R6 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r6.html)
### [P2996R7 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r7.html)
### [P2998R0 CTAD for function parameter types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2998r0.html)

関数テンプレートの呼び出し時の実引数推論において、CTADを利用した追加の候補を考慮するようにする提案。

関数テンプレートは一見、そのテンプレートパラメータの可能な置換のすべての候補からなるオーバーロードの集合の様に動作しますが、その呼び出しにおいては直接の引数と関数テンプレートの宣言に基づいて最も適切な置換を求めるためのルールに従って呼び出しが決定されており、関数テンプレートの呼び出し候補はかなり制限されています。

これにより、オーバーロードの検索範囲を狭め、意図しないテンプレートが選択されるのを防止していますが、そのルールにおいては型の変換がほとんど考慮されないことで、有用な使用例が制限されています。

```cpp
#include <span>
#include <vector>

template <typename T>
void f(const T&);

template <typename T>
void g(const std::vector<T>&);

template <typename T>
void h(std::span<T>);

void example() {
  std::vector<int> v;

  f(v); // OK, Tはstd::vector<int>に推論される
  g(v); // OK, Tはintに推論される
  h(v); // error: Tを推論できない
}
```

例えばこの例では、`std::span`に関する事前知識があれば`h()`の呼び出しは良い一致となることが分かりますが、現在のルールの下では`std::vector<int>`から`std::span<T>`を推論できないため、この一致が確立されることはなく、コンパイルエラーになります。

しかし、言語の他のところでは、このような変換を考慮した推論が成功する場所があります

```cpp
#include <span>
#include <vector>

std::vector<int> v;
std::span s = v; // OK, CIADによってsはstd::span<int, std::dynamic_extent>に推論
```

CTADのメカニズムを再利用するとともに、関数テンプレートのオーバーロード解決のルールに組み込むことによって、関数テンプレートの呼び出しにおいてもこのような推論を有効化することができ、それにより言語の一貫性も高まるとして、関数テンプレートのテンプレート引数推論においてCTADを利用した候補を考慮するようにしようとする提案です。

メカニズムとしては、関数テンプレートの引数型からエイリアステンプレートを生成し、そのエイリアステンプレートの名前を型名（プレースホルダ）、関数テンプレート呼び出しの実引数を初期化子として宣言された変数の初期化を通してCTADを実行し、エイリアステンプレートのテンプレートパラメータとして推論される型を元の関数テンプレートのテンプレートパラメータとして取得することで関数テンプレートのテンプレートパラメータ推論を実行します。

例えば次のような関数テンプレート宣言と呼び出しがある時

```cpp
template <typename V>
void f(std::tuple<std::string_view, V>);

void example() {
  std::pair<std::string, int> p = { "hello", 5 };
  
  f(p); // 現在は推論に失敗する
}
```

この`f()`の引数型とテンプレートパラメータをもちいてエイリアステンプレートを作成し

```cpp
// 仮説のエイリアステンプレート
template <typename V>
using A = std::tuple<std::string_view, V>;
```

このエイリアステンプレートを用いてCTADが実行される形の変数初期化宣言を作成し

```cpp
A x = p; // A deduced as A<int> (i.e. std::tuple<std::string_view, int>)
```

この宣言に対して行われるCTADの結果として得られる`A<int>`というテンプレートパラメータ推論結果から、元の関数テンプレートで対応するテンプレートパラメータをフィードバックすることで、`f(p);`の呼び出しからそのテンプレートパラメータは`f<int>()`に推論されます。

```cpp
f(p); // OK, Vはintに推論される
```

提案文書より、`std::span`の例

```cpp
#include <span>
#include <vector>

template <typename T>
void f(std::span<T>);

template <typename T>
void g(const std::vector<T>&);

void example() {
  int x[] = { 1, 2, 3, 4, 5 };

  f(x); // 以前はill-formed、この提案ではTはintに推論される
  g({ 1, 2, 3, 4, 5 }); // 以前はill-formed、この提案ではTはintに推論される
}
```

ただし、この提案はCTADの様な推論を関数呼び出し時にその引数型（のプレースホルダ型）に対して行うことを提案するものではありません。

```cpp
void f(std::pair p); // このような宣言を有効化することを提案しているわけではない
```

単純にCTADを利用するだけだとCTADの事情によってエラーとなるケースがあります

```cpp
template <typename T>
void copy(std::span<const T> from, std::span<T> to);

void example(std::span<const int> src1, std::span<int> src2) {
  int dst[5];

  copy(src1, dst); // OK
  copy(src2, dst); // error: Tをsrc2から推論できない
}
```

この問題は、`std::span<const T>`のエイリアステンプレートに対して使用される推論補助のテンプレートパラメータの`const`有無が一致しないことから起きており、エイリアステンプレートをべた書きした時でも起こります

```cpp
#include <span>

template <typename ElementType, std::size_t Extent = std::dynamic_extent>
using const_span = std::span<const ElementType, Extent>;

std::span<int> x;
const_span<int> y = x; // OK
const_span z = x; // error: std::span<int, std::dynamic_extent>からのconst_spanの推論補助が一致するものがない
```

この場合に`const_span`に対して生成される推論補助を見てみると

```cpp
// span<const T>を期待
template <typename ElementType, std::size_t Extent>
  const_span(const std::span<const ElementType, Extent>&) -> std::span<const ElementType, Extent>
    requires deduces-const-span<std::span<const ElementType, Extent>>;

// 戻り値型が推論可能制約を満たさない
template <std::ranges::contiguous_range R>
  const_span(R&&) -> std::span<std::remove_reference_t<std::ranges::range_reference_t<R>>>
    requires deduces-const-span<std::span<std::remove_reference_t<std::ranges::range_reference_t<R>>>>;
```

`deduces-const-span`は`const_span`のテンプレート引数が型引数から推論可能であることを要求する制約です。1つ目の候補は`x`が`span<int>`であるのに対して`span<const int>`を期待しているため失敗し、2つ目の候補は`std::span<int>`が`const_span`の特殊化として表現できないため制約を満たさず失敗します。したがって、使用可能な推論補助が無く、CTADも失敗します。

この問題はエイリアステンプレートに対して推論補助を指定できるようにすることで解決することができるため、この提案ではこれも一緒に提案しています

```cpp
template <typename ElementType, std::size_t Extent>
const_span(const std::span<ElementType, Extent>&) -> const_span<ElementType, Extent>;

void example() {
  std::span<int> x;

  const_span z = x; // ok、追加した推論補助が使用される
}

template <typename T>
void copy(const_span<T> from, std::span<T> to);

void example(std::span<const int> src1, std::span<int> src2) {
  int dst[5];

  copy(src1, dst); // OK
  copy(src2, dst); // OK
}
```

ただしこの提案は後方互換性に影響を与えないものではありません

```cpp
template <typename T>
struct X {};

template <typename T>
struct Y
{
    Y(X<T>);
};

template <typename T>
void f(X<T>, float); // #1

template <typename T>
void f(Y<T>, int); // #2

f(X<short>(), 5); // 以前はok、#1が選択されていた。この提案後曖昧になる
```

このようなコードは現在、`X<short>()`から`Y<T>`を推論できないため#2が選ばれることがない一方で、`X<T>`は推論可能であるため#1が選択され、エラーはありません。しかし、この提案の後では、`X<short>()`から`Y<T>`を推論できるようになる（CTADによってコンストラクタを用いた推論補助が生成され、それによってTを推論可能になる）ため、#1も#2もマッチしてしまい、曖昧になります。

- [P2998 進行状況](https://github.com/cplusplus/papers/issues/2057)

### [P3019R10 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r10.html)
### [P3045R2 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r2.html)
### [P3045R3 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r3.html)
### [P3049R1 node-handles for lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3049r1.pdf)
### [P3070R1 Formatting enums](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3070r1.html)
### [P3081R0 Core safety Profiles: Specification, adoptability, and impact](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3081r0.pdf)
### [P3091R3 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r3.html)
### [P3094R4 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r4.html)
### [P3094R5 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r5.html)
### [P3098R0 Contracts for C++: Postcondition captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3098r0.pdf)

契約プログラミング機能の事後条件構文において、値のキャプチャができるようにする提案。

P2900R8の契約プログラミング機能の事後条件からは、関数が呼び出された時点の古い値を参照することができません。これによって、コンテナの`push_back()`のような関数の制約のように、その関数で変更される前の値を参照する必要のある事後条件を記述することができません。この提案は、関数の事後条件においてその関数が呼び出された時点の値をキャプチャしておいて参照することができるようにしようとするものです。

```cpp
// コンテナのpush_back()の事後条件の記述の例
void push_back(T&&)
  post [old_size = size()] (size() == old_size + 1);
```

この例のようにキャプチャの構文はラムダ式のものを踏襲していますが、そのセマンティクスはかなり異なっており、より契約プログラミング機能に合わせたものになっています。

まず許可されるキャプチャの種類は、初期化キャプチャと明示的なコピーキャプチャのみです。デフォルトキャプチャや参照キャプチャは許可されません。

```cpp
// ✅ 明示的なコピーキャプチャ
int min(int x, int y)
  post [x, y] (r: r <= x && r <= y);

// ✅ ↑と等価な初期化キャプチャ
int min(int x, int y)
  post [x=x, y=y] (r: r <= x && r <= y)

// ❌ デフォルトキャプチャ
int min(int x, int y)
  post [=] (r: r <= x && r <= y);

// ❌ 参照キャプチャ
int min(int x, int y)
  post [&x, &y] (r: r <= x && r <= y);
   
// ✅ 初期化キャプチャによる参照キャプチャ
int min(int x, int y)
  post [&x=x, &y=y] (r: r <= x && r <= y)
```

また、`this`のキャプチャは効果が無く（メンバ関数の事後条件からはそのクラスのメンバにアクセス可能であるため）、`*this`のキャプチャ（`this`オブジェクト全体のコピー）は有効です。

キャプチャを行える契約注釈は事後条件（`post`）のみで、事前条件とアサーションにおいては許可されません。

このような事後条件におけるキャプチャのタイミングは事前条件が全て評価された後となります。

```cpp
int f(int x)
  post [x] (r: r != x)  // xのキャプチャはpre()の評価の後
  pre (x > 0);
```

キャプチャが複数ある場合に、それが構築される順番と破棄される順番、すなわちキャプチャのライフタイムにはいくつかのオプションがあります。例えば次のようなコードにおいて

```cpp
void f()
  post [a = get_a(), b = get_b()] (a == b) #1
  post [c = get_c(), d = get_d()] (c == d); #2
```

キャプチャの構築と破棄、述語評価のタイミングは

1. `a, b, c, d`の順で構築、`f()`の本体を実行、#1の評価、#2の評価、`d, b, c, a`の順で破棄
2. `c, d, a, b`の順で構築、`f()`の本体を実行、#1の評価、`b, a`の順で破棄、#2の評価、`d, c`の順で破棄
3. `a, b, c, d`の順で構築、`f()`の本体を実行、#2の評価、`d, cの順で破棄、`#1の評価、`b, a`の順で破棄

この3つのオプションにはトレードオフがあります

| 項目 | オプション1 | オプション2 | オプション3 |
| :--- | :--- | :--- | :--- |
| 事後条件の評価順序 | **宣言された順** | **宣言された順** | 逆順 |
| キャプチャの構築順序 | **宣言された順** | 宣言された順ではない | **宣言された順** |
| キャプチャの破棄タイミング | 全ての事後条件評価後 | **使用直後** | **使用直後** |
| Procedural interfaceへのマッピング | ❌ | ✅ | ✅ |
| ↑のマッピングでの事後条件の順序保持 | ❌| ❌| ✅ |
| 実装上の懸念 | ❌ | ✅ | ✅ |
| P2900の変更 | **不要** | **不要** | 必要 |

この提案では、オプション2を推奨しています。

ラムダ式とも、契約述語の他の部分とも異なり、事後条件でキャプチャされたものは非`const`となります。

```cpp
void increment (Iterator& iter)
  post [iter_old = iter] (++iter_old == iter); // ✅
```

これは、事後条件におけるキャプチャが完全にローカルなもの（変更を外部から観測できない）であり、述語を記述する以上その変更はより明白なものになるためです。

非メンバ関数の事後条件からコピーキャプチャできるのは関数引数のみです。

```cpp
namespace X {
  int i = 0;
  
  int f1() [i] post(r: r > i);      // ❌ 非ローカル変数iをキャプチャできない
  int f2(int j) [j] post(r: r > j); // ✅
};
```

これは、ラムダ式のセマンティクスを踏襲したものであると同時に、名前のシャドウィングの影響がグローバルな変数ではより大きくなるためです。

最後に、P2900R8ではコルーチンに対する事前・事後条件の指定が許可されたものの、事後条件からその引数を使用することが出来ません。これは、コルーチンの引数はコルーチンステートにすべてムーブされるためで、事後条件からの引数の使用を許可するとムーブ後状態を読み取る可能性があるためです。

この提案のキャプチャであれば、コルーチンの事後条件から引数を使用する場合に、コピーして使用するのか参照するのかを明示的に選択できるようになります。

```cpp
generator<int> sequence(int from, int to)
  pre (from <= to)
  post [from, to] (g : g.size() == to - from + 1);
  // 関数が呼び出された時の引数のコピーを参照

generator<int> sequence(int from, int to)
  pre (from <= to)
  post [&from=from, &to=to] (g : g.size() == to - from + 1);
  // 元の引数オブジェクトを参照（おそらく危険）
```

また、通常の関数のように事後条件から使用する関数引数を`const`にする必要もなくなります。

この提案は、最初の契約プログラミング機能に間に合わせることを望んでいますが、初期の機能セット（MVP）に必須ではないともしています。

- [P3098 進行状況](https://github.com/cplusplus/papers/issues/2059)

### [P3100R1 Undefined and erroneous behaviour are contract violations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3100r1.pdf)
### [P3125R1 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r1.html)
### [P3138R3 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r3.html)
### [P3149R6 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r6.html)
### [P3152R0 Add missing constructors and assignment for `indirect` and `polymorphic`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3152r0.html)

P3019で提案されている`indirect`と`polymorphic`に欠けているコンストラクタと代入演算子を追加する提案。

`indirect<T>`と`polymorphic<T>`はヒープ領域上に構築されたオブジェクトをその領域も含めて値のセマンティクスの下で扱うためのクラス型です。この提案では、それらの型に対する追加のコンストラクタと代入演算子を提案しています。

- コンストラクタ
    - 単一引数コンストラクタ
      - `std::optional`や`std::variant`が持つような、`T`そのものか`T`に変換可能な型を受け取る単一引数コンストラクタを追加する
      - `explicit`とし、アロケータ対応のものも追加する
    - Initializer-listを取るコンストラクタ
      - こちらも`std::optional`や`std::variant`と同様に、`std::initializer_list`を取るコンストラクタを追加する
      - `explicit`とし、アロケータ対応のものも追加する
- `indirect`にのみ、完全転送代入演算子を追加する
    - 単一引数コンストラクタの代入演算子版、受け取った一つの値を完全転送して内部の値に代入する
    - `polymorphic`は型消去を行っていることから、対応する代入演算子の存在が静的に分からないので追加しない

特に、2つ目の代入演算子については`indirect`の中身がムーブされた可能性がある場合の後で、中身が無い状態になった`indirect`オブジェクトに値を代入するコードを場合分けを必要とせずに書くことができるようになるメリットがあります。

```cpp
/// このようなコードを
indirect<int> i;
foo(i);  // iからムーブされうる

// *iが安全かどうかに応じて分岐する
if (!i.valueless_after_move()) {
  *i = 5;
} else {
  i = indirect(5);
}

/// こう書ける
indirect<int> i;
foo(i); // iからムーブされうる

i = 5;  // iの状態によらず新しい値を代入する
```

P3019とは個別にレビューできるようにするために、別の提案にしているようです。

- [P3019R0 Vocabulary Types for Composite Class Design - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P3019R0-Vocabulary-Types-for-Composite-Class-Design)
- [P3152 進行状況](https://github.com/cplusplus/papers/issues/2060)

### [P3160R2 An allocator-aware `inplace_vector`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3160r2.html)
### [P3179R3 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r3.html)
### [P3227R0 Contracts for C++: Fixing the contract violation handling API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3227r0.pdf)

契約違反ハンドラが呼び出されている状況をより詳細に取得するためのAPIを追加する提案。

無視あるいは即時終了以外のセマンティクスによって契約注釈が評価され、契約違反が起きた時、あるいは条件式が例外を送出したとき、契約違反ハンドラが呼び出されます。違反ハンドラには`contract_violation`型のオブジェクトが渡され、ここから違反に関する情報を得ることができます。違反ハンドラはユーザが置き換えることもできて、契約違反に伴う処理をカスタマイズすることができます。

ユーザ定義違反ハンドラの場合、違反ハンドラの呼び出され方やその状況に応じて、次の2つの事を判定したい場合があります

1. 違反ハンドラの呼び出しが正常にリターンした場合、契約違反処理メカニズムはプログラムを終了しようとするかどうか
    - もしプログラムが終了されようとしていてそれが望ましくない場合、例外を送出することによって違反処理メカニズムから脱出することができる
2. 違反ハンドラはなぜ呼び出されたのか？（条件が`false`になったのか、条件式が例外を送出したのか？
    - 例外が送出されていた場合、その例外を取得して処理/再送出する必要がある

現在のMVP仕様（P2900R8）ではこのようなクエリが可能なようにすることを意図されているものの、現在のAPIでは実際には可能になっていません。この提案は、違反ハンドラの引数である`contract_violation`型のオブジェクトを通してこれらの事をクエリできるようにすることを提案するものです。

#### 終了セマンティクスの検出

現在でも、`semantic()`メンバ関数から違反ハンドラの呼び出された元の契約注釈のセマンティクスを取得する事はでき、これは`evaluation_semantic`列挙型の値を返します

```cpp
enum class evaluation_semantic : unspecified {
  enforce = 1,
  observe = 2,
  // additional implementation-defined enumerators
};
```

標準の4つのセマンティクスを全て網羅していないのに加えて、仕様では契約注釈のセマンティクスとして実装定義のものを許可しています。したがって、この列挙型の値によって違反ハンドラリターン後のプログラムが終了するかどうかを判断できるのは、実装が追加のセマンティクスを提供していない場合に限ります。そして、実装が追加のセマンティクスを提供する場合、そのセマンティクスが違反ハンドラのリターン後にプログラムを終了するのかどうかを取得する移植可能な方法はありません。

```cpp
void handle_contract_violation(const& contract_violation) {
  // 実装定義のセマンティクスで呼ばれている場合、このチェックだけでは不十分
  if (violation.semantic() == evaluation_semantic::enforce) {
    throw DoNotTerminate();
  }

  // ここに来ているときでもこの後でプログラムを終了する可能性がある
}
```

実装定義の契約違反セマンティクスは必ずしもコンパイラの拡張だけで提供されるものではなく、MVP仕様は各種サニタイザーをはじめとする外部のツールが違反ハンドラを利用することを織り込んでおり、この場合違反ハンドラの呼び出しセマンティクスはリンク時に決定されます。

したがって、`semantic()`から得られる列挙値だけから違反ハンドラ後のプログラムの状態を知ることはできないため、この提案ではそれを専用にクエリする`bool`値関数`is_terminating()`を提案しています。

```cpp
// 使用例
void handle_contract_violation(const& contract_violation violation) {
  if (violation.is_terminating()) {
    // プログラム終了を回避する
    throw DoNotTerminate();
  }

  // ここに来ている場合、このままリターンしてもプログラムは継続される
}
```

この関数は、現在の契約評価セマンティクスが違反ハンドラがリターンした後にプログラムを終了する場合に`true`を返す関数です（このようなセマンティクスをterminating semanticと呼んでいる）。標準の中だと`enforce`セマンティクスが該当するほか、サニタイザーが違反ハンドラを利用する場合はこの関数が`true`を返すような`contract_violation`オブジェクトを渡す必要があります。

#### 条件式からの例外の処理

現在のMVP仕様では、違反ハンドラの呼び出しが契約条件式の評価時に送出された例外によるものかどうかを判断し、その例外を処理するために次のような呪文コードを記述する必要があります

```cpp
void handle_contract_violation (contract_violation& violation) {
  if (violation.detection_mode() == detection_mode::evaluation_exception) {
    my::handle(std::current_exception());
  }
}
```

名前空間を省略しないようにするとさらに長くなります。

`std::current_exception()`を無条件で呼び出すことでこれを効率的に実行できると考えるかもしれませんが、契約条件の評価は`catch`節でも行われる可能性があるため（特に`contract_assert()`）、無関係の例外オブジェクトを取得してしまう可能性があります。

この現在のAPIはユーザーエクスペリエンスが著しく低いため、違反ハンドラ内でその契約条件の評価に関する例外オブジェクトだけを取得するための専用のAPI、`evaluation_exception()`を追加することを提案しています。この関数は、現在の違反ハンドラの呼び出しのきっかけとなった例外送出に関する例外オブジェクトがある場合はその`exception_ptr`を返し、ない場合は空の`exception_ptr`を返します。

```cpp
void handle_contract_violation (contract_violation& violation) {
  // 現在の契約の評価に関する例外があればそれを取得する
  if (auto ex = violation.evaluation_exception()) {
    my::handle(ex);
  }
}
```

#### その他の提案

現在のMVP仕様では、違反後にプログラムを終了するセマンティクス（enforce/quick_enforce）のことを*enforcing semantics*と呼んでいますが、これを*terminating semantic*に変更することを提案しています。*enforcing semantics*の意味は、検出された契約違反を超えてプログラムを継続することを許可しない、の意味とされていますが、これは必ずしも、契約違反時にプログラムを終了しようとする、と同義ではないためです（例えば、例外送出や無限ループへの移行によってもプログラムの継続を止めることができ、これはenforcingだがterminatingではないため）。この提案の1つめの`is_terminating()`は（enforcingではなく）terminatingを検出することを意図しています。

`is_terminating()`の追加によって`semantic()`メンバおよびその戻り値を違反ハンドラの呼び出し状態の判定のために利用することには完全に意味がなくなり、`evaluation_exception()`の追加によって`detection_mode()`メンバおよびその戻り値を違反ハンドラの呼び出し状態の判定のために利用することには同じく意味がなくなりました。

このうち特に、`evaluation_semantic`列挙型の値は、ログの出力や契約注釈に対するラベルで利用されることが目論まれているためここでは削除を提案していません。しかし、この列挙値を違反ハンドラの呼び出し状態の判定に使用するのはもはや間違っているため、その目的で使用しないことを明記しておくことを提案しています（同様に、他の場所で使用とログ出力用途のために`detection_mode`列挙型も削除しようとしていません）。

また、`evaluation_semantic`列挙型の値を契約注釈に対するラベルで使いやすくするために、4つの標準セマンティクスに対する値を追加しておくことも提案しています。

- [P3227 進行状況](https://github.com/cplusplus/papers/issues/2061)

### [P3237R1 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r1.pdf)
### [P3261R0 Revisiting `const`-ification in Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3261r0.pdf)
### [P3261R1 Revisiting `const`-ification in Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3261r1.pdf)
### [P3271R1 Function Types with Usage (Contracts for Function Pointers)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3271r1.pdf)
### [P3287R1 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r1.pdf)
### [P3293R1 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3293r1.html)
### [P3294R2 Code Injection with Token Sequences](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3294r2.html)
### [P3295R2 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3295r2.html)
### [P3296R2 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r2.html)
### [P3298R1 Implicit user-defined conversion functions as operator.()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3298r1.pdf)
### [P3299R2 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r2.html)
### [P3310R3 Solving partial ordering issues introduced by P0522R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r3.html)
### [P3310R4 Solving issues introduced by P0522R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r4.html)
### [P3324R0 Attributes for namespace aliases, template parameters, and lambda captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3324r0.html)

現在属性の指定が許可されていないものに対して、属性の指定を可能にする提案。

C++の構文上、ほぼすべての名前やエンティティの宣言には属性を指定することができるようになっており、新機能が追加される際も構文は属性の指定を考慮して決定されます。しかし、一部例外があります。

- 名前空間エイリアス
- 型テンプレートパラメータ
- テンプレートテンプレートパラメータ
- ラムダキャプチャ

これらのものには現在属性を指定することができません。しかし、規格文書や関連する提案、CWG/LWG Issueなどを調査しても、これらのものが属性を指定できないようになっている理由は明確ではなく、単に忘れられているだけだと推測されます。

この提案は、これらのものにも属性を指定できるように構文スペースを確保することを提案するものです。提案ではそれぞれ、次のように関連する文法を調整しています

- 名前空間エイリアス
    - `attribute-specifier-seq`が`namespace`の直後に出現することを許可
        - 通常の名前空間と同じ
- 型テンプレートパラメータとテンプレートテンプレートパラメータ
    - `attribute-specifier-seq`がパラメータ宣言の先頭で出現することを許可
        - NTTPおよび関数引数の宣言と同じ
    - `attribute-specifier-seq`がパラメータ宣言内の識別子名の後に出現することを許可
        - NTTPおよび関数引数の宣言と同じ
- ラムダキャプチャ
    - `attribute-specifier-seq`が明示的キャプチャ宣言内の識別子名の後に出現することを許可
        - ただし、キャプチャ宣言の先頭には出現できない
          - `attribute-specifier-seq`の一般的な規則に則っている
    - `attribute-specifier-seq`が明示的キャプチャ宣言内の`this`,`*this`の後に出現することを許可
        - ただし、キャプチャ宣言の先頭には出現できない
    - `attribute-specifier-seq`がデフォルトキャプチャ宣言内の`&`,`=`の後に出現することを許可
        - ただし、キャプチャ宣言の先頭には出現できない

また同時に、一部の属性についてこれらのもので使用可能であることを明確にします

- `[[deprecated]]`: 名前空間エイリアスに指定したときに、効果をもつようにする
- `[[maybe_unused]]`: ラムダキャプチャに指定したときに、対応する非静的データメンバに対して適用されるようにする
- `[[maybe_unused]]`: ラムダキャプチャに指定したときに、対応する非静的データメンバに対して適用されるようにする
- `[[no_unique_address]]`: 型テンプレートパラメータとテンプレートテンプレートパラメータに指定したときに、効果を持つようにする

提案より、サンプルコード

```cpp
// 名前空間エイリアス
namespace ns {}
namespace [[deprecated]] nsa1 = ns; // ✅ 以前はng
namespace nsa2 [[deprecated]] = ns; // ❌ この場所の属性の配置は許可されない

// 型テンプレートパラメータとテンプレートテンプレートパラメータ
template<[[maybe_unused]] int nttp> // ✅ 現在でも
void ft1();
template<int nttp [[maybe_unused]]> // ✅ 現在でも
void ft2();
template<[[maybe_unused]] typename ttp> // ✅ 以前はng
void ft3();
template<typename ttp [[maybe_unused]]> // ✅ 以前はng
void ft4();
template<[[maybe_unused]] template<typename> class tttp> // ✅ 以前はng
void ft5();
template<template<typename> class tttp [[maybe_unused]]> // ✅ 以前はng
void ft6();

// ラムダキャプチャ
struct S {
  void mf(int p) {
    [ [[maybe_unused]] = ]{}();     // ❌ この場所の属性の配置は許可されない
    [ = [[maybe_unused]] ]{}();     // ✅ ただし無意味な[[maybe_unused]]の指定、以前はng
    [ [[maybe_unused]] & ]{}();     // ❌ この場所の属性の配置は許可されない
    [ & [[maybe_unused]] ]{}();     // ✅ ただし無意味な[[maybe_unused]]の指定、以前はng
    [ [[maybe_unused]] p ]{}();     // ❌ この場所の属性の配置は許可されない
    [ p [[maybe_unused]] ]{}();     // ✅ 以前はng
    [ [[maybe_unused]] this ]{}();  // ❌ この場所の属性の配置は許可されない
    [ this [[maybe_unused]] ]{}();  // ✅ 以前はng
    [ [[maybe_unused]] *this ]{}(); // ❌ この場所の属性の配置は許可されない
    [ *this [[maybe_unused]] ]{}(); // ✅ 以前はng

    [ [[no_unique_address]] = ]{}();     // ❌ この場所の属性の配置は許可されない
    [ = [[no_unique_address]] ]{}();     // ✅ 以前はng
    [ [[no_unique_address]] & ]{}();     // ❌ この場所の属性の配置は許可されない
    [ & [[no_unique_address]] ]{}();     // ✅ 以前はng
    [ [[no_unique_address]] p ]{}();     // ❌ この場所の属性の配置は許可されない
    [ p [[no_unique_address]] ]{}();     // ✅ 以前はng
    [ [[no_unique_address]] this ]{}();  // ❌ この場所の属性の配置は許可されない
    [ this [[no_unique_address]] ]{}();  // ✅ 以前はng
    [ [[no_unique_address]] *this ]{}(); // ❌ この場所の属性の配置は許可されない
    [ *this [[no_unique_address]] ]{}(); // ✅ 以前はng
  }
};
```

ラムダキャプチャの場合、`[[maybe_unused]]`や`[[no_unique_address]]`の指定によってそのクロージャ型のデータレイアウトを調整するために使用できる可能性があり、テンプレートパラメータについては使用していないことを明示的にするために`[[maybe_unused]]`属性を使用することは有効である可能性があります。どちらも現在はできませんが、この提案によって可能になります。

- [P3324 進行状況](https://github.com/cplusplus/papers/issues/2063)

### [P3327R0 Contract assertions on function pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3327r0.pdf)

関数ポインタに対する契約注釈の設計について検討する文書。

現在のContracts MVP提案（P2900R9）では、契約注釈がなされた関数のアドレスを関数ポインタに入れて呼び出した場合でもその契約条件はチェックされることを要求しています。しかし一方で、関数ポインタに対する契約注釈を行うことができません。関数ポインタがC++において広く使用されていることを鑑みると、関数ポインタに対する契約注釈は有用である可能性があります。

関数ポインタに対する契約注釈はコンパイラベンダからも契約プログラミング機能の一機能としてかなり重要視されていますが、現在のところこれを提案する文書は提出されておらず、その設計についての議論もあまり行われていません。

この提案は関数ポインタに対する契約注釈について、そのユースケースを提示するとともに、その設計について検討するものです。

この文章では、可能な構文として3種類のものを挙げています

**1. 契約注釈を宣言に付加する**

関数とラムダ式の宣言に使用されている契約注釈の文法（*function-contract-specifier-seq*）を再利用して、関数ポインタの宣言に対して付加します。

```cpp
// （メンバ）関数ポインタ宣言への契約注釈
int (*nonnegative_fptr)(int i) pre (i >= 0); // OK
int (*X::nonnegative_memfptr)(int i) pre (i >= 0); // OK

// typedef/using宣言への契約注釈
typedef int (*nonnegative_fptr_t)(int i) pre (i >= 0); // OK
using nonnegative_fptr_t = int(*)(int i) pre (i >= 0); // OK
```

**2. 契約注釈を型に付加する**

P2900R9の文法は関数ポインタ型に対して有効にすることができません（`pre`や`post`が関数名と曖昧になるため）。一方で、`typedef/using`では有効化することができます。

```cpp
// preが関数名としてもパースできる
int (*ftpr)(int i) pre (i >= 0) get_nonnegative_fptr(); // Error

// typedef宣言ならok
typedef int (*nonnegative_fptr_t)(int i) pre (i >= 0);

nonnegative_fptr_t get_nonnegative_fptr(); // OK
```

関数ポインタ型を使用可能な他のコンテキストでも同様であり、代わりに`typedef/using`を使用するようにすることで関数ポインタ型への契約注釈を疑似的に達成できます。

**3. 契約注釈を式に付加する**

契約注釈を、（メンバ）関数ポインタとして評価される式に対して付加するアイデアを考えることもできます。

```cpp
int (*)(int) get_fptr();

void test(int i) {
  get_fptr() (i);
//^^^^^^^^^^
//この式に対して契約注釈を付加する
}
```

ただし、P2900の構文はこれをサポートしておらず、検討された他の構文でもこれは不可能です。比較的自由度の高めな属性構文でさえも式に対しては適用できないため、これは実現不可能だと思われます。

これらの2つ（+1）の候補に対して、どのように動作すべきかのセマンティクスを指定する必要があります。この文章では

1. コンパイル時のセマンティクス
    - どの組み合わせがwell-formedか？
2. 実行時のセマンティクス
    - ポインタを介した呼び出し時にどの契約注釈をチェックすべきか？

の2つの部分に大別して、いくつかのパターンに分けて検討しています。

1. 関数ポインタと関数の契約注釈が同じ場合
2. 関数ポインタが関数の契約注釈を無視する場合（注釈無しポインタに注釈あり関数アドレスを代入した場合）
3. 関数ポインタが契約注釈を追加する場合（注釈ありポインタに注釈なし関数アドレスを代入した場合）
4. 関数の契約と関数ポインタの契約が異なる場合（どちらにも契約があるが、一致しない場合）
5. 中間契約（関数ポインタを別の関数ポインタへ代入する場合
6. 契約の伝播
7. テンプレートと型推論

**1. 関数ポインタと関数の契約注釈が同じ場合**

```cpp
int f(int i) pre (i >= 0);

int (*fptr)(int i) pre (i >= 0);

void test(int i) {
  fptr = f;
  fptr(i);
}
```

このようなケースにおける通常の期待は、このコードがエラーにならず`fptr`を介して`f`を呼び出した場合でもその契約条件がチェックされることでしょう。ただしこの場合には、関数と関数ポインタの契約注釈が正確に一致することを要求すべきかが問題となります。これは以前のContractsの提案でも検討された事がありますが、最終的には除外されました。

一致を定義しチェックできたとしても、それを厳密に要求するほど関数ポインタに格納可能な関数の潜在的な集合は小さくなります。同じことを行うものの契約が異なる関数は存在し得ますが（内部アルゴリズムの違いなど）、そのような関数群は同じ関数ポインタに格納できなくなります。

もう一つの懸念は、2つのエンティティが同じ契約注釈を持つかどうかによってSFINAE出来ない事を確認することです。これは、P2900の仕様が要求している契約注釈の存在は他のコンパイル時機能から認知できない、という原則に反するためです。


最後に、関数ポインタに独自の契約注釈を持たせるためにその情報をどこに格納するか、の仕様戦略について3つのものをオプションとして挙げています。

1. 関数ポインタ型の一部
    - この場合、契約注釈が事なる関数ポインタ型は異なる型となる
    - 契約注釈が
2. 関数ポインタの値の一部
3. 関数ポインタ変数宣言のプロパティ

この文書はあくまで、関数ポインタに対する契約注釈という機能のために考えるべきことの整理や検討を行っているのみで、それそのものを提案しているわけではありません。その機能の提案はこの文書をベースとして他の提案で議論されることを想定しています。

- [P3327 進行状況](https://github.com/cplusplus/papers/issues/2064)

### [P3334R0 Cross Static Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3334r0.pdf)

ある静的変数を、同じテンプレートの異なるインスタンス化で共有できるようにする機能の提案。

関数テンプレート、またはクラステンプレート内で宣言された`static`変数は通常、そのインスタンス化毎に実体が異なっています。このため、そのような静的変数をテンプレートがインスタンス化された回数のカウントに直接使用するようなことは現在できません。

この提案ではそれを可能にするために、テンプレートで共通の（各インスタンス化で共有された）`static`変数を作成可能にする機能を追加しようとするものです。

このような機能のユースケースには例えば

- アロケータ
    - 同じメモリプールを複数のインスタンス化で共有する
- 共有リソース
    - ロガーに使用する出力ストリームなど
- 共有統計
    - インスタンス化の回数等の記録（デバッグ用に役立つ場合がある

などがあります。

現在これらの事を達成するにはグローバル変数を使用せざるを得ませんが、この提案の機能では、グローバル変数の使用を回避しつつ同じテンプレートのインスタンス化の内側でのみ使用可能に制限された静的変数を得ることができます。

この提案ではまだ具体的な構文を決定しておらず、次の6つの選択肢を提示しています

1. `static`にブール型の引数を追加する：`static(true) int n = 5;`
    - `static(true)`でこの提案の機能、`static(false)`で現在の動作
    - 短所
        - `bool`引数は混乱の元かもしれない（`true`の意味が明確ではない
        - 式の記述を許可しない場合、他のところと一貫していない
2. `static`キーワードの前に新しいキーワードを追加する：`cross static int n = 5;`
    - 短所
        - 新しいキーワードの追加は通常好ましくない
            - 議論に時間がかかる
        - 既存のコードベースに登場しない名前の取得はかなり困難
    - 長所
        - 意味が明確（キーワードを適切に選択した場合
        - 追加するキーワードは明確に静的変数宣言に関係し、テンプレート引数に依存していないことが明確になる
3. 新しいキーワード`cross_static`を追加する： `cross_static int n = 5;`
    - 長所
        - この提案の目的以外には使用できない
        - 2つの単語で構成されたキーワードは1つのものよりもコードベースへの影響が低い
    - 短所
        - `cross`キーワードの別の使用方法がある場合、`cross ~`と`cross_static`で一貫しなくなる
4. `static`キーワードを2回連続で使用する：`static static int n = 5;`
    - 長所
      - 新しいキーワードが必要ない
    - 短所
      - ここまでの選択肢ほど明確ではない
          - 教育コストがかかる
      - 同じキーワードの繰り返しは間違いが起こりやすくなる
5. `static`を使用せずに、完全に新しいキーワードを使用する
    - `persistent`、`inherent`など
    - 長所
      - パースが簡単
    - 短所
      - `static`とのつながりが明確ではない
      - 既存のコードベースで使用されている可能性が高い
          - 単一キーワードだと、文脈依存として使用するのも難しくなる
      - コンパイラはこの新しいキーワードと`static`の併用に対してエラーを発せなければならない
6. `static`に対する新しい属性を使用する：`[[cross]] static int n = 5;`
    - 長所
      - パースが容易で、曖昧さがない
      - 属性内ではキーワードの競合が発生しない
    - 短所
      - 属性の無視可能性によって、コンパイラバージョンの違いで意味が異なる

このような変数の事をクロス`static`変数（cross-static variable）と呼んでいます。セマンティクスとしては追加で次のような特性を持ちます

- 次のものの間で一意のアドレスをもつ
    - 全てのテンプレートのインスタンス化
    - 異なる翻訳単位
- 通常の関数内`static`変数のように、スレッドセーフな遅延初期化を持つ

実装としては、現在の関数内`static`変数を活用して、クロス`static`変数毎にその他実体の定義を含む隠し関数を生成して、その変数への参照としてアクセスを提供することで実装できるとしています。

この提案は、SG7でのレビューにおいて関心を集めることができず、否決されています。

- [P3334 進行状況](https://github.com/cplusplus/papers/issues/2065)

### [P3335R2 Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r2.html)
### [P3346R0 `thread_local` means fiber-specific](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3346r0.pdf)

スレッドローカル変数がファイバーに対してもローカルになるようにする提案。

P0876では、ファイバーと呼ばれる軽量スレッド（スタックフルコルーチン）を実装するための基盤となるライブラリ機能（`fiber_context`）が提案され、将来のC++への導入に向けて議論されています。

ファイバーはあくまでスレッドではないため`thread_local`変数はファイバー間で区別されず、ある1つのスレッドで実行される複数のファイバーはそのスレッドの`thread_local`変数の変更を認識することができます。とはいえ、ファイバーは1つのスレッドで同時に1つしか実行されないため、競合が起こることはありません。

ただし、既存の`thread_local`変数を使用しているライブラリなどをファイバー並行した際に、このことが問題となる可能性があります。そのため、この提案では、`thread_local`変数のセマンティクスをファイバーにまで拡張することを提案しています。

この提案後には、`thread_local`変数はスレッド毎に異なる値を持つだけでなく、ファイバー毎にも異なる値を持つようになります。これにより、既存の`thread_local`変数を使用しているコードは自然にそのままスレッドからファイバーへ移行することができます。

また逆に、同じスレッド上で実行されるファイバー間で共有されるスレッドローカル変数が欲しいという需要に応えるために、`thread_specific_ptr`というライブラリ機能を導入することも提案しています。これは、Boost.Threadで開発されて出荷されているライブラリであり、ライブラリでエミュレートされたスレッドローカル変数です。こちらはファイバーを認識しないため、スレッドローカルでありつつファイバー間で共通な変数を使用することができます。

この提案はSG1におけるレビューで支持を得られず、リジェクトされています。

- [20分くらいでわかった気分になれるC++20コルーチン | PPT](https://www.slideshare.net/slideshow/20c20/168696770)
- [Boost.ThreadのTLSを使う - anon21's blog](https://anon21.hateblo.jp/entry/2012/01/08/102714)
- [P3346 進行状況](https://github.com/cplusplus/papers/issues/2066)

### [P3348R1 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3348r1.pdf)
### [P3349R0 Converting contiguous iterators to pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3349r0.html)

`contiguous_iterator`をポインタとして扱うことができるようにするために、標準ライブラリにおける要件を強化する提案。

`contiguous_iterator`は`std::to_address()`を使用してポインタに変換することができます。これによって`std::copy`を`std::memmove`にするような最適化が可能になるものの、`stdcontiguous_iterator`の持つ要件は単にイテレータの各要素がメモリ上で連続的に配列されていることを確認するだけにとどまっており、イテレータによる反復をポインタを用いた処理に置き換えることを許可していません。

例えば、特定の要素に到達した時に例外を送出することで終了する`throwing_iterator`のようなものを考えてみます。これは単なるイテレータラッパであるため、contiguousな範囲から作成されれば`throwing_iterator`も`contiguous_iterator`になります。

```cpp
int data[4]{1,2,3,4};
try {
  // data+2に到達すると例外を送出する
  ranges::for_each(throwing_iterator(data, data+2), data+4,
                   [](int i){ assert(i != 3); });
} catch (...) {
}
```

この例における`assert`は発動することは無いわけですが、このようなイテレータとしての副作用を考慮して`contiguous_iterator`のcontiguous性の活用が妨げられているとすると、`contiguous_iterator`は`random_access_iterator`と異なる部分が無くなってしまうため、存在意義がありません。

この提案では、`contiguous_iterator`のcontiguous性を標準ライブラリがより活用できるように、標準の文言を調整しようとするものです。

具体的には、標準ライブラリの実装が`contiguous`な範囲を扱う際に、イテレータによる反復をポインタによる反復に置き換えてることを許可する指定を明示的についかします（実装は、空ではない隣接範囲`r`を`[to_address(begin(r)), to_address(begin(r))+size(r))`に置き換えることを許可する）。これによって、標準ライブラリの実装は`contiguous_iterator`のイテレータとしてのAPIが持つ副作用（インクリメントや間接参照時の副作用）を考慮しないようになるとともに、ユーザーは標準ライブラリ実装がそれを考慮することに依存できなくなります。

この提案は2025年1月に行われた全体会議で承認され、C++26に導入されています。

- [P3349 進行状況](https://github.com/cplusplus/papers/issues/2067)

### [P3351R1 views::scan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3351r1.html)
### [P3352R0 Taming the Demons (C++ version) - Undefined Behavior and Partial Program Correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3352r0.pdf)

未定義動作がプログラム全体の動作を未定義にしないようにする提案。

現在のC++標準のルールにおいては、プログラムの実行グラフのどこかで未定義動作が発生すると、そのプログラム全体の動作について標準は何の要件も課さなくなります（これがいわゆる鼻から悪魔）。特に、未定義動作が発生する地点よりも前のコードにさえもその動作は及び、タイムトラベル最適化を引き起こす事が知られています。この提案では、これを抽象ルール（*abstract rule*）と呼んでいます。

対してここで提案されているのは、未定義動作が発生した場合に未定義動作を引き起こす操作自体に要件を課さないようにするにとどめて、他のwell-formedな動作はそのまま（well-formedのまま）にします。この提案しているルールを具象ルール（*concrete rule*）と呼んでいます。

現在の抽象ルールはコンパイラの最適化を妨げないためのルールであると認識されており、具象ルールはそれに対する破壊的変更に見えます。しかし実際のところ、抽象ルールとはコンパイラのバグ的な動作も含めて包含する形で成立したものであり、現在のコンパイラは具象ルールに基づいて動作しているため、具象ルールへの変更は既存慣行の標準化にすぎません。

また、抽象ルールの下で可能になるとされている望ましい最適化も、具象ルールによって妨げられる望ましい最適化も実際には存在せず、抽象ルールの下では不可能だった最適化すら存在することが、長年の経験と分析によって明らかにされています（WG14のUndefined Behavior study groupによる作業）。提案では難解ながらもその説明があります。

ただし、具象ルールであっても未定義動作が発生した地点以降の動作については変わらず何の要件も課しません。これは、未定義動作の後に発生する動作とはそれがどのようなものであっても、未定義動作と区別をつけることができないためです。そのため、具象ルールで変化するのは未定義動作が起きた地点より前のプログラムについての動作の保証のみです。

そのため、具象ルールは実際のところ現在および将来の実装にほとんど影響するものではなく、具象ルールによってほとんどの操作の状態が変化するわけでもありません。それでもなおこの提案を導入するメリットとして、次の事を挙げています

- 具象ルールは抽象ルールよりも単純で安全であり、教えやすくコードの動作の予測が簡単になる
    - 難解な抽象ルールが原因で発生するコンパイラのバグが存在している
- 具象ルールはC23で導入済みであり、C23のルールと一致する。CとC++は実装によって同じ中間表現へ変換されるフロントエンド言語であり、最適化はその中間表現に対して行われます。そのため、最適化の動作を制御するルールを共有していることは理にかなっている
- 具象ルールによって、未定義動作を含むプログラムの部分的な正しさを示すのがかなり簡単になる
    - 抽象ルールはかなり難解な一方、具象ルールはプログラムと実装の正しさ/誤りを証明するための基礎として遥かに簡単なもの
- 具象ルールは`volatile`操作のユーザーにとって望ましい、より現実的な結果をもたらす
    - これは、`volatile`操作のユーザーから明示的に要求されたものでもある
- 抽象ルールから具象ルールへの変更によって、望ましい最適化が妨げられるようになるなど、見落としがある可能性がある。そのような最適化が発見されて調査され、WG21と実装の協力によってそれが標準の欠陥なのかコンパイラのバグなのかを決定できるようになる
    - 抽象ルールではそのような発見の可能性を低くし、潜在的なコンパイラのバグさえも規格準拠とすることをデフォルトにしている

この提案のベースは、CのUndefined Behavior study groupで長年作業され調査てきた結論をC23標準に適用したN3128にあり、この提案はC++がそれに追随することを提案するものです。

ところでC++にはこの提案に非常に関連する提案として、観測可能なチェックポイントという最適化を提案するP1494があります（2025年1月にC++26に採択済み）。P1494では一部の操作を観測可能なチェックポイントとして定義して、観測可能なチェックポイントを超えて未定義動作が波及しないようにすることを提案しています。P1494のことばでいうなら、この提案はプログラム内のすべての場所を観測可能なチェックポイントにするものであり、P1494の上位互換と言えます（そして、この提案で述べられているように、それは現在の実装の動作そのものです）。

- [N3128 Taming the Demons -- Undefined Behavior and Partial Program Correctness](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3128.pdf)
- [P3352 進行状況](https://github.com/cplusplus/papers/issues/2068)

### [P3355R1 Fix submdspan for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3355r1.html)
### [P3367R0 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r0.html)

コンパイル時でもコルーチンを動作可能にする提案。

`std::generator`のようなコルーチンはRangeアダプタの簡易な実装に有用であり、コンパイル時に使用できるようになるとより便利です。この提案は、単純にコルーチンの定数式での実行を許可する提案です。

サンプルコード

```cpp
template <typename T>
constexpr auto fib() -> std::generator<T> {
  T a = 0;
  T b = 1;
  co_yield a;
  do {
      co_yield b;
      auto tmp = b;
      b += a;
      a = tmp;
  } while (true);
}

template <typename T, size_t N>
constexpr auto calculate_fibonnaci() {
  auto res = std::array<T, N>{};
  std::ranges::copy(fib<T>() | std::views::take(N), res.begin());
  return res;
}

constexpr auto cached_fibonnaci = calculate_fibonnaci<unsigned, 20>();
```

この提案では、特に複雑な仕様を追加することなく、現在定数式で禁止されているコルーチン（await式やyield式）の動作を単に許可しています。これにより、既存のコルーチンに対して`constexpr`を付加するだけで、そのコルーチンは定数式で実行可能になります（定数式でできないことをしていなければ）。

ただし、ある定数式の評価内で生成されたコルーチン（のステート）は、その式の評価内で解放されていなければならず、そうでなければコンパイルエラーになります（すなわち、コルーチンステートを実行時に持ち出すことはできません）。これは現在のコンパイル時の動的メモリ確保と解放についてのものと同じルールです。

筆者の方はこれをclangのフォークで試験実装したうえで提案しており、少しの実装負荷があったものの実装そのものに大きな障害は無かったようです。

EWG/CWGのレビューにおいて、実装の負荷の割に需要が小さいのではないか（特にC++26のタイムフレームの中では）という指摘があったようで、C++26に入れずにC++29に向けて検討されているようです。

- [P3367 進行状況](https://github.com/cplusplus/papers/issues/2069)

### [P3370R1 Add new library headers from C23](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3370r1.html)
### [P3371R2 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r2.html)
### [P3372R2 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r2.html)
### [P3375R1 Reproducible floating-point results](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3375r1.html)
### [P3376R0 Contract assertions versus static analysis and 'safety'](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3376r0.html)
### [P3378R0 `constexpr` exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3378r0.html)

例外型を`constexpr`指定する提案。

P3068にて定数式における例外送出が議論されており、この提案は順調に進行しています（2024年11月の全体会議で採択されています）。しかし、関連する例外型を定数式で使用可能にするための作業は遅れており、この提案はそれを行うためのものです。

P3068でも例外型の一部は定数式で使用可能となるように提案されていますが全てではなく、ここでは既に定数式で使用可能な機能（特に`std::vector`/`std::string`）が実行時に使用している例外を定数式でも同様に使用可能にすることを目的としています。

具体的には、次の例外型の全てのメンバ関数およびコンストラクタとデストラクタに`constexpr`を付加することを提案しています

- `logic_error`
- `domain_error`
- `invalid_argument`
- `length_error`
- `out_of_range`
- `runtime_error`
- `range_error`
- `overflow_error`
- `underflow_error`
- `bad_optional_access`
- `bad_variant_access`
- `bad_expected_access`
- `format_error`

筆者の方は提案の内容をlibc++で実装しており、実装上のポイントなどを報告しています（障害となるような困難さはないようです）。

- [P3378 進行状況](https://github.com/cplusplus/papers/issues/2071)

### [P3385R1 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3385r1.html)
### [P3386R0 Static Analysis of Contracts with P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3386r0.pdf)
### [P3387R0 Contract assertions on coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3387r0.pdf)

コルーチンにおける契約注釈の指定を許可する提案。

P2900R8のContracts MVP仕様では、コルーチンに対する契約注釈（`pre()`/`post()`）の指定を禁止しています（`contract_assert`を使用可能）。これは、コルーチンに対する事前条件と事後条件がどのように解釈されどのように振舞うべきか、が未確定であるためです。

これまでの議論等は以前の記事を参照

- [P2957R0 Contracts and coroutines - WG21月次提案文書を眺める（2023年8月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P2957R0-Contracts-and-coroutines)
- [P2957R1 Contracts and coroutines - WG21月次提案文書を眺める（2024年1月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2957R1-Contracts-and-coroutines)
- [P3251R0 C++ contracts and coroutines - WG21月次提案文書を眺める（2024年5月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3251R0-C-contracts-and-coroutines)

この提案は、P2957での議論をベースとして、以前の提案で検討されていなかったオプションや設計空間を徹底的に調査し、コルーチンとContractsの両方の設計目標と設計原則を最もよく満たすソリューションの確立と文言の提案、をするものです。

コルーチンに対する事前・事後条件の指定は、コルーチンのランプ関数に対する指定とすることを基本としています。コルーチンのランプ関数とは、ユーザー側から見た時にコルーチンを初期化して初期サスペンドポイントで中断させた状態でユーザ側へ返す、コルーチンのファクトリ関数のような役割をする暗黙的な関数です。この提案では、コルーチンの事前条件はランプ関数の引数およびその時点におけるプログラム状態に対する契約となり、事後条件はランプ関数の戻り値（`co_yield`の値ではない）に対する契約となります。

コルーチンに対する事前・事後条件をランプ関数の契約としてコルーチンの実装詳細（コルーチン動作を行う部分そのもの）とは切り離して考えることで、コルーチンに対する契約注釈の振る舞いを通常の関数にかなり近くすることができます。

それでも一点問題となるのは、コルーチンのランプ関数においては関数引数が常に`const`ではない、という点です。通常の関数においては、事後条件から（非参照）関数引数を参照する際に全ての関数宣言においてその引数は`const`である必要があります。これは事後条件で引数に対する意味のある条件を記述するために必要な事前条件です。

しかし、コルーチンのランプ関数においては、コルーチン引数をコルーチンステート内にムーブして保存し、なおかつその際にランプ関数が実質的に引数のトップレベル`const`を除去して動作します。これにより、コルーチンではその引数は常に非`const`であり、事後条件から参照するとムーブ後の値を参照しかねません。そのため、コルーチンの事後条件からその非参照引数を参照する場合の動作をどうするかを考え、選択する必要があります。


これらの事をベースとして、この提案では次の4 + 3のソリューションを提示しています

1. 全てのコルーチンで事前・事後条件を許可しない（P2900R8の現在
2. 事前条件は許可するが事後条件は許可しない（P2957R1で提案
3. 事前条件に加えて事後条件も許可し、事後条件からの非参照引数のODR使用を禁止する（P2957R2で代替提案
4. 事前条件に加えて事後条件も許可し、事後条件から使用される非参照引数はコルーチンステートのものを参照する
5. 事前条件に加えて事後条件も許可し、事後条件から使用される非参照引数は元のオブジェクトを参照し
    1. ランプ関数ではコルーチンステートへ引数をムーブでは無くコピーする
    2. 引数型が非トリビアルなムーブコンストラクタを持つ場合（ムーブ後状態を導入しうる場合）、ill-formedとする
    3. 何の制限も導入しない（ムーブ後の値を参照しうる

そのうえで、順守すべきContractsとコルーチンの設計目標としてつぎの7点を挙げています

1. コルーチンでも事前条件と事後条件を許可する
2. コルーチン性を実装の詳細として扱う
3. 引数のムーブ後状態を事後条件で公開しない
4. Contracts Prime Directive を満たす
    - Contracts Prime Directiveとは、既存のプログラムに契約注釈を追加してもそのプログラムの正確性は影響を受けない、というもの。契約注釈の存在がプログラムのコンパイル時/実行時のセマンティクスに影響を与えない
5. 事前条件と事後条件の間に新たな非一貫性を導入しない
6. リモートのコード破壊を助長しない
    - リモートのコード破壊とは、ある部分のコード変更が、一見無関係な別の部分に悪影響を与えることで、コンパイルエラーや実行時バグを引き起こすこと
    - 例えば、コピーコンストラクタだけを持つ型にムーブコンストラクタを導入した結果、ムーブ後状態が生まれることで実行時バグを引き起こす、など（これはソリューション5.3で起こりうる
7. 事前条件と事後条件の呼び出し側チェックをサポートする

これらの事を表に並べて比較すると

| 設計原則／ソリューション                               | 1    | 2    | 3    | 4    | 5.1   | 5.2   | 5.3   |
| :--------------------------------------------------- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| 1. コルーチンでも事前条件を許可する | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 1. コルーチンでも事後条件を許可する | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ |
| 2. コルーチン性を実装の詳細として扱う | ❓ | ❓ | ✅ | ❌ | ✅ | ❓ | ❌ |
| 3. 引数のムーブ後状態を事後条件で公開しない | ✅ | ✅ | ✅ | ✅ | ✅ | ❓ | ❌ |
| 4. Contracts Prime Directive を満たす | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ✅ |
| 5. 事前条件と事後条件の間に新たな非一貫性を導入しない | ✅ | ❌ | ✅ | ❌ | ✅ | ✅ | ❌ |
| 6. リモートのコード破壊を助長しない | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ✅ |
| 7. 事前条件と事後条件の呼び出し側チェックをサポートする | ✅ | ✅ | ✅ | ❌ | ✅ | ✅ | ✅ |

❓のところはどちらともとれる（判断が分かれる）事を表しています。

この表から明らかなように、全ての設計目標を満たしつつコルーチンとContractsの両方の設計原則と互換性があるソリューションは案3のみです。この結果から、この提案ではコルーチンにおける契約注釈として案3、すなわち

- コルーチンにおいて事前条件と事後条件を許可する
- コルーチンにおける事前事後条件は、そのランプ関数に対する契約となる
- コルーチン事後条件から非参照関数引数をODR使用すると、ill-formed

を提案しています。

- [P3387 進行状況](https://github.com/cplusplus/papers/issues/2073)

### [P3394R0 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3394r0.html)

C++任意のエンティティ（宣言）に対して静的リフレクションのためのアノテーションを付加できるようにする提案。

静的リフレクション機能をより活用するためには、リフレクション対象のエンティティに対して何らかの注釈を行い、その注釈をリフレクションから取得できるようにする必要があることが指摘されてきました。

この提案は、属性を拡張した注釈を導入することでこれを可能にしようとしています。注釈のための構文は次のようなものです

```cpp
struct C {
  [[=1]] int a;
};
```

`[[ ... ]]`の中に`=expr`という形の属性を指定することで注釈としています。構文スペースとしては属性の物を利用していますが、これは属性ではありません。

`=expr`の`expr`は定数式である必要があり、`std::meta::info`を通してその値が取得されるためその型はstructural typeである必要があります。

この提案の注釈が属性構文を使用しつつも属性ではないのは、属性が無視可能であることに加えて、属性を反射（`^^`）した後で何を返すべきかが明確ではないためです。例えば`^^[[nodiscard, gnu::always_inline]]`の結果のリフレクション値は文字列を返すか、P3294のトークンシーケンスを返すかですが、どちらにしてもあまり使いやすくはありません（ライブラリで追加のパースが必要になるため）。

その一方で、注釈に値を指定して、注釈のリフレクションがその値を返すようにすると非常に便利であることが分かったため、ここでは注釈（リフレクションを介して値をユーザーに返す）を属性（値を保存しない）と区別して導入しています。これにより、属性のリフレクションはそのために有用な別の性質を考えることができます。

加えて、この注釈のリフレクションを扱うためのライブラリメタ関数をいくつか追加しています。

```cpp
namespace std::meta {
  // リフレクション値が注釈を反映しているかどうかを調べる
  consteval bool is_annotation(info);

  // 特定のエンティティのアノテーションをすべて取得する
  consteval vector<info> annotations_of(info item);            // (1)
  // `type_of(a) == type`となる全ての注釈aを返す
  consteval vector<info> annotations_of(info item, info type); // (2) 
  // `dealias(type_of(a)) == ^^T`となる注釈aがあれば、それを返す
  template<class T>
  consteval optional<T> annotation_of(info item);

  // `dealias(type_of(a)) == ^^T`となる注釈aがあるかどうかを調べる
  template<class T>
    consteval bool has_annotation(info item);                 // (3)
  // `value_of(a) == reflect_value(value)`となる注釈aがあるかどうかを調べる
  template<class T>
    consteval bool has_annotation(info item, T const& value); // (4)

  // 宣言に注釈を付加する
  consteval info annotate(info item,
                          info value,
                          source_location loc = source_location::current());
}
```

その他の構文の例など

```cpp
// 注釈は繰り返し指定可能
[[=42, =42]] int x;
static_assert(annotations_of(^x).size() == 2);

// 同じエンティティの複数の宣言で指定された注釈は蓄積される
[[=42]] int f();
[[=24]] int f();
static_assert(annotations_of(^f).size() == 2);

// 注釈は属性と同じ場所に指定可能だが、type-specifier-seqの属性指定可能な場所
// およびempty-declarationには指定できない
struct [[=0]] S {};  // ✅: Sの注釈
[[=42]] int f();     // ✅: f()の注釈.
int f[[=0]] f();     // ✅: 同上
int [[=24]] f();     // ❌: 戻り値型intには指定できない
[[=123]];            // ❌: 空の宣言には指定できない

// 注釈は属性内のusingの後に指定できない
[[using clang: amdgpu_waves_per_eu, =nick("weapon")]]
int select_footgun(int);  // ❌
// 分ければok
[[using clang: amdgpu_waves_per_eu]] [[=nick("weapon")]]
int select_footgun(int);  // ✅
```

ユースケースとしては例えば、Rustのclapというコマンドライン引数パーサーライブラリと同じコンセプトのライブラリの作成を挙げています。

```cpp
struct Args {
  [[=clap::Help("Name of the person to greet")]]
  [[=clap::Short, =clap::Long]]
  std::string name;

  [[=clap::Help("Number of times to greet")]]
  [[=clap::Short, =clap::Long]]
  int count = 1;
};


int main(int argc, char** argv) {
  Args args = clap::parse<Args>(argc, argv);

  for (int i = 0; i < args.count; ++i) {
      std::cout << "Hello " << args.name << '\n';
  }
}
```

`Help`,`Short`,`Long`はメンバ変数に対応するコマンドライン引数がどのように使用できるかを指定するために必要な追加の注釈です。

実行の例

```
$ demo -h
USAGE:
  demo [-?|-h|--help] [-n|--name <name>] [-c|--count <count>]

Display usage information.

OPTIONS, ARGUMENTS:
  -?, -h, --help
  -n, --name <name>       Name of the person to greet
  -c, --count <count>     Number of times to greet

$ demo -n wg21 --count 3
Hello wg21
Hello wg21
Hello wg21
```

他にも、pytestのparametrize testやRustのserdeのようなSerializationライブラリの作成が例に挙げられています。

- [P3394 進行状況](https://github.com/cplusplus/papers/issues/2074)

### [P3399R0 Adjusting Electronic Polls to a Hybrid Workflow](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3399r0.pdf)

C++標準化作業における電子投票（*Electronic Poll*）のプロセスを調整する提案。

C++の標準化における電子投票はCOVID19のパンデミックをきっかけに導入されたもので、現在のC++標準化委員会がハイブリッドモード（対面+オンライン）で動いていることから非常に活用されています。ただし、導入当初から色々変わってきているため、そのプロセスを調整しようとするのがこの提案です。

とはいえ、電子投票プロセスは電話会議の決定を確認するのに役立つことが経験的に実証されているため、ここではそれを行わないようにすることを提案しているわけではありません。

ここで提案されているのは、「対面（ハイブリッド）会議で行われた決定、電子投票を行うことでプロセスが遅れる可能性のある提案（各作業部会の議長の裁量に委ねられる）については、電子投票プロセスをスキップ可能にする」ことです。ただし、スキップに際して議長はスキップに対する反対意見がないこととリアルタイムの投票結果がコンセンサスに達していることを確認する必要があります。

この理由としては

1. パンデミック前は電子投票は行われていなかった
2. 現在の対面（ハイブリッド）会議はオンラインで開催されており、参加のハードルはかなり下がっている。そのため、提案に関心のある人はそこまで労力をかけずともリアルタイムの投票に参加できるはず
3. 設計サイクルの終了間際に、手続き上の遅延によって修正や改善が3年遅れる可能性を可能な限り下げておきたい
4. 設計グループがレビューする提案は同じ週に文言グループもレビューする可能性が高い（電子投票はそれに間に合わない）。これまでは、慎重に計画を立てたうえで必要な場合には電子投票をスキップする投票を行って電子投票を回避してきた
5. 議長の裁量で電子投票をスキップ可能にする

等を挙げています。

この提案は少なくとも、LEWGのポリシーとして採択され、運用されていくようです。

- [P3378 進行状況](https://github.com/cplusplus/papers/issues/2071)

### [P3402R1 A Safety Profile Verifying Class Initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3402r1.html)
### [P3403R0 The Undefined Behavior Question](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3403r0.pdf)
### [P3404R0 `std::at` : Range-checked accesses to arbitrary containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3404r0.pdf)

カスタマイゼーションポイントオブジェクトである`std::at`の提案。

`.begin()`に対する`std::ranges::begin()`のように、ユーザー定義のものも含めた様々なコンテナに対して統一的に`.at()`を使用できると便利であるため、一部のコンテナだけが持つ`.at()`関数をフリー関数かつカスタマイゼーションポイントオブジェクトとして提供しようとする提案です。

`std::at`は`.at()`関数と同じメリット（範囲チェック付アクセス）を持ち、より汎用的に使用できます。提案では次の3つのケースをハンドルするようにされています

1. 既に`.at()`を持つコンテナ: メンバの`.at()`を呼び出す
2. 生配列: `std::array::at()`とほぼ同じ範囲チェック付きアクセスを提供
3. ユーザー定義型: ADLで`at()`関数をルックアップして呼び出す

範囲外アクセスの場合は例外を送出するのは既存の`.at()`の動作と変わりません。このために、このCPOはフリースタンディング指定できません。

- [P3404 進行状況](https://github.com/cplusplus/papers/issues/2077)

### [P3405R0 Out-of-order designated initializers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3405r0.html)
### [P3406R0 We need better performance testing](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3406r0.pdf)
### [P3407R0 Make idiomatic usage of `offsetof` well-defined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3407r0.html)
### [P3409R0 Enabling more efficient stop-token based cancellation of senders](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3409r0.html)
### [P3411R0 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3411r0.html)
### [P3412R0 String interpolation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3412r0.pdf)
### [P3413R0 A more flexible optional::value_or (else!)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3413r0.pdf)

`optional/expected`の`.value_or()`を補完する関数の提案。

この提案はP2218R0の引継ぎとなる提案です。基本的なモチベーションや設計はそのままに、`std::expected`に対しても同様の提案をしています。

ここで提案されているのは

- `.value_or_construct()`の追加
    - 有効値を保持していない場合、引数の値から有効値のオブジェクトを構築して返す
- `.value_or_else()`の追加
    - 有効値を保持していない場合、引数のcallableを呼び出してその戻り値を返す
      - `.value_or_construct()`の遅延評価版

の2点です。

`std::optional<T>`と`std::expected<T, E>`に対して、次のようなシグネチャで追加しようとしています

```cpp
template<class ... Args>
constexpr T value_or_construct( Args &&... args ) const &;
template<class ... Args>
constexpr T value_or_construct( Args &&... args ) &&;

template<class U, class ... Args>
constexpr T value_or_construct (initializer_list <U> il, Args&&... args>) const &;
template<class U, class ... Args>
constexpr T value_or_construct (initializer_list <U> il, Args&&... args>) &&;

template <class F>
constexpr T value_or_else (F&& f) const &;
template <class F>
constexpr T value_or_else (F&& f) &&;
```

- [P2218R0 : More flexible optional::value_or() - WG21月次提案文書を眺める（2020年9月）](https://onihusube.hatenablog.com/entry/2020/10/09/221025#P2218R0--More-flexible-optionalvalue_or)
- [P3413 進行状況](https://github.com/cplusplus/papers/issues/2084)

### [P3415R0 Range interface in std::optional breaks code!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3415r0.html)
### [P3416R0 exception_ptr_cast: Add && = delete overload](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3416r0.html)
### [P3417R0 Improving the handling of exceptions thrown from contract predicates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3417r0.pdf)
### [P3419R0 Reflection Syntax Options Summary](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3419r0.html)
### [P3420R0 Reflection of Templates](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3420r0.html)
### [P3421R0 Consteval destructors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3421r0.html)
### [P3422R0 Allow main function in named modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3422r0.html)
### [P3423R0 Extending User-Generated Diagnostic Messages](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3423r0.html)
### [P3425R0 Reducing operation-state sizes for subobject child operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3425r0.html)
### [P3427R0 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3427r0.pdf)
### [P3428R0 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3428r0.pdf)
### [P3429R0 Reflection header should minimize standard library dependencies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3429r0.html)
### [P3430R0 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3430r0.pdf)
### [P3433R0 Allocator Support for Operation States](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3433r0.pdf)
### [P3435R0 Reflection and meta-programming](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3435r0.html)
### [P3436R0 Strategy for removing safety-related undefined behavior by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3436r0.pdf)
### [P3437R0 Proposed default principles: Reflect C++, Generate C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3437r0.pdf)
### [P3438R0 Make integral overloads of std::to_string constexpr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3438r0.pdf)
### [P3439R0 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3439r0.pdf)
### [P3440R0 Add n_elements named constructor to std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3440r0.html)
### [P3441R0 Rename simd_split to simd_chunk](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3441r0.html)
### [P3442R0 [[invalidate_dereferencing]] attribute](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3442r0.pdf)
### [P3443R0 Reflection on SG21 2024 Process](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3443r0.pdf)
### [P3444R0 Memory safety without lifetime parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3444r0.html)
### [P3445R0 Add utilities for easier type/bit casting in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3445r0.html)
### [P3446R0 Profile invalidation - eliminating dangling pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3446r0.pdf)
### [P3447R0 Profiles syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3447r0.pdf)
### [P3449R0 constexpr std::generator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3449r0.html)
### [P3450R0 Extending is_within_lifetime](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3450r0.html)
### [P3451R0 A Suggestion for Reflection Access Control](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3451r0.html)
### [P3454R0 Revising Atomic Max/Min Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3454r0.pdf)
### [P3455R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2024/6/12-2024/10/9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3455r0.pdf)
### [P3456R0 system_scheduler on Win32, Darwin and Linux](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3456r0.html)
### [P3457R0 SG19: Machine Learning virtual Meeting Minutes to 2024/06/13-2024/10/10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3457r0.pdf)
### [P3460R0 Contracts Implementors Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3460r0.pdf)
### [P3465R0 Pursue P1179 as a Lifetime TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3465r0.pdf)
### [P3466R0 (Re)affirm design principles for future C++ evolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r0.pdf)
### [P3467R0 2024-10 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3467r0.html)
### [P3469R0 Virtual deducing this](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3469r0.pdf)
### [P3470R0 Interface-Unit-Only Module Library Support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3470r0.pdf)
### [P3471R0 Standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r0.html)
### [P3472R0 Make fiber_context::can_resume() const](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3472r0.html)
### [P3473R0 Splicing Should Respect Access Control](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3473r0.html)
### [P3474R0 std::arguments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3474r0.html)
### [P3475R0 Defang and deprecate memory_order::consume](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3475r0.pdf)
### [P3476R0 Slides for P2688R2 - Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3476r0.pdf)
### [P3477R0 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3477r0.html)
### [P3478R0 Constification should not be part of the MVP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3478r0.pdf)
### [P3479R0 Enabling C pragma support in C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3479r0.html)
### [P3480R0 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r0.pdf)
### [P3481R0 Summarizing std::execution::bulk() issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3481r0.pdf)
