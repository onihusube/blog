# ［C++］WG21月次提案文書を眺める（2024年09月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-09)

全部で51本あります。

もくじ

[:contents]

### [N4990 Business Plan and Convener's Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4990.pdf)

ビジネスユーザ向けのC++およびWG21の現状報告書。

### [P0472R2 Put std::monostate in <utility>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0472r2.pdf)
### [P1030R7 std::filesystem::path_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1030r7.pdf)
### [P1061R9 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r9.html)
### [P2019R7 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2019r7.pdf)
### [P2287R3 Designated-initializers for base classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2287r3.html)
### [P2319R1 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r1.html)
### [P2688R2 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r2.html)
### [P2786R7 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r7.pdf)
### [P2835R5 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r5.html)
### [P2835R6 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r6.html)
### [P2841R4 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r4.pdf)
### [P2846R3 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r3.pdf)
### [P2879R0 Proposal of std::dump](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2879r0.pdf)
### [P2945R1 Additional format specifiers for time_point](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2945r1.html)
### [P2988R7 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r7.pdf)
### [P3016R4 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r4.html)
### [P3019R9 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r9.html)
### [P3037R3 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r3.pdf)
### [P3074R4 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r4.html)
### [P3096R3 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r3.pdf)
### [P3128R1 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3128r1.pdf)
### [P3128R2 Graph Library: Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3128r2.pdf)
### [P3210R2 A Postcondition *is* a Pattern Match](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r2.pdf)
### [P3245R2 Allow `[[nodiscard]]` in type alias declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3245r2.html)
### [P3248R2 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3248r2.html)
### [P3290R2 Integrating Existing Assertions With Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3290r2.pdf)
### [P3295R1 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3295r1.html)
### [P3299R1 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r1.html)
### [P3309R2 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r2.html)
### [P3335R1 Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r1.html)
### [P3371R1 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r1.html)
### [P3372R1 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r1.html)
### [P3375R0 Reproducible floating-point results](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3375r0.html)

計算結果の再現性の保証された浮動小数点数型の提案。

C++標準では、浮動小数点数の動作（計算）のほとんどの部分は実装定義とされており、同じ計算式が異なるプラットフォームで同じ結果をもたらすとは限りません。

例えば次のようなコードは実装によって異なる結果を生成します。

```cpp
int main() {
	float line_0x(0.f);
	float line_0y(7.f);

	float normal_x(0.57f);
	float normal_y(0.8f);

	float px(10.f);
	float py(0.f);

	float v2p_x = px - line_0x;
	float v2p_y = py - line_0y;

	float distance = v2p_x * normal_x + v2p_y * normal_y;

	float direction_x = normal_x * distance;
	float direction_y = normal_y * distance;

	float proj_vector_x = px - direction_x;
	float proj_vector_y = py - direction_y;

	std::cout << "distance:      " << distance << std::endl;
	std::cout << "proj_vector_y: " << proj_vector_y << std::endl;
}
```

オプションなしでNvidia C++ compiler 24.5でビルドすると

```
distance:  	   0.0999997
proj_vector_y: -0.0799998
```

オプションなしでclang 18.1.0でビルドすると

```
distance:  	   0.0999999
proj_vector_y: -0.0799999
```

`-march=skylake`を指定してclangでビルドすると

```
distance:  	   0.1
proj_vector_y: -0.08
```

のようになります。これは出力が異なっているのではなく、実際にビットレベルで異なった結果となっています。特に、最適化を有効にするとプログラム中で実行される浮動小数点演算の性質・数・順序が実装ごとに異なり、これによって丸め演算の回数や順序が異なってくることから、プラットフォームによって異なった値を生成します。

ISO/IEC 60559:2020（IEEE 754）では浮動小数点演算の再現可能性についても指定しているものの、それを達成するには言語標準・実装・およびユーザーの強力が必要としています。しかし、C++では規格からして再現可能な浮動小数点演算をサポートしていません。

一部のアプリケーションにおいては浮動小数点演算の再現性が重要となる場合があります。例えば、ゲーム開発においては、クロスプラットフォームで展開する場合が多いため、異なるプラットフォーム間で浮動小数点演算結果が一致するようになるとコードの移植性を向上させることができます。あるいは、オンラインマルチプレイが可能なゲームにおいては、より簡単に異なるプラットフォーム間でデータを交換することができます。

科学計算では実装が浮動小数点演算に対して行う最適化（命令の融合や並べ替え）が計算結果に致命的な丸め誤差を導入してしまい、計算結果が不正確なものになる場合があります。これを回避・あるいは制御するためには、計算の順序が厳密に指定されていることが重要になります。

この提案では、再現性のある浮動小数点演算を実現するために、新しいライブラリ実装の浮動小数点数型を追加することを提案しています。

```cpp
namespace std {
  // 丸めモードの指定
  enum class iec_559_rounding_mode : unspecified;                                                                             // freestanding
  inline constexpr iec_559_rounding_mode iec_559_round_ties_to_even = iec_559_rounding_mode::round_ties_to_even;              // freestanding
  inline constexpr iec_559_rounding_mode iec_559_round_toward_positive = iec_559_rounding_mode::round_toward_positive;        // freestanding
  inline constexpr iec_559_rounding_mode iec_559_round_toward_negative = iec_559_rounding_mode::round_toward_negative;        // freestanding
  inline constexpr iec_559_rounding_mode iec_559_round_toward_zero = iec_559_rounding_mode::round_toward_zero;                // freestanding


  // 再現性のある浮動小数点数型
  template<class T, iec_559_rounding_mode R = round_ties_to_even>
  class strict_float {
  public:
    using value_type = T;

    constexpr strict_float(T);
    constexpr strict_float(const strict_float&) = default;
    template<class X, iec_559_rounding_mode Y>
    constexpr explicit strict_float(const strict_float&);

    constexpr operator value_type() const;

    constexpr strict_float& operator= (const T&);
    constexpr strict_float& operator+=(const T&);
    constexpr strict_float& operator-=(const T&);
    constexpr strict_float& operator*=(const T&);
    constexpr strict_float& operator/=(const T&);
  };
}
```

提案されているのは`strict_float<T, R>`というクラステンプレートで、`T`に浮動小数点数型（IEE754交換形式であることが規定される`float16_t, float32_t, float64_t, float128_t`のいずれか）を指定し、`R`に丸めモードの指定（`iec_559_rounding_mode`列挙型の値）を指定します。

この型は浮動小数点数型`T`のごく薄いラッパであり、この型の値に対する操作（計算）は実行時にソースコード上での順序と意味を保持する事（並べ替えや融合が許可されないこと）が要求され、保証されます。すなわち、再現可能性という性質はこの型の暗黙のプロパティとして（ISO/IEC 60559:2020に準拠した形で）指定されます。

計算における丸めモードに関しては`iec_559_rounding_mode`列挙型の値として型に埋め込まれており、演算子オーバーロードによってその丸めを使用する計算が静的に指定されます。

```cpp
namespace std {
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator+(strict_float<T, R>, <T, R>);              // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator+(strict_float<T, R>, T);                   // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator+(T, strict_float<T, R>);                   // freestanding
  
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator-(strict_float<T, R>, <T, R>);              // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator-(strict_float<T, R>, T);                   // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator-(T, strict_float<T, R>);                   // freestanding
  
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator*(strict_float<T, R>, <T, R>);              // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator*(strict_float<T, R>, T);                   // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator*(T, strict_float<T, R>);                   // freestanding
  
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator/(strict_float<T, R>, <T, R>);              // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator/(strict_float<T, R>, T);                   // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator/(T, strict_float<T, R>);                   // freestanding
  
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator+(strict_float<T, R>);                      // freestanding
  template<class T, iec_559_rounding_mode R>
  constexpr strict_float<T, R> operator-(strict_float<T, R>);                      // freestanding
}
```

この提案ではひとまず、四則演算のみをサポートする最小限の演算のみを提案しています。`<cmath>`にある関数などはアルゴリズムや丸めが指定されていないためそのまま利用できず、そのための作業は多大なものになるためです。また同様に、異なる形式の浮動小数点数間の再現可能な変換も将来のサポートとしています。

なお、よく似た提案がP2746R5で提案されていますが、P2746がFenvによる丸めモードの廃止と置換（よく似たクラステンプレートによる）だけを提案するものであるのに対して、この提案はさらに操作の融合や並べ替えを禁止することで計算の再現可能性を達成することを目指すものです。

- [浮動小数点演算の結果が環境依存なのはどんなときか - Zenn](https://zenn.dev/mod_poppo/articles/floating-point-portability)
- [P2746R5 Deprecate and Replace Fenv Rounding Modes - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2746R5-Deprecate-and-Replace-Fenv-Rounding-Modes)
- [P3375 進行状況](https://github.com/cplusplus/papers/issues/2035)

### [P3379R0 Constrain std::expected equality operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3379r0.html)
### [P3380R0 Extending support for class types as non-type template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3380r0.html)
### [P3381R0 Syntax for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3381r0.html)
### [P3382R0 Coarse clocks and resolutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3382r0.html)
### [P3383R0 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3383r0.html)
### [P3384R0 __COUNTER__](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3384r0.html)
### [P3385R0 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3385r0.html)
### [P3388R0 When Do You Know connect Doesn't Throw?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3388r0.pdf)
### [P3389R0 Of Operation States and Their Lifetimes (LEWG Presentation 2024-09-10)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3389r0.pdf)
### [P3390R0 Safe C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3390r0.html)
### [P3391R0 constexpr std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3391r0.html)
### [P3392R0 Do not promise support for function syntax of operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3392r0.pdf)
### [P3396R0 std::execution wording fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3396r0.html)
### [P3397R0 Clarify requirements on extended floating point types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3397r0.pdf)
### [P3398R0 User specified type decay](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3398r0.pdf)
### [P3401R0 Enrich Creation Functions for the Pointer-Semantics-Based Polymorphism Library - Proxy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3401r0.pdf)
### [P3402R0 A Safety Profile Verifying Class Initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3402r0.html)
