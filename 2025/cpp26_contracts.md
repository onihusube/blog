# C++26 Contracts

C++26では契約プログラミング機能が使用可能になります。この記事はその機能の解説を行うものです。なお、契約プログラミングそのものやその意義などについてはここでは解説しませんので、各自で調べてください。

[:contents]

### 構文

C++26 Contracts機能によって、契約プログラミング（契約による設計）の主要概念である事前条件と事後条件に対応するアサーションとその他のアサーションを専用の構文によってコード中に配置し、関数契約をC++コードの一部として記述できるようになります。このアサーションのことを**契約アサーション（contract assertions）**と呼びます。

契約アサーションには前述の事前条件・事後条件・その他アサーションにして3種類のアサーションがあります。

- `pre()` : 事前条件アサーション
- `post()` : 事後条件アサーション
- `contract_assert()` : アサーション文

3種類のアサーションは基本的には同じ使用法になり、`()`の中には契約条件を表す式を指定します

```cpp
int f(const int x)
  pre (x != 1)  // 事前条件アサーション
  post(r : r == x && r != 2) // 事後条件アサーション
{
  contract_assert(x != 3); // アサーション文

  return x;
}
```

事前条件と事後条件アサーションは関数の宣言の直後（`requires`節が存在する場合、その後）に対して付加し、関数本体の内など他の場所には指定できません。`contract_assert()`は逆に`pre()/post()`の場所には配置できず、文（*statement*）の一種として関数本体ブロック内などの分が配置できる場所に配置することができます。

関数ヘッドの直後（`requires`節が存在する場合、その後）、（定義がある場合は）本体ブロックの直前、が事前条件と事後条件アサーションを配置する専用の構文スペースになります。ここでは、`pre()`と`post()`を空白区切りで任意の個数配置することができます。`pre()`と`post()`の出現順は任意であり、両方あってもどちらか片方だけしかなくてもokです。一方で、他のものはここには配置できません。

```cpp
int f1(int x) pre(x != 1) pre(x != 2) pre(x != 3) ... pre(x != 1000) ...  // ok
{
  ...
}

int f2(const int x) post(x != 1) post(x < 0) pre(x == 0) post(r: r != x)  // ok
{
  ...
}

void f3(int x) contract_assert(x != 0)  // ng、ここに配置できるのはpre()とpost()のみ
{
  ...
}

template<typename T>
void f(T& x) requires std::integral<T> pre(x != 0) post(0 < x)  // ok
{
  ...
}
```

関数に対する事前・事後条件アサーションの指定はフリー関数に限定されたものではなく、メンバ関数でも使用可能です。

```cpp
template<typename T>
struct S {
  T t;

  int f1(int x) pre(x == 0) post(r: x != 0) // ok
  {
    ...
  }

  auto f2() const & noexcept [[attribute]] -> T requires std::integral<T> pre(t != 0) post(r: r < T(0));  // ok

  int f3(this S& self) pre(self.t == 0) post(r: r < 0); // ok
};
```

事後条件アサーションだけは関数の戻り値をキャプチャするための専用の構文スペースが用意されており、`post(ret: expr)`の様に条件式`expr`の前の`ret`の部分に戻り値を指すように任意の名前を指定できます。戻り値を表すこの名前は続く`expr`内で使用することができ、値としてはその関数の戻り値が取得できます。

戻り値の無い（`void`戻り値型の）関数の事後条件アサーションにおける結果名の使用はコンパイルエラーとなります。

```cpp
void f()
  post(r: ...)  // ng、戻り値の無い関数での結果名の指定はコンパイルエラー
{
  ...
}
```

事後条件アサーションにおけるこの結果名は、事後条件アサーションが関連付けられている関数の戻り値のオブジェクト/参照を表す束縛（*result binding*）であり、言語参照（`T&`）とは異なる形の参照の様な名前になります（これは構造化束縛において導入される各束縛の名前と同じ扱いのものです）。そして、結果名の式としての値カテゴリ（`decltype(r)`）は`const`左辺値（`const T&`、`T`は戻り値型）となります。

戻り値への参照ではなく束縛としていることによって、`return`文における暗黙ムーブやRVOの影響をうけなくなっており、結果名はそれらの適用された関数戻り値を直接示しています。

なお、`pre`/`post`は`override`等と同じ文脈依存キーワードであり、`contract_assert`はキーワードとして新規追加されています。そのため、`pre`/`post`は他の名前として使用できる一方、`contract_assert`は使用できません。

```cpp
int pre(const int x)
  pre(x != 1)           // ok
  post(post: post == x) // ok
{
  int contract_assert;  // ng、これはダメ

  ...
}
```

以下、この記事では事前条件アサーションと事後条件アサーションの事を単に事前条件と事後条件と呼びます。

#### 契約アサーションの述語（契約条件式）

アサーションの種類によらず、契約アサーションには何かしら契約条件を表現する条件式を指定する必要があります。この条件式の事を述語（*predicate*）と呼びます。この述語というのはアルゴリズムの文脈などで使用される言葉と同じ意味です。

述語は文脈的に`bool`変換が可能（contextually converted to `bool`）な式である必要がある他は任意のC++式を記述することができます。すなわち、`if`や条件演算子の条件式として使用できるものが使用できます。ただし、後述する`const`化の違いがあります。

```cpp
void f1(int* ptr) pre(ptr)  // ok、ptr != nullptr と等価
{}

void f2(std::optional<int> opt) pre(opt)  // ok、opt.has_value() と等価
{}
```

以下、この記事ではこの述語の事を**契約条件式**と呼ぶことにします。

#### `const`化

3種類いずれの契約アサーションにおいても、その契約条件式内から参照可能な外部の変数はすべて、暗黙的に`const`化されます。

この`const`化は契約条件式の振る舞いがC++の他の部分とかなり異なる点です。これは、契約条件式の評価に伴う副作用の発生を防止するための措置の一つです。

契約条件式には文脈的に`bool`変換が可能であれば任意の式を記述することができます。（`const`化を除いて）それ以外に特に制限は無いため、その条件式を起点として任意のC++コードを実行することができます。プログラムの任意時点の状態をチェックするための契約アサーションからプログラムの状態を変更することは通常間違った行いであるため、これをなるべく防止するためにこの`const`化の措置が取られています。

```cpp
void f() {
  std::vector<bool> vec{true, false};

  contract_assert(vec.emplace_back(true) == true);  // ng、vecはconst
}  
```

この`const`化は契約条件式の外部の変数の使用すべてに対して作用します。関数引数、ローカル変数、グローバル/名前空間スコープの変数、`static`/`thread_local`変数、NTTPや構造化束縛、そして`this`および`*this`まで、あらゆる外部の変数は`const`化されます。事後条件における結果名の値カテゴリが`const`左辺値なのも`const`化の一部です。

```cpp
int n = 0;
struct X { bool m(); };

struct Y {
  int z = 0;

  void f(int i, int* p, int& r, X x, X* px)
    pre (++n)     // ng、const左辺値を変更しようとしている（グローバル変数
    pre (++i)     // ng、const左辺値を変更しようとしている
    pre (++(*p))  // ok、ポインタの参照先には伝播しない
    pre (++r)     // ng、const左辺値を変更しようとしている
    pre (x.m())   // ng、非constメンバ関数呼び出し
    pre (px->m()) // ok、ポインタの参照先には伝播しない 
    pre ([=, &i, *this] mutable {
      ++n;        // ng、const左辺値を変更しようとしている
      ++i;        // ng、const左辺値を変更しようとしている
      ++p;        // ok、コピーキャプチャされたクロージャ型のメンバの変更（ポインタ
      ++r;        // ok、コピーキャプチャされたクロージャ型のメンバの変更（非参照
      ++this->z;  // ok、コピーキャプチャされた*thisの変更
      ++z;        // ok、コピーキャプチャされた*thisの変更
      int j = 17;

      [&]{
        int k = 34;
        ++i; // ng、const左辺値を変更しようとしている
        ++j; // ok
        ++k; // ok
      }();

      return true;
    }());

  template <int N, int& R, int* P>
  void g()
    pre(++N)      // ng、prvalueを変更しようとしている
    pre(++R)      // ng、const左辺値を変更しようとしている
    pre(++(*P));  // ok、ポインタの参照先には伝播しない

  int h()
    post(r : ++r) // ng、const左辺値を変更しようとしている
    post(r: [=] mutable {
      ++r;  // ok、コピーキャプチャされたクロージャ型のメンバの変更
      return true;
    }());

  int& k()
    post(r : ++r); // ng、const左辺値を変更しようとしている
};
```

契約条件式には任意の式を使用できるため、当然ラムダ式が使用できます。契約条件式内ラムダ式内部で宣言された変数（コピーキャプチャも含めて）にはこの`const`化は適用されません。

また、この`const`化は浅いもので、深く伝播することはありません、例えば、外部のポインタを使用しているときそのポインタそのものは`const`化されていますが（`T* const`）、ポインタの参照先（`*ptr`/`ptr->~`）までは伝播しません。

仮に`const`化を解除したい場合は、`const_cast`を使用します。

```cpp
struct S {
  int m_resource;
  std::mutex m_mtx;

  // 非constのステータスチェック
  bool cond() {
    std::lock_guard _{m_mtx};

    return m_resource != 0;
  }

  int f()
    pre(this->cond())                 // ng、非constメンバ関数呼び出し
    pre(const_cast<S*>(this)->cond()) // ok
  {}
}
```

#### 事後条件における関数引数の使用

事後条件から関数引数を使用することは良くありそうですが、その場合に使用する引数は参照であるか、そうでないなら`const`宣言されていなければなりません。非参照の場合、これは暗黙`const`化とは関係なく明示的に`const`と宣言されている必要があります。

```cpp
void f(int a1, const int a2, int& a3)
  post(a1 == 0) // ng。事後条件からの非参照非const引数の使用
  post(a2 == 0) // ok、const引数
  post(a3 == 0) // ok、参照引数
```

これは、事後条件から使用される非参照非`const`関数引数について、どの時点の値をキャプチャすべきか？という問題を回避するためのものです。

例えば次のようなライブラリ関数があるとします

```cpp
// ユーザーが見る宣言
int generate(int lo, int hi)
  pre (lo <= h)
  post(r: lo <= r && r <= hi);
```

この宣言からは、事後条件によって引数`lo, hi`に対して戻り値が`[lo, hi]`の範囲内に収まっていることが明確に読み取れます。しかしこの関数の実装が次のようになっていたとしたらどうでしょうか

```cpp
// 開発者が見る定義
int generate(int lo, int hi)
  pre (lo <= h)
  post(r: lo <= r && r <= hi) // 事後条件からの引数使用に制限がないとする
{
  int result = lo;

  while (++lo <= hi) // loが更新される
  {
    if (further())
      ++result;      // loよりもゆっくりとインクリメントされる
  }
  return result;
}
```

この関数は値渡しで引数を変更しています。これにより、この定義から見る事後条件の意味は全く違ったものになっています。

関数の非参照引数を変更するというのは正気ならやらないとは思われますが、言語が暗黙的にこれを行う場合があります。

```cpp
std::string g(std::string p)
  post (r: starts_with(p))  // 事後条件からの引数使用に制限がないとする
{
  return p; // 引数の暗黙ムーブ
}
```

関数引数は暗黙ムーブの対象であるため、事後条件でそのような関数引数を使用すると意図通りに動作しなくなります。

このように、関数定義内で引数が変更されていると、関数宣言の契約アサーション（特に事後条件）のみから戻り値に対する推論を行うことができなくなります。このことは事前条件では問題にならず（変更前であるため）、事後条件でのみ問題になります。また、引数が参照である（変更されるものであるため）か`const`である場合（変更できないため）も問題になりません。

これを防止するために、事後条件から使用できる関数引数は参照もしくは非参照の`const`なものに限定されています。

#### 宣言と定義が分かれている場合

C++の関数はその宣言と定義を分けて記述することができるほか、宣言だけなら何度も再宣言することができます。この場合にも契約アサーション（事前条件と事後条件アサーション）を指定することはできますが、少し注意が必要です。

関数に対して事前条件と事後条件アサーションを指定する場合、翻訳単位におけるその関数の最初の宣言に対して指定しておかなければなりません。そして、同じ翻訳単位内で続く再宣言は事前条件と事後条件アサーションの指定について次のどちらかを順守する必要があります

- 事前条件と事後条件アサーションを一切指定しない
- 最初の宣言と全く同一の事前条件と事後条件アサーションを指定する

一つの翻訳単位内でこれが満たされない場合、コンパイルエラーとなります。

```cpp
// 最初の宣言
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2);

// 有効な再宣言: 事前/事後条件アサーションを持たない
int f(const int x);

// 有効な再宣言: 事前/事後条件アサーションを持つ
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2);

// 有効な再宣言（定義）: 事前/事後条件アサーションを持たない
int f(const int x)
{
  contract_assert(x != 3);  // contract_assertは関係ない

  return x;
}

// 不正な再宣言: 異なる事前/事後条件アサーションを持つ
int f(const int x)
  pre (x != 1);     // ng

// 不正な再宣言: 異なる事前/事後条件アサーションを持つ
int f(const int x)
  pre (0 < x)
  post(r: r == 0);  // ng
```

後の宣言で事前条件と事後条件アサーションが指定されていない場合、暗黙的に最初の宣言の事前条件と事後条件アサーションと同一のものが指定されているものとして扱われます。

最初の宣言に事前条件と事後条件アサーションが指定されていない場合、あとの宣言で追加することはできません。

```cpp
// 契約アサーションを持たない関数宣言
int f(const int x);

// 不正な再宣言:  事前/事後条件アサーションが追加された
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2); // ng
{
  contract_assert(x != 3);

  return x;
}
```

翻訳単位が複数ある場合、ある関数に対応する最初の宣言は翻訳単位毎に1つづつ存在しえます（このような状況はヘッダファイルに契約アサーションを持つ関数の宣言を記述して、そのヘッダを複数のソースファイルでインクルードした時に起こります）。ある関数に対応するそのような複数の最初の宣言の間で同一の事前条件と事後条件アサーションが指定されていない場合、診断不要のill-formed（IFNDR）となります。

```cpp
/// 翻訳単位1におけるf()の宣言
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2);

/// 翻訳単位2におけるf()の宣言
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2); // ok

/// 翻訳単位3におけるf()の宣言
int f(const int x); // IFNDR、契約アサーションの指定がない
```

IFNDRは診断されない、すなわちコンパイルエラーとなることを要求されていないため、未定義動作となります。これはODR違反が起きているのとほぼ同じことです。ここでの翻訳単位には共有ライブラリの様なものも当然含まれます。

これらのルールを理解したうえで問題となるのは、事前条件と事後条件アサーションの同一性の定義です。契約アサーションは何をもって同一と言えるのでしょうか？

ある2つの事前/事後条件アサーションのシーケンスは次の場合に同一とみなされます

1. 同一の契約アサーション指定（1つの`pre(...)`/`post(...)`）が
2. 同じ順序で指定されている

この一つの契約アサーション指定の同一性は、ODRの意味での同一です。これは、関数宣言`d1`と`d2`がありそれぞれ契約アサーション指定`c1`と`c2`（この`c1. c2`は単一の`pre(...)`/`post(...)`）を持っているとき、その述語`p1`と`p2`は、宣言`d1`と`d2`に対応する仮想的な関数本体に配置されコンパイルされたときにODRに違反しない、場合にODRの意味で同一となります。すなわち、この時に仮想的な`d1, d2`の定義が異なっていない状態の場合に、契約アサーション指定`c1`と`c2`は同一となります。

このODRの同一性をより具体的に言えば、この仮想的な`d1, d2`がビット単位で全く同じ機械語コードにコンパイルされる場合、がODRの意味で同一と言えます（最適化の事は考えないでください）。したがって、異なる翻訳単位にある時でも、同じ関数に指定された事前/事後条件アサーションが参照する変数や関数等は同じものにならなければなりません。

一方で、関数引数の名前やテンプレートパラメータ名、事後条件における結果名、などはODR同一性においては考慮されないため、異なっていても問題ありません（これは通常の関数のODRよりも緩いルールです。通常の`inline`関数や関数テンプレートでは、字句的に同一であることが求められます）。

```cpp
/// 翻訳単位1におけるf()の宣言
int f(const int x)
  pre (x != 1)
  post(r : r == x && r != 2);
  
/// 翻訳単位2におけるf()の宣言
int f(const int y)
  pre (y != 1)
  post(b : b == y && b != 2); // ok
  
/// 翻訳単位3
static int x = 0;

/// 翻訳単位3におけるf()の宣言
int f(const int a)
  pre (x != 1)
  post(r : r == x && r != 2); // IFNDR、翻訳単位1と2の契約アサーションと同一ではない
  
/// 翻訳単位4におけるf()の宣言
int f(const int y)
  post(b : b == y && b != 2)
  pre (y != 1);               // IFNDR、順番が異なる
```

この同一性の違反は翻訳単位が同じであればチェックされてコンパイルエラーとなります。

##### 事前条件と事後条件アサーションにおけるラムダ式の使用

ラムダ式がリンケージを必要とする場所（関数宣言付近）に現れる場合、そのクロージャ型は必ず固有のものになるというルールがあります。これと契約アサーション指定の同一性のルールによって、事前条件と事後条件アサーションでラムダ式が使用されている場合は同じ翻訳単位内で全く同じ文字列によって再宣言していたとしても（仮に契約アサーション指定を省略したとしても）、同一性を満たすことができません

```cpp
// 同じ翻訳単位内にあっても
void f() pre([]{ return true; }()); // ok、最初の宣言
void f() pre([]{ return true; }()); // ng、最初の宣言の契約アサーションと同一ではない
void f();                           // ng、最初の宣言の契約アサーションと同一ではない
```

このような場合でも再宣言をしなければ事前条件と事後条件アサーションでラムダ式を使用することに問題はありません。

ラムダ式のこのような性質についてはC++20 P0351R4のこの解説を参照してください

- [C++20 評価されない文脈でのラムダ式 [P0315R4] - cpprefjp](https://cpprefjp.github.io/lang/cpp20/wording_for_lambdas_in_unevaluated_contexts.html)

##### 事後条件での関数引数の使用

事後条件で関数引数を使用するにはその引数が非参照なら`const`である必要があるというのはもう説明したことです。これは単に事後条件が存在する場合のみ`const`にしておけばいいのではなく、すべての宣言において`const`でなければなりません。通常の関数宣言では、値引数の`const`有無は関数宣言のマッチングにおいて考慮されないため、少し注意が必要です。

```cpp
void f1(int n);
void f1(const int n); // ok、f1()の再宣言

void f1(const int n) post(r: r == n);
void f1(int n);   // ng、事後条件で使用している引数が（非参照）非const
```

再宣言において事前条件と事後条件アサーションが省略された場合、最初の宣言と同一の契約アサーション指定がなされているとみなされるため、後の宣言でも事後条件で使用している引数に`const`が必要です。

これはここまでで懇々と説明してきたODR同一性とは少し関係がないことですが、契約アサーション付き関数の再宣言においては注意すべきことです。

### 評価セマンティクス

ここまでで、C++ Contractsにおける契約アサーションはどのように記述できるか、ということはなんとなくわかったと思います。すると気になってくることは、この契約アサーションはどう振舞うのか？ということでしょう。

もちろん、契約アサーションは書いて終わりではなく、通常のコードと同様にその記述の正しさなどが検証され、実行時にチェックするようにすることもできます。契約アサーションがどのようにふるまうのか、すなわち契約アサーションのセマンティクスは、大きく評価（条件式のチェック、実行）と評価の後に起こることの2つに分割されて定義されており、どのように評価されるのかについての事をContractsの**評価セマンティクス**と呼びます。

#### 4つのセマンティクス

C++ Contractsの評価セマンティクスは単一ではありません。評価するかしないかやどう評価するのか、評価してどうするのかについてはプログラムによって様々な要求・要件があります。言語標準の機能としてそれらの要求をなるべく受け止められるようにするために、評価セマンティクスは固定ではなくいくつか規定されたセマンティクスから選択して適用可能なようになっています。

C++26時点では、4つの評価セマンティクスが標準で規定されています。

1. *ignore*
2. *observe*
3. *enforce*
4. *quick enfore*

これに加えて、実装が実装定義のセマンティクスを追加しても良いことになっています。

これらのセマンティクスは主に、契約条件式を評価（チェック）するかしないか、評価した後に契約違反ハンドラを呼び出すか出さないか、契約違反が起きた後に実行を継続するかどうかが異なっています。

C++26時点の各セマンティクスの違いは表にして一覧できます

|セマンティクス|チェック|違反ハンドラ|違反後継続|
|---|---|---|---|
|*ignore*|しない|呼び出さない|する|
|*observe*|する|呼び出す|する（条件付）|
|*enforce*|する|呼び出す|しない（条件付）|
|*quick enfore*|する|呼び出さない|しない|

表のチェック列の意味は、プログラムの実行が契約アサーションに到達した時にそこに指定された契約条件式を評価するかどうかです。チェックするセマンティクスでは契約条件式が評価されてその結果が`bool`値として取得されます。契約条件式が`false`を返した場合、その契約アサーションの表明する契約が破られている状態であり、これを契約違反（が発生した状態）と呼びます。

違反ハンドラ列の意味は、契約条件式が評価されて契約違反が発生した後に、契約違反ハンドラと呼ばれるコールバック処理を呼び出すかどうかです。呼び出すセマンティクスでは契約違反発生後に違反ハンドラ（専用のライブラリ関数）を起動して、契約違反をハンドリングします。この違反ハンドラについては次の章で詳しく解説します。

違反後継続列の意味は、契約違反が発生した後でもプログラムの実行を継続するかどうかです。*observe*と*enforce*セマンティクスでは違反後に違反ハンドラが呼ばれてさらにその後に継続するかどうかです。しないセマンティクスでは契約違反が起こるとプログラムが終了されます。*observe*と*enforce*セマンティクスの継続に関する条件とは、違反ハンドラの呼び出しが正常にリターンするかどうかです。

*observe*と*enforce*セマンティクスにおいて違反ハンドラの呼び出し後の振る舞いは次のようになります

- *observe* : 違反ハンドラが正常にリターンした場合、違反を起こした契約アサーションの直後から元の実行パスを再開する
    - 違反ハンドラがリターンしなければ、元の実行パスの再開はされない
- *enforce* : 違反ハンドラが正常にリターンした場合、プログラムを終了する
    - 違反ハンドラがリターンしなければ、プログラムは終了されない

*observe*と*enforce*のデフォルトの継続動作はそれぞれするとしないですが、違反ハンドラがリターンするかどうかによってこの動作をオーバーライドできます。これについては次章で詳しく説明します。

*ignore*セマンティクスはチェックを行わないため契約違反が発生しないので違反ハンドラ呼び出しもプログラム終了も行われません。そのため実際に契約違反が発生していたとしてもそれを検出することはできません。しかし、これにより契約アサーションの評価によるオーバーヘッドをゼロにすることができます。なお、契約アサーションが*ignore*セマンティクスでコンパイルし実行される場合でも契約条件式のコンパイルは行われています（これは`assert`マクロのセマンティクスとは異なる点です）。

*observe*セマンティクスは契約違反をロギングしながらプログラムの実行をなるべく優先するもので、レガシーなコードからの移行期に選択するセマンティクスとなることを目的とするものです。ただし、契約違反が発生した状態でプログラムの実行を継続すると早晩未定義動作に突入するため安全なセマンティクスとは言えない側面があります（これは*ignore*セマンティクスも同様）。

*enforce*セマンティクスは契約違反をロギングしつつも違反時に終了することでバグの影響を最小にとどめることを目的とするものです。契約違反が発生したら速やかにプログラムは終了されるため、未定義動作に陥ることがないという意味で安全なセマンティクスでもあります。また、*enforce*セマンティクスはデフォルトの評価セマンティクスとしておくことが推奨されています。

*observe*と*enforce*セマンティクスでは契約違反時の診断情報（違反が発生した場所などの情報）が提供されます（これは推奨事項ではあります）。

*quick enfore*セマンティクスは違反ハンドラ呼び出しを伴わず、チェックして違反が発生すると即プログラムを終了させます。これは契約アサーションによって生成されるコードサイズを最小限に抑えるとともに、違反が起きたらなるべく速やかにプログラムを終了させることを目的としています。*quick enfore*では契約違反に関する診断情報が提供されないか最小限のものになる可能性があります。

#### 評価セマンティクスの選択

契約アサーションのデフォルトのセマンティクスとしては*enforce*セマンティクスが標準で推奨されていますが、セマンティクスを選択する方法は実装定義とされています。

通常これはコンパイラオプションを通じてコンパイル時に一括で制御することが想定されていますが、より柔軟にリンク時（異なる設定によってコンパイルされた翻訳単位の結合時）・ロード時（設定ファイルや環境変数など）・実行時（外部のデバッガの指定など）などに変更できるようにすることもサポートされています。

全ての契約アサーションのセマンティクスを一括で指定するようなコンパイラオプションはほぼ確実に提供されるため、通常はそれを使用することになると思われます。

評価セマンティクスの選択方法の自由度に対応して、ある契約アサーションの評価にどの評価セマンティクスが選択されるかも実装定義とされます。特に、この評価セマンティクスの選択は契約アサーション毎に異なっていても良く、さらに同じ契約アサーションでも評価ごとに異なるセマンティクスを選択することも許可されています。

例えば、Clangの試験実装では`-fcontract-evaluation-semantic`というオプションによって指定することができ、さらに`-fcontract-group-evaluation-semantic`というオプションで別途属性で指定したグループごとに制御する方法を提供しています。

評価セマンティクスは4つありましたが、実装は4つの評価セマンティクスの全てをサポートしていなくても良いとされています。

#### 契約アサーションの評価タイミングと評価回数

チェックされる評価セマンティクスにおいて、契約アサーションの契約条件式の評価のタイミングは厳密に指定されています。

- 事前条件（`pre()`） : 関数呼び出し時、関数引数の初期化後、関数本体の実行前
- 事後条件（`post()`） : 戻り値が初期化され、ローカル変数がすべて破棄された後、関数引数の破棄の前
- アサーション文（`contract_assert()`） : 制御フローがその文に到達した時

ある関数に対して事前条件または事後条件が複数指定されている場合、事前条件と事後条件それぞれの評価の内側で、個別の事前条件/事後条件は宣言順（指定された順序）で評価されます。

```cpp
int f(const int n, int& out)  // (0) : 関数引数初期化
                              // (10) : 関数引数破棄
  pre(n != 0)     // (1)
  post(0 < out)   // (2)
  pre(n < 100)    // (3)
  post(r: n < r)  // (4)
{
  int m = 10; // (5)

  out = g(n, m);

  contract_assert(out != 0);  // (6)
  contract_assert(0 < m);     // (7)

  return m + n; // (8)
} // (9) : ローカル変数破棄
```

この例において、関数`f()`が呼び出されるとまず、事前条件（`(1)(3)`）が次の順序で評価されます

```
(0) => (1) => (3) => (5)
```

次に関数本体が評価され

```
(5) => (6) => (7) => (8)
```

最後に事後条件（`(2)(4)`）が評価されます

```
(8) => (9) => (2) => (4) => (10)
```

ここでの評価とは評価セマンティクスによる選択の前の契約アサーションそのものの評価のことです。各契約アサーションがこの順で評価されていく際に、*ignore*セマンティクスが選択されている契約アサーションではその契約条件式の評価がスキップされます。以下、この節では評価という言葉を専らこの意味で使用しています。契約アサーションの評価とその条件式の評価の違いに注意してください。

コンストラクタ/デストラクタやコルーチンなどにおいては少し異なる点があるものの、この評価順序には自由度はほぼありません。例えば同じ契約アサーションのシーケンス（事前条件や事後条件の集まり）内で順番を入れ替えて宣言順を逸脱することはできません。

ただ、このような評価の順序とは別にそれぞれの契約アサーションが何回評価されるのかは実装定義となります。

ある関数について、次の3種類の**順次評価される（evaluated in sequence）**契約アサーションの集合が形成されます

1. 関数に指定されている事前条件アサーション
2. 関数に指定されている事後条件アサーション
3. 関数本体内で連続しているアサーション文

1と2はある関数に最大1つづつしかありませんが、3は1つの関数に対して複数存在しえます。

先に述べたような評価順序で評価が行われる一方で、このような集合の1つの評価中には、そこに含まれる評価済みの契約アサーションを、実装定義の回数まで任意の評価セマンティクスで再評価することが許可されます。すなわち、契約アサーションは1回以上評価され、契約条件式は0回以上評価されます。そして、この上限は必ずしも1ではありません。

```cpp
void f(int i)
{
  // この2つのアサーション文によって1つの順次評価される集合が形成される
  contract_assert(i > 0);   // #1
  contract assert(i < 10);  // #2

  // この集合においては次の評価順序と回数は有効（合法）
  // 有効な評価順序: #1 #2
  // 有効な評価順序: #1 #1 #2 #2
  // 有効な評価順序: #1 #2 #1 #2
  // 有効な評価順序: #1 #2 #2 #1
  
  // 有効ではない評価順序: #2 #1
}
```
```cpp
void f(int *p)
  pre( p != nullptr ) // precondition #1
  pre( *p > 0 );      // precondition #2

// 順次評価される集合は{#1 #2}
// この集合においては次の評価順序と回数は有効（合法）
// #1 #2
// #1 #1 #2
// #1 #2 #1 #2
// #1 #2 #2 #1 

// 次の評価順序と回数は無効（合法ではない）
// #2 #1
// #2 #2
// #1
// #1 #1
```

推奨事項として、コンパイラはこのような契約アサーションの評価の回数を指定するオプションを提供することと、デフォルトの動作は各契約アサーションが正確に1回だけ評価されるようにしておくことが推奨されています。

このような複数回の評価が起こる場合の分かりやすく合理的な例は、事前条件/事後条件を持つ関数が共有ライブラリで定義されている場合です。契約アサーションの指定に関して前述のように最初の宣言に指定されている必要があることから、ヘッダファイル経由でそのような関数に対する事前条件と事後条件は呼び出し側（共有ライブラリ使用者）でも呼び出される側（共有ライブラリ内部）でも同じ契約アサーションが見えています。その場合に呼び出し側と呼び出される側の両方の翻訳単位がチェックされるセマンティクス（例えば*enforce*）を指定してコンパイルされているとします。

この時、実装の取りえる評価方法として、呼び出し側と呼び出される側の双方で契約アサーションの評価およびその条件式の評価を行うという方法があります。この場合、事前条件は関数呼び出し直前に、呼び出し側と呼び出される側の両方で2回評価され、事後条件も同様に2回評価されます。

```cpp
/// ヘッダファイル
int f(int *p)
  pre( p != nullptr ) // #1
  pre( *p > 0 )       // #2
  post(r: 0 < r)      // #3
  post(r: r < 100);   // #4

/// 共有ライブラリcpp
#include "header.hpp"

int f(int *p) {
  // 関数契約に違反しない定義とする
  ...
}

/// 共有ライブラリ利用側cpp
#include "header.hpp"

int main() {
  int n = 100;

  int r = f(&n);
  // 呼び出し側と呼び出される側の両方で契約アサーションを評価する場合
  // #1 #2 |翻訳単位の壁| #1 #2 f() #3 #4 |翻訳単位の壁| #3 #4
  // の順序で契約アサーションが評価される
}
```

このような評価方法は想定され許可されている物であり、なおかつ合理的なものでもあります。リンク時やロード時のセマンティクス選択がサポートされている場合、このような評価を削減できる可能性はありますが、それをサポートするかどうかやどうサポートするかは実装定義となるため、このように評価される可能性を排除するには実装がどうなっているかを調べる必要があります。

それ以外に繰り返し評価が発生するケースとして、アサーションのテストのためにあえて複数回試行する評価方法が挙げられています。

`const`化と合わせてこの契約アサーションの評価回数の不定性によっても、契約条件式が副作用を伴いまたそれに依存するような使い方はC++26 Contractsの使い方としては間違っている物であり、推奨されません。

さらに、コンパイラがある契約条件式についてその評価結果が`true`になるか`false`になるかを証明できる場合、コンパイラはその式を評価する代わりにその結果を使用することが許可されています。別の言い方をすると、その契約条件式（副作用をもちうる）と同じ結果になる副作用の無い式を代わりに使用して契約条件式の評価を行うことができます。

このような契約条件式の置換は契約条件式の一部分ではなく全体に対して行われるため、契約条件式の持つ副作用はすべてが起こるか全く起こらないかのどちらかになります。

このことからも、契約アサーションの契約条件式には副作用を含めるべきではありません。

#### 定数式における契約アサーション

契約アサーションの評価は定数式でも使用可能です。そこでも4つの評価セマンティクスのいずれかが適用されることになるのですが、少しだけ実行時と異なる点があります。

まず、コンパイル時には契約違反ハンドラというものがありません。このため、*enforce*と*quick enfore*は同じ意味になります。そして、違反後継続しない（プログラム終了する）セマンティクスにおけるプログラム終了は、コンパイル時においてはコンパイルエラーを意味します。

また、契約違反の定義も変わっており、定数式において契約違反とみなされるのは

- 契約条件式が`false`に評価された
- 契約条件式が定数式で実行できなかった
    - 条件式内にコンパイル時実行できないものがあった

の2つの場合です。特に、後者はコンパイル時特有の違反となります。

これらのことを踏まえて先ほどの表を書き直すと次のようになります

|セマンティクス|チェック|違反時|
|---|---|---|
|*ignore*|しない|何もしない|
|*observe*|する|診断出力|
|*enforce*|する|コンパイルエラー|
|*quick enfore*|する|コンパイルエラー|

*ignore*セマンティクスは実行時と同様に定数式でも何もしないセマンティクスとなります。ただし、指定された契約条件式がコンパイルされないわけではありません（定数式中で評価されないだけ）。

*observe*セマンティクスも実行時と同様に定数式では違反を検出したらそれについての診断メッセージを発行して実行を継続します。定数式においては未定義動作の心配がないため安全ではあります。また、診断メッセージは警告として扱われます。

*enforce*と*quick enfore*は前述のようにコンパイル時には同じ意味になり、契約違反を検出するとコンパイルエラーを発生させてコンパイルを停止させます。この時、コンパイルエラーメッセージの一環としてどのアサーションで違反が起きたかなどの診断情報が出力されるはずです。

このコンパイル時の評価セマンティクスの選択に関しても実行時同様実装定義となりますが、特筆すべき点として、同じ契約アサーションが実行時とコンパイル時で異なるセマンティクスによって評価されることが許可されています。対応して、コンパイラは実行時とコンパイル時で異なるセマンティクス指定フラグを提供することができます。

例えば、コンパイル時は*enforce*セマンティクスで評価し（バグをなるべく検出）、実行時は*ignore*セマンティクスで評価し実行する（オーバヘッド最小化）、という選択は合理的なものとなりえます。

#### 契約アサーションとコンセプト/SFINAE

定数式における契約違反の定義に契約条件式が定数式で実行できない場合というのが含まれているのは、式が定数式で実行できるかどうかによってSFINAEすることを防止するためです。

C++26 Contractsの設計原則の中には「コンセプトは契約を認識しない」というものがあり、契約アサーションの存在が（コンセプトだけではなく）コンパイル時のプロパティに影響を与えないように設計されています。

そのため、契約アサーションの存在あるいはその評価セマンティクスの違いによって

- コンセプトが満たされるかどうか
- SFINAEの結果
- オーバーロード解決の結果
- `if constexpr`の分岐結果
- `noexcept`演算子の結果

が変化することはありません。

ある関数に契約アサーションを追加してもその周辺でのコンパイル時のプロパティは追加前と変化せず、評価セマンティクスの選択が変わった時でも変化せず、契約アサーションを取り除いても変化することはありません。

ここでは詳細は説明しませんが、これを徹底するために定数初期化ができるかどうかの判定および定数初期化式の実行に際して少し変わったことをしています（P2900R14 3.5.12 Constant Evaluation で詳しく説明されています）。

### 契約違反ハンドラ

契約アサーションがどのように評価されるのかは評価セマンティクスによって制御されることは分かりました。次は、評価された後、特にObserveとEnforceの2つのセマンティクスにおいて評価された後にどう振舞うかの部分を見ていきます。

この評価後のセマンティクスは、**契約違反ハンドラ（*contract-violation handler*）**というものによって定義されています。以下この記事では契約違反ハンドラの事を単に違反ハンドラと呼びます。


違反ハンドラそのものにもpre/postを指定できる

デフォルトの違反ハンドラの動作

#### 契約条件式の評価中の例外

#### `<contracts>`

### 特殊な関数等に対する契約アサーションの扱い

ここまででC++26 Contractsの基本的な解説は完了しました。ここまでの例はほぼすべて普通の関数で例示してきているため、普通ではない関数と契約アサーションがどのように相互作用するのかをここで見ていきます。ここの章での契約アサーションとは、ほぼ事前条件と事後条件の事です。`contract_assert`は文が書ける場所には書くことができて、その外側の関数がなんであるかに関わらず使用することができます。

#### 仮想関数

C++26 Contractsでは仮想関数に対する契約アサーションの指定は禁止されています。

元になった提案であるP2900ではかなり直前のリビジョンまで残っていたのですが、継承時契約アサーションの継承とその評価方法について合意を得ることができず、C++29以降の機能として検討していくためにC++26では禁止されました。

#### ラムダ式

ラムダ式に対しても契約アサーションを指定できます。指定する場所も通常の関数同様本体の直前、`requires`の後です。

```cpp
[](const int x) -> int
  pre (x != 1)
  post(r : r == x && r != 2)
{
  contract_assert(x != 3);

  return x;
};
```

このように指定された事前条件と事後条件は、クロージャ型の関数呼び出し演算子（`operator()`）に指定されたものとして扱われます。そのほかのルールも通常の関数とほぼ同様になります。

ラムダ式特有の注意点は、契約アサーションからラムダ式外部の変数を参照しているときでも、それが暗黙キャプチャをトリガーしないことです。したがって、契約アサーションだけで使用されており、ラムダ式内の他の部分で使用されていない外部変数の使用はコンパイルエラーとなります。

```cpp
static int i = 0;

void test() {
  auto f1 = [=] pre(i > 0) {  // ok、グローバル変数の参照（キャプチャ不要）
  };

  int i = 1;

  auto f2 = [=] pre(i > 0) { // ng、iを暗黙キャプチャできない
  };

  auto f3 = [i] pre(i > 0) { // ok、iは明示的にキャプチャされている
  };

  auto f4 = [=] {
    contract_assert(i > 0); // ng、iを暗黙キャプチャできない
  };

  auto f5 = [=] {
    contract_assert(i > 0); // ok、iは契約アサーション以外で暗黙キャプチャされている
    (void)i;
  };

  auto f6 = [=]
    pre([]{
        bool x = true;
        return [=]{ return x; }(); // ok、xは暗黙キャプチャされている
      }()
    ){
  };
}
```

ラムダ式の契約アサーションから外部の変数を参照しキャプチャが必要な場合は、明示的にキャプチャするか、ラムダ式の他のところで参照するようにしましょう。

これは、契約アサーションの存在がクロージャ型のコンパイル時プロパティに影響を与えないようにするためです。

#### コンストラクタ/デストラクタ

コンストラクタ/デストラクタに対しても契約アサーション（事前条件と事後条件）を指定できます。ただし、通常の関数とは異なり、コンストラクタ/デストラクタはクラスのメンバの初期化と破棄を担うものであるため、評価のタイミング等について注意すべき部分があります。

特に、コンストラクタの事前条件およびデストラクタの事後条件の評価タイミングは次のようになります

1. コンストラクタの事前条件 : コンストラクタ引数の初期化後、すべての非静的メンバが初期化される前
    - 関数`try`ブロックやメンバ初期化子リストを含めた関数本体の評価前
2. デストラクタの事後条件 : すべてのサブオブジェクト（基底クラスおよび非静的メンバ）が破棄された後

したがって、これらの場所の契約アサーションからそのクラスのメンバにアクセスすると未定義動作となります。特に、派生クラスの一部としてコンストラクタ/デストラクタが実行されている場合、派生クラスオブジェクトは初期化前/破棄後でありいずれにせよ生存期間外にあるため、`dynamic_cast`や`typeid`等動的型に依存する処理も未定義義動作となります。

これらの場所の契約アサーションにおけるメンバアクセスリスクを軽減するために、これらの場所では非静的メンバ名を直接使用できないようになっています。どうしてもアクセスしたい場合は`this->`を明示することでアクセス可能ですが、この場合でも安全に使用可能なのはそのアドレスくらいです。

```cpp
struct X {
  int i = 0;

  X()
    pre (i == 0)          // ng、メンバ変数名を使用できない
    pre (this->i == 0)    // UB、メンバ変数は初期化前
    pre (check(&this->i)) // ok、メンバ変数のアドレスは使用可能
    post (i == 0)         // ok、コンストラクタ事後条件は通常通り
  {}

  void f()
    pre (i == 0)    // OK
    post (i == 0);  // OK

  ~X()
    pre (i == 0)              // ok、デストラクタ事前条件は通常通り
    post (i == 0)             // ng、メンバ変数名を使用できない
    post (this->i == 0)       // UB、メンバ変数は破棄済
    post (check(&this->i));   // ok、メンバ変数のアドレスは使用可能
};
```

これ以外の部分は通常の関数の契約アサーションと同じです。

#### `default`/`delete`な関数

ほとんどの場合コンストラクタやデストラクタが該当しますが、最初の宣言で`default`指定されている関数に対する事前条件/事後条件の指定は禁止されています。

```cpp
struct X {
  X() pre (true) = default; // ng、defaultな関数にpre()を指定できない
};

struct Y {
  Y() pre (true); // ok
};


Y::Y() pre (true) = default;  // ok、最初の宣言ではない（pre(true)は省略可能
```

これは特殊メンバ関数のトリビアル性と契約アサーションの評価で矛盾が生じることを回避するためです。とはいえ、最初の宣言でなければ指定できてしまうようですが・・・

これと同様に、`delete`指定されている関数宣言に対する事前条件/事後条件の指定も禁止されています。

```cpp
struct X {
  X() pre (true) = delete; // ng
};
```

こちらはコンストラクタやデストラクタだけでなく通常の関数でもです。

#### コルーチン

コルーチンにも契約アサーション（事前条件と事後条件）を指定することができます。ただし、それはコルーチンそのもの（サスペンド時やその解除時、コルーチンの終了時など）に対するものではなく、ランプ関数と呼ばれるコルーチンを起動する関数に対する契約になります。

コルーチンのランプ関数とは、コルーチンになっている関数を呼び出した際にまず呼び出される、コルーチンを起動するための関数です。このランプ関数はコルーチンステートを初期化してコルーチン起動して最初のサスペンド地点まで進めてから、その関数の戻り値型として表示されているコルーチン型（コルーチンハンドルを保持している型）のオブジェクトを返して終了します。

コルーチンに対する事前条件と事後条件はこのランプ関数に対する事前条件と事後条件となります。したがって、コルーチンに対する事前条件と事後条件はユーザーが記述したコルーチン処理の`co_yield`や`co_return`に適用されるわけではありません。

```cpp
// sequenceはコルーチンだとする
std::generator<int> sequence(int from, int to)
  pre (from <= to);

// このようなコルーチンとその契約は次のように書き換えた関数に対する契約アサーションとほぼ等しい

// コルーチン実装詳細
std::generator<int> sequence_impl(int from, int to);

// 非コルーチン、疑似ランプ関数
std::generator<int> sequence_ramp(int from, int to)
  pre (from <= to)
{
  return sequence_impl(std::move(from), std::move(to));
}
```

この例のコルーチン`sequence()`には事前条件が指定されていますが、それは通常の関数によって書きかえた後の`sequence_ramp()`の様な関数に対して同じ契約アサーションを指定している場合と同じように扱われます（あくまでこれはイメージです）。

コルーチンに対する事前条件と事後条件の評価の順序は次のようになります

- 事前条件 : 関数引数の初期化後、コルーチンステートの初期化処理の前
    - 特に、関数引数がコルーチンステートに格納される前
- 事後条件 : コルーチン戻り値の`return`時
    - ランプ関数の`return`時
    - コルーチン状態内のあらゆるものの破棄との間での順序は不定

コルーチンの事後条件では、コルーチン関数の戻り値（`co_yield`した値ではなく）に対して事後条件を指定することができます

```cpp
awaitable<int> cancelable_session(int id)
  pre (0 < id)
  post (r: is_cancelable(r)); // rはawaitable<int>オブジェクト
```

標準のコルーチン型（`std::generator`、`std::task`）はいずれもこのような状態をチェックする関数が無いのでできることは無いですが、ユーザー定義のコルーチン型では有用な場合もあるでしょう。

ただし、コルーチンではコルーチンステートの初期化時にその関数引数をすべて、値の場合は`const`修飾を無視して、コルーチンステート内にムーブして格納します。このため、事後条件から関数引数を参照することができません。

```cpp
std::execution::task<int> coro(const std::string str)
  pre(str.empty() == false)   // ok、事前条件からの関数引数の使用は安全
  post(str.empty() == false); // ng、コルーチン事後条件において関数引数を使用できない
```

`contract_assert()`にはこれらのような制限がなく、コルーチン内部で使用できコルーチンの制御フローの一部としてアサーションを行うことがでるのですが、契約条件式で使用できる式について少し制限があり、契約条件式でawait式/yield式を使用できません。

```cpp
std::generator<int> f() {
  contract_assert(((co_yield 1), true)); // ng
}

stdex::task<void> g() {
  contract_assert(0 < (co_await query_database())); // ng

  ...
}
```

ただしこれは、その直接のコルーチンに大して影響を与えるawait式/yield式が禁止されているだけで、そうでない場合は使用可能です。例えば、コルーチンになっているラムダ式の即時呼び出しが該当します

```cpp
contract_assert(([]()-> std::generator<int> {
  co_yield 1; // ok
}(), true));
```

これらの式の存在が関数をコルーチンにするため、これは`contract_assert()`に対する制限というよりはawait式/yield式に対する制限ではあります。この制限は、契約アサーションの評価セマンティクスの選択がコルーチンの動作を変更しないようにするためのものです。

#### 関数ポインタ

C++26 Contractsでは関数ポインタ/メンバ関数ポインタに対する契約アサーション（事前条件と事後条件）の指定はサポートされていません。

```cpp
typedef int (*fpt)(int) post (r: r != 0); // ng

int f(int x)
  post (r: r != 0);

int (*fp)(int) post (r: r != 0) = f;  // ng
int (X::*fptr)(int) post (r: r != 0) = &X::f; // ng
```

契約アサーションの指定はその型に影響を与えないため、どのようにアサーションをポインタに適用し、どのようにそれを伝播するのかなどの設計の検討がほとんど進んでいないためです。これも、C++29以降の機能として予定されています（が、おそらく関数ポインタにそのまま指定できるようにはならないでしょう）。

ただし、契約アサーションを持つ関数を関数ポインタに入れることはでき、その場合でも呼び出し時の契約アサーションは評価されます。

```cpp
int f(int x)
  pre(0 < x)
  post (r: r != 0);

int (*fp)(int) = f; // OK

fp(-1); // 契約違反が発生する
```

これはメンバ関数ポインタや`std::function`等ラッパを介した場合でも同様で、契約アサーションを持つ関数がそれらに格納されている場合、呼び出し時に契約アサーションは評価されます。

#### `main()`

`main()`関数にも事前条件と事後条件を指定することができます。

```cpp
int main(int argc, char *argv[])
  pre(2 < argc)
  post(r: r != 0)
{
  ...

  return 10;
}
```

評価等のルールにも特別なところはなく、通常の関数と同じように扱われます。

この例のようにプログラム引数に対して使用する以外にも、`main()`呼び出し前（あるいは終了前）のプログラムのより大域的な状態を検査するのにも使用できます。

### C++26の他の機能との相互作用

#### 未定義動作とObservable Checkpoints

C++26ではObservable Checkpointsという概念が導入されています。これはUBによるタイムトラベル最適化（コード上の因果関係を逆転するような最適化）を防止するためのチェックポイントであり、プログラムのある地点で発生したUBがObservable Checkpointsを超えてプログラムをUBにすることを防止するものです。

`std::observable()`およびI/O関数の呼び出しがObservable Checkpointsとして扱われますが、契約アサーションもObservable Checkpointsを導入します。

より正確には契約アサーションに関連して次のイベントがObservable Checkpointsとして扱われます

- 契約アサーション評価に際して、契約条件式の評価が開始されたこと
- *observe*セマンティクスで評価された契約アサーションから呼び出された違反ハンドラが正常にリターンしたこと

これによって、契約アサーション以降で発生したUBが契約アサーションを超えて波及し、契約アサーションそのものを消し去ったりその評価をスキップすることが禁止されます。

```cpp
volatile int i = 0;

void f(int *p) {
  if (p != nullptr) // #1
  {
    ++i;
  }

  contract_assert(0 <= *p); // p == nullptrの場合UB
}
```

この例では、`#1`の後の`contract_assert`が*ignore*セマンティクス以外で評価される場合、（Observable Checkpointsがないとすると）タイムトラベル最適化により`#1`のチェックが削除されるなどの事が発生しえます。

`contract_assert`の契約条件式評価開始地点がObservable Checkpointsになっていることで、契約アサーションの条件式にUBが含まれていたとしても、その契約アサーションよりも前にそのUBが波及するのを阻止します。

```cpp
void g(int *p) {
  contract_assert(p != nullptr); // #2

  ++(*p); // p == nullptrの場合UB
}
```

この例では、`#2`の`contract_assert`が*observe*セマンティクスで評価されている場合、違反ハンドラの呼び出しがリターンした後でも実行が継続されることでその後の`*p`が実行されUBになります。、（Observable Checkpointsがないとすると）タイムトラベル最適化により`#2`の契約アサーションそのものが削除される可能性があります。

*observe*セマンティクスによって呼び出された違反ハンドラのリターンがObservable Checkpointsになっていることで、契約アサーション以降のUBが契約アサーションそのものを削除することを防止します。このことは*observe*セマンティクスが契約違反発生後も実行継続する際のUBの影響を緩和します。

#### 標準ライブラリの堅牢化モード（Standard Library Hardening）

C++26では標準ライブラリに対して堅牢化モードというものが定義され、標準ライブラリの一部の事前条件が実行時にチェックされ、違反していたらプログラムが終了されるようになります。

ここまで似たような話を聞いてきたと思います。この堅牢化モードにはC++26 Contractsが使用され、Contractsの枠組みの中で標準ライブラリの実行時検査が行われます。

```cpp
int main() {
  std::vector vec = {1, 2, 3};

  int& r = vec[4];  // 堅牢化モードでは契約違反が発生し、プログラムが終了される
}
```

堅牢化モードにおける評価セマンティクスは*enforce*/*quick enforce*のどちらかが使用され、非堅牢化モードでは*ignore*セマンティクスが使用されます（*observe*セマンティクスは使用されません）。

- [P3471R4 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3471r4.html)
- [P3697R1 Minor additions to C++26 standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3697r1.html)
- [P3878R1 Standard library hardening should not use the 'observe' semantic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3878r1.html)

#### リフレクション

C++26 Contractsの設計原則として契約アサーションの存在が他のもののコンパイル時プロパティに影響を与えないというものがあることもあり、関数に指定された契約アサーション（事前条件と事後条件）をリフレクション（`^^`）を使用して取得する方法はありません。これはリフレクションを用いて関数をコピーする際にコピーできないプロパティがあるということでもあります。

一応検討はされているようですが、どうなるかはまだよく見えていません。

### 標準化の話

#### C++29以降の展望

C++ Contractsは当然これで終わりではありません。もともと、C++20で議論紛糾の末に標準からいったん削除された後、合意可能な最小の共通仕様（minimal viable product(MVP)）としてのContractsとして設計されたものがC++26 Contractsになっています。

ここで見てきた中でも

- 仮想関数に対する契約
- 関数ポインタに対する契約

などはC++29以降に導入する予定です。他にも、契約アサーションへのラベル指定機能（[P3400R1 Specifying Contract Assertion Properties with Labels](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3400r1.pdf)）などの機能拡張も検討中です。

さらに進んで、ContractsをC++における未定義動作/エラー性動作のハンドリングに使用するという構想も検討されています。

- [P3100R5 A framework for systematically addressing undefined behaviour in the C++ Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r5.pdf)
    - [P3100R0 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3100R0-Undefined-and-erroneous-behaviour-are-contract-violations)

関連して、違反ハンドラをより活用しようとするアイデアもあります

- [契約プログラミング機能の違反ハンドラ - 地面を見下ろす少年の足蹴にされる私](https://onihusube.hatenablog.com/entry/2025/03/30/232511)

#### 実装定義について

C++26 Contractsの仕様及びここでの説明においては実装定義（*Implementation defined*）あるいは推奨（*Recommended practice*）という言葉が目に付いたかもしれません。動作を突き詰めていくとその最後の部分は実装定義とされていることは実際に多く、これはC++26 Contractsの元の提案P2900に対して度々投げかけられた批判でもありました。

ただ、この実装定義は標準が何も規定していないとか保証していないということでは全くないことを誤解しないでください。Contractsの理念や目的は提案文書等を通じて説明されているため、標準がその動作やセマンティクスを実装任せにしているというよく見られる批判はことContractsには当たりません。

ではなぜこれほど実装定義な項目が多いのかというと、それはContracts機能をC++が使用可能な場所の全てとは言わないまでもなるべく多くの環境で使用できるようにするためです。

C++の実行環境は、指先サイズのマイコンからスーパーコンピューターまで多様なハードウェアに及んでおり、そこで動作するプログラムに対する要件も様々なものがあります。ある環境では実行リソースが潤沢である程度リッチな機能を実行できる一方で、別の環境では厳しくリソースが制限され標準出力すら持たないことがあります。またある環境ではプログラムの実行停止を可能な限り回避することが求められることもあれば、セキュリティの目的のために実行時エラーが検出されたら最速でプログラムを終了する必要があることもあります。

C++26 Contractsの動作、とくに契約アサーションのセマンティクスの細部を細かく規定すると、それによってContractsを使用できなくなる実装が発生します。上記例に挙げたように相反する要件がある場合もあります。そういった実装の事を顧みずに仕様を決めてしまえばContracts機能の普及が妨げられ、使えない環境では永遠に使うことができなくなります。特に、Contracts機能はC++プログラムの正確性を向上させるために重要な機能であり、強く待ち望まれている機能でもあるため、標準仕様としてのそのような振る舞いはC++に対する失望を招きます。

C++26 Contracts仕様にある実装定義とは、こうした多様な実装・環境・要件をなるべく受け止めるための抽象化層です。無計画に実装定義としているわけではなく、Contractsが全体としてどういう機能であるかということはしかっりと説明・規定された上で、最後の最も実装に近い部分においての振る舞いの部分を実装定義としておくことで様々な要件を吸収しようとしています。C++26 Contracts仕様の実装定義はかなり慎重に検討され配置されています。

#### C++26 Contractsの設計について興味のある人へ

C++26 Contractsの仕様そのものの直接の提案は[P2900R14](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2900r14.pdf)ですが、これに至るまでの間に、それこそP2900R0以前にも、いくつもの関連提案があります。すべてを列挙することは困難ではあるものの、それらの提案とその議論の過程にはC++26 Contractsの設計がなぜこのようになったのかについての重要な情報が残されています。

このような議論の過程については、C++26 Contractsを主導した人々によってP2899R1という文書にまとめられています。この文書にはC++26 Contracts成立の過程が詳しく記されています。興味がある人は見てみるとよいでしょう（169Pありますが）。

- [P2899R1 Contracts for C++ - Rationale](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2899r1.pdf)

### 参考文献

- [P2900R14 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2900r14.pdf)
- [P2899R1 Contracts for C++ - Rationale](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2899r1.pdf)
- [P3819R0 Remove `evaluation_exception()` from contract-violation handling for C++26](https://open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)
- [P3460 C++ Contracts Implementers Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3460r0.pdf)
- [P3328R0 Observable Checkpoints During Contract Evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3328r0.pdf)
