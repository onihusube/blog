# ［C++］WG21月次提案文書を眺める（2024年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-12)

全部で166本あります。

もくじ

[:contents]


### [N4977 2025-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4977.pdf)

2025年11月にハワイのコナで行われる全体会議のインフォメーション。

予定（2025年11月3日～8日）と場所、ホテルの案内などが記載されています。

### [N4995 WG21 agenda: 18-23 November 2024, Wroclaw, Poland](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4995.html)

2024年11月にヴロツワフで行われた会議のアジェンダ。

### [N4997 Hagenberg Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4997.pdf)

2025年2月にオーストリアのハーゲンベルクで行われる全体会議のインフォメーション。

予定（2025年2月10日～15日）と場所、ホテルの案内などが記載されています。

### [N4998 WG21 2024-11 Wroclaw Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4998.pdf)

2024年11月6日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Wroclaw会議で何をするかなどの報告がなされています。

### [N4999 WG21 agenda: 10-15 February 2025, Hagenberg, Austria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4999.html)

2025年2月にハーゲンベルクで行われる会議のアジェンダ。

### [N5000 WG21 November 2024 Hybrid meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5000.pdf)

2024年11月にWroclawで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N5001 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5001.pdf)

C++26のワーキングドラフト第7弾

### [N5002 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5002.html)

↑の変更点をまとめた文書。

### [N5003 2025 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5003.pdf)

2025年に行われる、WG21管理者ミーティングの予定表。

### [P0178R1 Allocators and swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0178r1.pdf)

アロケータが等価ではない場合のコンテナ間`swap`を未定義動作ではなくする提案。

C++17で導入された`polymorphic_allcoator`のように、状態を持つアロケータにおいては同じアロケータ型のアロケータオブジェクト同士の比較が必ずしも`true`にはなりません。その場合、そのようなアロケータ同士を保持するコンテナの`swap`は未定義動作となります。

`swap`は単にコンテナの内部ハンドルを交換するだけで済み、アロケータが等価であればアロケータそのものの交換作業は不要になります。しかし、アロケータ等価ではない場合にそのような`swap`を行ってしまうと交換後のコンテナでは、そのメモリ領域を解放する能力のないアロケータとそのアロケータから取得されていないメモリ領域がペアになった状態になり、この状態では正しくリソース解放が行われなくなります。

C++11以前には状態を持つアロケータがサポートされていなかったため、標準のコンテナのデフォルト動作はアロケータの不一致を考慮しない`swap`（すなわち、アロケータ以外の内部ハンドル等の`swap`）を行います。C++11では状態を持つアロケータがサポートされたものの、`propagate_on_container_swap`が`true_type`の場合にのみ`swap`操作でアロケータが伝播する事を期待できますが、`std::allocator`は（および`std::allocator_traits`、`std::pmr::polymorphic_allcoator`も）これを定義しないため、標準コンテナのアロケータはステートフルなものが指定されても`propagate_on_container_swap`が`true_type`で定義されていなければアロケータが等価ではない場合の`swap`は未定義動作となります。

これはおそらく、以前からコンテナ`swap`の要件が定数時間であることも関係していると思われます。

いずれにしても、標準のコンテナはほとんどの場合にアロケータが等価ではない場合の`swap`を未定義動作としています。

`std::swap()`は広い契約をもつ関数であるものの、標準のコンテナの`swap`操作は`std::swap`の各コンテナによるオーバーロードを通してカスタマイズされており、各コンテナの`swap`（メンバ関数）はこのアロケータ不一致に関するより狭い契約を持ちます。これは、広い契約を持つ関数を狭い契約をもつ関数で置き換えており、

これによりユーザーは、アルゴリズム等のジェネリックなコードにおいてコンテナの`swap`を行う場合に、それが標準のコンテナであるかどうか（アロケータの不一致をケアする必要があるかどうか）、すなわち`std::swap`の契約とは異なる契約になっていないかを考慮する必要があります。

この現状に対してこの提案は、標準のコンテナの`swap`がアロケータが等価ではない場合でも未定義動作とならないようにすることを提案するものです。

標準のコンテナのアロケータと`swap`の関係は現在次のようになっており

|swap時の伝播可能性＼実行時等価性|アロケータが等価|アロケータが等価ではない|
|---|:-:|:-:|
|`propagate_on_container_swap`有効|✅|✅|
|`propagate_on_container_swap`無効|✅|☠|

この提案は、この表の右下の部分をwell-formedにしようとしています。

具体的には、アロケータが等価ではなく`propagate_on_container_swap`も無効な場合には要素ごとのムーブによってアロケータが一致するように要素を交換する事を要求するようにします（同時に、計算量の要件も緩和します）。そのほかの場合の動作は現状通りで変更しません。

とても簡易には次のような実装になります

```cpp
void CONTAINER_TYPE::swap(CONTAINER_TYPE & other) {
  if( std::allocator_traits<allocator_type>::propagate_on_container_swap
   || std::allocator_traits<allocator_type>::is_always_equal
   || this->get_allocator() == other.get_allocator()) {
    // trust compiler will optimize the compile-time branching
    // take the fast path

    if constexpr(std::allocator_traits<allocator_type>::propagate_on_container_swap) {
      using std::swap;
      swap(this->get_allocator(),other.get_allocator());
    }
  }
  else if constexpr( all traits are consistent ) {
    CONTAINERbuffer{std::move(other)};
    other = std::move(*this);
    *this = std::move(buffer);
  }
  else {
    //Copy into buffer having the right allocator
    CONTAINERbuffer_this {std::move(other), this->get_allocator()};
    CONTAINERbuffer_other{std::move(*this), other.get_allocator()};

    this->swap(buffer_this);
    other.swap(buffer.other);
  }
}
```

この提案の根拠としては、ブルームバーグ社内コードベースでの10年以上に渡るステートフルアロケータと標準ライブラリの使用経験において、提案するような動作を保守し続けており、現在でもその動作をサポートする理にかなったユースケースが存在している事を確認している事を挙げています。少なくともブルームバーグ社内のユーザーは、線形時間かつ例外を送出しうる`swap`と未定義動作のどちらかの選択を迫られたときに明確に前者を選択している、としています。

- [C++ named requirements: AllocatorAwareContainer (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer)
- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P0260R12 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r12.html)
### [P0260R13 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r13.html)
### [P0447R27 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r27.html)
### [P0447R28 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r28.html)
### [P0472R3 Put std::monostate in <utility>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0472r3.pdf)
### [P1040R7 std::embed and #depend](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1040r7.html)
### [P1061R10 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r10.html)
### [P1928R13 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r13.pdf)
### [P1928R14 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r14.pdf)
### [P1928R15 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r15.pdf)
### [P1967R13 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1967r13.html)
### [P2014R1 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r1.pdf)

↓

### [P2014R2 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r2.html)

コルーチンステートを割り当てる際の`operator new`呼び出しの際に、`std::align_val_t`を考慮するようにする提案。

この提案は、C++20のNBコメントUS061とUS063で提起された問題に対する解決策を提案するものです。

コルーチンが最初に呼びされた時にコルーチンステートを確保しようとする際に、プロミス型のコンテキストおよびグローバルな`operator new`を探索しますが、その際に`std::align_val_t`を取るオーバーロードを考慮していません。それによって、コルーチンの引数やプロミス型など、コルーチンフレームに保存されるものの中にオーバーアライメントされたものが含まれている場合などに正しくアラインされない可能性があります。

US061とUS063はどちらもこの問題の解決を求めるものであり、この提案のR0ではそのためのオプションを2つ提案していました

1. 割り当てるストレージが*new-extended*アライメントを要求する場合にのみ、 `std::align_val_t`オーバーロードを優先する
    - 利点: `new/delete`式の動作とより一貫している
    - 欠点: コルーチン開始時の`operator new`探索のルールが複雑化し、2回探索する必要がある。また、`std::align_val_t`オーバーロードを呼び出すかどうかの選択がコルーチンフレームのレイアウトが判明するコンパイルフェーズの後半まで延期しなければならなくなる
2. コルーチンフレームや*new-extended*アライメントを要求するかに関係なく常に`std::align_val_t`オーバーロードを優先する
    - 利点: より単純
    - 欠点: `new/delete`式の動作と矛盾する

そして、EWGでの議論の結果オプション1が選択されています。

オプション1でのコルーチン開始時（初期化時）にコルーチン用の追加の記憶域を確保する必要がある場合に行われる2段階の探索は次のようになります。

---

まず、その記憶域は非配列の`operator new`を呼び出すことで確保され、使用する`operator new`はプロミス型のコンテキストで探索され、その結果何らかの関数が見つかった場合、その集合からオーバーロード解決を次のように行う

1. 最初のオーバーロード解決は、引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 第二引数はコルーチンステートのアライメントであり、`std::align_val_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
        - 依存型ではない = 第二引数がテンプレートパラメータによって指定されていない
    - 見つからなかった場合、最初の2つの引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
2. 第二のオーバーロード解決は、再度引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する
    - 見つからなかった場合、第一引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する

`operator new`がプロミス型のコンテキストで見つからなかった場合、*overaligned-allocation-function*を` ::operator new(std::size_t, std::align_val_t)`で、*normal-allocation-function*を`::operator new(std::size_t)`で定義する。

そして、コルーチンステートが*new-extended*アライメントを持ち、かつ*overaligned-allocation-function*が見つかっている場合、コルーチンステートは*overaligned-allocation-function*の呼び出しによって確保される。そうではない場合で*normal-allocation-function*が見つかっている場合、コルーチンステートは*normal-allocation-function*で確保される。それ以外の場合はill-formed。

---

現在の仕様は、プロミス型のコンテキストでは2番目のオーバーロード解決フェーズのみを行い、またグローバルスコープの探索では`std::size_t`型の引数だけを用いてオーバロード解決を行い、そこで見つかった関数がそのまま使用されます。

なお、コルーチンステートを解放する`operator delete`も同様に`std::align_val_t`オーバロードを考慮するように修正されます。とはいえ`new`の場合ほど複雑ではなく

1. プロミス型のコンテキスト -> グローバルスコープ の順で`operator delete`を探索
2. プロミス型のコンテキストで見つかった候補の中に*destroying operator delete*が含まれている場合、ill-formed
3. コルーチンステートが*new-extended*アライメントを持つ場合、`std::align_val_t`型の引数を取るオーバーロードが優先される
4. そうではない場合、`std::align_val_t`型の引数を取らないオーバーロードが優先される
5. 優先される候補以外の候補は削除され、残った候補のうちでは`std::size_t`型の引数を取るものが取らないものよりも優先される

のようになっています。

なお、この提案はCWGのレビュー中だったものの、著者の方がこれ以上追及されないとして、取り下げられているようです。

- [US061 09.04.4 p10 Coroutine allocation should consider std::align_val_t P2014](https://github.com/cplusplus/nbballot/issues/60)
- [US063 09.04.4 Coroutine allocation should consider std::align_val_t](https://github.com/cplusplus/nbballot/issues/62)
- [コルーチン [P0912R5] - cpprefjp](https://cpprefjp.github.io/lang/cpp20/coroutines.html)
- [P2014 進行状況](https://github.com/cplusplus/papers/issues/750)

### [P2319R3 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r3.html)
### [P2319R4 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r4.html)
### [P2645R1 path_view: a design that took a wrong turn](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2645r1.html)
### [P2656R4 WITHDRAWN: C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2656r4.html)
### [P2686R5 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r5.pdf)
### [P2688R4 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r4.html)
### [P2717R6 WITHDRAWN: Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2717r6.html)
### [P2781R5 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2781r5.html)
### [P2786R9 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r9.pdf)
### [P2786R10 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r10.pdf)
### [P2786R11 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r11.html)
### [P2825R3 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r3.html)
### [P2830R5 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r5.html)
### [P2830R6 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r6.html)
### [P2830R7 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r7.html)
### [P2835R7 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r7.html)
### [P2846R5 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r5.pdf)
### [P2863R8 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r8.html)
### [P2865R6 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2865r6.pdf)
### [P2866R5 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2866r5.pdf)
### [P2897R6 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r6.html)
### [P2897R7 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r7.html)
### [P2900R11 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r11.pdf)
### [P2900R12 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r12.pdf)
### [P2996R8 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r8.html)
### [P3008R3 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r3.html)
### [P3016R5 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r5.html)
### [P3019R11 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r11.pdf)
### [P3037R4 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r4.pdf)
### [P3045R4 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r4.html)
### [P3050R3 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r3.html)
### [P3051R3 WITHDRAWN: Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3051r3.html)
### [P3068R5 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r5.html)
### [P3068R6 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r6.html)
### [P3074R5 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r5.html)
### [P3096R4 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r4.pdf)
### [P3096R5 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r5.pdf)
### [P3098R1 Contracts for C++: Postcondition captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3098r1.pdf)
### [P3111R1 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r1.html)
### [P3111R2 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r2.html)
### [P3117R1 Extending Conditionally Borrowed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3117r1.html)
### [P3125R2 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r2.html)
### [P3136R1 Retiring niebloids](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3136r1.html)
### [P3138R4 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r4.html)
### [P3138R5 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r5.html)
### [P3146R2 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r2.html)
### [P3149R7 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r7.html)
### [P3149R8 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r8.html)
### [P3152R1 Add missing constructors and assignment for indirect and polymorphic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3152r1.html)
### [P3179R4 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r4.html)
### [P3185R0 A proposed direction for C++ Standard Networking based on IETF TAPS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3185r0.html)

C++のNetworkライブラリの基礎的な設計の指針として、IETFのTAPSを基礎とする提案。

IETFのTAPS（Transport Services Application Programming Interface）とは、いわゆるソケット通信をはじめとするトランスポートプロトコルのAPIを再定義するもので、ネットワーク通信を必要とするアプリケーションにネットワーク機能を提供するための、特定の言語やプロトコルに依存しない抽象アーキテクチャを定義することを目的としているものです。

この提案ではC++の将来のNetwork標準ライブラリのAPIや設計をこのTAPSと整合するものにする事を提案しています。その理由としては

- 言語に依存しないAPIを提案しており、なおかつNetworking TSの欠けている機能として挙げられている領域をカバーしている
    - 名前付き接続（DNS解決など）
    - トランスポート層セキュリティ
- 既存のネットワークAPI（Berkeley Socketsからの派生など）の概念やそれに対応する命名規則に一貫性がないという問題に対処しようとしている
    - 現在のネットワークライブラリでは、同じものを表す概念やAPI名が歴史的経緯や使用するプロトコルによって大きく異なる
- TAPSアーキテクチャはアプリケーションとトランスポート間のインターフェースを再定義し、アプリケーションとの契約を根本的に変えることなくトランスポート層を進化させることを目指している
- TAPS勧告は、一般的なユースケースをシンプルかつ一貫性のあるものにしつつ、トランスポート層をよりきめ細かく制御する必要があるアプリケーションに対してはその方法を提供する事を目的としている

などが挙げられています。

Networking TSを含む従来のソケット通信のモデルは次のように説明できます

- ソケットAPIを用いて接続を作成し、データを転送する
- ソケットAPIは、TCPおよびUDPプロトコルの実装へのインターフェースを提供する
    - 実装は通常、システムカーネルによって提供される
- TCP/UDP実装はネットワーク層インターフェースを介してデータを送受信する
- ソケットは、トランスポート層およびネットワーク層のアドレスに直接バインドされる
    - これらのアドレスは通常、システムが提供するDNSスタブリゾルバによって実行される別の解決手段によって取得される

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
        |                 |                  |
  +------------+     +------------+    +--------------+
  |  DNS stub  |     | Stream API |    | Datagram API |
  |  resolver  |     +------------+    +--------------+
  +------------+          |                  |
                    +---------------------------------+
                    |    TCP                UDP       |
                    |    Kernel Networking Stack      |
                    +---------------------------------+
                                    |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

これに対して、TAPSのAPI構造は次のようになっています

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|              Transport Services API                 |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|          Transport Services Implementation          |
|  (Using: DNS, UDP, TCP, SCTP, DCCP, TLS, QUIC, etc) |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

TAPSのAPIは、接続の作成とデータ転送のためのインターフェースを定義し、複数のインタラクションパターンのインターフェースを定義したものです。そして、このAPIは特定のプロトコルに特化したものではなく、より汎用的に様々なプロトコルをサポートすることができ、初期セットとしてTCP/UDPのみに限定しても将来的にQUICなどのプロトコルにライブラリを拡張可能です。

名前解決を接続の確立とデータ転送と組み合わせていることで、このAPIの実装（それは各実装のQoIとされる）はより柔軟なものになっています。

そして、従来のソケットベースAPIとの重要な違いは、TAPS APIはデフォルトで非同期かつイベント駆動型であることです。アプリケーションへのデータ転送を表現するためにメッセージという抽象的な概念を用いています。また、アプリケーションがネットワークエンドポイント識別子を解決して複数のアドレス・プロトコル・パスを記述して、これらのストリームを同時に扱う方法を記述しています。

提案にはもう少し詳しくTAPS APIの特徴が紹介されています。

この提案ではSG4に対して、Networking TSの大規模再設計を行うべきか、このTAPS APIのようなより現代的な規範に従うか、の選択を迫っています。

- [RFC 9621 - Architecture and Requirements for Transport Services](https://datatracker.ietf.org/doc/rfc9621/)
- [RFC 9622 - An Abstract Application Programming Interface (API) for Transport Services](https://datatracker.ietf.org/doc/rfc9622/)
- [RFC 9623 - Implementing Interfaces to Transport Services](https://datatracker.ietf.org/doc/rfc9623/)
- [P3185 進行状況](https://github.com/cplusplus/papers/issues/2145)

### [P3204R0 Why Contracts?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3204r0.pdf)

C++ Contractsに対する疑問の声に応える文書。

P2900R7がSG21からEWGに転送され、より広い委員会メンバに提示されたときに、Herb Sutterさんが（おそらくMSを代表する形で）2つの質問事項を提示したようです。この文書はそれを受けて、それ（+1）に対する回答を行うとともにそれを文書の形で残して公開しておくためのものです。

ここで回答されているのは次の3つの質問です

1. 契約プログラミングという概念そのもの及びその言語実装は何十年も前から利用可能であるにもかかわらず、あまり主流ではない。にもかかわらず、C++における契約プログラミング機能が成功すると確信する根拠は何か？
2. C++0xのコンセプトは標準ライブラリに適用してみようとするまでは素晴らしいものに見えていた。Contractsの標準化は標準ライブラリでどのように使用されるかを特定せずに成功するか？
3. 現在の環境において、委員会の中で多くの安全性向上に関する提案が競合している中で、なぜContractsが優先されるべきか？

それぞれに対する回答を要約すると

1. C++ Contractsは既に成功しており、この機能は最初から既存および将来の機能との強力な統合によって既存の全ての機能の優れた代替手段を提供することを目指して設計されている
    - P2900のContracts機能は現在マクロベースで広く利用されているアサーション機能の既存の実践に進化型であり、それら既存のアサーション機能は様々な形と場所で実装され広く使用されており、Contractsがすぐに提供する機能や将来的に提供しようとする機能のほとんどはすでに利用されている
    - 重要なのは、Contractsではそれらマクロベースの既存機能の持つ問題点の多くを修正しており、それらのライブラリサイドでは対処できない問題を解消していることによって、既存のアサーション機能のすべてにとって魅力的な移行先となること
    - 特に、P2900の設計原則の1つである「契約注釈の存在及びその評価は、プログラムの正当性を変更するべきではない」という原則によって、契約注釈をプログラムに追加することでプログラムの正当性を検証することができ、なおかつ既存のプログラムに容易に導入可能となる
    - そして長期的な目標として、プログラムの正しさを担保するアノテーションを付与するための強固な基盤を提供し、それによってプログラムの正しさを堅牢に静的解析することを可能にする、というものがある
2. Yes、なぜなら、C++コミュニティはContractsの様な契約チェックを最新の標準ライブラリ実装を含む既存のライブラリで使用してきた豊富な経験を持っているため
    - さらに、標準ライブラリの仕様はC++20の頃から、契約と契約チェック機能を意識して記述されている
    - ただし、現在の標準ライブラリ実装が持つマクロベースのソリューションによって契約チェックを提供することをすぐにやめる（事を促す）べきではなく、ライブラリがコア言語に移行する準備ができ、その意思があり、移項できる状態にあることを前提に契約アサーションを標準ライブラリ仕様に盛り込むことは標準というものに対して無責任な行為である
        - 当面の間（おそらくは無期限に）、ライブラリ実装が正確性のチェックにContracts機能を使用するかしないか、あるいはまったくチェックしないかどうかは実装のQoIとしておくべき
3. Contracts機能は、安全性を脅かす未定義動作の根本的なバグに対処するための基盤的なソリューションである
    - 未定義動作を悪用することで発生するCVEの問題は、ほぼ同語反復的にそのような問題の発生を可能にするソフトウェアバグの結果である
    - 未定義動作の悪用を防ぐことは症状に対処することであって、バグを含むプログラムこそが真の問題であるはず
    - Contracts及び契約プログラミングの概念は、そのようなバグを識別しその発生源を軽減する方法を提供する
    - そして、Contracts機能による契約注釈の導入は、あらゆる品質のコードベースへの導入に当たって可能な限り障害が少なくなるように設計されている。これによって、レガシーコードベースを段階的に修正していくことが可能となる
        - さらに、レガシーコードベースにまず契約注釈を導入していくことで、開発者はそのコードベースの意味を把握できるだけでなく、その動作を明文化し、期待通りに動作しなかった場合にそれを継続的に補足することができる
    - したがって、契約チェックは最新のコンパイラでコンパイル可能なあらゆるC++プログラムで利用可能な正確性向上への入り口となる

より詳細な回答は文書を参照してください。もっと良いことが書いてあります。

- [P3204 進行状況](https://github.com/cplusplus/papers/issues/2146)

### [P3222R1 Fix C++26 by adding transposed special cases for P2642 layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r1.html)
### [P3227R1 Fixing the library API for contract violation handling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3227r1.pdf)
### [P3230R1 views::unchecked_(take|drop)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3230r1.html)
### [P3232R1 User-defined erroneous behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3232r1.html)
### [P3237R2 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r2.pdf)
### [P3247R2 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r2.html)
### [P3261R2 Revisiting `const`-ification in Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3261r2.pdf)
### [P3284R2 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r2.html)
### [P3287R2 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r2.pdf)
### [P3296R3 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r3.html)
### [P3299R3 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r3.html)
### [P3309R3 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
### [P3310R5 Solving issues introduced by relaxed template template parameter matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r5.html)
### [P3319R2 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3319r2.pdf)
### [P3323R1 cv-qualified types in atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
### [P3325R4 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r4.html)
### [P3325R5 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r5.html)
### [P3329R0 Healing the C++ Filter View](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3329r0.pdf)
### [P3335R3 Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r3.html)
### [P3335R4 WITHDRAWN: Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r4.html)
### [P3339R1 WITHDRAWN: C++ Ecosystem IS Open License](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3339r1.html)
### [P3342R1 Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r1.pdf)
### [P3342R2 WITHDRAWN: Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r2.html)
### [P3355R2 Fix submdspan for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3355r2.html)
### [P3367R1 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r1.html)
### [P3367R2 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r2.html)
### [P3371R3 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r3.html)
### [P3378R1 constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3378r1.html)
### [P3380R1 Extending support for class types as non-type template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3380r1.html)
### [P3383R1 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3383r1.html)
### [P3385R2 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3385r2.html)
### [P3386R1 Static Analysis of Contracts with P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3386r1.pdf)
### [P3396R1 std::execution wording fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3396r1.html)
### [P3409R1 Enabling more efficient stop-token based cancellation of senders](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3409r1.html)
### [P3422R1 Allow main function in named modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3422r1.html)
### [P3424R0 Define Delete With Throwing Exception Specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3424r0.pdf)

`delete`演算子オーバーロードが例外を送出しうる例外仕様を持つことを禁止する提案。

`operator delete`はユーザーによって明示的に`noexcept(false)`等と指定されない限り、デフォルトで`noexcept`になります。`noexcept(false)`と明示的に指定して例外を投げられるようにすることもできるのですが、その場合の振る舞いは未定義動作となります。したがって、`operator delete`に例外を送出しうる例外仕様を指定する有効なユースケースは存在していません。

そのため、この提案では`delete`演算子オーバーロードに対する例外を送出しうる例外仕様の指定をill-formedにしようとしています。

この提案の推奨は、例外を送出しうる例外仕様（`noexcept(false)`等）を禁止し、例外を投げうる例外仕様（`noexcept`等）は非推奨としておくことです。前者については意味がない使用法ですが、後者については妥当な使用法であるためです。

ただし、GCCの現在の実装にはdestroying operator deleteに対する暗黙の`noexcept`を行わないというバグがあるため、これが修正される前にこの提案が適用されると、そのバグによりdestroying operator deleteが全てコンパイルエラーを起こすようになってしまう可能性がある、と報告しています。

- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P3427R1 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3427r1.pdf)
### [P3428R1 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3428r1.pdf)
### [P3429R1 Reflection header should minimize standard library dependencies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3429r1.html)
### [P3430R1 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3430r1.pdf)
### [P3436R1 Strategy for removing safety-related undefined behavior by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3436r1.pdf)
### [P3437R1 Proposed principles: Reflect C++, generate C++ (by default)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3437r1.pdf)
### [P3449R1 constexpr std::generator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3449r1.html)
### [P3466R1 (Re)affirm design principles for future C++ evolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r1.pdf)
### [P3468R0 2024-10 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3468r0.html)

2024年2月に行われたLEWGの投票の結果。

次の13の提案が投票にかけられ、否決されたものはありません。

- [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://wg21.link/P2897R5)
- [P3008R2 Atomic floating-point min/max](https://wg21.link/P3008R2)
- [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://wg21.link/P3050R2)
- [P3068R4 Allowing exception throwing in constant-evaluation](https://wg21.link/P3068R4)
- [P3136R0 Retiring niebloids](https://wg21.link/P3136R0)
- [P3222R0 Fix C++26 by adding transposed special cases for P2642 layouts](https://wg21.link/P3222R0)
- [P3309R2 constexpr atomic and atomic_ref](https://wg21.link/P3309R2)
- [P3323R0 cv-qualified types in atomic and atomic_ref](https://wg21.link/P3323R0)
- [P3325R3 A Utility for Creating Execution Environments](https://wg21.link/P3325R3)
- [P0472R2 Put std::monostate in <utility>](https://wg21.link/P0472R2)
- [P3355R1 Fix submdspan for C++26](https://wg21.link/P3355R1)
- [P3369R0 constexpr for uninitialized_default_construct](https://wg21.link/P3369R0)
- [P3399R0 Adjusting Electronic Polls to a Hybrid Workflow](https://wg21.link/P3399R0)

最後のものを除いて、どれもC++26に向けてLWGに転送されます。

賛否の票数や投票に当たって寄せられたコメントが記載されています。

### [P3471R1 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r1.html)
### [P3471R2 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r2.html)
### [P3477R1 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3477r1.html)
### [P3480R1 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r1.pdf)
### [P3480R2 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r2.pdf)
### [P3482R0 Proposed API for creating TAPS based networking connections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3482r0.html)

IETFのTAPSに基づいたネットワークライブラリのAPIの提案。

IETFのTAPSについては少し上のP3185R0を参照。

この提案は、P3185R0に続いてTAPSに基づいた実際のライブラリAPIを提案するものです。ただし、全く新しいものを提案するのではなく、P2762(R2)で提案されているもの、すなわちNetworking TSに`std::execution`（sender/receiver）を組み込んだ形のライブラリをベースにして、それに対してTAPSの概念や言葉に基づいた変更を加えています。

#### TAPSのプロパティ

TAPSではある接続に対する要件を記述するためにプロパティベースのアプローチを採用しています。TAPS実装では、接続の際に指定されたプロパティを満たす1つ以上の接続方法の候補セットを特定し、ユーザーの選択や追加の指定などによってその中から1つを選択して接続に使用します。

そのようなプロパティには次のものがあります

1. 事前接続（Preconnections）
    - 接続の確立は事前接続から開始される
    - TAPSでは、事前接続オブジェクトを定義する4つのプロパティグループを定義している
        1. ローカルエンドポイント（Local Endpoint）
        2. リモートエンドポイント（Remote Endpoint）
        3. トランスポート（Transport）
        4. セキュリティ（Security）
2. エンドポイント（Endpoints）
    - エンドポイント接続の始点と終点を定義し、ローカルとリモートに区別される
    - エンドポイントには次のプロパティがある
        1. ホストネーム: 例"nyarlathotep.example.org"
        2. インターフェース: 例"en0"
        3. サービス: 例"https"
        4. マルチキャストグループ: 例"224.0.0.252" or "ff02::114"
        5. ホップ制限: 数値
3. トランスポート（Transports）
    - トランスポートは基盤となるインフラストラクチャが満たすことが期待される要件の集合によって定義される
    - ほとんどのトランスポートは、次のいずれかの値を取る設定として表現される
        1. Require
        2. Prefer
        3. None
        4. Avoid
        5. Prohibit
    - トランスポートには、要件を表現するために使用できる次のプロパティがある
        1. interface
            - `(interface, preference)`のようなタプル値の集合
        2. reliability: preference
        3. preserve_msg_boundaries: preference
        4. per_msg_reliability: preference
        5. preserve_order: preference
        6. zero_rtt_msg: preference
        7. multistreaming: preference
        8. full_checksum_send: preference
        9. full_checksum_recv: preference
        10. congestion_control: preference
        11. keep_alive: preference
        12. use_temp_local_address: preference
        13. multipath
            - 列挙型: `{ disabled, active, passive }`
        14. advertises_alt_addr: preference
        15. direction
            - 列挙型: `{ both, send, recv }`
        16. soft_error_notify: preference
        17. active_read_before_send: preference
4. セキュリティ（Security）
    - トランスポートのセキュリティは、満たさなければならない一連の要件によって定義される
    - 次のプロパティがサポートされている
        1. allowed_security_protocols: プロトコル識別子のシーケンス
        2. server_cert: 証明書のシーケンス
        3. client_cert: 証明書のシーケンス
        4. pinned_server_cert: 証明書のシーケンス
        5. alpn: アプリケーション層のプロトコルネゴシエーション値のシーケンス
        6. supported_group: グループ識別子のシーケンス
        7. ciphersuite: 暗号スイート識別子のシーケンス
        8. signature_algorithm: アルゴリズム識別子のシーケンス
        9. max_cached_session: 整数値
        10. cached_session_lifetime: 期限を示す値
        11. preshared_key: 鍵の実体
        12. trust_verification_handler: `sender`のシーケンス
        13. challenge_handler: `sender`のシーケンス

エンドポイント・トランスポート・セキュリティの3つのプロパティセットはまず事前接続を確立するために使用され、その確立後に事前接続は接続（オブジェクト）を作成するために使用されます。TAPSでは、事前接続型に対して接続（`Connection`型オブジェクト）を作成するための3つの関数を定義します

1. `Initiate() -> Connection`: アクティブオープン接続
    - クライアントがサーバーと通信する場合などに使用する
    - `client_connection()`という名前でも良い
2. `Listen() -> Connection`: パッシブオープン接続
    - サーバーがクライアントからの接続を待ち受ける場合などに使用する
    - `server_connection()`という名前でも良い
3. `Rendezvous() -> Connection`: ピアツーピア接続
    - `peer_to_peer_connection()`という名前でも良い

追加で、事前接続がエンドポイント解決（名前解決）を行えることを規定しており、そのための関数を定義します

1. `Resolve() -> (local_endpoint[], remote_endpoint[])`

#### Framer

TAPSによるユーザー（ライブラリ利用者）とのやり取りは明確にメッセージベースであり、従来のソケット通信ライブラリ（バークレイソケットやNetworking TSなど）とは異なっています。TAPSでは、受信データの1つ以上のチャンクから完全なメッセージ（またはエラー）を生成する**Framer**という概念を導入しています。Framerは、送信や受信等のイベントを何かしらの単位でフレーム化することを担っており、そのフレーム化のためのルールを表現するものです。

Framerは事前接続から接続を取得する際の（関数の）オプション引数でもあります。Framerはイベント駆動型で、基盤となるトランスポートから、接続の開始・受信/送信データ・接続の終了、に関するイベントを受信します。

Framerでは、送信メッセージのエンコード方法や受信メッセージのデコード方法の定義等を行うことで接続のプロトコルスタックを拡張することができ、ストリーム指向のトランスポートプロトコルを使用する場合でも明確に定義されたメッセージ境界を提供することができます。

例えば、デフォルトである`default_framer`はバークレイソケットなどと同様に動作して、現在受信しているバイトを返すだけですが、より高レベルのFramerとして基礎のバイトストリームからHTTPのレスポンスをデコードし、ヘッダとメッセージを分離して返す`http_framer`を考えることができます。

#### メッセージコンテキスト

データの送受信呼び出しにおいては、アプリケーションはメッセージコンテキストを指定することができ、このメッセージコンテキストにはいくつかの役割があります

- 送信/受信操作に渡されるメッセージコンテキストは、Framerがメッセージデータをどのように扱うかについてを制御するFramer固有のプロパティを伝達する手段として使用される
- メッセージコンテキストは完了したメッセージ（イベント）を受信する`receiver`（の`set_value`チャネル）とやり取りするために使用できる
- 複数の部分的な送信/受信操作を関連付けるために使用できる
- メッセージコンテキストにはインターフェースやリモートエンドポイントなどに関する情報が含まれているが、Framerはこれを拡張してフレーム化されるメッセージについての追加のメタデータを指定できる
    - 例えばHTTPヘッダなど

#### TAPSとP2762R2の調和

この提案のライブラリは、ここまでで説明したようなTAPSの概念を優先しつつも、既存の提案であるP2762をベースとしたものになっています。例えば、P2762でがソケット型とそれに対する操作を定義するCPO群を定義していますが、ここで提案している`connect, listen, rendezvous`CPOはソケット型ではなく`Connection`型を返し、`async_send()`や`async_receive()`などのCPOは`Connection`型に対する操作として再定義されます。

TAPSのプロパティや概念は基礎のトランスポートがTCP/IPベースであることを仮定しています。しかし、例えば基礎のトランスポートとしてMPIを使用して、Infiniband等の高性能ファブリックを使用する、といったニーズがある他、Asioにはシリアル通信やプロセス間通信を基礎トランスポートとしたソケットのサポート等があります。

プロセス間通信の場合エンドポイントはホスト名を持たず、セキュリティプロパティも無関係です。同様にトランスポートのプロパティもオプションになる場合もあれば、エンドポイントやトランスポートの種類などにより暗黙的に決定される場合もあります。

TAPSでは事前接続型はそのプロパティに応じて3つの異なる種類の接続形態（アクティブオープン、パッシブ（リッスン）、ランデブー（P2P））を想定していますが、TCP/IPベース以外のトランスポートをサポートしようとする場合、常にこの3つの接続形態が利用可能であると仮定することはできなくなります。

そこで、この提案ではこの3つの接続形態（及び基礎となるトランスポート種別）に対応する接続型（`Connection`型）を共通ではなく異なるものとして、接続型は基礎となるトランスポートのサポートする操作のみをそのインターフェースとして公開し利用可能にするようにします（TAPSでは接続型は単一の型であり、異なるトランスポートをサポートするための最大公約数的なインターフェースを公開するものとされている）。そして、事前接続型に応じた3つの接続操作はCPOとしてカスタマイズポイントになることで、ベンダー/ユーザーはTCP/IPベース以外のトランスポートをサポートできるようになります。

標準ライブラリとしては、TAPSで示されているエンドポイント・トランスポート・セキュリティのプロパティに準拠したデフォルトのトランスポート実装を提供し、`std::net::ip`名前空間に配置します。

そのような事前接続のプロパティセットを実装がクエリするための方法として、P3325で提案されている実行環境用のプロパティクエリと定義の仕組みを応用することを提案しています。これによって、事前接続型がP3325の方法によって各種プロパティを取得できるようになってさえいれば、ユーザー側で定義した任意の型（＝任意のプロパティセット）を事前接続型として使用できるようになります。標準ライブラリとしてはデフォルトの事前接続型を提供します。

ここでも、3つの接続操作（`connect, listen, rendezvous`）がCPOであることによって、事前接続型に応じた接続型の選択がカスタマイズ可能になります。

TAPSでは信頼検証とチャレンジ処理のためのセキュリティハンドラをコールバック操作として記述していますが、これは本質的に非同期操作であり、`sender/receiver`の語彙によって表現でき、またそうすべきです。ただし、現在の`sender`ではこのための能力が不足しているため、ここでは`sequence_sender`というタイプの新しい`sender`を提案しています。

`sequence_sender`は`sender`に対して`set_next_value()`操作を追加したもので、`set_next_value()`操作は（`io_context`によって）値を受信した際に実行する処理をスケジューリングできる`sender`を返します。

例えばセキュリティコールバックの場合、接続型からそのための`sequence_sender`を取得し、`set_next_value()`によってセキュリティコールバック（信頼検証やIDチャレンジ）に必要な追加の値を受け取って、その操作を表す`sender`を返します。この`sender`に対して`receiver`を接続することでセキュリティコールバックの結果を取得します。

Framerは受信したバイト列をデコードしてメッセージ型に変換するだけではなく強く片付けされたヘッダを導入することもでき、Framerに対してこのようなヘッダセットやその型に関する情報を伝達するのにもP3325で提案されている`runtime_env`の仕組みを使用することを提案しています。標準ライブラリとしては、受信したデータの生のバイト列を`Connection`型固有のメッセージコンテキストともに返す`default_framer`を提供します。

接続のネゴシエーションと確立、フレーミング、メッセージ送受信はすべて、TAPSにおいても本質的に非同期操作です。したがって、これらの機能をC++ライブラリにエンコードする際には、`sender/receiver`の語彙を使用することができます。ただし、足りない部分があるので`sequence_sender`という拡張を提案しています（`sequence_sender`に関しては追加の提案でさらに詳細に説明される予定）。

事前接続におけるリモートエンドポイントの解決（名前解決）も非同期操作であるため、それを行う`resolve()`操作も`sender`を返すようにすることを提案しています。これにより、問い合わせのタイムアウトやキャンセル、中断などを自然にサポートできるようになります。

`Connection`型を構築するプロセスは通常このリモートエンドポイントの名前解決に依存するため、`resolve()`が非同期的で`sender`を返す場合、`Connection`を作成するエントリポイントも同様に`sender`を返すようにします

`Connection`はまた、受信/送信操作に基づくメッセージの配信に関するイベントに加えて、接続そのもののライフサイクルに関するイベントを配信する`sender`でもあります。このライフサイクルにはたとえば、ソフトエラー、パス変更、Closed、Abort、CloseGroup、AbortGroup、ConnectionError等があります。

P2762の非同期操作のほとんどは引き続き利用可能ですが、これらの事を踏まえて一部が修正されます。特に

- `async_accept()`は、提案されている`async_listen()`に統合される
- `async_connect()`は、提案されている`async_initiate()`に統合される
- `async_resolve_address()`と`async_resolve_name()`は、`async_resolve()`操作に統合される

P2762のデータ送信操作は次のように変更されます

- `async_send()`はメッセージ全体・ファイル全体などを送信するためのカスタマイズポイントとなる
    - 基礎となるトランスポートにメッセージをエンコードするための方法はFramerに移譲される
    - `async_send()`はメッセージコンテキストを受け入れるようになる
- `async_send()`の`message_flags`引数は削除され、トランスポートによるメッセージ配信を指示するプロパティはすべてメッセージコンテキストの一部になる
- `async_send()`の戻り値型は`send-sender`となる
    - `send-sender`はメッセージの送信中に発生した可能性のあるエラーに加えて、メッセージがつつがなく送信されたことや送信前にタイムアウトしたことなどを表す値を返す場合がある
- ユーザー視点からはストリームトランスポートへのデータ送信とデータグラム指向トランスポートへのメッセージ送信に違いは無いため、`async_send_to()`は削除
- TAPSに則って部分送信操作をサポートしており、このような部分送信操作はメッセージコンテキストオブジェクトによって紐づけられる
- 部分送信操作は、その個別の部分メッセージの送信によって生じた結果を受信する`send-sender`を返す

同様に、P2762のデータ受信操作も一部が次のように変更されます

- `async_receive()`はメッセージ全体・ファイル全体などを送信するためのカスタマイズポイントとなる
    - メッセージの定義（バイト列からの1メッセージの抽出方法）はFramerに移譲される
    - `async_receive()`はメッセージコンテキストを受け入れるようになる
- ユーザー視点からは、ストリームトランスポートへのデータ受信とデータグラム指向トランスポートへのメッセージ受信に違いは無いため、`async_receive_from()`は削除
- TAPSでは`async_read_some()`に似た部分受信操作を許可している
    - 同じメッセージコンテキストオブジェクトを指定する部分受信操作は、同じ論理受信操作の一部となる
    - ここでは、`async_receive()`のオーバーロードとして最大読み取り長を含めるか、`async_receive_some()`操作を導入すること
- `async_receive()`の戻り値型は`receive-sender`を返す
- `async_receive()`によって最終的に送信される`set_value()`呼び出しには、操作開始時に提供されたメッセージコンテキストとメッセージの全体または部分的メッセージが含まれる
- `async_receive()`は`std::execution`の他の非同期操作と同様に、`stop_token`を用いてキャンセル可能

この提案の現在のリビジョンでの変更はまだ作業途中であり、将来のリビジョンで更なる作業が予定されています。

- [P3482 進行状況](https://github.com/cplusplus/papers/issues/2151)

### [P3483R0 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r0.pdf)
### [P3483R1 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r1.pdf)
### [P3484R0 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r0.pdf)
### [P3484R1 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r1.pdf)
### [P3484R2 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r2.pdf)
### [P3485R0 Grouping using declarations with braces](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3485r0.html)

`using`宣言をグループで行えるようにする提案。

名前空間から特定の名前を現在のスコープで利用可能にするためには通常`using nemaspace`よりも個別の名前を`using`する方が好まれます。

```cpp
using std::format;
using std::format_to;
using std::formatter;
using std::chrono::duration;
using std::chrono::time_point;
using std::chrono::duration_cast;
```

しかし、この方法はかなり冗長であり、あまり見やすくもありません。

一応C++17では`using`宣言のパック展開サポートの副作用として`using`を省略できるようになっています

```cpp
using std::format, std::format_to, std::formatter;
using std::chrono::duration, std::chrono::time_point, std::chrono::duration_cast;
```

しかし多少はましとはいえまだ冗長です。一つの`using`宣言のグループ内では共通する部分の名前空間を繰り返す必要はなさそうに見えます。例えば次のように書くことができれば、かなり簡潔に`using`宣言を記述できるようになります

```cpp
using std::{format, format_to, formatter};
using std::chrono::{duration, time_point, duration_cast};
```

この提案は、`using`宣言においてこのようにグルーピングして記述できるようにしようとするものです。

これは新機能の提案ではなく、純粋に可読性を向上させるための機能拡張の提案です。

提案では、ワイルドカードの使用（`using std::chrono::*;`）や波かっこのネスト（`using std::{formatter, chrono::{duration, time_point}};`）についても検討していますが、いずれも不許可としています。

筆者の方はClangをフォークして実装してみたところかなり簡単に実装できたと報告しています。

- [P3485 進行状況](https://github.com/cplusplus/papers/issues/2154)

### [P3487R0 Postconditions odr-using a parameter that may be passed in registers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3487r0.pdf)
### [P3488R0 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r0.pdf)
### [P3488R1 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r1.pdf)
### [P3489R0 Postconditions odr-using a parameter of dependent type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3489r0.pdf)
### [P3490R0 Justification for ranges as the output of parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3490r0.html)
### [P3491R0 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3491r0.html)
### [P3492R0 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3492r0.html)
### [P3493R0 Ruminations on reflection and access](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3493r0.html)
### [P3495R0 Remarks on Basis Statistics, P1708R9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3495r0.pdf)

P1708R9に対する意見書。

P1708R9では、C++の標準ライブラリに初等的な統計処理機能を導入することを提案しています。P1708R9については以前の記事を参照

- [P1708R9 Basic Statistics - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P1708R9-Basic-Statistics)

この提案では、P1708R9が標準規格として採用可能となるために足りていない部分を指摘し、更なる作業を促すものです。

1. 未規定の結果
    - `NaN`/`Inf`の入力
        - この入力がなぜ未規定の結果をもたらすのかの根拠がない
            - `<cmath>`の関数はこのような場合の結果が厳密に指定されている
        - これらの入力があった場合に、`FE_INVALID`は発生するか？
    - 不十分な要素数
        - 設計空間の問題として言及
    - アンダーフロー/オーバーフロー
        - アンダーフローの場合、なぜ結果が未規定となるのかが不明瞭
        - どちらの場合も、定数評価中に何が起こるかはP0533R9に従うことで簡単に明らかにできる
2. 不十分な現状の設計の説明
    - アキュムレータに関して、BoostのAccumulatorsが引用されているがリンク切れしている
        - 提案自体にその説明があったほうが親切
    - アキュムレータと通常関数の性能について比較したグラフには改善の余地がある
        - エラーバーがない
        - 一部の処理において劣っているように見えるのはなぜか？
        - 並列実行するとどう変化するか？
3. 設計空間
    - 不十分な要素数の範囲の入力
        - 検討されている統計量の計算はすべて、要素数が0ではない範囲を必要とする
        - これは当然であるとしても、必要要素数に満たない範囲が入力された場合に何が起こるかについて議論されていない
            - `std::expected`の採用など、他のアプローチの比較検討などを特にしていない
        - ユーザーに対して未規定の結果を返す方法をこれほど多く提供することは、ユーザーにとってむしろ不親切となりうる
        - 定数評価中の場合に何が起こるかも明確ではない
    - 精度（accuracy）
        - 計算順序
            - 例えば、平均値の計算結果の精度は累積の計算順序に依存する。速度よりも精度を優先する場合、ソートしてから入力することで最小値から最大値の方向で計算を行いたいと考えるかもしれない
            - しかし現状では、各関数における計算順序は指定されていないため、このような事前ソートは無駄になる可能性がある
            - さらに、各関数にそれが指定された場合、アキュムレータではどのような保証になるのか？
        - 同じ統計量を返す関数とアキュムレータの間での結果の一致
            - ある統計量を計算するフリー関数と、それに対応するアキュムレータに対して、同じ範囲を入力したとき、結果が一致するか？
            - 現在の参照実装ではそうなっていない
            - ここにも、トレードオフを伴う設計余地があり、適切に議論する必要がある
        - 高い精度（precision）の結果型の指定
            - ユーザーが範囲の要素型の精度よりも高い精度の結果型を指定することがある
            - この場合、`<linalg>`の関数が行うように結果型の精度で計算が行われることを保証する必要がある
    - 並列化
        - フリー関数には実行ポリシーを取るオーバーロードがあるが、アキュムレータについては無い
        - アキュムレータが並列化に対応できるか、どのように対応するか、について議論が無い
        - ユーザー定義reducerのためのコンセプトを定義していないが、どのように定義できるかを検討することは有益かもしれない
4. APIに関する懸念
    - デフォルト`bool`値
        - デフォルト`bool`値が存在するとAPIが難解になる
        - 例えば、`kurtosis(r, true, false)`はユーザーにとって難解。各統計計算の入力パラメータは構造体で保持する方が望ましい
    - 表現力豊かな戻り値型
        - 一部の関数は`std::pair`を返すが、返される内容をフィールド名で表現できる名前付き構造体を返したほうが良いかもしれない
    - アキュムレータの構築
        - アキュムレータが要素の範囲からの構築をサポートしない正当な理由はあるか？
    - アキュムレータの`operator()`の戻り値型
        - 現在`void`を返すが、`*this`を返すことは検討しているか？
    - 明示的なテンプレートパラメータ指定
        - フリー関数では戻り値型を明示的に指定できるオーバーロードが存在するが、`std::reduce`に倣って初期値を引数で受け取ることでその型をそのまま使用するという方法もある

この提案は、統計関数自体に必要性やそれを導入しようとするP1708に反対しているわけではなく、現状の設計では標準ライブラリに求められる厳密さのレベルに達していないため、その点について指摘し追加作業を促すものです。

- [P3495 進行状況](https://github.com/cplusplus/papers/issues/2160)

### [P3497R0 Guarded Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3497r0.html)
### [P3498R0 Stop the Bleeding but, First, Do No Harm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3498r0.pdf)
### [P3502R0 Slides for D2900R11 - Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3502r0.pdf)

P2900R11（Contracts提案）の説明スライド

P2900の前回会議（2024/06 セントルイス）からの変更点、11月の会議（このスライドがプレゼンされたところ）の達成目標、なぜContractsが必要なのか、について解説されています。

### [P3503R0 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3503r0.html)
### [P3504R0 C++ Standard Library Ready Issues to be moved in Wroclaw, Nov. 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3504r0.html)
### [P3508R0 Wording for constexpr for specialized memory algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
### [P3510R0 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r0.html)
### [P3510R1 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r1.html)
### [P3510R2 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r2.html)
### [P3517R0 Slides presented to LEWG on trivial relocation in Wroclaw](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3517r0.pdf)
### [P3518R0 Slides for Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3518r0.pdf)
### [P3519R0 Slides for P3425 presentation to LEWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3519r0.pdf)
### [P3520R0 Wroclaw Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3520r0.pdf)
### [P3521R0 Pattern Matching: Customization Point for Open Sum Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3521r0.html)
### [P3524R0 Core Language Working Group "ready" Issues for the November, 2024 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3524r0.html)
### [P3525R0 Explicit Implicit Template Regions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3525r0.html)
### [P3527R0 Pattern Matching: *variant-like* and `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3527r0.html)
### [P3530R0 Intrinsic for reading uninitialized memory](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3530r0.html)
### [P3533R0 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3533r0.html)
### [P3537R0 Presentation on Concurrent Queue API LEWG Telecon 2024-Dec-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3537r0.pdf)
### [P3539R1 Consistent Function Label Naming for Sections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3539r1.pdf)
### [P3540R0 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3540r0.html)
### [P3541R0 Violation handlers vs `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3541r0.html)
### [P3542R0 Abolish the term "converting constructor"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3542r0.html)
### [P3543R0 Response to Core Safety Profiles (P3081)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3543r0.pdf)
