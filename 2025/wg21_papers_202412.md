# ［C++］WG21月次提案文書を眺める（2024年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-12)

全部で166本あります。

もくじ

[:contents]


### [N4977 2025-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4977.pdf)

2025年11月にハワイのコナで行われる全体会議のインフォメーション。

予定（2025年11月3日～8日）と場所、ホテルの案内などが記載されています。

### [N4995 WG21 agenda: 18-23 November 2024, Wroclaw, Poland](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4995.html)

2024年11月にヴロツワフで行われた会議のアジェンダ。

### [N4997 Hagenberg Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4997.pdf)

2025年2月にオーストリアのハーゲンベルクで行われる全体会議のインフォメーション。

予定（2025年2月10日～15日）と場所、ホテルの案内などが記載されています。

### [N4998 WG21 2024-11 Wroclaw Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4998.pdf)

2024年11月6日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Wroclaw会議で何をするかなどの報告がなされています。

### [N4999 WG21 agenda: 10-15 February 2025, Hagenberg, Austria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4999.html)

2025年2月にハーゲンベルクで行われる会議のアジェンダ。

### [N5000 WG21 November 2024 Hybrid meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5000.pdf)

2024年11月にWroclawで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N5001 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5001.pdf)

C++26のワーキングドラフト第7弾

### [N5002 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5002.html)

↑の変更点をまとめた文書。

### [N5003 2025 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5003.pdf)

2025年に行われる、WG21管理者ミーティングの予定表。

### [P0178R1 Allocators and swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0178r1.pdf)

アロケータが等価ではない場合のコンテナ間`swap`を未定義動作ではなくする提案。

C++17で導入された`polymorphic_allcoator`のように、状態を持つアロケータにおいては同じアロケータ型のアロケータオブジェクト同士の比較が必ずしも`true`にはなりません。その場合、そのようなアロケータ同士を保持するコンテナの`swap`は未定義動作となります。

`swap`は単にコンテナの内部ハンドルを交換するだけで済み、アロケータが等価であればアロケータそのものの交換作業は不要になります。しかし、アロケータ等価ではない場合にそのような`swap`を行ってしまうと交換後のコンテナでは、そのメモリ領域を解放する能力のないアロケータとそのアロケータから取得されていないメモリ領域がペアになった状態になり、この状態では正しくリソース解放が行われなくなります。

C++11以前には状態を持つアロケータがサポートされていなかったため、標準のコンテナのデフォルト動作はアロケータの不一致を考慮しない`swap`（すなわち、アロケータ以外の内部ハンドル等の`swap`）を行います。C++11では状態を持つアロケータがサポートされたものの、`propagate_on_container_swap`が`true_type`の場合にのみ`swap`操作でアロケータが伝播する事を期待できますが、`std::allocator`は（および`std::allocator_traits`、`std::pmr::polymorphic_allcoator`も）これを定義しないため、標準コンテナのアロケータはステートフルなものが指定されても`propagate_on_container_swap`が`true_type`で定義されていなければアロケータが等価ではない場合の`swap`は未定義動作となります。

これはおそらく、以前からコンテナ`swap`の要件が定数時間であることも関係していると思われます。

いずれにしても、標準のコンテナはほとんどの場合にアロケータが等価ではない場合の`swap`を未定義動作としています。

`std::swap()`は広い契約をもつ関数であるものの、標準のコンテナの`swap`操作は`std::swap`の各コンテナによるオーバーロードを通してカスタマイズされており、各コンテナの`swap`（メンバ関数）はこのアロケータ不一致に関するより狭い契約を持ちます。これは、広い契約を持つ関数を狭い契約をもつ関数で置き換えており、

これによりユーザーは、アルゴリズム等のジェネリックなコードにおいてコンテナの`swap`を行う場合に、それが標準のコンテナであるかどうか（アロケータの不一致をケアする必要があるかどうか）、すなわち`std::swap`の契約とは異なる契約になっていないかを考慮する必要があります。

この現状に対してこの提案は、標準のコンテナの`swap`がアロケータが等価ではない場合でも未定義動作とならないようにすることを提案するものです。

標準のコンテナのアロケータと`swap`の関係は現在次のようになっており

|swap時の伝播可能性＼実行時等価性|アロケータが等価|アロケータが等価ではない|
|---|:-:|:-:|
|`propagate_on_container_swap`有効|✅|✅|
|`propagate_on_container_swap`無効|✅|☠|

この提案は、この表の右下の部分をwell-formedにしようとしています。

具体的には、アロケータが等価ではなく`propagate_on_container_swap`も無効な場合には要素ごとのムーブによってアロケータが一致するように要素を交換する事を要求するようにします（同時に、計算量の要件も緩和します）。そのほかの場合の動作は現状通りで変更しません。

とても簡易には次のような実装になります

```cpp
void CONTAINER_TYPE::swap(CONTAINER_TYPE & other) {
  if( std::allocator_traits<allocator_type>::propagate_on_container_swap
   || std::allocator_traits<allocator_type>::is_always_equal
   || this->get_allocator() == other.get_allocator()) {
    // trust compiler will optimize the compile-time branching
    // take the fast path

    if constexpr(std::allocator_traits<allocator_type>::propagate_on_container_swap) {
      using std::swap;
      swap(this->get_allocator(),other.get_allocator());
    }
  }
  else if constexpr( all traits are consistent ) {
    CONTAINERbuffer{std::move(other)};
    other = std::move(*this);
    *this = std::move(buffer);
  }
  else {
    //Copy into buffer having the right allocator
    CONTAINERbuffer_this {std::move(other), this->get_allocator()};
    CONTAINERbuffer_other{std::move(*this), other.get_allocator()};

    this->swap(buffer_this);
    other.swap(buffer.other);
  }
}
```

この提案の根拠としては、ブルームバーグ社内コードベースでの10年以上に渡るステートフルアロケータと標準ライブラリの使用経験において、提案するような動作を保守し続けており、現在でもその動作をサポートする理にかなったユースケースが存在している事を確認している事を挙げています。少なくともブルームバーグ社内のユーザーは、線形時間かつ例外を送出しうる`swap`と未定義動作のどちらかの選択を迫られたときに明確に前者を選択している、としています。

- [C++ named requirements: AllocatorAwareContainer (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer)
- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P0260R12 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r12.html)
### [P0260R13 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r13.html)
### [P0447R27 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r27.html)
### [P0447R28 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r28.html)
### [P0472R3 Put std::monostate in <utility>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0472r3.pdf)
### [P1040R7 std::embed and #depend](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1040r7.html)
### [P1061R10 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r10.html)
### [P1928R13 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r13.pdf)
### [P1928R14 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r14.pdf)
### [P1928R15 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r15.pdf)
### [P1967R13 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1967r13.html)
### [P2014R1 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r1.pdf)

↓

### [P2014R2 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r2.html)

コルーチンステートを割り当てる際の`operator new`呼び出しの際に、`std::align_val_t`を考慮するようにする提案。

この提案は、C++20のNBコメントUS061とUS063で提起された問題に対する解決策を提案するものです。

コルーチンが最初に呼びされた時にコルーチンステートを確保しようとする際に、プロミス型のコンテキストおよびグローバルな`operator new`を探索しますが、その際に`std::align_val_t`を取るオーバーロードを考慮していません。それによって、コルーチンの引数やプロミス型など、コルーチンフレームに保存されるものの中にオーバーアライメントされたものが含まれている場合などに正しくアラインされない可能性があります。

US061とUS063はどちらもこの問題の解決を求めるものであり、この提案のR0ではそのためのオプションを2つ提案していました

1. 割り当てるストレージが*new-extended*アライメントを要求する場合にのみ、 `std::align_val_t`オーバーロードを優先する
    - 利点: `new/delete`式の動作とより一貫している
    - 欠点: コルーチン開始時の`operator new`探索のルールが複雑化し、2回探索する必要がある。また、`std::align_val_t`オーバーロードを呼び出すかどうかの選択がコルーチンフレームのレイアウトが判明するコンパイルフェーズの後半まで延期しなければならなくなる
2. コルーチンフレームや*new-extended*アライメントを要求するかに関係なく常に`std::align_val_t`オーバーロードを優先する
    - 利点: より単純
    - 欠点: `new/delete`式の動作と矛盾する

そして、EWGでの議論の結果オプション1が選択されています。

オプション1でのコルーチン開始時（初期化時）にコルーチン用の追加の記憶域を確保する必要がある場合に行われる2段階の探索は次のようになります。

---

まず、その記憶域は非配列の`operator new`を呼び出すことで確保され、使用する`operator new`はプロミス型のコンテキストで探索され、その結果何らかの関数が見つかった場合、その集合からオーバーロード解決を次のように行う

1. 最初のオーバーロード解決は、引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 第二引数はコルーチンステートのアライメントであり、`std::align_val_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
        - 依存型ではない = 第二引数がテンプレートパラメータによって指定されていない
    - 見つからなかった場合、最初の2つの引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
2. 第二のオーバーロード解決は、再度引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する
    - 見つからなかった場合、第一引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する

`operator new`がプロミス型のコンテキストで見つからなかった場合、*overaligned-allocation-function*を` ::operator new(std::size_t, std::align_val_t)`で、*normal-allocation-function*を`::operator new(std::size_t)`で定義する。

そして、コルーチンステートが*new-extended*アライメントを持ち、かつ*overaligned-allocation-function*が見つかっている場合、コルーチンステートは*overaligned-allocation-function*の呼び出しによって確保される。そうではない場合で*normal-allocation-function*が見つかっている場合、コルーチンステートは*normal-allocation-function*で確保される。それ以外の場合はill-formed。

---

現在の仕様は、プロミス型のコンテキストでは2番目のオーバーロード解決フェーズのみを行い、またグローバルスコープの探索では`std::size_t`型の引数だけを用いてオーバロード解決を行い、そこで見つかった関数がそのまま使用されます。

なお、コルーチンステートを解放する`operator delete`も同様に`std::align_val_t`オーバロードを考慮するように修正されます。とはいえ`new`の場合ほど複雑ではなく

1. プロミス型のコンテキスト -> グローバルスコープ の順で`operator delete`を探索
2. プロミス型のコンテキストで見つかった候補の中に*destroying operator delete*が含まれている場合、ill-formed
3. コルーチンステートが*new-extended*アライメントを持つ場合、`std::align_val_t`型の引数を取るオーバーロードが優先される
4. そうではない場合、`std::align_val_t`型の引数を取らないオーバーロードが優先される
5. 優先される候補以外の候補は削除され、残った候補のうちでは`std::size_t`型の引数を取るものが取らないものよりも優先される

のようになっています。

なお、この提案はCWGのレビュー中だったものの、著者の方がこれ以上追及されないとして、取り下げられているようです。

- [US061 09.04.4 p10 Coroutine allocation should consider std::align_val_t P2014](https://github.com/cplusplus/nbballot/issues/60)
- [US063 09.04.4 Coroutine allocation should consider std::align_val_t](https://github.com/cplusplus/nbballot/issues/62)
- [コルーチン [P0912R5] - cpprefjp](https://cpprefjp.github.io/lang/cpp20/coroutines.html)
- [P2014 進行状況](https://github.com/cplusplus/papers/issues/750)

### [P2319R3 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r3.html)
### [P2319R4 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r4.html)
### [P2645R1 path_view: a design that took a wrong turn](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2645r1.html)
### [P2656R4 WITHDRAWN: C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2656r4.html)
### [P2686R5 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r5.pdf)
### [P2688R4 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r4.html)
### [P2717R6 WITHDRAWN: Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2717r6.html)
### [P2781R5 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2781r5.html)
### [P2786R9 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r9.pdf)
### [P2786R10 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r10.pdf)
### [P2786R11 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r11.html)
### [P2825R3 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r3.html)
### [P2830R5 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r5.html)
### [P2830R6 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r6.html)
### [P2830R7 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r7.html)
### [P2835R7 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r7.html)
### [P2846R5 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r5.pdf)
### [P2863R8 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r8.html)
### [P2865R6 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2865r6.pdf)
### [P2866R5 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2866r5.pdf)
### [P2897R6 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r6.html)
### [P2897R7 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r7.html)
### [P2900R11 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r11.pdf)
### [P2900R12 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r12.pdf)
### [P2996R8 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r8.html)
### [P3008R3 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r3.html)
### [P3016R5 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r5.html)
### [P3019R11 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r11.pdf)
### [P3037R4 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r4.pdf)
### [P3045R4 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r4.html)
### [P3050R3 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r3.html)
### [P3051R3 WITHDRAWN: Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3051r3.html)
### [P3068R5 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r5.html)
### [P3068R6 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r6.html)
### [P3074R5 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r5.html)
### [P3096R4 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r4.pdf)
### [P3096R5 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r5.pdf)
### [P3098R1 Contracts for C++: Postcondition captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3098r1.pdf)
### [P3111R1 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r1.html)
### [P3111R2 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r2.html)
### [P3117R1 Extending Conditionally Borrowed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3117r1.html)
### [P3125R2 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r2.html)
### [P3136R1 Retiring niebloids](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3136r1.html)
### [P3138R4 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r4.html)
### [P3138R5 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r5.html)
### [P3146R2 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r2.html)
### [P3149R7 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r7.html)
### [P3149R8 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r8.html)
### [P3152R1 Add missing constructors and assignment for indirect and polymorphic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3152r1.html)
### [P3179R4 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r4.html)
### [P3185R0 A proposed direction for C++ Standard Networking based on IETF TAPS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3185r0.html)

C++のNetworkライブラリの基礎的な設計の指針として、IETFのTAPSを基礎とする提案。

IETFのTAPS（Transport Services Application Programming Interface）とは、いわゆるソケット通信をはじめとするトランスポートプロトコルのAPIを再定義するもので、ネットワーク通信を必要とするアプリケーションにネットワーク機能を提供するための、特定の言語やプロトコルに依存しない抽象アーキテクチャを定義することを目的としているものです。

この提案ではC++の将来のNetwork標準ライブラリのAPIや設計をこのTAPSと整合するものにする事を提案しています。その理由としては

- 言語に依存しないAPIを提案しており、なおかつNetworking TSの欠けている機能として挙げられている領域をカバーしている
    - 名前付き接続（DNS解決など）
    - トランスポート層セキュリティ
- 既存のネットワークAPI（Berkeley Socketsからの派生など）の概念やそれに対応する命名規則に一貫性がないという問題に対処しようとしている
    - 現在のネットワークライブラリでは、同じものを表す概念やAPI名が歴史的経緯や使用するプロトコルによって大きく異なる
- TAPSアーキテクチャはアプリケーションとトランスポート間のインターフェースを再定義し、アプリケーションとの契約を根本的に変えることなくトランスポート層を進化させることを目指している
- TAPS勧告は、一般的なユースケースをシンプルかつ一貫性のあるものにしつつ、トランスポート層をよりきめ細かく制御する必要があるアプリケーションに対してはその方法を提供する事を目的としている

などが挙げられています。

Networking TSを含む従来のソケット通信のモデルは次のように説明できます

- ソケットAPIを用いて接続を作成し、データを転送する
- ソケットAPIは、TCPおよびUDPプロトコルの実装へのインターフェースを提供する
    - 実装は通常、システムカーネルによって提供される
- TCP/UDP実装はネットワーク層インターフェースを介してデータを送受信する
- ソケットは、トランスポート層およびネットワーク層のアドレスに直接バインドされる
    - これらのアドレスは通常、システムが提供するDNSスタブリゾルバによって実行される別の解決手段によって取得される

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
        |                 |                  |
  +------------+     +------------+    +--------------+
  |  DNS stub  |     | Stream API |    | Datagram API |
  |  resolver  |     +------------+    +--------------+
  +------------+          |                  |
                    +---------------------------------+
                    |    TCP                UDP       |
                    |    Kernel Networking Stack      |
                    +---------------------------------+
                                    |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

これに対して、TAPSのAPI構造は次のようになっています

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|              Transport Services API                 |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|          Transport Services Implementation          |
|  (Using: DNS, UDP, TCP, SCTP, DCCP, TLS, QUIC, etc) |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

TAPSのAPIは、接続の作成とデータ転送のためのインターフェースを定義し、複数のインタラクションパターンのインターフェースを定義したものです。そして、このAPIは特定のプロトコルに特化したものではなく、より汎用的に様々なプロトコルをサポートすることができ、初期セットとしてTCP/UDPのみに限定しても将来的にQUICなどのプロトコルにライブラリを拡張可能です。

名前解決を接続の確立とデータ転送と組み合わせていることで、このAPIの実装（それは各実装のQoIとされる）はより柔軟なものになっています。

そして、従来のソケットベースAPIとの重要な違いは、TAPS APIはデフォルトで非同期かつイベント駆動型であることです。アプリケーションへのデータ転送を表現するためにメッセージという抽象的な概念を用いています。また、アプリケーションがネットワークエンドポイント識別子を解決して複数のアドレス・プロトコル・パスを記述して、これらのストリームを同時に扱う方法を記述しています。

提案にはもう少し詳しくTAPS APIの特徴が紹介されています。

この提案ではSG4に対して、Networking TSの大規模再設計を行うべきか、このTAPS APIのようなより現代的な規範に従うか、の選択を迫っています。

- [RFC 9621 - Architecture and Requirements for Transport Services](https://datatracker.ietf.org/doc/rfc9621/)
- [RFC 9622 - An Abstract Application Programming Interface (API) for Transport Services](https://datatracker.ietf.org/doc/rfc9622/)
- [RFC 9623 - Implementing Interfaces to Transport Services](https://datatracker.ietf.org/doc/rfc9623/)
- [P3185 進行状況](https://github.com/cplusplus/papers/issues/2145)

### [P3204R0 Why Contracts?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3204r0.pdf)
### [P3222R1 Fix C++26 by adding transposed special cases for P2642 layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r1.html)
### [P3227R1 Fixing the library API for contract violation handling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3227r1.pdf)
### [P3230R1 views::unchecked_(take|drop)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3230r1.html)
### [P3232R1 User-defined erroneous behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3232r1.html)
### [P3237R2 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r2.pdf)
### [P3247R2 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r2.html)
### [P3261R2 Revisiting `const`-ification in Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3261r2.pdf)
### [P3284R2 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r2.html)
### [P3287R2 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r2.pdf)
### [P3296R3 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r3.html)
### [P3299R3 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r3.html)
### [P3309R3 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
### [P3310R5 Solving issues introduced by relaxed template template parameter matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r5.html)
### [P3319R2 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3319r2.pdf)
### [P3323R1 cv-qualified types in atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
### [P3325R4 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r4.html)
### [P3325R5 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r5.html)
### [P3329R0 Healing the C++ Filter View](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3329r0.pdf)
### [P3335R3 Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r3.html)
### [P3335R4 WITHDRAWN: Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r4.html)
### [P3339R1 WITHDRAWN: C++ Ecosystem IS Open License](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3339r1.html)
### [P3342R1 Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r1.pdf)
### [P3342R2 WITHDRAWN: Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r2.html)
### [P3355R2 Fix submdspan for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3355r2.html)
### [P3367R1 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r1.html)
### [P3367R2 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r2.html)
### [P3371R3 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r3.html)
### [P3378R1 constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3378r1.html)
### [P3380R1 Extending support for class types as non-type template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3380r1.html)
### [P3383R1 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3383r1.html)
### [P3385R2 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3385r2.html)
### [P3386R1 Static Analysis of Contracts with P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3386r1.pdf)
### [P3396R1 std::execution wording fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3396r1.html)
### [P3409R1 Enabling more efficient stop-token based cancellation of senders](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3409r1.html)
### [P3422R1 Allow main function in named modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3422r1.html)
### [P3424R0 Define Delete With Throwing Exception Specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3424r0.pdf)

`delete`演算子オーバーロードが例外を送出しうる例外仕様を持つことを禁止する提案。

`operator delete`はユーザーによって明示的に`noexcept(false)`等と指定されない限り、デフォルトで`noexcept`になります。`noexcept(false)`と明示的に指定して例外を投げられるようにすることもできるのですが、その場合の振る舞いは未定義動作となります。したがって、`operator delete`に例外を送出しうる例外仕様を指定する有効なユースケースは存在していません。

そのため、この提案では`delete`演算子オーバーロードに対する例外を送出しうる例外仕様の指定をill-formedにしようとしています。

この提案の推奨は、例外を送出しうる例外仕様（`noexcept(false)`等）を禁止し、例外を投げうる例外仕様（`noexcept`等）は非推奨としておくことです。前者については意味がない使用法ですが、後者については妥当な使用法であるためです。

ただし、GCCの現在の実装にはdestroying operator deleteに対する暗黙の`noexcept`を行わないというバグがあるため、これが修正される前にこの提案が適用されると、そのバグによりdestroying operator deleteが全てコンパイルエラーを起こすようになってしまう可能性がある、と報告しています。

- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P3427R1 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3427r1.pdf)
### [P3428R1 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3428r1.pdf)
### [P3429R1 Reflection header should minimize standard library dependencies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3429r1.html)
### [P3430R1 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3430r1.pdf)
### [P3436R1 Strategy for removing safety-related undefined behavior by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3436r1.pdf)
### [P3437R1 Proposed principles: Reflect C++, generate C++ (by default)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3437r1.pdf)
### [P3449R1 constexpr std::generator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3449r1.html)
### [P3466R1 (Re)affirm design principles for future C++ evolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r1.pdf)
### [P3468R0 2024-10 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3468r0.html)

2024年2月に行われたLEWGの投票の結果。

次の13の提案が投票にかけられ、否決されたものはありません。

- [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://wg21.link/P2897R5)
- [P3008R2 Atomic floating-point min/max](https://wg21.link/P3008R2)
- [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://wg21.link/P3050R2)
- [P3068R4 Allowing exception throwing in constant-evaluation](https://wg21.link/P3068R4)
- [P3136R0 Retiring niebloids](https://wg21.link/P3136R0)
- [P3222R0 Fix C++26 by adding transposed special cases for P2642 layouts](https://wg21.link/P3222R0)
- [P3309R2 constexpr atomic and atomic_ref](https://wg21.link/P3309R2)
- [P3323R0 cv-qualified types in atomic and atomic_ref](https://wg21.link/P3323R0)
- [P3325R3 A Utility for Creating Execution Environments](https://wg21.link/P3325R3)
- [P0472R2 Put std::monostate in <utility>](https://wg21.link/P0472R2)
- [P3355R1 Fix submdspan for C++26](https://wg21.link/P3355R1)
- [P3369R0 constexpr for uninitialized_default_construct](https://wg21.link/P3369R0)
- [P3399R0 Adjusting Electronic Polls to a Hybrid Workflow](https://wg21.link/P3399R0)

最後のものを除いて、どれもC++26に向けてLWGに転送されます。

賛否の票数や投票に当たって寄せられたコメントが記載されています。

### [P3471R1 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r1.html)
### [P3471R2 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r2.html)
### [P3477R1 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3477r1.html)
### [P3480R1 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r1.pdf)
### [P3480R2 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r2.pdf)
### [P3482R0 Proposed API for creating TAPS based networking connections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3482r0.html)
### [P3483R0 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r0.pdf)
### [P3483R1 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r1.pdf)
### [P3484R0 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r0.pdf)
### [P3484R1 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r1.pdf)
### [P3484R2 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r2.pdf)
### [P3485R0 Grouping using declarations with braces](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3485r0.html)

`using`宣言をグループで行えるようにする提案。

名前空間から特定の名前を現在のスコープで利用可能にするためには通常`using nemaspace`よりも個別の名前を`using`する方が好まれます。

```cpp
using std::format;
using std::format_to;
using std::formatter;
using std::chrono::duration;
using std::chrono::time_point;
using std::chrono::duration_cast;
```

しかし、この方法はかなり冗長であり、あまり見やすくもありません。

一応C++17では`using`宣言のパック展開サポートの副作用として`using`を省略できるようになっています

```cpp
using std::format, std::format_to, std::formatter;
using std::chrono::duration, std::chrono::time_point, std::chrono::duration_cast;
```

しかし多少はましとはいえまだ冗長です。一つの`using`宣言のグループ内では共通する部分の名前空間を繰り返す必要はなさそうに見えます。例えば次のように書くことができれば、かなり簡潔に`using`宣言を記述できるようになります

```cpp
using std::{format, format_to, formatter};
using std::chrono::{duration, time_point, duration_cast};
```

この提案は、`using`宣言においてこのようにグルーピングして記述できるようにしようとするものです。

これは新機能の提案ではなく、純粋に可読性を向上させるための機能拡張の提案です。

提案では、ワイルドカードの使用（`using std::chrono::*;`）や波かっこのネスト（`using std::{formatter, chrono::{duration, time_point}};`）についても検討していますが、いずれも不許可としています。

筆者の方はClangをフォークして実装してみたところかなり簡単に実装できたと報告しています。

- [P3485 進行状況](https://github.com/cplusplus/papers/issues/2154)

### [P3487R0 Postconditions odr-using a parameter that may be passed in registers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3487r0.pdf)
### [P3488R0 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r0.pdf)
### [P3488R1 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r1.pdf)
### [P3489R0 Postconditions odr-using a parameter of dependent type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3489r0.pdf)
### [P3490R0 Justification for ranges as the output of parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3490r0.html)
### [P3491R0 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3491r0.html)
### [P3492R0 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3492r0.html)
### [P3493R0 Ruminations on reflection and access](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3493r0.html)
### [P3495R0 Remarks on Basic Statistics, P1708R9 <../2024/p1708r9.pdf>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3495r0.pdf)
### [P3497R0 Guarded Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3497r0.html)
### [P3498R0 Stop the Bleeding but, First, Do No Harm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3498r0.pdf)
### [P3502R0 Slides for D2900R11 - Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3502r0.pdf)
### [P3503R0 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3503r0.html)
### [P3504R0 C++ Standard Library Ready Issues to be moved in Wroclaw, Nov. 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3504r0.html)
### [P3508R0 Wording for constexpr for specialized memory algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
### [P3510R0 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r0.html)
### [P3510R1 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r1.html)
### [P3510R2 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r2.html)
### [P3517R0 Slides presented to LEWG on trivial relocation in Wroclaw](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3517r0.pdf)
### [P3518R0 Slides for Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3518r0.pdf)
### [P3519R0 Slides for P3425 presentation to LEWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3519r0.pdf)
### [P3520R0 Wroclaw Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3520r0.pdf)
### [P3521R0 Pattern Matching: Customization Point for Open Sum Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3521r0.html)
### [P3524R0 Core Language Working Group "ready" Issues for the November, 2024 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3524r0.html)
### [P3525R0 Explicit Implicit Template Regions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3525r0.html)
### [P3527R0 Pattern Matching: *variant-like* and `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3527r0.html)
### [P3530R0 Intrinsic for reading uninitialized memory](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3530r0.html)
### [P3533R0 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3533r0.html)
### [P3537R0 Presentation on Concurrent Queue API LEWG Telecon 2024-Dec-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3537r0.pdf)
### [P3539R1 Consistent Function Label Naming for Sections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3539r1.pdf)
### [P3540R0 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3540r0.html)
### [P3541R0 Violation handlers vs `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3541r0.html)
### [P3542R0 Abolish the term "converting constructor"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3542r0.html)
### [P3543R0 Response to Core Safety Profiles (P3081)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3543r0.pdf)
