# ［C++］WG21月次提案文書を眺める（2024年12月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-12](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-12)

全部で166本あります。

もくじ

[:contents]


### [N4977 2025-11 Kona meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4977.pdf)

2025年11月にハワイのコナで行われる全体会議のインフォメーション。

予定（2025年11月3日～8日）と場所、ホテルの案内などが記載されています。

### [N4995 WG21 agenda: 18-23 November 2024, Wroclaw, Poland](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4995.html)

2024年11月にヴロツワフで行われた会議のアジェンダ。

### [N4997 Hagenberg Meeting Invitation and Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4997.pdf)

2025年2月にオーストリアのハーゲンベルクで行われる全体会議のインフォメーション。

予定（2025年2月10日～15日）と場所、ホテルの案内などが記載されています。

### [N4998 WG21 2024-11 Wroclaw Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4998.pdf)

2024年11月6日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Wroclaw会議で何をするかなどの報告がなされています。

### [N4999 WG21 agenda: 10-15 February 2025, Hagenberg, Austria](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4999.html)

2025年2月にハーゲンベルクで行われる会議のアジェンダ。

### [N5000 WG21 November 2024 Hybrid meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5000.pdf)

2024年11月にWroclawで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [N5001 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5001.pdf)

C++26のワーキングドラフト第7弾

### [N5002 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5002.html)

↑の変更点をまとめた文書。

### [N5003 2025 WG21 admin telecon meetings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n5003.pdf)

2025年に行われる、WG21管理者ミーティングの予定表。

### [P0178R1 Allocators and swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0178r1.pdf)

アロケータが等価ではない場合のコンテナ間`swap`を未定義動作ではなくする提案。

C++17で導入された`polymorphic_allcoator`のように、状態を持つアロケータにおいては同じアロケータ型のアロケータオブジェクト同士の比較が必ずしも`true`にはなりません。その場合、そのようなアロケータ同士を保持するコンテナの`swap`は未定義動作となります。

`swap`は単にコンテナの内部ハンドルを交換するだけで済み、アロケータが等価であればアロケータそのものの交換作業は不要になります。しかし、アロケータ等価ではない場合にそのような`swap`を行ってしまうと交換後のコンテナでは、そのメモリ領域を解放する能力のないアロケータとそのアロケータから取得されていないメモリ領域がペアになった状態になり、この状態では正しくリソース解放が行われなくなります。

C++11以前には状態を持つアロケータがサポートされていなかったため、標準のコンテナのデフォルト動作はアロケータの不一致を考慮しない`swap`（すなわち、アロケータ以外の内部ハンドル等の`swap`）を行います。C++11では状態を持つアロケータがサポートされたものの、`propagate_on_container_swap`が`true_type`の場合にのみ`swap`操作でアロケータが伝播する事を期待できますが、`std::allocator`は（および`std::allocator_traits`、`std::pmr::polymorphic_allcoator`も）これを定義しないため、標準コンテナのアロケータはステートフルなものが指定されても`propagate_on_container_swap`が`true_type`で定義されていなければアロケータが等価ではない場合の`swap`は未定義動作となります。

これはおそらく、以前からコンテナ`swap`の要件が定数時間であることも関係していると思われます。

いずれにしても、標準のコンテナはほとんどの場合にアロケータが等価ではない場合の`swap`を未定義動作としています。

`std::swap()`は広い契約をもつ関数であるものの、標準のコンテナの`swap`操作は`std::swap`の各コンテナによるオーバーロードを通してカスタマイズされており、各コンテナの`swap`（メンバ関数）はこのアロケータ不一致に関するより狭い契約を持ちます。これは、広い契約を持つ関数を狭い契約をもつ関数で置き換えており、

これによりユーザーは、アルゴリズム等のジェネリックなコードにおいてコンテナの`swap`を行う場合に、それが標準のコンテナであるかどうか（アロケータの不一致をケアする必要があるかどうか）、すなわち`std::swap`の契約とは異なる契約になっていないかを考慮する必要があります。

この現状に対してこの提案は、標準のコンテナの`swap`がアロケータが等価ではない場合でも未定義動作とならないようにすることを提案するものです。

標準のコンテナのアロケータと`swap`の関係は現在次のようになっており

|swap時の伝播可能性＼実行時等価性|アロケータが等価|アロケータが等価ではない|
|---|:-:|:-:|
|`propagate_on_container_swap`有効|✅|✅|
|`propagate_on_container_swap`無効|✅|☠|

この提案は、この表の右下の部分をwell-formedにしようとしています。

具体的には、アロケータが等価ではなく`propagate_on_container_swap`も無効な場合には要素ごとのムーブによってアロケータが一致するように要素を交換する事を要求するようにします（同時に、計算量の要件も緩和します）。そのほかの場合の動作は現状通りで変更しません。

とても簡易には次のような実装になります

```cpp
void CONTAINER_TYPE::swap(CONTAINER_TYPE & other) {
  if( std::allocator_traits<allocator_type>::propagate_on_container_swap
   || std::allocator_traits<allocator_type>::is_always_equal
   || this->get_allocator() == other.get_allocator()) {
    // trust compiler will optimize the compile-time branching
    // take the fast path

    if constexpr(std::allocator_traits<allocator_type>::propagate_on_container_swap) {
      using std::swap;
      swap(this->get_allocator(),other.get_allocator());
    }
  }
  else if constexpr( all traits are consistent ) {
    CONTAINERbuffer{std::move(other)};
    other = std::move(*this);
    *this = std::move(buffer);
  }
  else {
    //Copy into buffer having the right allocator
    CONTAINERbuffer_this {std::move(other), this->get_allocator()};
    CONTAINERbuffer_other{std::move(*this), other.get_allocator()};

    this->swap(buffer_this);
    other.swap(buffer.other);
  }
}
```

この提案の根拠としては、ブルームバーグ社内コードベースでの10年以上に渡るステートフルアロケータと標準ライブラリの使用経験において、提案するような動作を保守し続けており、現在でもその動作をサポートする理にかなったユースケースが存在している事を確認している事を挙げています。少なくともブルームバーグ社内のユーザーは、線形時間かつ例外を送出しうる`swap`と未定義動作のどちらかの選択を迫られたときに明確に前者を選択している、としています。

- [C++ named requirements: AllocatorAwareContainer (since C++11) - cppreference.com](https://en.cppreference.com/w/cpp/named_req/AllocatorAwareContainer)
- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P0260R12 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r12.html)

↓

### [P0260R13 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r13.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)
- [P0260R9 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P0260R9-C-Concurrent-Queues)
- [P0260R10 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P0260R10-C-Concurrent-Queues)
- [P0260R11 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P0260R11-C-Concurrent-Queues)

R12での変更は

- St. LouisでのLEWG/SG1フィードバックを反映
    - アロケータ受け入れに関する文言を追加
    - シングルエンドインターフェースを提供しない理由を追記
    - `buffer_queue`がムーブ不可な理由を追記
    - `buffer_queue`が`emplace`を提供しない理由を追記
- WroclawでのSG1フィードバックを反映
    - sequential consistencyに関する文言を修正
    - `async_*`に関する文言を修正
    - `buffered_queue`のキューとしての順序の指定を修正
- 使用例を追加

このリビジョンでの変更は

- `conqueue_errc`に`success`を追加
- エラーハンドリングの更新
- コンセプトの根拠を追加
- API（エラーハンドリング・戻り値型・`emplace`）の更新（根拠も含めて
- 例を更新

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0447R27 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r27.html)
### [P0447R28 Introduction of std::hive to the standard library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0447r28.html)
### [P0472R3 Put std::monostate in <utility>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0472r3.pdf)
### [P1040R7 std::embed and #depend](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1040r7.html)
### [P1061R10 Structured Bindings can introduce a Pack](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1061r10.html)
### [P1928R13 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r13.pdf)
### [P1928R14 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r14.pdf)
### [P1928R15 std::simd - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r15.pdf)
### [P1967R13 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1967r13.html)
### [P2014R1 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r1.pdf)

↓

### [P2014R2 Proposed resolution for US061/US062 - aligned allocation of coroutine frames](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2014r2.html)

コルーチンステートを割り当てる際の`operator new`呼び出しの際に、`std::align_val_t`を考慮するようにする提案。

この提案は、C++20のNBコメントUS061とUS063で提起された問題に対する解決策を提案するものです。

コルーチンが最初に呼びされた時にコルーチンステートを確保しようとする際に、プロミス型のコンテキストおよびグローバルな`operator new`を探索しますが、その際に`std::align_val_t`を取るオーバーロードを考慮していません。それによって、コルーチンの引数やプロミス型など、コルーチンフレームに保存されるものの中にオーバーアライメントされたものが含まれている場合などに正しくアラインされない可能性があります。

US061とUS063はどちらもこの問題の解決を求めるものであり、この提案のR0ではそのためのオプションを2つ提案していました

1. 割り当てるストレージが*new-extended*アライメントを要求する場合にのみ、 `std::align_val_t`オーバーロードを優先する
    - 利点: `new/delete`式の動作とより一貫している
    - 欠点: コルーチン開始時の`operator new`探索のルールが複雑化し、2回探索する必要がある。また、`std::align_val_t`オーバーロードを呼び出すかどうかの選択がコルーチンフレームのレイアウトが判明するコンパイルフェーズの後半まで延期しなければならなくなる
2. コルーチンフレームや*new-extended*アライメントを要求するかに関係なく常に`std::align_val_t`オーバーロードを優先する
    - 利点: より単純
    - 欠点: `new/delete`式の動作と矛盾する

そして、EWGでの議論の結果オプション1が選択されています。

オプション1でのコルーチン開始時（初期化時）にコルーチン用の追加の記憶域を確保する必要がある場合に行われる2段階の探索は次のようになります。

---

まず、その記憶域は非配列の`operator new`を呼び出すことで確保され、使用する`operator new`はプロミス型のコンテキストで探索され、その結果何らかの関数が見つかった場合、その集合からオーバーロード解決を次のように行う

1. 最初のオーバーロード解決は、引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 第二引数はコルーチンステートのアライメントであり、`std::align_val_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
        - 依存型ではない = 第二引数がテンプレートパラメータによって指定されていない
    - 見つからなかった場合、最初の2つの引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかり、第二引数が依存型ではない場合、見つかった関数を*overaligned-allocation-function*として定義する
2. 第二のオーバーロード解決は、再度引数リストを組み立てたうえで行われる
    - 第一引数は確保サイズ（コルーチンフレームのサイズ）であり、`std::size_t`型
    - 残りの引数はコルーチンの引数リストとなる
        - コルーチンがメンバ関数の場合、先頭には`*this`がある
    - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する
    - 見つからなかった場合、第一引数だけからなる引数リストによって再度オーバーロード解決を行う
        - オーバーロード解決の結果実行可能な関数が見つかった場合、見つかった関数を*normal-allocation-function*として定義する

`operator new`がプロミス型のコンテキストで見つからなかった場合、*overaligned-allocation-function*を` ::operator new(std::size_t, std::align_val_t)`で、*normal-allocation-function*を`::operator new(std::size_t)`で定義する。

そして、コルーチンステートが*new-extended*アライメントを持ち、かつ*overaligned-allocation-function*が見つかっている場合、コルーチンステートは*overaligned-allocation-function*の呼び出しによって確保される。そうではない場合で*normal-allocation-function*が見つかっている場合、コルーチンステートは*normal-allocation-function*で確保される。それ以外の場合はill-formed。

---

現在の仕様は、プロミス型のコンテキストでは2番目のオーバーロード解決フェーズのみを行い、またグローバルスコープの探索では`std::size_t`型の引数だけを用いてオーバロード解決を行い、そこで見つかった関数がそのまま使用されます。

なお、コルーチンステートを解放する`operator delete`も同様に`std::align_val_t`オーバロードを考慮するように修正されます。とはいえ`new`の場合ほど複雑ではなく

1. プロミス型のコンテキスト -> グローバルスコープ の順で`operator delete`を探索
2. プロミス型のコンテキストで見つかった候補の中に*destroying operator delete*が含まれている場合、ill-formed
3. コルーチンステートが*new-extended*アライメントを持つ場合、`std::align_val_t`型の引数を取るオーバーロードが優先される
4. そうではない場合、`std::align_val_t`型の引数を取らないオーバーロードが優先される
5. 優先される候補以外の候補は削除され、残った候補のうちでは`std::size_t`型の引数を取るものが取らないものよりも優先される

のようになっています。

なお、この提案はCWGのレビュー中だったものの、著者の方がこれ以上追及されないとして、取り下げられているようです。

- [US061 09.04.4 p10 Coroutine allocation should consider std::align_val_t P2014](https://github.com/cplusplus/nbballot/issues/60)
- [US063 09.04.4 Coroutine allocation should consider std::align_val_t](https://github.com/cplusplus/nbballot/issues/62)
- [コルーチン [P0912R5] - cpprefjp](https://cpprefjp.github.io/lang/cpp20/coroutines.html)
- [P2014 進行状況](https://github.com/cplusplus/papers/issues/750)

### [P2319R3 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r3.html)
### [P2319R4 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2319r4.html)
### [P2645R1 path_view: a design that took a wrong turn](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2645r1.html)
### [P2656R4 WITHDRAWN: C++ Ecosystem International Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2656r4.html)
### [P2686R5 constexpr structured bindings and references to constexpr variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2686r5.pdf)
### [P2688R4 Pattern Matching: `match` Expression](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2688r4.html)
### [P2717R6 WITHDRAWN: Tool Introspection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2717r6.html)
### [P2781R5 std::constexpr_wrapper](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2781r5.html)
### [P2786R9 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r9.pdf)
### [P2786R10 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r10.pdf)
### [P2786R11 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r11.html)
### [P2825R3 Overload resolution hook: declcall( unevaluated-call-expression )](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2825r3.html)
### [P2830R5 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r5.html)
### [P2830R6 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r6.html)
### [P2830R7 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r7.html)
### [P2835R7 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r7.html)
### [P2846R5 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r5.pdf)
### [P2863R8 Review Annex D for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2863r8.html)
### [P2865R6 Remove Deprecated Array Comparisons from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2865r6.pdf)
### [P2866R5 Remove Deprecated Volatile Features From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2866r5.pdf)
### [P2897R6 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r6.html)
### [P2897R7 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r7.html)
### [P2900R11 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r11.pdf)
### [P2900R12 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r12.pdf)
### [P2996R8 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r8.html)
### [P3008R3 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3008r3.html)
### [P3016R5 Resolve inconsistencies in begin/end for valarray and braced initializer lists](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3016r5.html)
### [P3019R11 Vocabulary Types for Composite Class Design](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3019r11.pdf)
### [P3037R4 constexpr std::shared_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3037r4.pdf)
### [P3045R4 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r4.html)
### [P3050R3 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r3.html)
### [P3051R3 WITHDRAWN: Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3051r3.html)
### [P3068R5 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r5.html)
### [P3068R6 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r6.html)
### [P3074R5 trivial unions (was std::uninitialized<T>)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3074r5.html)
### [P3096R4 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r4.pdf)
### [P3096R5 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r5.pdf)
### [P3098R1 Contracts for C++: Postcondition captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3098r1.pdf)
### [P3111R1 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r1.html)
### [P3111R2 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r2.html)
### [P3117R1 Extending Conditionally Borrowed](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3117r1.html)
### [P3125R2 constexpr pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r2.html)
### [P3136R1 Retiring niebloids](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3136r1.html)
### [P3138R4 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r4.html)
### [P3138R5 views::cache_latest](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r5.html)
### [P3146R2 Clarifying std::variant converting construction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3146r2.html)
### [P3149R7 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r7.html)
### [P3149R8 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r8.html)
### [P3152R1 Add missing constructors and assignment for indirect and polymorphic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3152r1.html)
### [P3179R4 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r4.html)
### [P3185R0 A proposed direction for C++ Standard Networking based on IETF TAPS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3185r0.html)

C++のNetworkライブラリの基礎的な設計の指針として、IETFのTAPSを基礎とする提案。

IETFのTAPS（Transport Services Application Programming Interface）とは、いわゆるソケット通信をはじめとするトランスポートプロトコルのAPIを再定義するもので、ネットワーク通信を必要とするアプリケーションにネットワーク機能を提供するための、特定の言語やプロトコルに依存しない抽象アーキテクチャを定義することを目的としているものです。

この提案ではC++の将来のNetwork標準ライブラリのAPIや設計をこのTAPSと整合するものにする事を提案しています。その理由としては

- 言語に依存しないAPIを提案しており、なおかつNetworking TSの欠けている機能として挙げられている領域をカバーしている
    - 名前付き接続（DNS解決など）
    - トランスポート層セキュリティ
- 既存のネットワークAPI（Berkeley Socketsからの派生など）の概念やそれに対応する命名規則に一貫性がないという問題に対処しようとしている
    - 現在のネットワークライブラリでは、同じものを表す概念やAPI名が歴史的経緯や使用するプロトコルによって大きく異なる
- TAPSアーキテクチャはアプリケーションとトランスポート間のインターフェースを再定義し、アプリケーションとの契約を根本的に変えることなくトランスポート層を進化させることを目指している
- TAPS勧告は、一般的なユースケースをシンプルかつ一貫性のあるものにしつつ、トランスポート層をよりきめ細かく制御する必要があるアプリケーションに対してはその方法を提供する事を目的としている

などが挙げられています。

Networking TSを含む従来のソケット通信のモデルは次のように説明できます

- ソケットAPIを用いて接続を作成し、データを転送する
- ソケットAPIは、TCPおよびUDPプロトコルの実装へのインターフェースを提供する
    - 実装は通常、システムカーネルによって提供される
- TCP/UDP実装はネットワーク層インターフェースを介してデータを送受信する
- ソケットは、トランスポート層およびネットワーク層のアドレスに直接バインドされる
    - これらのアドレスは通常、システムが提供するDNSスタブリゾルバによって実行される別の解決手段によって取得される

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
        |                 |                  |
  +------------+     +------------+    +--------------+
  |  DNS stub  |     | Stream API |    | Datagram API |
  |  resolver  |     +------------+    +--------------+
  +------------+          |                  |
                    +---------------------------------+
                    |    TCP                UDP       |
                    |    Kernel Networking Stack      |
                    +---------------------------------+
                                    |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

これに対して、TAPSのAPI構造は次のようになっています

```
+-----------------------------------------------------+
|                    Application                      |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|              Transport Services API                 |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|          Transport Services Implementation          |
|  (Using: DNS, UDP, TCP, SCTP, DCCP, TLS, QUIC, etc) |
+-----------------------------------------------------+
                          |
+-----------------------------------------------------+
|               Network Layer Interface               |
+-----------------------------------------------------+
```

TAPSのAPIは、接続の作成とデータ転送のためのインターフェースを定義し、複数のインタラクションパターンのインターフェースを定義したものです。そして、このAPIは特定のプロトコルに特化したものではなく、より汎用的に様々なプロトコルをサポートすることができ、初期セットとしてTCP/UDPのみに限定しても将来的にQUICなどのプロトコルにライブラリを拡張可能です。

名前解決を接続の確立とデータ転送と組み合わせていることで、このAPIの実装（それは各実装のQoIとされる）はより柔軟なものになっています。

そして、従来のソケットベースAPIとの重要な違いは、TAPS APIはデフォルトで非同期かつイベント駆動型であることです。アプリケーションへのデータ転送を表現するためにメッセージという抽象的な概念を用いています。また、アプリケーションがネットワークエンドポイント識別子を解決して複数のアドレス・プロトコル・パスを記述して、これらのストリームを同時に扱う方法を記述しています。

提案にはもう少し詳しくTAPS APIの特徴が紹介されています。

この提案ではSG4に対して、Networking TSの大規模再設計を行うべきか、このTAPS APIのようなより現代的な規範に従うか、の選択を迫っています。

- [RFC 9621 - Architecture and Requirements for Transport Services](https://datatracker.ietf.org/doc/rfc9621/)
- [RFC 9622 - An Abstract Application Programming Interface (API) for Transport Services](https://datatracker.ietf.org/doc/rfc9622/)
- [RFC 9623 - Implementing Interfaces to Transport Services](https://datatracker.ietf.org/doc/rfc9623/)
- [P3185 進行状況](https://github.com/cplusplus/papers/issues/2145)

### [P3204R0 Why Contracts?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3204r0.pdf)

C++ Contractsに対する疑問の声に応える文書。

P2900R7がSG21からEWGに転送され、より広い委員会メンバに提示されたときに、Herb Sutterさんが（おそらくMSを代表する形で）2つの質問事項を提示したようです。この文書はそれを受けて、それ（+1）に対する回答を行うとともにそれを文書の形で残して公開しておくためのものです。

ここで回答されているのは次の3つの質問です

1. 契約プログラミングという概念そのもの及びその言語実装は何十年も前から利用可能であるにもかかわらず、あまり主流ではない。にもかかわらず、C++における契約プログラミング機能が成功すると確信する根拠は何か？
2. C++0xのコンセプトは標準ライブラリに適用してみようとするまでは素晴らしいものに見えていた。Contractsの標準化は標準ライブラリでどのように使用されるかを特定せずに成功するか？
3. 現在の環境において、委員会の中で多くの安全性向上に関する提案が競合している中で、なぜContractsが優先されるべきか？

それぞれに対する回答を要約すると

1. C++ Contractsは既に成功しており、この機能は最初から既存および将来の機能との強力な統合によって既存の全ての機能の優れた代替手段を提供することを目指して設計されている
    - P2900のContracts機能は現在マクロベースで広く利用されているアサーション機能の既存の実践に進化型であり、それら既存のアサーション機能は様々な形と場所で実装され広く使用されており、Contractsがすぐに提供する機能や将来的に提供しようとする機能のほとんどはすでに利用されている
    - 重要なのは、Contractsではそれらマクロベースの既存機能の持つ問題点の多くを修正しており、それらのライブラリサイドでは対処できない問題を解消していることによって、既存のアサーション機能のすべてにとって魅力的な移行先となること
    - 特に、P2900の設計原則の1つである「契約注釈の存在及びその評価は、プログラムの正当性を変更するべきではない」という原則によって、契約注釈をプログラムに追加することでプログラムの正当性を検証することができ、なおかつ既存のプログラムに容易に導入可能となる
    - そして長期的な目標として、プログラムの正しさを担保するアノテーションを付与するための強固な基盤を提供し、それによってプログラムの正しさを堅牢に静的解析することを可能にする、というものがある
2. Yes、なぜなら、C++コミュニティはContractsの様な契約チェックを最新の標準ライブラリ実装を含む既存のライブラリで使用してきた豊富な経験を持っているため
    - さらに、標準ライブラリの仕様はC++20の頃から、契約と契約チェック機能を意識して記述されている
    - ただし、現在の標準ライブラリ実装が持つマクロベースのソリューションによって契約チェックを提供することをすぐにやめる（事を促す）べきではなく、ライブラリがコア言語に移行する準備ができ、その意思があり、移項できる状態にあることを前提に契約アサーションを標準ライブラリ仕様に盛り込むことは標準というものに対して無責任な行為である
        - 当面の間（おそらくは無期限に）、ライブラリ実装が正確性のチェックにContracts機能を使用するかしないか、あるいはまったくチェックしないかどうかは実装のQoIとしておくべき
3. Contracts機能は、安全性を脅かす未定義動作の根本的なバグに対処するための基盤的なソリューションである
    - 未定義動作を悪用することで発生するCVEの問題は、ほぼ同語反復的にそのような問題の発生を可能にするソフトウェアバグの結果である
    - 未定義動作の悪用を防ぐことは症状に対処することであって、バグを含むプログラムこそが真の問題であるはず
    - Contracts及び契約プログラミングの概念は、そのようなバグを識別しその発生源を軽減する方法を提供する
    - そして、Contracts機能による契約注釈の導入は、あらゆる品質のコードベースへの導入に当たって可能な限り障害が少なくなるように設計されている。これによって、レガシーコードベースを段階的に修正していくことが可能となる
        - さらに、レガシーコードベースにまず契約注釈を導入していくことで、開発者はそのコードベースの意味を把握できるだけでなく、その動作を明文化し、期待通りに動作しなかった場合にそれを継続的に補足することができる
    - したがって、契約チェックは最新のコンパイラでコンパイル可能なあらゆるC++プログラムで利用可能な正確性向上への入り口となる

より詳細な回答は文書を参照してください。もっと良いことが書いてあります。

- [P3204 進行状況](https://github.com/cplusplus/papers/issues/2146)

### [P3222R1 Fix C++26 by adding transposed special cases for P2642 layouts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3222r1.html)
### [P3227R1 Fixing the library API for contract violation handling](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3227r1.pdf)
### [P3230R1 views::unchecked_(take|drop)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3230r1.html)
### [P3232R1 User-defined erroneous behaviour](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3232r1.html)
### [P3237R2 Matrix Representation of Contract Semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3237r2.pdf)
### [P3247R2 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r2.html)
### [P3261R2 Revisiting `const`-ification in Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3261r2.pdf)
### [P3284R2 `write_env` and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r2.html)
### [P3287R2 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r2.pdf)
### [P3296R3 let_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r3.html)
### [P3299R3 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r3.html)
### [P3309R3 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r3.html)
### [P3310R5 Solving issues introduced by relaxed template template parameter matching](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r5.html)
### [P3319R2 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3319r2.pdf)
### [P3323R1 cv-qualified types in atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3323r1.html)
### [P3325R4 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r4.html)
### [P3325R5 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r5.html)
### [P3329R0 Healing the C++ Filter View](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3329r0.pdf)
### [P3335R3 Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r3.html)
### [P3335R4 WITHDRAWN: Structured Core Options](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3335r4.html)
### [P3339R1 WITHDRAWN: C++ Ecosystem IS Open License](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3339r1.html)
### [P3342R1 Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r1.pdf)
### [P3342R2 WITHDRAWN: Working Draft, Standard for C++ Ecosystem](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3342r2.html)
### [P3355R2 Fix submdspan for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3355r2.html)
### [P3367R1 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r1.html)
### [P3367R2 constexpr coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3367r2.html)
### [P3371R3 Fix C++26 by making the rank-1, rank-2, rank-k, and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r3.html)
### [P3378R1 constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3378r1.html)
### [P3380R1 Extending support for class types as non-type template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3380r1.html)
### [P3383R1 mdspan.at()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3383r1.html)
### [P3385R2 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3385r2.html)
### [P3386R1 Static Analysis of Contracts with P2900](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3386r1.pdf)
### [P3396R1 std::execution wording fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3396r1.html)
### [P3409R1 Enabling more efficient stop-token based cancellation of senders](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3409r1.html)
### [P3422R1 Allow main function in named modules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3422r1.html)
### [P3424R0 Define Delete With Throwing Exception Specification](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3424r0.pdf)

`delete`演算子オーバーロードが例外を送出しうる例外仕様を持つことを禁止する提案。

`operator delete`はユーザーによって明示的に`noexcept(false)`等と指定されない限り、デフォルトで`noexcept`になります。`noexcept(false)`と明示的に指定して例外を投げられるようにすることもできるのですが、その場合の振る舞いは未定義動作となります。したがって、`operator delete`に例外を送出しうる例外仕様を指定する有効なユースケースは存在していません。

そのため、この提案では`delete`演算子オーバーロードに対する例外を送出しうる例外仕様の指定をill-formedにしようとしています。

この提案の推奨は、例外を送出しうる例外仕様（`noexcept(false)`等）を禁止し、例外を投げうる例外仕様（`noexcept`等）は非推奨としておくことです。前者については意味がない使用法ですが、後者については妥当な使用法であるためです。

ただし、GCCの現在の実装にはdestroying operator deleteに対する暗黙の`noexcept`を行わないというバグがあるため、これが修正される前にこの提案が適用されると、そのバグによりdestroying operator deleteが全てコンパイルエラーを起こすようになってしまう可能性がある、と報告しています。

- [P0178 進行状況](https://github.com/cplusplus/papers/issues/2149)

### [P3427R1 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3427r1.pdf)
### [P3428R1 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3428r1.pdf)
### [P3429R1 Reflection header should minimize standard library dependencies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3429r1.html)
### [P3430R1 simd issues: explicit, unsequenced, identity-element position, and members of disabled simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3430r1.pdf)
### [P3436R1 Strategy for removing safety-related undefined behavior by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3436r1.pdf)
### [P3437R1 Proposed principles: Reflect C++, generate C++ (by default)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3437r1.pdf)
### [P3449R1 constexpr std::generator](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3449r1.html)
### [P3466R1 (Re)affirm design principles for future C++ evolution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3466r1.pdf)
### [P3468R0 2024-10 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3468r0.html)

2024年2月に行われたLEWGの投票の結果。

次の13の提案が投票にかけられ、否決されたものはありません。

- [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://wg21.link/P2897R5)
- [P3008R2 Atomic floating-point min/max](https://wg21.link/P3008R2)
- [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://wg21.link/P3050R2)
- [P3068R4 Allowing exception throwing in constant-evaluation](https://wg21.link/P3068R4)
- [P3136R0 Retiring niebloids](https://wg21.link/P3136R0)
- [P3222R0 Fix C++26 by adding transposed special cases for P2642 layouts](https://wg21.link/P3222R0)
- [P3309R2 constexpr atomic and atomic_ref](https://wg21.link/P3309R2)
- [P3323R0 cv-qualified types in atomic and atomic_ref](https://wg21.link/P3323R0)
- [P3325R3 A Utility for Creating Execution Environments](https://wg21.link/P3325R3)
- [P0472R2 Put std::monostate in <utility>](https://wg21.link/P0472R2)
- [P3355R1 Fix submdspan for C++26](https://wg21.link/P3355R1)
- [P3369R0 constexpr for uninitialized_default_construct](https://wg21.link/P3369R0)
- [P3399R0 Adjusting Electronic Polls to a Hybrid Workflow](https://wg21.link/P3399R0)

最後のものを除いて、どれもC++26に向けてLWGに転送されます。

賛否の票数や投票に当たって寄せられたコメントが記載されています。

### [P3471R1 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r1.html)
### [P3471R2 Standard Library Hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3471r2.html)
### [P3477R1 There are exactly 8 bits in a byte](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3477r1.html)
### [P3480R1 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r1.pdf)
### [P3480R2 std::simd is a range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3480r2.pdf)
### [P3482R0 Proposed API for creating TAPS based networking connections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3482r0.html)

IETFのTAPSに基づいたネットワークライブラリのAPIの提案。

IETFのTAPSについては少し上のP3185R0を参照。

この提案は、P3185R0に続いてTAPSに基づいた実際のライブラリAPIを提案するものです。ただし、全く新しいものを提案するのではなく、P2762(R2)で提案されているもの、すなわちNetworking TSに`std::execution`（sender/receiver）を組み込んだ形のライブラリをベースにして、それに対してTAPSの概念や言葉に基づいた変更を加えています。

#### TAPSのプロパティ

TAPSではある接続に対する要件を記述するためにプロパティベースのアプローチを採用しています。TAPS実装では、接続の際に指定されたプロパティを満たす1つ以上の接続方法の候補セットを特定し、ユーザーの選択や追加の指定などによってその中から1つを選択して接続に使用します。

そのようなプロパティには次のものがあります

1. 事前接続（Preconnections）
    - 接続の確立は事前接続から開始される
    - TAPSでは、事前接続オブジェクトを定義する4つのプロパティグループを定義している
        1. ローカルエンドポイント（Local Endpoint）
        2. リモートエンドポイント（Remote Endpoint）
        3. トランスポート（Transport）
        4. セキュリティ（Security）
2. エンドポイント（Endpoints）
    - エンドポイント接続の始点と終点を定義し、ローカルとリモートに区別される
    - エンドポイントには次のプロパティがある
        1. ホストネーム: 例"nyarlathotep.example.org"
        2. インターフェース: 例"en0"
        3. サービス: 例"https"
        4. マルチキャストグループ: 例"224.0.0.252" or "ff02::114"
        5. ホップ制限: 数値
3. トランスポート（Transports）
    - トランスポートは基盤となるインフラストラクチャが満たすことが期待される要件の集合によって定義される
    - ほとんどのトランスポートは、次のいずれかの値を取る設定として表現される
        1. Require
        2. Prefer
        3. None
        4. Avoid
        5. Prohibit
    - トランスポートには、要件を表現するために使用できる次のプロパティがある
        1. interface
            - `(interface, preference)`のようなタプル値の集合
        2. reliability: preference
        3. preserve_msg_boundaries: preference
        4. per_msg_reliability: preference
        5. preserve_order: preference
        6. zero_rtt_msg: preference
        7. multistreaming: preference
        8. full_checksum_send: preference
        9. full_checksum_recv: preference
        10. congestion_control: preference
        11. keep_alive: preference
        12. use_temp_local_address: preference
        13. multipath
            - 列挙型: `{ disabled, active, passive }`
        14. advertises_alt_addr: preference
        15. direction
            - 列挙型: `{ both, send, recv }`
        16. soft_error_notify: preference
        17. active_read_before_send: preference
4. セキュリティ（Security）
    - トランスポートのセキュリティは、満たさなければならない一連の要件によって定義される
    - 次のプロパティがサポートされている
        1. allowed_security_protocols: プロトコル識別子のシーケンス
        2. server_cert: 証明書のシーケンス
        3. client_cert: 証明書のシーケンス
        4. pinned_server_cert: 証明書のシーケンス
        5. alpn: アプリケーション層のプロトコルネゴシエーション値のシーケンス
        6. supported_group: グループ識別子のシーケンス
        7. ciphersuite: 暗号スイート識別子のシーケンス
        8. signature_algorithm: アルゴリズム識別子のシーケンス
        9. max_cached_session: 整数値
        10. cached_session_lifetime: 期限を示す値
        11. preshared_key: 鍵の実体
        12. trust_verification_handler: `sender`のシーケンス
        13. challenge_handler: `sender`のシーケンス

エンドポイント・トランスポート・セキュリティの3つのプロパティセットはまず事前接続を確立するために使用され、その確立後に事前接続は接続（オブジェクト）を作成するために使用されます。TAPSでは、事前接続型に対して接続（`Connection`型オブジェクト）を作成するための3つの関数を定義します

1. `Initiate() -> Connection`: アクティブオープン接続
    - クライアントがサーバーと通信する場合などに使用する
    - `client_connection()`という名前でも良い
2. `Listen() -> Connection`: パッシブオープン接続
    - サーバーがクライアントからの接続を待ち受ける場合などに使用する
    - `server_connection()`という名前でも良い
3. `Rendezvous() -> Connection`: ピアツーピア接続
    - `peer_to_peer_connection()`という名前でも良い

追加で、事前接続がエンドポイント解決（名前解決）を行えることを規定しており、そのための関数を定義します

1. `Resolve() -> (local_endpoint[], remote_endpoint[])`

#### Framer

TAPSによるユーザー（ライブラリ利用者）とのやり取りは明確にメッセージベースであり、従来のソケット通信ライブラリ（バークレイソケットやNetworking TSなど）とは異なっています。TAPSでは、受信データの1つ以上のチャンクから完全なメッセージ（またはエラー）を生成する**Framer**という概念を導入しています。Framerは、送信や受信等のイベントを何かしらの単位でフレーム化することを担っており、そのフレーム化のためのルールを表現するものです。

Framerは事前接続から接続を取得する際の（関数の）オプション引数でもあります。Framerはイベント駆動型で、基盤となるトランスポートから、接続の開始・受信/送信データ・接続の終了、に関するイベントを受信します。

Framerでは、送信メッセージのエンコード方法や受信メッセージのデコード方法の定義等を行うことで接続のプロトコルスタックを拡張することができ、ストリーム指向のトランスポートプロトコルを使用する場合でも明確に定義されたメッセージ境界を提供することができます。

例えば、デフォルトである`default_framer`はバークレイソケットなどと同様に動作して、現在受信しているバイトを返すだけですが、より高レベルのFramerとして基礎のバイトストリームからHTTPのレスポンスをデコードし、ヘッダとメッセージを分離して返す`http_framer`を考えることができます。

#### メッセージコンテキスト

データの送受信呼び出しにおいては、アプリケーションはメッセージコンテキストを指定することができ、このメッセージコンテキストにはいくつかの役割があります

- 送信/受信操作に渡されるメッセージコンテキストは、Framerがメッセージデータをどのように扱うかについてを制御するFramer固有のプロパティを伝達する手段として使用される
- メッセージコンテキストは完了したメッセージ（イベント）を受信する`receiver`（の`set_value`チャネル）とやり取りするために使用できる
- 複数の部分的な送信/受信操作を関連付けるために使用できる
- メッセージコンテキストにはインターフェースやリモートエンドポイントなどに関する情報が含まれているが、Framerはこれを拡張してフレーム化されるメッセージについての追加のメタデータを指定できる
    - 例えばHTTPヘッダなど

#### TAPSとP2762R2の調和

この提案のライブラリは、ここまでで説明したようなTAPSの概念を優先しつつも、既存の提案であるP2762をベースとしたものになっています。例えば、P2762でがソケット型とそれに対する操作を定義するCPO群を定義していますが、ここで提案している`connect, listen, rendezvous`CPOはソケット型ではなく`Connection`型を返し、`async_send()`や`async_receive()`などのCPOは`Connection`型に対する操作として再定義されます。

TAPSのプロパティや概念は基礎のトランスポートがTCP/IPベースであることを仮定しています。しかし、例えば基礎のトランスポートとしてMPIを使用して、Infiniband等の高性能ファブリックを使用する、といったニーズがある他、Asioにはシリアル通信やプロセス間通信を基礎トランスポートとしたソケットのサポート等があります。

プロセス間通信の場合エンドポイントはホスト名を持たず、セキュリティプロパティも無関係です。同様にトランスポートのプロパティもオプションになる場合もあれば、エンドポイントやトランスポートの種類などにより暗黙的に決定される場合もあります。

TAPSでは事前接続型はそのプロパティに応じて3つの異なる種類の接続形態（アクティブオープン、パッシブ（リッスン）、ランデブー（P2P））を想定していますが、TCP/IPベース以外のトランスポートをサポートしようとする場合、常にこの3つの接続形態が利用可能であると仮定することはできなくなります。

そこで、この提案ではこの3つの接続形態（及び基礎となるトランスポート種別）に対応する接続型（`Connection`型）を共通ではなく異なるものとして、接続型は基礎となるトランスポートのサポートする操作のみをそのインターフェースとして公開し利用可能にするようにします（TAPSでは接続型は単一の型であり、異なるトランスポートをサポートするための最大公約数的なインターフェースを公開するものとされている）。そして、事前接続型に応じた3つの接続操作はCPOとしてカスタマイズポイントになることで、ベンダー/ユーザーはTCP/IPベース以外のトランスポートをサポートできるようになります。

標準ライブラリとしては、TAPSで示されているエンドポイント・トランスポート・セキュリティのプロパティに準拠したデフォルトのトランスポート実装を提供し、`std::net::ip`名前空間に配置します。

そのような事前接続のプロパティセットを実装がクエリするための方法として、P3325で提案されている実行環境用のプロパティクエリと定義の仕組みを応用することを提案しています。これによって、事前接続型がP3325の方法によって各種プロパティを取得できるようになってさえいれば、ユーザー側で定義した任意の型（＝任意のプロパティセット）を事前接続型として使用できるようになります。標準ライブラリとしてはデフォルトの事前接続型を提供します。

ここでも、3つの接続操作（`connect, listen, rendezvous`）がCPOであることによって、事前接続型に応じた接続型の選択がカスタマイズ可能になります。

TAPSでは信頼検証とチャレンジ処理のためのセキュリティハンドラをコールバック操作として記述していますが、これは本質的に非同期操作であり、`sender/receiver`の語彙によって表現でき、またそうすべきです。ただし、現在の`sender`ではこのための能力が不足しているため、ここでは`sequence_sender`というタイプの新しい`sender`を提案しています。

`sequence_sender`は`sender`に対して`set_next_value()`操作を追加したもので、`set_next_value()`操作は（`io_context`によって）値を受信した際に実行する処理をスケジューリングできる`sender`を返します。

例えばセキュリティコールバックの場合、接続型からそのための`sequence_sender`を取得し、`set_next_value()`によってセキュリティコールバック（信頼検証やIDチャレンジ）に必要な追加の値を受け取って、その操作を表す`sender`を返します。この`sender`に対して`receiver`を接続することでセキュリティコールバックの結果を取得します。

Framerは受信したバイト列をデコードしてメッセージ型に変換するだけではなく強く片付けされたヘッダを導入することもでき、Framerに対してこのようなヘッダセットやその型に関する情報を伝達するのにもP3325で提案されている`runtime_env`の仕組みを使用することを提案しています。標準ライブラリとしては、受信したデータの生のバイト列を`Connection`型固有のメッセージコンテキストともに返す`default_framer`を提供します。

接続のネゴシエーションと確立、フレーミング、メッセージ送受信はすべて、TAPSにおいても本質的に非同期操作です。したがって、これらの機能をC++ライブラリにエンコードする際には、`sender/receiver`の語彙を使用することができます。ただし、足りない部分があるので`sequence_sender`という拡張を提案しています（`sequence_sender`に関しては追加の提案でさらに詳細に説明される予定）。

事前接続におけるリモートエンドポイントの解決（名前解決）も非同期操作であるため、それを行う`resolve()`操作も`sender`を返すようにすることを提案しています。これにより、問い合わせのタイムアウトやキャンセル、中断などを自然にサポートできるようになります。

`Connection`型を構築するプロセスは通常このリモートエンドポイントの名前解決に依存するため、`resolve()`が非同期的で`sender`を返す場合、`Connection`を作成するエントリポイントも同様に`sender`を返すようにします

`Connection`はまた、受信/送信操作に基づくメッセージの配信に関するイベントに加えて、接続そのもののライフサイクルに関するイベントを配信する`sender`でもあります。このライフサイクルにはたとえば、ソフトエラー、パス変更、Closed、Abort、CloseGroup、AbortGroup、ConnectionError等があります。

P2762の非同期操作のほとんどは引き続き利用可能ですが、これらの事を踏まえて一部が修正されます。特に

- `async_accept()`は、提案されている`async_listen()`に統合される
- `async_connect()`は、提案されている`async_initiate()`に統合される
- `async_resolve_address()`と`async_resolve_name()`は、`async_resolve()`操作に統合される

P2762のデータ送信操作は次のように変更されます

- `async_send()`はメッセージ全体・ファイル全体などを送信するためのカスタマイズポイントとなる
    - 基礎となるトランスポートにメッセージをエンコードするための方法はFramerに移譲される
    - `async_send()`はメッセージコンテキストを受け入れるようになる
- `async_send()`の`message_flags`引数は削除され、トランスポートによるメッセージ配信を指示するプロパティはすべてメッセージコンテキストの一部になる
- `async_send()`の戻り値型は`send-sender`となる
    - `send-sender`はメッセージの送信中に発生した可能性のあるエラーに加えて、メッセージがつつがなく送信されたことや送信前にタイムアウトしたことなどを表す値を返す場合がある
- ユーザー視点からはストリームトランスポートへのデータ送信とデータグラム指向トランスポートへのメッセージ送信に違いは無いため、`async_send_to()`は削除
- TAPSに則って部分送信操作をサポートしており、このような部分送信操作はメッセージコンテキストオブジェクトによって紐づけられる
- 部分送信操作は、その個別の部分メッセージの送信によって生じた結果を受信する`send-sender`を返す

同様に、P2762のデータ受信操作も一部が次のように変更されます

- `async_receive()`はメッセージ全体・ファイル全体などを送信するためのカスタマイズポイントとなる
    - メッセージの定義（バイト列からの1メッセージの抽出方法）はFramerに移譲される
    - `async_receive()`はメッセージコンテキストを受け入れるようになる
- ユーザー視点からは、ストリームトランスポートへのデータ受信とデータグラム指向トランスポートへのメッセージ受信に違いは無いため、`async_receive_from()`は削除
- TAPSでは`async_read_some()`に似た部分受信操作を許可している
    - 同じメッセージコンテキストオブジェクトを指定する部分受信操作は、同じ論理受信操作の一部となる
    - ここでは、`async_receive()`のオーバーロードとして最大読み取り長を含めるか、`async_receive_some()`操作を導入すること
- `async_receive()`の戻り値型は`receive-sender`を返す
- `async_receive()`によって最終的に送信される`set_value()`呼び出しには、操作開始時に提供されたメッセージコンテキストとメッセージの全体または部分的メッセージが含まれる
- `async_receive()`は`std::execution`の他の非同期操作と同様に、`stop_token`を用いてキャンセル可能

この提案の現在のリビジョンでの変更はまだ作業途中であり、将来のリビジョンで更なる作業が予定されています。

- [P3482 進行状況](https://github.com/cplusplus/papers/issues/2151)

### [P3483R0 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r0.pdf)

↓

### [P3483R1 Contracts for C++: Pre-Wroclaw technical clarifications](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3483r1.pdf)

P2900R10のコーナーケースについて明確化する提案。

C++26に向けたContracts MVPの提案（P2900R10）は既にGCCとClangにおいて先行して実装されており（P3460R0で報告されています）、限定的ながら実装と展開の経験が得られています。この提案はその際に判明した仕様のコーナーケースについて説明し、改善を図るものです。

報告されているのは次のものです

1. 戻り値型推論を利用している関数の事後条件での結果オブジェクト名は遅延解析するべき
2. 事後条件内での結果オブジェクトのトリビアルコピーは事後条件評価と逐次的に行う
3. 事後条件内でodr-usedされる引数名の場合、その`const`は依存型の一部とすることができる
    - P3489R0に分離
4. 再宣言された事前・事後条件内でラムダ式が出現できる

この提案ではこのうちの1、2と4について現在の仕様を改善する文言を提案しています。

#### 1. 戻り値型推論を利用している関数の事後条件での結果オブジェクト名は遅延解析するべき

戻り値型推論を利用している（`auto`や`decltype(auto)`等を戻り値型に指定している）場合、事後条件は定義である宣言に指定されていなければならないと規定されています（したがって定義以前に宣言が存在できない）。これは事後条件のパースを完了するには戻り値型が分かっている必要があるためです。この規定に関して、事後条件に`<`が含まれている場合の実装方法と振る舞いに関する曖昧さがあります。

例えば次のようなコードにおいて

```cpp
struct A {
  template <int N>
  bool f() const;
};

auto h()
  post (v: v.f<6>())
{
  return A{};
}
```

`h()`の事後条件内で現れる`<`トークンは、`<`演算子として解釈されるべきかテンプレートパラメータリストの開始山かっことして解釈されるべきかは、`h()`の戻り値型（`v`の型）が分からないと決定できません。この実装方法に関しては2つの選択肢があります

1. `h()`のような関数における事後条件内では、戻り値型は遅延解析される
    - 事後条件の述語式は関数本体がパースされた後にパースされる
2. `h()`のような関数における事後条件内では、戻り値名は依存名として扱われる
    - 上記例の場合、`template`キーワードが必要となる（このままだとill-formed） 

P3460R0ではClang実装者の意見として1を採用すべきとされています。この提案でも同様に1のソリューションを採用することを提案しています。これはClangおよびGCCの実装にてすでに実装されている方法でもあります。

提案としてはこの1の方法で実装刷るべきであることを明確化する注釈を追記することを提案しています。

なお、この問題自体はC++20の頃のContractsの仕様において把握され解決が（この1のソリューションと同じ方法）採択済みであり、それはP2900にも受け継がれていましたが、他の変更などによってその文言の意図するところが不明瞭になっていたようです。

#### 2. 事後条件内での結果オブジェクトのトリビアルコピーは事後条件評価と逐次的に行う

関数の戻り値がRVOスロットを持たず、レジスタで直接的に返される場合、このような場合、結果オブジェクトはメモリ上に存在しないため、事後条件内から結果オブジェクトを参照する場合に実装はそのコピーを作成する場合があります。このような場合のコピーはトリビアルでなければならないため、このケースは戻り値型がトリビアルコピー可能な場合にのみ発生します。

この場合の問題は、このようにコピーされて一時的に実体化された戻り値オブジェクトは、複数の事後条件にわたって同じ値を使用する必要があるかどうか、というこｔです。

例えば次のようなコードにおいて、全ての契約アサーションがチェックされるセマンティクスで正確に一回だけ評価されるとして

```cpp
int f()
  post(r : ++const_cast<int&>(r) == 1)
  post(r : ++const_cast<int&>(r) == 2)  // true or false?
{
  return 0;
}
```

2つめの事後条件の評価は、最初のアサーションによって行われた変更を認識するかしないか（認識するとしたら`true`に、しないとしたら`false`になる）、という問題です。

P2900R10の現在の仕様では、戻り値型がトリビアルコピー可能ではない場合は`r`は常に同じオブジェクトを参照する必要があり、戻り値型がトリビアルコピー可能である場合はコンパイラは追加のコピーを作成することができるものの、コピーは事後条件の評価と同時に行う必要がある、とされています。言い換えると、この例の場合に`r`が参照するオブジェクトがコピーされるにしても、そのことは事後条件の評価結果に影響を与えません。

したがって、この例においてはどちらの事後条件アサーションの評価結果も`true`にならなければなりません。

この提案では、このことを明確化するように注記とサンプルコードを追記することを提案しています。

ただし、上記の例のような契約注釈を行うべきではなく、この場合の仮定も常に保証されるとは限りません。この例はあくまで問題の解説のためのコードです。

#### 4. 再宣言された事前・事後条件内でラムダ式が出現できる

通常、全く同じトークン列であっても、ラムダ式は出現した場所によって異なるエンティティとして扱われます。

```cpp
int main() {
  auto l1 = []{};
  auto l2 = []{};
  // l1とl2は異なるクロージャ型を持つ
}
```

この場合の問題は、事前・事後条件式内でラムダ式が使用されている場合に、その契約注釈が複数の宣言にわたって繰り返されているとき、どうなるべきかという点です。

契約注釈を持つ関数の再宣言そのものは許可されていますが、この場合、最初の宣言と全く同じ契約注釈を持つか、契約注釈を一切持たないか、のどちらかのみが許可されています。異なる場所で宣言されているラムダ式が異なるエンティティとなる場合、再宣言にトークンレベルで同一の契約注釈を指定していても、この規定を満たすのかどうか、あるいは満たすべきかどうか、が不透明です。

```cpp
// f.h
void f() pre([]{ _ = scoped_lock(obj_mtx); return obj.is_valid(); }());

// f.cpp
void f() pre([]{ _ = scoped_lock(obj_mtx); return obj.is_valid(); }()) {
  // implementation
}
```

この提案では、この場合にのみ、最初の宣言と再宣言の契約注釈内のラムダ式を同一のエンティティとして扱うようにすることを提案しています。これは、`inline`関数内のラムダ式と同じ扱いとなり、ODR違反となるかのルールについて全く同じ扱いをする必要があります。

この設計意図を明確化するために、文言に例を追加することを提案しています。

この提案は既に、3の報告を除いてP2900に適用済みです。

- [P3460R0 Contracts Implementors Report](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3460r0.pdf)
- [P3483 進行状況](https://github.com/cplusplus/papers/issues/2152)

### [P3484R0 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r0.pdf)

↓

### [P3484R1 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r1.pdf)

↓

### [P3484R2 Postconditions odr-using a parameter modified in an overriding function](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3484r2.pdf)

仮想関数のオーバーライドと事後条件からの引数参照が組み合わさった場合の問題を解消する提案。

P2900R10のContracts MVPでは、事後条件から非参照関数引数を参照する場合、その引数はすべての宣言において`const`指定されていることを要求します。これは、非参照非`const`の引数は関数本体内で任意に変更される可能性があり、それによって呼び出し側から見た事後条件の意味が暗黙的に変化してしまうことを防止するためです。

また、コルーチンにおいては`const`の有無にかかわらず事後条件からの関数引数を参照することは禁止されています。なぜなら、コルーチンはその初期化時に全ての引数をコルーチンステート内にムーブするため、事後条件から参照するものは常にムーブ後状態になってしまうためです。

これらのことによって、コードの読み手及び性的解析機は、事後条件内で使用されている関数引数がその呼び出し中に変更されることがないことを静的に確認することができるようになります。

しかし、これにはまだ抜け穴があります。例えば次のような仮想関数を定義した基底クラスがあるとき

```cpp
struct Base {
  virtual Integer f(const Integer i) post (r: r >= i);
};
```

このクラスを継承した派生クラスにおいては引数の`const`をドロップすることが許可されています。そのため、次のようにオーバーライドすることができます

```cpp
Integer Derived::f(Integer i) {
  i = 0;
  return i;
};
```

P2900R10での仮想関数における契約条件評価のセマンティクスでは、静的に呼び出される基底クラスの関数`Base::f()`と動的に決定されるオーバーライドする関数`Derived::f()`の2つの関数における契約が評価されます。基底クラスの参照から派生クラスの関数を呼び出そうとすると、このような場合に望ましくないことが起こります

```cpp
void test(Base& b) {
  Integer j = b.f(3); // 契約違反は検出されない
  // jは0が返されており、事後条件（3以上のはず）は成立しない
}

int main() {
  Derived d;
  test(d);
}
```

あるいは別のケースで、値（非`const`）で受けている引数をそのままリターンする場合、暗黙ムーブが起こることになりますが、これによって事後条件から使用している引数がムーブ後状態になってしまう場合もあり得ます

```cpp
struct Base2 {
  virtual std::string g(const std::string p) post(r : r.starts_with(p));
};

class Derived2 : public Base2 {
  std::string f(std::string p) override {
    return p; // 暗黙ムーブ
  }
};
```

これらはまさに、P2900が通常の関数およびコルーチンにおいて防止している事後条件からの関数引数参照の問題と全く同じことです。通常の関数同様に、仮想関数においてもこれは防止される必要があります。

この提案はこの問題の報告と解決を提案するものです。

まずソリューションとして次の6つを提示しています

1. 仮想関数の事後条件で非参照引数を使用する場合、それが`const`であるかどうかにかかわらず使用を禁止する
    - ただし、その関数あるいはクラスが`final`である場合は除く
2. 仮想関数の事後条件で非参照引数を使用する場合、その引数はすべてのオーバーライド宣言において`const`でなければならない
3. 仮想関数の事後条件で非参照引数を使用する場合、その引数はすべてのオーバーライド定義において`const`でなければならない
    - 定義ではない宣言においては`const`を省略可能
4. 任意の関数の事後条件で非参照引数を使用する場合、その引数はその関数およびそれをオーバーライドする関数の定義において`const`でなければならない
    - 定義ではない宣言においては`const`を省略可能
5. オーバーライドする関数が非参照引数の`const`を削除できるようにする
    - つまり現状維持 
6. オーバーライドする関数が非参照引数の`const`を削除できるようにするが、基底クラスの対応する関数で`const`で宣言されている非参照引数を変更しようとする場合、未定義動作とする

提案ではこれらのオプションの持つ特性を詳細に検討しています。そのうえで、4と6は実現可能ではないとして、SG21での検討のために1、2、3、5のソリューションを提案しています。

提案より、比較をまとめた表

| 特性 ＼ オプション | **1** | **2** | **3** | **4** | **5** | **6** |
| :--- | :----: | :----: | :----: | :----: | :----: | :----: |
| 仮想関数で非参照引数を事後条件から使用することを許可するか                                |   ❌   |   ✅   |   ✅   |   ✅   |   ✅   |   ✅   |
| 事後条件から使用される非参照引数の変更とそれに伴うバグを防ぐか                            |   ✅   |   ✅   |   ✅   |   ✅   |   ❌   |   ❌   |
| 仮想関数に事後条件を追加することが、それをオーバーライドする派生クラスを破壊しないか        |   ✅   |   ❌   |   ✅   |   ✅   |   ✅   |   ✅   |
| 仮想関数に事後条件を追加することが、それをオーバーライドする派生クラスの利用者を破壊しないか |   ✅   |   ❌   |   ✅   |   ✅   |   ✅   |   ✅   |
| 仮想関数オーバーライドと通常の関数との間に新たな不整合を導入しないか                       |   ✅   |   ✅   |   ❌   |   ✅   |   ✅   |   ✅   |
| 明確に規定でき、実用的に実装可能か                                                      |   ✅   |   ✅   |   ✅   |   ❌   |   ✅   |   ❌   |
| 未定義動作の新たな発生源を導入しないか                                                  |   ✅   |   ✅   |   ✅   |   ✅   |   ✅   |   ❌   |

オプション4と6は、「明確に規定でき、実用的に実装可能」ではないため、実現可能ではないと判断されました。

なお、オプション1は将来的に互換性を維持しながら他のオプションに移行でき、オプション2は3もしくは5にのみ移行でき、オプション3は5にのみ移行でき、オプション5は他のオプションに移行できません。

この提案は関数事後条件における問題を報告する3セットの提案（P3484・P3487・P3489）の1つであり、これら3つの提案はまとめて扱って一貫した方法で解決されるのが望ましいとしています（残り2つは下の方にあります）。

SG21の投票では、オプション2がコンセンサスを得ており、P2900に導入されたようです。

ただし、オプション2では基底の関数に非参照引数を使用する事後条件を追加しようとすると、それをオーバーライドしているすべての関数の宣言において引数を`const`にする必要があります。現在非参照関数引数の`const`付加があまり一般的ではないのを考慮すると、もしそれらがライブラリや共有ライブラリの形で所有者が分割されている場合、修正不可能なコンパイルエラーに繋がります。

なお、オプションに関わらず、この提案のそもそもの問題からですが、派生先（オーバーライドする関数）で引数を使用する事後条件を追加する分には特に問題がありません。

- [P3484 進行状況](https://github.com/cplusplus/papers/issues/2153)

### [P3485R0 Grouping using declarations with braces](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3485r0.html)

`using`宣言をグループで行えるようにする提案。

名前空間から特定の名前を現在のスコープで利用可能にするためには通常`using nemaspace`よりも個別の名前を`using`する方が好まれます。

```cpp
using std::format;
using std::format_to;
using std::formatter;
using std::chrono::duration;
using std::chrono::time_point;
using std::chrono::duration_cast;
```

しかし、この方法はかなり冗長であり、あまり見やすくもありません。

一応C++17では`using`宣言のパック展開サポートの副作用として`using`を省略できるようになっています

```cpp
using std::format, std::format_to, std::formatter;
using std::chrono::duration, std::chrono::time_point, std::chrono::duration_cast;
```

しかし多少はましとはいえまだ冗長です。一つの`using`宣言のグループ内では共通する部分の名前空間を繰り返す必要はなさそうに見えます。例えば次のように書くことができれば、かなり簡潔に`using`宣言を記述できるようになります

```cpp
using std::{format, format_to, formatter};
using std::chrono::{duration, time_point, duration_cast};
```

この提案は、`using`宣言においてこのようにグルーピングして記述できるようにしようとするものです。

これは新機能の提案ではなく、純粋に可読性を向上させるための機能拡張の提案です。

提案では、ワイルドカードの使用（`using std::chrono::*;`）や波かっこのネスト（`using std::{formatter, chrono::{duration, time_point}};`）についても検討していますが、いずれも不許可としています。

筆者の方はClangをフォークして実装してみたところかなり簡単に実装できたと報告しています。

- [P3485 進行状況](https://github.com/cplusplus/papers/issues/2154)

### [P3487R0 Postconditions odr-using a parameter that may be passed in registers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3487r0.pdf)

関数の引数/戻り値がレジスタ経由で渡される場合に、その事前・事後条件内での扱いについて明確化する提案。

C++では、基本型のような単純な型以外でも、いわゆるトリビアルなクラス型についてはその値をレジスタ経由で関数とやり取りすることが許可されています。その際、レジスタ上にあるオブジェクトにはアドレスが無いため、そのような引数/戻り値を参照するC++のコードは、その（トリビアルな）コピーから構築された一時オブジェクトを参照しているかのように扱うことによって、C++のオブジェクトモデルからの逸脱を回避しています（[[class.temporary]/3](https://timsong-cpp.github.io/cppwp/n4950/class.temporary#3)にそのための規定があります）。

現在のC++においては、ほぼこれが起きていることを観測する方法が無いために、この仕様によって問題が引き起こされることはありませんでした。しかし、Contractsの事前・事後条件からこのような引数/戻り値を使用する場合、呼び出し側でのチェックの実装可能性について問題がある場合があります。

P2900R10のContractsでは契約注釈の評価の実装方法として、呼び出し側チェック（caller-side check）と呼び出し先チェック（Callee-side check）の2つの実装方法を許可しています。これは文字通り、ある関数を呼び出した際にその関数でなされている契約注釈の条件式の評価（チェック）を関数を呼び出した側で行う（チェックコードを呼び出し側に展開する）のか、関数の呼び出し先で行う（チェックコードを関数本体内に展開する）のかの違いです。

呼び出し先でのチェックは常に実装可能と想定されているのに対して、呼び出し側でのチェックは場合によっては実装できないことが分かっています。例えば、関数ポインタに格納された関数の契約チェックは、どの関数が呼ばれるかが実行時に決まるため呼び出し側ではチェックできません。また、関数引数の破棄を呼び出し先で行うABI（Windows ABIなど）の場合は事後条件のチェックを呼び出し元で行うことができません。

全てのチェックが呼び出し側で行うことはできずとも、P2900ではなるべく多くのチェックを呼び出し側で行えるようにしようとしています。なぜなら、それによって契約チェックをオフにしてコンパイルされたライブラリにおいて、再コンパイルすることなく利用側で契約チェックを有効化できる、という重要なユースケースがサポートされるほか、仮想関数の契約チェックも呼び出し側チェックと呼び出し先チェックを組み合わせることで実現されるためです。

#### 事前条件

レジスタ経由の引数渡しにおける呼び出し側チェック実装の問題の一つ目はまず、事前条件からそのような関数引数を使用する場合です。

事前条件は多くの場合関数の引数を使用することになりますが、使用しようとする引数がレジスタ経由で渡されている場合、事前条件内で使用されるレジスタ渡しされている引数についてを考慮する規定が無く、[class.temporary]/3の規定からその場合は関数本体内で参照される対応する一時オブジェクトと同じものを参照する必要性が導かれます。これによって、事前条件の呼び出し側でのチェックは実装不可能となっています。

この提案では、これについては単純にそれを考慮した規定（レジスタ渡しされている引数オブジェクトについては、一時コピー前のものか一時コピー後のものかいずれかを使用するようにする）を追加することを提案しています。呼び出し側チェックの場合は関数に渡される前の引数を参照すればよく、呼び出し先チェックでは現状通り一時コピーを参照すれば、どちらのチェックも実装可能です。

#### 事後条件と戻り値の使用

事後条件においては事前条件とは異なり、引数だけでなく戻り値のオブジェクトも使用できます。ただし、この戻り値がレジスタ渡しされる場合に事後条件が一時コピー前後のどちらを参照するかについてはすでに考慮された規定が盛り込まれており、呼び出し側チェックと呼び出し先チェックのどちらの実装も可能になるようになっています。

このことは割と簡単に観測できてはしまいます

```cpp
class X { /∗ ... ∗/ };

X f(const X* ptr)
  post(r: &r == ptr)  // 👈
{
  return X{};
}

int main() {
  X x = f(&x);
}
```

`X`がトリビアルではない場合、`f()`の事後条件から参照されるのは戻り値のオブジェクトそのものなので、この事後条件は常に満たされます。一方、`X`がトリビアルでレジスタ経由で返される場合、事後条件から参照されるのは戻り値オブジェクトの一時コピーなので、事後条件は失敗する可能性があります。

とはいえ、呼び出し側チェックと呼び出し先チェックのどちらによっても事後条件チェックは実装可能であるため、その観点からは問題ありません（そしておそらく、このようなチェックを行いたいユースケースは無いと判断されているため、このような挙動も問題視されていません）。

#### 事後条件と引数の使用

問題があるのは、事後条件から関数の引数を使用する場合です。

```cpp
X* ptr;

void f(const X x)
  post (ptr == &x)
{
  ptr = &x;
}
```

こんな契約条件を書くなという点はさておき、この事後条件は`x`がレジスタ渡しされている場合、現在の規定の下では（事前条件の場合と同様の理由によって）この事後条件は常に満たされます。それはすなわち、事後条件からはこの引数の一時コピーを参照しなければならないということでもあり、それにより呼び出し側でのチェックは実装不可能となります（Windows ABIのようにそもそも実装できないケースはさておき）。

前2つのケースと同様の規定をこの場合に対しても追加することで問題の解消を図ることができるのですが、事後条件の場合引数オブジェクトが参照されるのが関数の呼び出し終了後であるという決定的な違いがあります。これにより、関数本体内で引数オブジェクトが変更され、なおかつそれがレジスタ渡しされている（一時コピーの）オブジェクトに対するものである場合、呼び出し側チェック（一時コピー前のオブジェクトを参照）と呼び出し先チェック（一時コピー後のオブジェクトを参照）の間で観測するオブジェクトの状態（アドレスだけではなく）が異なるということが起こりえます。

事後条件から使用される引数は常に`const`である必要があるため、そのような事が起こる場合は関数本体内で`const_cast`等の手段でオブジェクトの状態を変化しているということなので、そのような契約を記述することは間違ってはいます。ただし、オブジェクトの状態を変更することと正しさが結びついているような型を考えることができてしまいます。

```cpp
class RandomInteger {
  mutable bool _computed = false;
  mutable int _value;

public:

  int value() const {
    if (!_computed) {
      _value = rand();  // 遅延計算し、値をキャッシュする
      _computed = true;
    }

    return _value;  // 2回目以降の呼び出しでは、キャッシュされた値を返す
  }

};
```

この`RandomInteger`クラスはトリビアルなコピーコンストラクタとデストラクタを持つため、レジスタ渡しで渡すことができます。

```cpp
int f(const RandomInteger i)
  post(r: r & i.value() == 0) // ここでのすべてのiが同じオブジェクトを参照しているなら、満たされる
{
  return ~i.value();
}
```

事後条件内で使用されている`i`と関数本体内で使用されている`i`が、同じオブジェクトを参照する場合にのみこの事後条件は常に満たされます。しかし、事後条件の呼び出し側でのチェックを許可するためにレジスタ渡しされている引数オブジェクトの参照先を曖昧（一時コピー前でも後でもどちらでもいい）にしてしまうことによってそのような保証は無くなり、このコードは正しく動作しなくなります。

このコードは現在のC++（及びP2900R10）では、レジスタ渡しされた元のオブジェクトを変更する手段が無いため観測できず、問題になりません。

この提案では、この解決のために8つのオプションを提示しています

1. 事後条件アサーションをP2900から削除する
2. 事後条件アサーションから、あらゆる関数引数の使用を禁止する
3. 事後条件アサーションから、非参照関数引数の使用を禁止する
4. 事後条件アサーションから、スカラ型ではない非参照関数引数の使用を禁止する
    - 事後条件からは、レジスタ渡しされている引数オブジェクトについては、一時コピー前のものか一時コピー後のものかいずれかを使用するようにする、規定を追加
    - 事後条件の呼び出し側チェック実装を可能にする（条件を満たしていれば）
5. 事後条件アサーションから、レジスタ渡し可能な条件を満たすスカラ型ではない非参照関数引数の使用を禁止する
    - オプション4と同じ規定を追加して、事後条件の呼び出し側チェック実装を可能にする
    - レジスタ渡しの条件を満たさなければ、事後条件からクラス型引数の使用が可能になる
6. 事後条件アサーションから、レジスタ渡し可能な条件を満たし1つ以上の`mutable`サブオブジェクトを持つ型の引数の使用を禁止する
    - オプション4と同じ規定を追加して、事後条件の呼び出し側チェック実装を可能にする
7. オプション4と同じ規定を追加するが、それ以上の制限を設けない
    - 上記のような問題を許容する
8. 事後条件アサーションから非参照関数引数が使用される場合、関数本体と同じオブジェクトを使用する
    - 現状維持
    - 呼び出し側での事後条件チェックの実装のためには、一部の実装でABI破壊が必要となる

オプションは厳しいものからの昇順で並んでいます。

各オプションの比較

| 特徴 ＼ オプション                                | 1   | 2   | 3    | 4   | 5  | 6    | 7  | 8  |
| :----------------------------------------------- | :-- | :-- | :-- | :-- | :-- | :-- | :-- | :-- |
| 一般的に事後条件を許可する                         | ❌ | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  |
| 事後条件からの参照引数の使用を許可する              | ❌ | ❌ | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  |
| 事後条件からの参照+スカラ型引数の使用を許可する     | ❌ | ❌ | ❌ | 〇  | 〇  | 〇  | 〇  | 〇  |
| 事後条件からのあらゆる型の非参照引数の使用を許可する | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | 〇  | 〇  |
| 特定の型の特性に基づく、脆弱な区別を回避する        | 〇  | 〇  | 〇  | ❓  | ❌ | ❌ | 〇  | 〇  |
| フットガンを許容する                              | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  | ❌ | 〇  |
| ABI破損無しで呼び出し側チェックを可能にする         | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  | 〇  | ❌ |

これらのオプションには同時に満たすことの出来ない3つの要件が存在します

1. 事後条件から任意の型の非参照引数を使用できるようにする
2. `mutable`サブオブジェクトによるフットガンを回避する
3. レジスタ経由の受け渡しを削除するABI破損なしで、事後条件の呼び出し側チェックを可能にする

1つ目の要件を放棄するとオプション1~6を選択でき、2つ目の要件を放棄するとオプション7が最適になり、3つ目の要件を放棄するとオプション8が最適になります。

オプション1~3はこの提案の議論についてはオプション4~6と比較すると何の利点もありませんが、P3484とP3489で報告されている問題の一貫した解決の方法としては選択肢たり得る可能性があります。

オプション8を除くオプションは、より数字の大きなオプションに事後的に移行できます（オプション8から他のオプションへは移行できません）。また、オプション4を選択するとコルーチンの事後条件の制約が緩和（スカラ型の非参照引数を使用可能になる）される可能性があります。

この提案では、これらのオプションはどれも検討する価値があるとして、これ以上絞り込まずに判断をSG21に委ねています。

この提案は関数事後条件における問題を報告する3セットの提案（P3484・P3487・P3489）の1つであり、これら3つの提案はまとめて扱って一貫した方法で解決されるのが望ましいとしています（残りは上の方と下の方にあります）。

SG21の投票では、オプション7だけがコンセンサスを得ることができたようです。

- [P3487 進行状況](https://github.com/cplusplus/papers/issues/2155)

### [P3488R0 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r0.pdf)
### [P3488R1 Floating-Point Excess Precision](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3488r1.pdf)
### [P3489R0 Postconditions odr-using a parameter of dependent type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3489r0.pdf)

依存型の引数が事後条件で使用される場合の挙動について明確化する提案。

P2900R10のContracts MVPでは、事後条件から非参照関数引数を参照する場合、その引数はすべての宣言において`const`指定されていることを要求します。これは、非参照非`const`の引数は関数本体内で任意に変更される可能性があり、それによって呼び出し側から見た事後条件の意味が暗黙的に変化してしまうことを防止するためです。

しかし、関数テンプレートにおいてテンプレートパラメータを型名として宣言されている引数（提案では、この引数のCV修飾含めた型のことを依存型と言っている）については、関数の宣言時点ではその引数が`const`であるかどうかはわからず、この引数が事後条件で使用されている場合にどうすべきかがP2900R10の仕様では明確ではありません。

これは次のような単純な関数テンプレートと事後条件で容易に起こりえます

```cpp
template <typename T>
void f(T t)
  post(t > 0);
```

この関数テンプレートは`const`な型でもそうでない型によってもインスタンス化される可能性があり、型推論によって型が導出される場合もそうでない場合もあります。いずれにせよ、この関数テンプレートを最初にパースする際には引数`t`の`const`有無は判明せず、事後条件における`t`の使用をコンパイルエラーとすべきかは分かりません。

より場合分けすると、この関数テンプレートが`const`ではない型`T`によってインスタンス化される場合はコンパイルエラーにすべきであることは明白です。

```cpp
int main() {
  int i = 1;
  f<int>(i); // error
}
```

しかし、`const`な型によってインスタンス化される場合の動作が明確ではありません。

```cpp
int main() {
  int i = 1;
  f<const int>(i); // OK?
}
```

この提案はこのケースの規定の明確化を図るものです。

提案ではソリューションとして次の2つのオプションを提示しています

1. 依存型の引数が事後条件で使用される場合、その引数宣言には明示的な`const`を必要とする
    - すなわち、インスタンス化されるかどうか及びどのようにインスタンス化されるかによらず、上記の例の`f`はill-formedとする
2. 依存型の引数が事後条件で使用される場合、その引数宣言の`const`修飾を依存型の一部とすることを許可する
    - すなわち、上記の例の`f`のような関数テンプレートの宣言の時点でエラーにはしないが、非`const`な型でインスタンス化される場合はill-formed


2つのオプションのトレードオフは、エラーが報告されるタイミングです。オプション1はかなり早期にエラーが報告される一方で、オプション2はともすればかなり後になってからエラーが報告されます。しかし、オプション1の場合は上記例で`f<const int>(i)`のようにしたときの様な意味的には許可されるべきコードがエラーになってしまうというデメリットもあります。また一方で、オプション2ではテンプレートパラメータの`const`性によって関数テンプレートのコンパイル結果が変化するという問題もあります。

オプション1を選択すると、後からオプション2に移行することができますが、オプション2からオプション1へ移行することはできません。

この提案ではどちらのオプションもトレードオフが明確でありどちらにも検討する価値があるとして、決定をSG21に委ねるために両方のオプションを提案しています。

この提案は関数事後条件における問題を報告する3セットの提案（P3484・P3487・P3489）の1つであり、これら3つの提案はまとめて扱って一貫した方法で解決されるのが望ましいとしています（残り2つは上の方にあります）。

SG21の投票ではどちらのオプションもコンセンサスを得たようですが、オプション1の方が賛成票が多かったようです。

- [P3489 進行状況](https://github.com/cplusplus/papers/issues/2154)

### [P3490R0 Justification for ranges as the output of parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3490r0.html)
### [P3491R0 define_static_{string,object,array}](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3491r0.html)
### [P3492R0 Sized deallocation for placement new](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3492r0.html)
### [P3493R0 Ruminations on reflection and access](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3493r0.html)
### [P3495R0 Remarks on Basis Statistics, P1708R9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3495r0.pdf)

P1708R9に対する意見書。

P1708R9では、C++の標準ライブラリに初等的な統計処理機能を導入することを提案しています。P1708R9については以前の記事を参照

- [P1708R9 Basic Statistics - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P1708R9-Basic-Statistics)

この提案では、P1708R9が標準規格として採用可能となるために足りていない部分を指摘し、更なる作業を促すものです。

1. 未規定の結果
    - `NaN`/`Inf`の入力
        - この入力がなぜ未規定の結果をもたらすのかの根拠がない
            - `<cmath>`の関数はこのような場合の結果が厳密に指定されている
        - これらの入力があった場合に、`FE_INVALID`は発生するか？
    - 不十分な要素数
        - 設計空間の問題として言及
    - アンダーフロー/オーバーフロー
        - アンダーフローの場合、なぜ結果が未規定となるのかが不明瞭
        - どちらの場合も、定数評価中に何が起こるかはP0533R9に従うことで簡単に明らかにできる
2. 不十分な現状の設計の説明
    - アキュムレータに関して、BoostのAccumulatorsが引用されているがリンク切れしている
        - 提案自体にその説明があったほうが親切
    - アキュムレータと通常関数の性能について比較したグラフには改善の余地がある
        - エラーバーがない
        - 一部の処理において劣っているように見えるのはなぜか？
        - 並列実行するとどう変化するか？
3. 設計空間
    - 不十分な要素数の範囲の入力
        - 検討されている統計量の計算はすべて、要素数が0ではない範囲を必要とする
        - これは当然であるとしても、必要要素数に満たない範囲が入力された場合に何が起こるかについて議論されていない
            - `std::expected`の採用など、他のアプローチの比較検討などを特にしていない
        - ユーザーに対して未規定の結果を返す方法をこれほど多く提供することは、ユーザーにとってむしろ不親切となりうる
        - 定数評価中の場合に何が起こるかも明確ではない
    - 精度（accuracy）
        - 計算順序
            - 例えば、平均値の計算結果の精度は累積の計算順序に依存する。速度よりも精度を優先する場合、ソートしてから入力することで最小値から最大値の方向で計算を行いたいと考えるかもしれない
            - しかし現状では、各関数における計算順序は指定されていないため、このような事前ソートは無駄になる可能性がある
            - さらに、各関数にそれが指定された場合、アキュムレータではどのような保証になるのか？
        - 同じ統計量を返す関数とアキュムレータの間での結果の一致
            - ある統計量を計算するフリー関数と、それに対応するアキュムレータに対して、同じ範囲を入力したとき、結果が一致するか？
            - 現在の参照実装ではそうなっていない
            - ここにも、トレードオフを伴う設計余地があり、適切に議論する必要がある
        - 高い精度（precision）の結果型の指定
            - ユーザーが範囲の要素型の精度よりも高い精度の結果型を指定することがある
            - この場合、`<linalg>`の関数が行うように結果型の精度で計算が行われることを保証する必要がある
    - 並列化
        - フリー関数には実行ポリシーを取るオーバーロードがあるが、アキュムレータについては無い
        - アキュムレータが並列化に対応できるか、どのように対応するか、について議論が無い
        - ユーザー定義reducerのためのコンセプトを定義していないが、どのように定義できるかを検討することは有益かもしれない
4. APIに関する懸念
    - デフォルト`bool`値
        - デフォルト`bool`値が存在するとAPIが難解になる
        - 例えば、`kurtosis(r, true, false)`はユーザーにとって難解。各統計計算の入力パラメータは構造体で保持する方が望ましい
    - 表現力豊かな戻り値型
        - 一部の関数は`std::pair`を返すが、返される内容をフィールド名で表現できる名前付き構造体を返したほうが良いかもしれない
    - アキュムレータの構築
        - アキュムレータが要素の範囲からの構築をサポートしない正当な理由はあるか？
    - アキュムレータの`operator()`の戻り値型
        - 現在`void`を返すが、`*this`を返すことは検討しているか？
    - 明示的なテンプレートパラメータ指定
        - フリー関数では戻り値型を明示的に指定できるオーバーロードが存在するが、`std::reduce`に倣って初期値を引数で受け取ることでその型をそのまま使用するという方法もある

この提案は、統計関数自体に必要性やそれを導入しようとするP1708に反対しているわけではなく、現状の設計では標準ライブラリに求められる厳密さのレベルに達していないため、その点について指摘し追加作業を促すものです。

- [P3495 進行状況](https://github.com/cplusplus/papers/issues/2160)

### [P3497R0 Guarded Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3497r0.html)
### [P3498R0 Stop the Bleeding but, First, Do No Harm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3498r0.pdf)
### [P3502R0 Slides for D2900R11 - Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3502r0.pdf)

P2900R11（Contracts提案）の説明スライド

P2900の前回会議（2024/06 セントルイス）からの変更点、11月の会議（このスライドがプレゼンされたところ）の達成目標、なぜContractsが必要なのか、について解説されています。

### [P3503R0 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3503r0.html)
### [P3504R0 C++ Standard Library Ready Issues to be moved in Wroclaw, Nov. 2024](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3504r0.html)
### [P3508R0 Wording for constexpr for specialized memory algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3508r0.html)
### [P3510R0 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r0.html)
### [P3510R1 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r1.html)
### [P3510R2 Leftover properties of `this` in constructor preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3510r2.html)
### [P3517R0 Slides presented to LEWG on trivial relocation in Wroclaw](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3517r0.pdf)
### [P3518R0 Slides for Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3518r0.pdf)
### [P3519R0 Slides for P3425 presentation to LEWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3519r0.pdf)
### [P3520R0 Wroclaw Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3520r0.pdf)
### [P3521R0 Pattern Matching: Customization Point for Open Sum Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3521r0.html)
### [P3524R0 Core Language Working Group "ready" Issues for the November, 2024 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3524r0.html)
### [P3525R0 Explicit Implicit Template Regions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3525r0.html)
### [P3527R0 Pattern Matching: *variant-like* and `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3527r0.html)
### [P3530R0 Intrinsic for reading uninitialized memory](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3530r0.html)
### [P3533R0 constexpr virtual inheritance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3533r0.html)
### [P3537R0 Presentation on Concurrent Queue API LEWG Telecon 2024-Dec-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3537r0.pdf)
### [P3539R1 Consistent Function Label Naming for Sections](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3539r1.pdf)
### [P3540R0 #embed Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3540r0.html)
### [P3541R0 Violation handlers vs `noexcept`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3541r0.html)
### [P3542R0 Abolish the term "converting constructor"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3542r0.html)
### [P3543R0 Response to Core Safety Profiles (P3081)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3543r0.pdf)
