# ［C++］WG21月次提案文書を眺める（2024年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-08)

全部で113本あります。

もくじ

[:contents]

### [N4988 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4988.pdf)

C++26のワーキングドラフト第5弾

### [N4989 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4989.html)

↑の変更点をまとめた文書。

### [P2414R4 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2414r4.pdf)

Pointer lifetime-end zapと呼ばれる問題の解決策の提案。

以前の記事を参照

- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R1 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2414R1-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R2 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2414R2-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)

このリビジョンでの変更は

- 2024年6月のSG1レビューを受けての更新
    - 無効なポインタへの操作の合法化に関する部分をP3347に分離
    - 関数とクラスの追加
- フィードバックを受けてドラフトの文言を追加し更新
- Historyセクションを最後に移動

などです。

このリビジョンでは次の事を提案しています

1. `make_ptr_prospective()`を提案
    - ポインタを受け取り、そのポインタに対応する見込みポインタ（prospective pointer）を返す関数
2. 指しているオブジェクトの寿命が尽きた後でも使用可能なポインタlikeな型であるクラステンプレート、`usable_ptr<T>`を提案
3. 見込みポインタ値を生成して格納するようにアトミック操作を再定義
4. 見込みポインタ値を生成して格納するように`volatile`操作を再定義

見込みポインタ（prospective pointer）値とは、寿命が開始されていないオブジェクトに対応するポインタ値のことです。これには、ストレージ領域がまだ作成されていないオブジェクトへのポインタも含まれ、見込みポインタもまた無効なポインタのように比較と間接参照以外の操作が許可されます（することを提案しています）。

見込みポインタを作成する唯一の方法は有効なポインタを`uintptr_t`にキャストしてからまた元のポインタ値に戻すことです。

`make_ptr_prospective()`関数は`T`型のポインタ`p`に対する`reinterpret_cast<T*>(reinterpret_cast<std::uintptr_t>(p))`の様な操作（見込みポインタの取得処理）を行うライブラリ関数です。

これらの概念および操作は、ポインタの指す先のオブジェクトが並行に破棄および再構築されるような場合においてその有効なポインタを取得するためのものです（例えば、ポインタ値をロードした後にそのポインタに対応するオブジェクトが別のスレッドで破棄されうる場合に、それを気にせずにそのポインタ値を使用する場合など）。P2434R1の"Consequences for pointer zap"セクションにサンプルコードと説明が少しあります。

- [P2434R1: Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r1.html)
- [P2414 進行状況](https://github.com/cplusplus/papers/issues/1084)

### [P2822R2 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r2.pdf)
### [P2897R4 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r4.html)
### [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r5.html)
### [P2900R8 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf)
### [P2988R6 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r6.pdf)
### [P2996R5 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r5.html)
### [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r2.html)
### [P3068R4 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r4.html)
### [P3126R2 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r2.pdf)
### [P3130R2 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r2.pdf)
### [P3131R2 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r2.pdf)
### [P3284R1 `finally`, `write_env`, and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r1.html)
### [P3315R0 2024-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3315r0.html)
### [P3325R3 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r3.html)
### [P3347R0 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3347r0.pdf)

無効化されたポインタに対する一部の演算を明示的に許可する提案。

この提案はP2414R3で提案されていた言語への変更を分離したものです。

P2414R3ではオブジェクトの寿命が尽きた後にそのオブジェクトを指していたポインタが無効化される（ほとんどの操作が未定義もしくは実装定義になる）問題（Pointer lifetime-end zapと呼ばれる）を解決するために言語とライブラリの双方からの提案を行っていました。しかし、言語パートのみを単独でEWGに進めるため（議論およびレビューをしやすくするためと思われる）にその言語提案部分を単独分離したのがこの提案です。

P2414R3およびこの提案では、無効なポインタおよび暫定的なポインタ（無効化された後にその領域に再びオブジェクトが構築された場合のポインタ）に対して、比較と間接参照以外の操作において無効および暫定的なポインタ値の表現バイト列を忠実に計算することを要求するようにすることを提案しています。より詳細には

1. 比較および間接参照以外のポインタに対する操作は、そのポインタが無効であるかどうかなどに関わらずその表現バイトを忠実に計算しなければならない
    - 実装は、ポインタが指しているオブジェクトの有効期間の終了に伴ってポインタの表現バイトを変更することはできない
2. 比較ではないポインタの操作においては、そのオペランドに一致した表現バイトを生成しなければならない
    - ある無効なポインタに整数定数を加算した場合、それと同じ初期表現バイトを持つ有効なポインタに同じ値を加算した時と同じ表現バイトにならなければならない
3. 比較操作は決定論的でなければならない。すなわち、ポインタAとBのペアがあるとき、これを連続して何回比較しても一貫した結果が得られる必要がある
    - ただしこれはポインタAとBがそれぞれ同一（provenanceも含めて）である場合にのみ保証される
      - 例えば、Aから派生したポインタCが翻訳単位を超えるなどしてそのprovenanceが再計算されている場合、AとBの比較結果とCとBの比較結果が一貫している必要はない 
4. ポインタの実装にトラップ表現（値を表現しないビットパターン）が存在する実装では、特別な注意が必要

のようなことを提案しています。

この提案はまた、P2434R1で提案されているangelic provenance（整数からポインタへのキャストの際、プログラムに定義された動作をもたらすポインタ値が1つ以上存在する場合そのような値の一つが結果となる、のような非決定的なポインタの選択方法）に基づいて、その提案が採択されたことを前提として、無効および暫定的なポインタに対する操作（比較と間接参照以外）を定義しています。これは、元々P2414R3が救済しようとしていた無効なポインタを活用する並行アルゴリズムがP2434のメリットを享受できるようにするためです。

- [P2434R0 Nondeterministic pointer provenance - WG21月次提案文書を眺める（2024年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2434R0-Nondeterministic-pointer-provenance)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)
- [P3347 進行状況](https://github.com/cplusplus/papers/issues/2019)

### [P3348R0 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3348r0.pdf)
### [P3361R0 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r0.pdf)
### [P3361R1 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r1.pdf)
### [P3362R0 Static analysis and 'safety' of Contracts, P2900 vs. P2680/P3285](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3362r0.html)

静的解析の観点からP2900のContracts機能は不十分であるため、P2680/P3285で提案されている副作用や未定義動作を予め制限するアプローチを取るようにする提案。

P2900のContracts機能では契約条件式に対して特段の制約を設けておらず、そこではほとんど通常のC++コードを記述可能で、そのような述語コードは任意の副作用やUBを伴うことができます。

これに対してP3285ではコンベア関数の概念を導入し、コンベア関数内では未定義動作につながりうる操作を一切禁止し一部のUBの動作を定義することでUBフリーな関数の定義を可能にし、なおかつ非緩和契約という概念（その関数の呼び出しによって発生する副作用はその評価コーンの内側に閉じていること）によってUBと副作用のない関数を作成できるようにしています。これを契約述語として契約条件式に用いることでContracts機能はUBと副作用を禁止できます（P3285ではさらに緩和契約によってP2900相当の制限のない契約も行うことができる）。

この提案は、契約条件式におけるUBと副作用の問題点という軸でP2900とP3285の提案を比較した場合、特に静的解析において有利なのがP3285であるとして、そちらのアプローチを採用することを提案するものです。

例えば次のようなコードにおいて

```cpp
// 別の翻訳単位で定義されている述語
bool pred(int x);

// pred()を用いて契約された関数
int func_a() post(r: pred(r));
void func_b(int x) pre(pred(x));

int main() {
  func_b(func_a()); // このコードは正しいか？
}
```

これらの宣言のみから、`main()`関数内における関数呼び出しの妥当性は判断できるでしょうか？答えはできない、でしょう。先に呼ばれる`func_a()`の事後条件と後から呼ばれる`func_b()`の事前条件が同じであるため、正しいかもしれないと推測するかもしれません。しかし、そこで使用されている`pred()`は定義が見えておらず、任意の副作用やUBを伴う可能性があります。

`pred()`が副作用やUBを伴っている場合、この2回の呼び出しで両方の結果が同じになる保証がなく、これらの事前条件と事後条件は接続されているとみなすことはできません。人間に判断できないように、これは静的解析機でも判断できません。

一方で、P3285のコンベア関数（と非緩和契約）による述語だとどうでしょうか？

```cpp
// 別の翻訳単位で定義されている述語（コンベア関数
bool pred(int x) conveyor;  // 構文は未定

// pred()を用いて契約された関数
int func_a() post(r: pred(r));
void func_b(int x) pre(pred(x));

int main() {
  func_b(func_a()); // このコードは正しいか？
}
```

この場合、`pred()`はUBや副作用がないことが分かっているため、人間も静的解析機も`func_a()`の事後条件と後から呼ばれる`func_b()`の事前条件は同じ値に評価され、接続していることが分かります。重要なことは、これは`pred()`の定義を見に行かなくても分かるという点で、静的解析の負荷が大きく軽減されます。

この特性はさらに、静的解析だけではなく実行時チェックにも適しています。副作用やUBが無ければ、プログラマがチェックしたいことをチェックするためのコードの記述が非常に簡単になるためです。

このようなことはP2900の緩和契約のみでは達成することはできず、P2900のContracts機能は実際には静的解析の助けになりません。ただしこの提案はP2900が不要であると言っているのではなく、緩和契約とともにコンベア関数のように厳格に制限された契約も同時に必要であると主張しています。当然すべての契約条件がコンベア関数のように厳格な形で記述できるわけではなく、緩和契約でしか記述できない場合の方が多いでしょう。

ただし、P2900の緩和契約を先に標準化してしまった場合、この厳格な契約を後から導入することはできないか、困難になります。両方は同時に標準化される必要があります。

P2680/P3285の提案はSG21およびSG23においてあまり好意的に受け取られておらず、主な反対意見は「言語内で別のより一般的な保護を導入すれば（プロファイル提案など）、契約条件を特別扱いする必要はない」というものです。これが間違っている理由としては

1. そのようなより一般的な保護はオプトインである可能性が高い
2. 副作用の制限についてはあまり考慮されていない

の2点を挙げています。

ここで強く主張されていることは、言語の他の部分が副作用とUBフリーであるかどうかに関係なく、契約注釈内が副作用とUBフリーであることが重要であり契約注釈には特別な保護が必要である、ということです。

- [P3285R0 Contracts: Protecting The Protector - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3285R0-Contracts-Protecting-The-Protector)
- [P3362 進行状況](https://github.com/cplusplus/papers/issues/2022)

### [P3364R0 Remove Deprecated `u8path` overloads From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3364r0.pdf)

非推奨だった`u8path()`を削除する提案。

`u8path()`はC++17の`<filesystem>`ライブラリの一部であり、`char8_t`が無かった時代にUTF-8エンコードされた`char`の文字列から`filesystem::path`オブジェクトを構築するために追加されました。しかしその後のC++20にて`char8_t`文字型とそれを使用した文字列型が導入され、`filesystem::path`のコンストラクタでも文字型でエンコーディングが識別できるようになったため不要になり、非推奨とされていました。

この提案は、これを削除しようとするものです。

この提案の内容そのものはC++23のサイクル中にLEWGにおいて合意が取れていましたが、筆者の方のリソース不足のため間に合いませんでした。その間にLWG Issue 3840にて非推奨を解除すべきとするIssueが提出されC++26サイクルで改めてレビューされたようです。

SG16ではこの関数の現状維持が推奨され、LEWGでは非推奨解除と削除のどちらにも支持者がおり、どちらの方向性でも合意を得ることは難しい雰囲気のようです。

この提案はどうやら、SG16において改めて方向性を確認して議論するために個別の提案として分離されたようです。

- [LWG Issue 3840. filesystem::u8path should be undeprecated](https://cplusplus.github.io/LWG/issue3840)
- [P3364 進行状況](https://github.com/cplusplus/papers/issues/2023)

### [P3365R0 Remove the Deprecated iterator Class Template from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3365r0.pdf)
### [P3366R0 Remove Deprecated Atomic Initialization API from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3366r0.pdf)
### [P3369R0 constexpr for uninitialized_default_construct](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
### [P3370R0 Add new library headers from C23](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3370r0.html)
### [P3371R0 Fix C++26 by making the symmetric and Hermitian rank-k and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r0.html)
### [P3372R0 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r0.html)
### [P3373R0 Of Operation States and Their Lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3373r0.pdf)
### [P3374R0 Adding formatter for fpos](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3374r0.html)
