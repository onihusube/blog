# ［C++］WG21月次提案文書を眺める（2024年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-08)

全部で113本あります。

もくじ

[:contents]

### [N4988 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4988.pdf)

C++26のワーキングドラフト第5弾

### [N4989 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4989.html)
### [P2414R4 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2414r4.pdf)

Pointer lifetime-end zapと呼ばれる問題の解決策の提案。

以前の記事を参照

- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R1 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2414R1-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R2 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2414R2-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)

このリビジョンでの変更は

- 2024年6月のSG1レビューを受けての更新
    - 無効なポインタへの操作の合法化に関する部分をP3347に分離
    - 関数とクラスの追加
- フィードバックを受けてドラフトの文言を追加し更新
- Historyセクションを最後に移動

などです。

このリビジョンでは次の事を提案しています

1. `make_ptr_prospective()`を提案
    - ポインタを受け取り、そのポインタに対応する見込みポインタ（prospective pointer）を返す関数
2. 指しているオブジェクトの寿命が尽きた後でも使用可能なポインタlikeな型であるクラステンプレート、`usable_ptr<T>`を提案
3. 見込みポインタ値を生成して格納するようにアトミック操作を再定義
4. 見込みポインタ値を生成して格納するように`volatile`操作を再定義

見込みポインタ（prospective pointer）値とは、寿命が開始されていないオブジェクトに対応するポインタ値のことです。これには、ストレージ領域がまだ作成されていないオブジェクトへのポインタも含まれ、見込みポインタもまた無効なポインタのように比較と間接参照以外の操作が許可されます（することを提案しています）。

見込みポインタを作成する唯一の方法は有効なポインタを`uintptr_t`にキャストしてからまた元のポインタ値に戻すことです。

`make_ptr_prospective()`関数は`T`型のポインタ`p`に対する`reinterpret_cast<T*>(reinterpret_cast<std::uintptr_t>(p))`の様な操作（見込みポインタの取得処理）を行うライブラリ関数です。

これらの概念および操作は、ポインタの指す先のオブジェクトが並行に破棄および再構築されるような場合においてその有効なポインタを取得するためのものです（例えば、ポインタ値をロードした後にそのポインタに対応するオブジェクトが別のスレッドで破棄されうる場合に、それを気にせずにそのポインタ値を使用する場合など）。P2434R1の"Consequences for pointer zap"セクションにサンプルコードと説明が少しあります。

- [P2434R1: Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r1.html)
- [P2414 進行状況](https://github.com/cplusplus/papers/issues/1084)

### [P2822R2 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r2.pdf)
### [P2897R4 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r4.html)
### [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r5.html)
### [P2900R8 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf)
### [P2988R6 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r6.pdf)
### [P2996R5 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r5.html)
### [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r2.html)
### [P3068R4 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r4.html)
### [P3126R2 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r2.pdf)
### [P3130R2 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r2.pdf)
### [P3131R2 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r2.pdf)
### [P3284R1 `finally`, `write_env`, and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r1.html)
### [P3315R0 2024-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3315r0.html)
### [P3325R3 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r3.html)
### [P3347R0 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3347r0.pdf)

無効化されたポインタに対する一部の演算を明示的に許可する提案。

この提案はP2414R3で提案されていた言語への変更を分離したものです。

P2414R3ではオブジェクトの寿命が尽きた後にそのオブジェクトを指していたポインタが無効化される（ほとんどの操作が未定義もしくは実装定義になる）問題（Pointer lifetime-end zapと呼ばれる）を解決するために言語とライブラリの双方からの提案を行っていました。しかし、言語パートのみを単独でEWGに進めるため（議論およびレビューをしやすくするためと思われる）にその言語提案部分を単独分離したのがこの提案です。

P2414R3およびこの提案では、無効なポインタおよび暫定的なポインタ（無効化された後にその領域に再びオブジェクトが構築された場合のポインタ）に対して、比較と間接参照以外の操作において無効および暫定的なポインタ値の表現バイト列を忠実に計算することを要求するようにすることを提案しています。より詳細には

1. 比較および間接参照以外のポインタに対する操作は、そのポインタが無効であるかどうかなどに関わらずその表現バイトを忠実に計算しなければならない
    - 実装は、ポインタが指しているオブジェクトの有効期間の終了に伴ってポインタの表現バイトを変更することはできない
2. 比較ではないポインタの操作においては、そのオペランドに一致した表現バイトを生成しなければならない
    - ある無効なポインタに整数定数を加算した場合、それと同じ初期表現バイトを持つ有効なポインタに同じ値を加算した時と同じ表現バイトにならなければならない
3. 比較操作は決定論的でなければならない。すなわち、ポインタAとBのペアがあるとき、これを連続して何回比較しても一貫した結果が得られる必要がある
    - ただしこれはポインタAとBがそれぞれ同一（provenanceも含めて）である場合にのみ保証される
      - 例えば、Aから派生したポインタCが翻訳単位を超えるなどしてそのprovenanceが再計算されている場合、AとBの比較結果とCとBの比較結果が一貫している必要はない 
4. ポインタの実装にトラップ表現（値を表現しないビットパターン）が存在する実装では、特別な注意が必要

のようなことを提案しています。

この提案はまた、P2434R1で提案されているangelic provenance（整数からポインタへのキャストの際、プログラムに定義された動作をもたらすポインタ値が1つ以上存在する場合そのような値の一つが結果となる、のような非決定的なポインタの選択方法）に基づいて、その提案が採択されたことを前提として、無効および暫定的なポインタに対する操作（比較と間接参照以外）を定義しています。これは、元々P2414R3が救済しようとしていた無効なポインタを活用する並行アルゴリズムがP2434のメリットを享受できるようにするためです。

- [P2434R0 Nondeterministic pointer provenance - WG21月次提案文書を眺める（2024年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2434R0-Nondeterministic-pointer-provenance)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)
- [P3347 進行状況](https://github.com/cplusplus/papers/issues/2019)

### [P3348R0 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3348r0.pdf)
### [P3361R0 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r0.pdf)
### [P3361R1 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r1.pdf)
### [P3362R0 Static analysis and 'safety' of Contracts, P2900 vs. P2680/P3285](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3362r0.html)
### [P3364R0 Remove Deprecated u8path overloads From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3364r0.pdf)
### [P3365R0 Remove the Deprecated iterator Class Template from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3365r0.pdf)
### [P3366R0 Remove Deprecated Atomic Initialization API from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3366r0.pdf)
### [P3369R0 constexpr for uninitialized_default_construct](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)
### [P3370R0 Add new library headers from C23](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3370r0.html)
### [P3371R0 Fix C++26 by making the symmetric and Hermitian rank-k and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r0.html)
### [P3372R0 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r0.html)
### [P3373R0 Of Operation States and Their Lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3373r0.pdf)
### [P3374R0 Adding formatter for fpos](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3374r0.html)
