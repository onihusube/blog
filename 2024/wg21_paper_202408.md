# ［C++］WG21月次提案文書を眺める（2024年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-08)

全部で113本あります。

もくじ

[:contents]

### [N4988 Working Draft, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4988.pdf)

C++26のワーキングドラフト第5弾

### [N4989 Editors' Report, Programming Languages -- C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4989.html)

↑の変更点をまとめた文書。

### [P2414R4 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2414r4.pdf)

Pointer lifetime-end zapと呼ばれる問題の解決策の提案。

以前の記事を参照

- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R1 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2414R1-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R2 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2414R2-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)

このリビジョンでの変更は

- 2024年6月のSG1レビューを受けての更新
    - 無効なポインタへの操作の合法化に関する部分をP3347に分離
    - 関数とクラスの追加
- フィードバックを受けてドラフトの文言を追加し更新
- Historyセクションを最後に移動

などです。

このリビジョンでは次の事を提案しています

1. `make_ptr_prospective()`を提案
    - ポインタを受け取り、そのポインタに対応する見込みポインタ（prospective pointer）を返す関数
2. 指しているオブジェクトの寿命が尽きた後でも使用可能なポインタlikeな型であるクラステンプレート、`usable_ptr<T>`を提案
3. 見込みポインタ値を生成して格納するようにアトミック操作を再定義
4. 見込みポインタ値を生成して格納するように`volatile`操作を再定義

見込みポインタ（prospective pointer）値とは、寿命が開始されていないオブジェクトに対応するポインタ値のことです。これには、ストレージ領域がまだ作成されていないオブジェクトへのポインタも含まれ、見込みポインタもまた無効なポインタのように比較と間接参照以外の操作が許可されます（することを提案しています）。

見込みポインタを作成する唯一の方法は有効なポインタを`uintptr_t`にキャストしてからまた元のポインタ値に戻すことです。

`make_ptr_prospective()`関数は`T`型のポインタ`p`に対する`reinterpret_cast<T*>(reinterpret_cast<std::uintptr_t>(p))`の様な操作（見込みポインタの取得処理）を行うライブラリ関数です。

これらの概念および操作は、ポインタの指す先のオブジェクトが並行に破棄および再構築されるような場合においてその有効なポインタを取得するためのものです（例えば、ポインタ値をロードした後にそのポインタに対応するオブジェクトが別のスレッドで破棄されうる場合に、それを気にせずにそのポインタ値を使用する場合など）。P2434R1の"Consequences for pointer zap"セクションにサンプルコードと説明が少しあります。

- [P2434R1: Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r1.html)
- [P2414 進行状況](https://github.com/cplusplus/papers/issues/1084)

### [P2822R2 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r2.pdf)

ADLにおいて考慮される関連名前空間を制御する言語機能の提案。

以前の記事を参照

- [P2822R0 Providing user control of associated entities of class types - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2822R0-Providing-user-control-of-associated-entities-of-class-types)
- [P2822R1 Providing user control of associated entities of class types - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2822R1-Providing-user-control-of-associated-entities-of-class-types)

このリビジョンでの変更は

- 関連エンティティの指定子によってテンプレートに名前を付ける機能の削除
- モジュールからエクスポートされた明示的な関連エンティティ指定子を持つADLのルールについての文言を現在のセマンティクスに近づけるために文言を改善

などです。

- [P2822 進行状況](https://github.com/cplusplus/papers/issues/1746)

### [P2897R4 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r4.html)

↓

### [P2897R5 aligned_accessor: An mdspan accessor expressing pointer overalignment](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2897r5.html)

`mdspan`のアクセサポリシークラスに、参照する領域ポインタに`std::assume_aligned`を適用してアクセスする`aligned_accessor`の提案。

以前の記事を参照

- [P2897R0 `aligned_accessor`: An mdspan accessor expressing pointer overalignment - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2897R0-aligned_accessor-An-mdspan-accessor-expressing-pointer-overalignment)
- [P2897R1 `aligned_accessor`: An mdspan accessor expressing pointer overalignment - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2897R1-aligned_accessor-An-mdspan-accessor-expressing-pointer-overalignment)
- [P2897R3 `aligned_accessor`: An mdspan accessor expressing pointer overalignment - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P2897R3-aligned_accessor-An-mdspan-accessor-expressing-pointer-overalignment)

R4での変更は、`is_sufficiently_aligned()`を`aligned_accessor`の静的メンバ関数ではなく非メンバ関数にしたことです。

このリビジョンでの変更は

- `is_sufficiently_aligned()`を`<bit>`ではなく`<memory>`に移動
- `is_sufficiently_aligned()`に“Throws: Nothing”を指定し、その説明を追加

などです。

`std::is_sufficiently_aligned()`はこの提案で追加されている関数で、ポインタが期待するアライメントでアラインされているかどうかを調べる関数です。

```cpp
namespace std {
  template<size_t Alignment, class T>
  bool is_sufficiently_aligned(T* ptr);
}
```

これは、あるポインタを`aligned_accessor`で使用する前にそのポインタが期待するアライメント要件を満たしているかどうかをチェックするための関数です。当初は`aligned_accessor`の静的メンバ関数でしたが、より一般に使用できるものであるためフリー関数になり、`<memory>`ヘッダに配置されました。

- [P2897 進行状況](https://github.com/cplusplus/papers/issues/1568)

### [P2900R8 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r8.pdf)

C++ 契約プログラミング機能の提案。

以前の記事を参照

- [P2900R1 Contracts for C++ - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2900R1-Contracts-for-C)
- [P2900R3 Contracts for C++ - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2900R3-Contracts-for-C)
- [P2900R4 Contracts for C++ - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2900R4-Contracts-for-C)
- [P2900R5 Contracts for C++ - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2900R5-Contracts-for-C)
- [P2900R6 Contracts for C++ - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2900R6-Contracts-for-C)
- [P2900R7 Contracts for C++ - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2900R7-Contracts-for-C)

このリビジョンでの変更は

- 仮想関数での`pre()/post()`のサポートを追加
    - P3097R0の内容
- 契約アサーションをobservable checkpointにした
    - P3328R0のの内容
- メンバ関数ポインタについての説明を追加
- 契約アサーションの定数評価に関する説明を追加
- 契約違反ハンドラの同時呼び出しについての説明を追加
- 契約述語はfull-expressionであることを明確化

などです。

- [P2900 進行状況](https://github.com/cplusplus/papers/issues/1648)

### [P2988R6 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r6.pdf)
### [P2996R5 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r5.html)
### [P3050R2 Fix C++26 by optimizing linalg::conjugated for noncomplex value types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3050r2.html)
### [P3068R4 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r4.html)
### [P3126R2 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r2.pdf)
### [P3130R2 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r2.pdf)
### [P3131R2 Graph Library: Graph Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r2.pdf)
### [P3284R1 `finally`, `write_env`, and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r1.html)
### [P3315R0 2024-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3315r0.html)
### [P3325R3 A Utility for Creating Execution Environments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3325r3.html)
### [P3347R0 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3347r0.pdf)

無効化されたポインタに対する一部の演算を明示的に許可する提案。

この提案はP2414R3で提案されていた言語への変更を分離したものです。

P2414R3ではオブジェクトの寿命が尽きた後にそのオブジェクトを指していたポインタが無効化される（ほとんどの操作が未定義もしくは実装定義になる）問題（Pointer lifetime-end zapと呼ばれる）を解決するために言語とライブラリの双方からの提案を行っていました。しかし、言語パートのみを単独でEWGに進めるため（議論およびレビューをしやすくするためと思われる）にその言語提案部分を単独分離したのがこの提案です。

P2414R3およびこの提案では、無効なポインタおよび暫定的なポインタ（無効化された後にその領域に再びオブジェクトが構築された場合のポインタ）に対して、比較と間接参照以外の操作において無効および暫定的なポインタ値の表現バイト列を忠実に計算することを要求するようにすることを提案しています。より詳細には

1. 比較および間接参照以外のポインタに対する操作は、そのポインタが無効であるかどうかなどに関わらずその表現バイトを忠実に計算しなければならない
    - 実装は、ポインタが指しているオブジェクトの有効期間の終了に伴ってポインタの表現バイトを変更することはできない
2. 比較ではないポインタの操作においては、そのオペランドに一致した表現バイトを生成しなければならない
    - ある無効なポインタに整数定数を加算した場合、それと同じ初期表現バイトを持つ有効なポインタに同じ値を加算した時と同じ表現バイトにならなければならない
3. 比較操作は決定論的でなければならない。すなわち、ポインタAとBのペアがあるとき、これを連続して何回比較しても一貫した結果が得られる必要がある
    - ただしこれはポインタAとBがそれぞれ同一（provenanceも含めて）である場合にのみ保証される
      - 例えば、Aから派生したポインタCが翻訳単位を超えるなどしてそのprovenanceが再計算されている場合、AとBの比較結果とCとBの比較結果が一貫している必要はない 
4. ポインタの実装にトラップ表現（値を表現しないビットパターン）が存在する実装では、特別な注意が必要

のようなことを提案しています。

この提案はまた、P2434R1で提案されているangelic provenance（整数からポインタへのキャストの際、プログラムに定義された動作をもたらすポインタ値が1つ以上存在する場合そのような値の一つが結果となる、のような非決定的なポインタの選択方法）に基づいて、その提案が採択されたことを前提として、無効および暫定的なポインタに対する操作（比較と間接参照以外）を定義しています。これは、元々P2414R3が救済しようとしていた無効なポインタを活用する並行アルゴリズムがP2434のメリットを享受できるようにするためです。

- [P2434R0 Nondeterministic pointer provenance - WG21月次提案文書を眺める（2024年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2434R0-Nondeterministic-pointer-provenance)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)
- [P3347 進行状況](https://github.com/cplusplus/papers/issues/2019)

### [P3348R0 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3348r0.pdf)
### [P3361R0 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r0.pdf)
### [P3361R1 Class invariants and contract checking philosophy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3361r1.pdf)
### [P3362R0 Static analysis and 'safety' of Contracts, P2900 vs. P2680/P3285](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3362r0.html)

静的解析の観点からP2900のContracts機能は不十分であるため、P2680/P3285で提案されている副作用や未定義動作を予め制限するアプローチを取るようにする提案。

P2900のContracts機能では契約条件式に対して特段の制約を設けておらず、そこではほとんど通常のC++コードを記述可能で、そのような述語コードは任意の副作用やUBを伴うことができます。

これに対してP3285ではコンベア関数の概念を導入し、コンベア関数内では未定義動作につながりうる操作を一切禁止し一部のUBの動作を定義することでUBフリーな関数の定義を可能にし、なおかつ非緩和契約という概念（その関数の呼び出しによって発生する副作用はその評価コーンの内側に閉じていること）によってUBと副作用のない関数を作成できるようにしています。これを契約述語として契約条件式に用いることでContracts機能はUBと副作用を禁止できます（P3285ではさらに緩和契約によってP2900相当の制限のない契約も行うことができる）。

この提案は、契約条件式におけるUBと副作用の問題点という軸でP2900とP3285の提案を比較した場合、特に静的解析において有利なのがP3285であるとして、そちらのアプローチを採用することを提案するものです。

例えば次のようなコードにおいて

```cpp
// 別の翻訳単位で定義されている述語
bool pred(int x);

// pred()を用いて契約された関数
int func_a() post(r: pred(r));
void func_b(int x) pre(pred(x));

int main() {
  func_b(func_a()); // このコードは正しいか？
}
```

これらの宣言のみから、`main()`関数内における関数呼び出しの妥当性は判断できるでしょうか？答えはできない、でしょう。先に呼ばれる`func_a()`の事後条件と後から呼ばれる`func_b()`の事前条件が同じであるため、正しいかもしれないと推測するかもしれません。しかし、そこで使用されている`pred()`は定義が見えておらず、任意の副作用やUBを伴う可能性があります。

`pred()`が副作用やUBを伴っている場合、この2回の呼び出しで両方の結果が同じになる保証がなく、これらの事前条件と事後条件は接続されているとみなすことはできません。人間に判断できないように、これは静的解析機でも判断できません。

一方で、P3285のコンベア関数（と非緩和契約）による述語だとどうでしょうか？

```cpp
// 別の翻訳単位で定義されている述語（コンベア関数
bool pred(int x) conveyor;  // 構文は未定

// pred()を用いて契約された関数
int func_a() post(r: pred(r));
void func_b(int x) pre(pred(x));

int main() {
  func_b(func_a()); // このコードは正しいか？
}
```

この場合、`pred()`はUBや副作用がないことが分かっているため、人間も静的解析機も`func_a()`の事後条件と後から呼ばれる`func_b()`の事前条件は同じ値に評価され、接続していることが分かります。重要なことは、これは`pred()`の定義を見に行かなくても分かるという点で、静的解析の負荷が大きく軽減されます。

この特性はさらに、静的解析だけではなく実行時チェックにも適しています。副作用やUBが無ければ、プログラマがチェックしたいことをチェックするためのコードの記述が非常に簡単になるためです。

このようなことはP2900の緩和契約のみでは達成することはできず、P2900のContracts機能は実際には静的解析の助けになりません。ただしこの提案はP2900が不要であると言っているのではなく、緩和契約とともにコンベア関数のように厳格に制限された契約も同時に必要であると主張しています。当然すべての契約条件がコンベア関数のように厳格な形で記述できるわけではなく、緩和契約でしか記述できない場合の方が多いでしょう。

ただし、P2900の緩和契約を先に標準化してしまった場合、この厳格な契約を後から導入することはできないか、困難になります。両方は同時に標準化される必要があります。

P2680/P3285の提案はSG21およびSG23においてあまり好意的に受け取られておらず、主な反対意見は「言語内で別のより一般的な保護を導入すれば（プロファイル提案など）、契約条件を特別扱いする必要はない」というものです。これが間違っている理由としては

1. そのようなより一般的な保護はオプトインである可能性が高い
2. 副作用の制限についてはあまり考慮されていない

の2点を挙げています。

ここで強く主張されていることは、言語の他の部分が副作用とUBフリーであるかどうかに関係なく、契約注釈内が副作用とUBフリーであることが重要であり契約注釈には特別な保護が必要である、ということです。

- [P3285R0 Contracts: Protecting The Protector - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3285R0-Contracts-Protecting-The-Protector)
- [P3362 進行状況](https://github.com/cplusplus/papers/issues/2022)

### [P3364R0 Remove Deprecated `u8path` overloads From C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3364r0.pdf)

非推奨だった`u8path()`を削除する提案。

`u8path()`はC++17の`<filesystem>`ライブラリの一部であり、`char8_t`が無かった時代にUTF-8エンコードされた`char`の文字列から`filesystem::path`オブジェクトを構築するために追加されました。しかしその後のC++20にて`char8_t`文字型とそれを使用した文字列型が導入され、`filesystem::path`のコンストラクタでも文字型でエンコーディングが識別できるようになったため不要になり、非推奨とされていました。

この提案は、これを削除しようとするものです。

この提案の内容そのものはC++23のサイクル中にLEWGにおいて合意が取れていましたが、筆者の方のリソース不足のため間に合いませんでした。その間にLWG Issue 3840にて非推奨を解除すべきとするIssueが提出されC++26サイクルで改めてレビューされたようです。

SG16ではこの関数の現状維持が推奨され、LEWGでは非推奨解除と削除のどちらにも支持者がおり、どちらの方向性でも合意を得ることは難しい雰囲気のようです。

この提案はどうやら、SG16において改めて方向性を確認して議論するために個別の提案として分離されたようです。

- [LWG Issue 3840. filesystem::u8path should be undeprecated](https://cplusplus.github.io/LWG/issue3840)
- [P3364 進行状況](https://github.com/cplusplus/papers/issues/2023)

### [P3365R0 Remove the Deprecated iterator Class Template from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3365r0.pdf)

非推奨だった`std::iterator`クラステンプレートを削除する提案。

`std::iterator`はカテゴリや値型等を指定して継承することでイテレータの定義を簡単にするためのクラステンプレートでしたが、入れ子型の定義しかしてくれず、どのテンプレートパラメータが何を指定しているのかが`using/typedef`で書いてある時よりも分かりづらくなり、さらにそれらの入れ子型定義が継承しているクラス内から使用できないなどの問題があり、あまり役に立たなかったためC++17で非推奨とされました。

C++20では`iteartor_traits`のアップデートなどによってこのクラステンプレートを改めて使用する意義は完全になくなっており、むしろ間違って使用すると有害になる可能性があるとして、この提案では削除しようとしています。

C++20時点では、`std::iterator`のデフォルトテンプレート引数を利用する有効な使用例が存在しており、そのようなコードが壊れてしまう懸念などから削除にはコンセンサスが得られませんでした。

しかし、C++23時点では`<ranges>`の導入に伴う`iteartor_traits`周りのアップデートによって`std::iterator`に依存していたコードが減ったため、削除へのコンセンサスが高まりました。それを受けてこの提案が単独で分離されたようです。

- [`std::iterator` - cpprefjp](https://cpprefjp.github.io/reference/iterator/iterator.html)
- [P3365 進行状況](https://github.com/cplusplus/papers/issues/2024)

### [P3366R0 Remove Deprecated Atomic Initialization API from C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3366r0.pdf)

非推奨だった`std::atomic`の初期化関数を削除する提案。

当初の`std::atomic`クラステンプレートのデフォルトコンストラクタは内部に保持する値を未初期化のまま構築していました。これはCとの互換性のためだったとのことです。このため、`std::atomic`を値初期化するためのユーティリティである`std::atomic_init()/ATOMIC_VAR_INIT`が用意されていました。

しかし、C++20で`std::atomic`のデフォルトコンストラクタの振る舞いが修正されたためこれらのものは不要になり、非推奨にされました。この提案はこれらのものを削除しようとするものです。

`ATOMIC_VAR_INIT`マクロはCからのものでしたが、C17で非推奨化されC23で削除されています。C規格への参照をC23に更新するならば、これを削除する必要があります。非推奨とはいえ文言を標準に維持するにはコストがかかるため、`ATOMIC_VAR_INIT`と一緒に同種の`std::atomic_init()`も削除しようとしています。

- [`std::atomic_init` - cpprefjp](https://cpprefjp.github.io/reference/atomic/atomic_init.html)
- [`ATOMIC_VAR_INIT` - cpprefjp](https://cpprefjp.github.io/reference/atomic/atomic_var_init.html)
- [P3366 進行状況](https://github.com/cplusplus/papers/issues/2025)

### [P3369R0 constexpr for `uninitialized_default_construct`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3369r0.html)

`uninitialized_default_construct()`を`cosntexpr`指定する提案。

P2283R2にて未初期化領域の初期化を行うアルゴリズム関数の多くが`constexpr`対応されました。そこでは定数式での初期化を`std::construct_at()`を用いて指定していましたが、`std::construct_at()`は値初期化しか行うことができず、デフォルト初期化を行う`uninitialized_default_construct()`は`constexpr`対応されませんでした。

P2747R2にて配置`new`の定数式での許可が提案されており、これは2024年6月の全体会議でC++26に導入されています。これを前提にすると、規定の変更を全く行うことなく`uninitialized_default_construct()`を`constexpr`指定できるため、この提案ではこれらの関数に`constexpr`を追加することだけを提案しています。

この提案の対象は`std::uninitialized_default_construct()`と`std::ranges::uninitialized_default_construct()`の並行アルゴリズムではないオーバーロードです。

この提案はこのリビジョンがそのまま2024年11月の全体会議で採択されています。

- [P2283R2 constexpr for specialized memory algorithms - WG21月次提案文書を眺める（2021年12月）](https://onihusube.hatenablog.com/entry/2022/01/10/235544#P2283R2-constexpr-for-specialized-memory-algorithms)
- [P3369 進行状況](https://github.com/cplusplus/papers/issues/2026)

### [P3370R0 Add new library headers from C23](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3370r0.html)
### [P3371R0 Fix C++26 by making the symmetric and Hermitian rank-k and rank-2k updates consistent with the BLAS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3371r0.html)

`<linalg>`の一部の関数を対応するBLAS関数の仕様と整合させる提案。

`<linalg>`にある関数群は基本的に、BLASの関数のどれか1つ（以上）に対応しており、対応するBLAS関数で行える計算はすべて行えるように設計されています。ただし、一部の関数はそうなっていなかったことが報告されました。

BLASの`DSYRK`関数は`C := βC + αAA^T`の計算行いますが、`<linalg>`で対応する`symmetric_matrix_rank_k_update()`は`C := C + αAA^T`を計算します。つまり係数`β`を適用する方法が無くなっています。

そして、同種のrank-k update系の関数でも同様の問題があることが分かりました

- `linalg::symmetric_matrix_rank_k_update()`: `C := C + αAA^T`
- `linalg::hermitian_matrix_rank_k_update()`: `C := C + αAA^H`
- `linalg::symmetric_matrix_rank_2k_update()`: `C := C + αAB^H + αBA^H`
- `linalg::hermitian_matrix_rank_2k_update()`: `C := C + αABH + ᾱBAH`（`ᾱ`は`α`の複素共役

いずれの関数でも、`C`に対して係数`β`を適用しなくなっています。

これらの関数は行列と行列の積の特殊なケース（入力が三角行列であり、結果が対称行列orエルミート行列になる）を処理する関数ですが、通常の行列と行列の積（`xGEMM`: `C := βC + αAB`）に対応する`linalg::matrix_product()`では、次の2種類のオーバーロードが用意されています

1. 上書き: `C := AB`
2. 更新: `C := E + AB`

更新オーバーロードではスケール係数`α, β`を`linalg::matrix_product(scaled(alpha, A), B, scaled(beta, C), C)`（引数順は`A, B, E, C`、`E`と`C`がエイリアスしていることを許容）のようにすることで処理しています。BLASの関数は基本的にこのように、BLASの関数の処理をC++で記述して実行できるように上書きと更新の2つのオーバーロードを提供しています。

しかし、`symmetric_matrix_rank_k_update()`をはじめとする問題の関数は更新オーバーロードがなく、`linalg::matrix_product()`の更新・上書きのどちらのオーバーロードとも異なるセマンティクスを持っています。また、BLASの`DSYRK`関数（および同種の対応するその他の関数）は`β`係数を0にすることで上書きを行うことができます。

この提案では、この問題の解決のために上記4つの関数を`linalg::matrix_product()`等の関数と同じように動作させるようにすることを提案しています。具体的には次の2つの変更を提案しています

1. 入力行列引数`E`を持つ更新オーバーロードを追加
    - 例えば、`symmetric_matrix_rank_k_update(A, E, C, upper_triangle)`は`C := E + AA^T`を計算し、`C`と`E`のエイリアスを許可することで`E`に`scaled(beta, C)`のように指定して係数`β`を適用するようにする
    - `E`は入力行列（`in-matrix`）となり、`C`は入出力行列（`possibly-packed-inout-matrix`）から出力行列（`possibly-packed-out-matrix`）に変更
2. 既存のオーバーロードの動作を、呼び出し方法を変更せずに上書きオーバーロードに変更
    - 例えば、`symmetric_matrix_rank_k_update(A, C, upper_triangle)`は` C := AA^T`を計算するようになる
    - `C`は入出力行列（`possibly-packed-inout-matrix`）から出力行列（`possibly-packed-out-matrix`）に変更

2つ目の変更により、BLASでは提供されている上書き動作（`C := αAA^T`）を提供できるようになりますが、この変更は破壊的変更ともなります。そのため、この提案はC++26サイクル中に完了する必要があるとしています。

- [`<linalg>` - cpprefjp](https://cpprefjp.github.io/reference/linalg.html)
- [P3371 進行状況](https://github.com/cplusplus/papers/issues/2028)

### [P3372R0 constexpr containers and adapters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3372r0.html)
### [P3373R0 Of Operation States and Their Lifetimes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3373r0.pdf)
### [P3374R0 Adding formatter for fpos](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3374r0.html)
