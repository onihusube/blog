# ［C++］WG21月次提案文書を眺める（2024年05月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2024 mailing2024-05](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/#mailing2024-05)

全部で139本あります。

もくじ

[:contents]

### [N4983 WG21 agenda: 24-29 June 2024, St. Louis, MO, USA](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/n4983.html)

2024年6月にセントルイスで行われた会議のアジェンダ。

### [P0260R9 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0260r9.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)

このリビジョンでの変更は

- 提案する文言の拡充
- `capacity`の修正
- `push()/pop()`の文言に"strongly happens before"を使うように変更
- discussion pointsを追加
- コンストラクタとデストラクタが同じスレッドに戻ることに関する段落を削除
- `try_*`はブロックしなくなった
- `try_*`のspurious failureに関する文言を追加
- キューを事前に埋める`bounded_queue`のコンストラクタを削除
- P3282への参照を追加
- `try_push(T &&, T &)`に関する議論をHistoric Contentsに移動

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0843R12 inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0843r12.html)

静的な最大キャパシティを持ちヒープ領域を使用しない`std::vector`である`inplace_vector`の提案。

以前の記事を参照

- [P0843R5 static_vector - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P0843R5-static_vector)
- [P0843R6 static_vector - ［C++］WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P0843R6-static_vector)
- [P0843R8 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P0843R8-inplace_vector)
- [P0843R9 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P0843R9-inplace_vector)
- [P0843R10 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P0843R10-inplace_vector)
- [P0843R11 `inplace_vector` - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0843R11-inplace_vector)

このリビジョンでの変更は

- 以前のリビジョンを復帰して、条件付き`constexpr`を有効化
- R8で削除された`constexpr`対応の議論を再導入

などです。

この提案は、2024年6月の全体会議でC++26に向けて採択されています。

- [P0843 進行状況](https://github.com/cplusplus/papers/issues/114)

### [P0963R2 Structured binding declaration as a condition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p0963r2.html)

構造化束縛宣言を条件式を書くところで書けるようにする提案。

以前の記事を参照

- [P0963R1 Structured binding declaration as a condition - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P0963R1-Structured-binding-declaration-as-a-condition)

このリビジョンでの変更は、分解前に条件をチェックするという評価順序を規定しそれについての議論を追加したことと、提案する文言の改善などです。

この提案は、2024年6月の全体会議でC++26に向けて採択されています。

- [P0963 進行状況](https://github.com/cplusplus/papers/issues/1617)

### [P1000R6 C++ IS schedule](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1000r6.pdf)

C++26策定までのスケジュールなどを説明した文書。

このリビジョンはR5のものとほぼ同じですが、決定済みの会議開催地の地名が記載されるようになっています。

### [P1083R8 Move resource_adaptor from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1083r8.html)

`pmr::resource_adaptor`をLibrary Foundermental TSからワーキングドラフトへ移動する提案。

以前の記事を参照

- [P1083R4 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P1083R4-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R5 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P1083R5-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R6 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P1083R6-Move-resource_adaptor-from-Library-TS-to-the-C-WP)
- [P1083R7 Move `resource_adaptor` from Library TS to the C++ WP - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P1083R7-Move-resource_adaptor-from-Library-TS-to-the-C-WP)

このリビジョンでの変更は、`resource-adaptor-imp`に可変長引数コンストラクタを追加した事などです。

この提案は現在LWGでレビュー中です。

- [P1083 進行状況](https://github.com/cplusplus/papers/issues/33)

### [P1112R5 Language support for class layout control](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1112r5.pdf)

クラスレイアウトを明示的に制御するための構文の提案。

以前の記事を参照

- [P1112R4 Language support for class layout control - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1112R4-Language-support-for-class-layout-control)

このリビジョンでの変更は

- Cでは構造体メンバの宣言順調整でこの問題を解消できるが、C++ではそれは実行可能ではないことについての説明の追加
- リフレクションではこの問題を解決できないことについてのセクションを追加
- Design principlesセクションを追加
- `eval`ストラテジーを追加
- `smallest`を`small`に変更し、アルゴリズムの説明を追加
- 対象読者を追加
- 文言作成に関する戦略を追記

などです。

今回レイアウトに関する指示を行う方法が1つ追加されました

- `layout(eval(consteval_func))`
  - 元のレイアウトをエントリーの配列として取得し、オフセットフィールドを変更できる`consteval`関数を呼び出す

`layout(eval(func))`に渡す`consteval`関数は、レイアウトを変更する場合に`true`を返し、変更しないならば`false`を返す必要があります。そして、その引数には次のような構造体の配列が渡されます

```cpp
// クラスの元のレイアウトについての、各メンバ毎の情報を持つ
struct layout_entry {
  enum type_id { base, member, tech };
  type_id type;
  string_view name; // メンバ名
  size_t index;     // 宣言順のインデックス
  size_t size;      // sizeof()の結果の値
  int alignment;    // alignas()の結果の値
  bool noua;        // [[no_unique_address]]の有無
  bool fixed;       // ムーブ可能かどうか
  size_t orig_offset;    // 元のレイアウトにおけるオフセット
  mutable size_t offset; // 変更するオフセット（初期値はorig_offsetの値）
};

// layout(eval(f))に渡す関数の例
consteval bool my_layout_func(span<const layout_entry> entries);
```

これによって、プログラマはかなり詳細にそのオフセットを制御することができるようになります。

この提案はこれ以上追求しないことがEWGで決定されたようです。

- [P1112 進行状況](https://github.com/cplusplus/papers/issues/38)

### [P1144R11 `std::is_trivially_relocatable`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1144r11.html)

オブジェクトの再配置（*relocation*）という操作を定義し、それをサポートするための基盤を整える提案。

以前の記事を参照

- [P1144R6 Object relocation in terms of move plus destroy - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P1144R6-Object-relocation-in-terms-of-move-plus-destroy)
- [P1144R7 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年04月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P1144R7-stdis_trivially_relocatable)
- [P1144R8 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1144R8-stdis_trivially_relocatable)
- [P1144R9 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P1144R9-stdis_trivially_relocatable)
- [P1144R10 `std::is_trivially_relocatable` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P1144R10-stdis_trivially_relocatable)

このリビジョンでの変更は

- この提案に準拠済みのライブラリについての参照の追加
- `uninitialized_relocate_n`のテンプレートパラメータのために`NoThrowInputIterator`要件を追加
- P3279への相互参照を追加

などです。

- [P1144 進行状況](https://github.com/cplusplus/papers/issues/43)

### [P1255R13 A view of 0 or 1 elements: views::nullable And a concept to constrain maybes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1255r13.pdf)

任意のオブジェクトや`std::optional`等のmaybeモナドな対象を要素数0か1のシーケンスに変換するRangeアダプタ`views::maybe`/`views::nullable`の提案。

以前の記事を参照

- [P1255R6 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P1255R6--A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R7 : A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年05月）](https://onihusube.hatenablog.com/entry/2022/06/11/191943#P1255R7-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R8 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P1255R8-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R9 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P1255R9-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R10 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2023年09月）](https://onihusube.hatenablog.com/entry/2023/10/29/180915#P1255R10-A-view-of-0-or-1-elements-viewsmaybe)
- [P1255R12 A view of 0 or 1 elements: `views::maybe` - ［C++］WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P1255R12-A-view-of-0-or-1-elements-viewsmaybe)

このリビジョンでの変更は

- `views::maybe`を削除し、`std::optional`の`range`化を好む
- `std::maybe`コンセプトの追加
- `std::optional`やポインタ型など`maybee`型のためのフリー関数を追加

などです。

`std::maybe`コンセプトは次のような単純なものです

```cpp
template <class T>
concept maybe = requires(const T t) {
  bool(t);
  *(t);
};
```

これに対して次のフリー関数を追加します

```cpp
template <class T, class R = optional<decay_t<T>>>
constexpr auto yield_if(bool b, T&& t) -> R {
  return b ? forward<T>(t) : R{};
}

template <maybe T,
          class U,
          class R = common_reference_t<iter_reference_t<T>, U&&>>
constexpr auto reference_or(T&& m, U&& u) -> R {
  static_assert(!reference_constructs_from_temporary_v<R, U>);
  static_assert(!reference_constructs_from_temporary_v<R, T&>);
  return bool(m) ? static_cast<R>(*m) : static_cast<R>((U&&)u);
}

template <maybe T,
          class U,
          class R = common_type_t<iter_reference_t<T>, U&&>>
constexpr auto value_or(T&& m, U&& u) -> R {
  return bool(m) ? static_cast<R>(*m) : static_cast<R>(forward<U>(u))
}

template <maybe T,
          class I,
          class R = common_type_t<iter_reference_t<T>,
          invoke_result_t<I>>>
constexpr auto or_invoke(T&& m, I&& invocable) -> R {
  return bool(m) ? static_cast<R>(*m) : static_cast<R>(invocable());
}
```

- [P1255 進行状況](https://github.com/cplusplus/papers/issues/60)

### [P1306R2 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1306r2.pdf)

コンパイル時にステートメントをループ生成することのできる、展開ステートメントの提案。

展開ステートメントとは、通常の`range`（配列や`std::vector`等コンテナ）に加えてタプルやクラス、波かっこのリストを反復することのできるコンパイル時のループ構文であり、ループの結果としてはループ本体のコード（ステートメント）をループの度にその場に展開していきます。

例えば次のような拡張ステートメントは

```cpp
auto tup = std::make_tuple(0, ‘a’, 3.14);
template for (auto elem : tup) {
  std::cout << elem << std::endl;
}
```

次のようにコードをべた書きしたのと等価になります

```cpp
auto tup = std::make_tuple(0, ‘a’, 3.14);
{
  auto elem = std::get<0>(tup);
  std::cout << elem << std::endl;
}
{
  auto elem = std::get<1>(tup);
  std::cout << elem << std::endl;
}
{
  auto elem = std::get<2>(tup);
  std::cout << elem << std::endl;
}
```

また展開ステートメントでは、波かっこリストが特別扱いされており、上記のコードは次のように書くこともできます

```cpp
template for (auto elem : {0, 'a', 3.14}) {
  std::cout << elem << std::endl;
}
```

この波かっこリストは初期化子リストではなく、この波かっこリストは初期化を行わずに各要素に対して直接ループが展開されます。

展開ステートメントは次のものに対して使用できます

- 構造化束縛可能なクラス型のオブジェクト
    - プレーンな構造体やタプルなど
- `constexpr`な範囲オブジェクト
    - 主に`std::vector`
- 波かっこで区切られた式のリスト（展開初期化子リスト、"expansion-init-lists"）
    - 例えば、パラメータパックも`{pack...}`とすることでループ対象になる

展開ステートメントはループな風を装っていますが、実際のところコンパイル時にループによってステートメントを生成していくのではなく、予めイテレーション対象の各要素によって生成されたステートメントの列として、範囲`for`同様に言語組み込みのマクロのような形で、一発で置換されます。とはいえ、結果のコードのインスタンス化順序や実行された時の実行順はあたかもループによって順番にステートメントが生成されていったのと同じように見えます。

この展開ステートメントは特に静的リフレクション機能と非常に相性が良い機能です。P2996R5より、列挙値を列挙値名の文字列に変換するサンプルコード

```cpp
template <typename E>
  requires std::is_enum_v<E>
constexpr std::string enum_to_string(E value) {
  template for (constexpr auto e : std::meta::enumerators_of(^E)) {
    if (value == [:e:]) {
      return std::string(std::meta::identifier_of(e));
    }
  }

  return "<unnamed>";
}

enum Color { red, green, blue };
static_assert(enum_to_string(Color::red) == "red");
static_assert(enum_to_string(Color(42)) == "<unnamed>");
```

`^E`は列挙型`E`からそのリフレクション情報を取り出しており、それに対する`std::meta::enumerators_of()`は列挙型の各列挙子のリフレクション情報を取り出しています。ここでのイテレーション対象`e`は`std::meta::info`の値で、`[:e:]`（スプライシング）によって対応する列挙値の定数値に変換することで、展開ステートメントの各ステートメントは列挙型`E`の列挙子1つに対してマッチする`if`文を生成します。

`(std::meta::identifier_of()`はリフレクション情報からそれに対応する識別子名を文字列で得るもので、ここでは`e`は列挙子を映したものなので、列挙子名がコンパイル時文字列で得られます。

この`template for`以外のものはP2996の静的リフレクション提案ですべて用意されているものです。

- [P1306 進行状況](https://github.com/cplusplus/papers/issues/156)

### [P1494R3 Partial program correctness](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1494r3.html)

因果関係を逆転するような過度な最適化を防止するためのバリアである`std::observable()`の提案。

以前の記事を参照

- [P1494R2 Partial program correctness - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1494R2-Partial-program-correctness)

このリビジョンでの変更は

- フリースタンディングでのサポートを要求
- 実装可能性を明確化
- I/O関数を暗黙的なチェックポイントとして扱うようにする代替案についての説明の追加

などです。

- [P1494 進行状況](https://github.com/cplusplus/papers/issues/376)

### [P1928R9 `std::simd` - Merge data-parallel types from the Parallelism TS 2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p1928r9.pdf)

`std::simd<T>`をParallelism TS v2から標準ライブラリへ移す提案。

以前の記事を参照

- [P1928R1 Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P1759R3-Native-handles-and-file-streams)
- [P1928R2 Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P1928R2-Merge-data-parallel-types-from-the-Parallelism-TS-2)
- [P1928R3 Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P1928R3-Merge-data-parallel-types-from-the-Parallelism-TS-2)
- [P1928R4 `std::simd` - Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P1928R4-stdsimd---Merge-data-parallel-types-from-the-Parallelism-TS-2)
- [P1928R6 `std::simd` - Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P1928R6-stdsimd---Merge-data-parallel-types-from-the-Parallelism-TS-2)
- [P1928R7 `std::simd` - Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P1928R7-stdsimd---Merge-data-parallel-types-from-the-Parallelism-TS-2)
- [P1928R8 `std::simd` - Merge data-parallel types from the Parallelism TS 2 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P1928R8-stdsimd---Merge-data-parallel-types-from-the-Parallelism-TS-2)

このリビジョンでの変更は

- ベクトル化可能な型として、C++23の拡張浮動小数点数型を追加
- "selected indices”と“selected elements”の定義を改善
- ABIタグの意図を紹介する文言の改善
- `size`を呼び出し可能として一貫して使用
- 不足していた`reduce`の`type_identity_t`を追加
- `basic_simd_mask`のデフォルトテンプレート引数を`native-abi`に修正
- `simd_mask`のデフォルトテンプレート引数を`simd`と一貫するように修正
- `<simd>`ヘッダを追加するのに必要な変更を追加
- 2つの投票結果を追加
- `simd_size(_v)`を説明専用にする
- `reduce_min_index`と`reduce_max_index`事前条件を復元

などです。

この提案は現在、LWGでレビュー中です。

- [P1928 進行状況](https://github.com/cplusplus/papers/issues/670)

### [P2019R6 Thread attributes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2019r6.pdf)

`std::thread/std::jthread`において、そのスレッドのスタックサイズとスレッド名を実行開始前に設定できるようにする提案。

- [P2019R1 Usability improvements for `std::thread` - ［C++］WG21月次提案文書を眺める（2022年08月）](https://onihusube.hatenablog.com/entry/2022/09/04/141015#P2019R1-Usability-improvements-for-stdthread)
- [P2019R2 Usability improvements for `std::thread` - ［C++］WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2019R2-Usability-improvements-for-stdthread)
- [P2019R3 Thread attributes - ［C++］WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2019R3-Thread-attributes)
- [P2019R4 Thread attributes - ［C++］WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2019R4-Thread-attributes)
- [P2019R5 Thread attributes - ［C++］WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2019R5-Thread-attributes)

このリビジョンでの変更は、安全性向上のためにスレッド属性引数が左辺値参照にならないように制約を追加したことです。

現在のリビジョンでの使い方は次のようになっています

```cpp
void f(int);

int main() {
  std::jthread thread{
      std::thread::name_hint{"Worker"},       // スレッド名の指定
      std::thread::stack_size_hint{512*1024}, // スタックサイズの指定
      f, 42 // 実行する処理とその引数
  };

  return 0;
}
```

- [P2019 進行状況](https://github.com/cplusplus/papers/issues/817)

### [P2034R4 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2034r4.pdf)

ラムダ式の全体を`mutable`とするのではなく、一部のキャプチャだけを`mutable`指定できるようにする提案。

以前の記事を参照

- [P2034R1 Partially Mutable Lambda Captures - WG21月次提案文書を眺める（2020年4月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P2034R1--Partially-Mutable-Lambda-Captures)
- [P2034R2 Partially Mutable Lambda Captures - WG21月次提案文書を眺める（2020年4月）](https://onihusube.hatenablog.com/entry/2020/07/05/003248#P2034R2--Partially-Mutable-Lambda-Captures)
- [P2034R2 Partially Mutable Lambda Captures - WG21月次提案文書を眺める（2024年4月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2034R3-Partially-Mutable-Lambda-Captures)

このリビジョンでの変更は、Meta-Motivationを追記したことと、いくつかのサンプルを改善したことなどです。

メタモチベーションでは、`const`な変数は正しく扱うのが簡単で間違って扱うのが難しいはずであり、ラムダキャプチャの文脈で`const`をシンプルかつ正確に指定できるようになすることはプログラムの安全性とセキュリティを向上させるものである、としています。

- [P2034 進行状況](https://github.com/cplusplus/papers/issues/764)

### [P2079R4 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2079r4.html)

ハードウェアの提供するコア数（スレッド数）に合わせた固定サイズのスレッドプールを提供する*Scheduler*の提案。

- [P2079R1 Parallel Executor - ［C++］WG21月次提案文書を眺める（2020年8月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P1899R1-stride_view)
- [P2079R2 System execution context - ［C++］WG21月次提案文書を眺める（2022年1月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2079R2-System-execution-context)
- [P2079R3 System execution context - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P2079R3-System-execution-context)

このリビジョンでの変更は

- 設計上の考慮事項と目標をさらに追加
- さまざまな置き換え可能性オプションの比較を追加
- 置き換え可能性ABI標準化のモチベーションを追加
- 置き換え用ABIの例を追加
- 生存期間保証を強化
    - `system_context`がその上で起動されたすべての作業よりも長く生存しなければならないことが明記され、破棄時に未完了の作業がある場合は `std::terminate`が呼び出されるようにした

などです。

置き換え可能性（*replaceabiilty*）とは、`system_context`の実装をユーザーが置き換えられるようにすることをサポートする機能の事です。これは、厳密なシングルスレッドしか利用可能ではない組み込み環境やoneTBBのようなベンダー固有実装の利用など、多様な実行環境に対応するためです。

この方法としては3つの方法が考えられます

- コンパイル時の置き換え
- リンク時の置き換え
- 実行時の置き換え

| 方法 | メリット | デメリット |
|---|---|---|
| リンク時 | * 標準の先行例あり: `operator new` の置換と類似している<br/> * 予測可能性が高い: アプリケーション全体に適用されることが保証される<br/> * リンク時最適化により、型消去や間接参照をある程度削減できる可能性がある | * ABI の定義が必要となるため、型消去や非効率性が発生する可能性がある<br/> * 共有ライブラリを使用する場合、異なる置換バージョンが混在する可能性があり、正しく動作させることが難しい<br/> * 置換がリンクの順序に依存する可能性がある |
| 実行時 | * 標準の先行例あり:  `std::set_terminate()` と類似している<br/> * 共有ライブラリ (例: Windows の DLL における C++ 標準ライブラリの同一バージョン) を使用したアプリケーションで、一貫した動作を容易に実現できる<br/> * 1つのプログラムに system scheduler の複数の実装を含めることができる | * system scheduler の置換と、それを用いた作業の生成との間で競合状態が発生する可能性がある<br/> * ABI を介した処理が必要となるため、リンク時最適化ができない<br/> * 異なる実装が起動時に system scheduler のためのリソースを割り当てた後、`main` の開始時に実装が置換される可能性がある (主に QOI の問題) <br/>* 安全性を確保するため、およびユーザーが明示的に正しい処理を行うために、厳密なライフタイムと所有権の制御が必要となる |
| コンパイル時 | * ユーザーは、あらゆる場所で利用できる型定義を使用して置換を行うことができ、簡単に切り替えることができる<br/> | * ODR 違反が発生する可能性がある<br/> * 同一プロセス内の異なるバイナリ間で共有できない |

提案では、コンパイル時の置き換えは`system_context`の重要な設計原則の一つである、オーバーサブスクリプションを回避するためにアプリケーション全体で共通な1つの実行コンテキストを持つ（ためのもの）、というのを破ってしまうため有効なオプションではないとしており、実行時かリンク時のどちらかがオプションとして残っています。

- [P2079 進行状況](https://github.com/cplusplus/papers/issues/806)

### [P2413R1 Remove unsafe conversions of unique_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2413r1.html)

`std::unique_ptr`における、危険な暗黙変換を禁止する提案。

以前の記事を参照

- [P2413R0 Remove unsafe conversions of unique_ptr - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2413R0-Remove-unsafe-conversions-of-unique_ptr)

このリビジョンでの変更は

- 変換先の型に*destroying operator delete*がある場合でも変換を許可する
- `default_delete::operator()`を制約する
- 生ポインタを取る`std::unique_ptr`のメンバ関数を制約する
- 不完全型を処理する
- 破壊的変更を文書化

などです。

- [P2413 進行状況](https://github.com/cplusplus/papers/issues/1083)

### [P2434R1 Nondeterministic pointer provenance](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2434r1.html)

現在のC++のポインタ意味論をポインタの*provenance*モデルに対して整合させるための提案。

- [P2434R0 Nondeterministic pointer provenance - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2434R0-Nondeterministic-pointer-provenance)

このリビジョンでの変更は

- P2318R1の分析と提案に関する議論を明確化
- pointer zapへの影響についての調査を追加

などです。

pointer zapへの影響については、皆無ではないものの小さな追加の変更だけで対応できるとしています。

- [P2434 進行状況](https://github.com/cplusplus/papers/issues/1364)

### [P2689R3 Atomic Refs Bound to Memory Orderings & Atomic Accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2689r3.html)

`mdspan`の要素にアトミックにアクセスするためのアクセサである、`atomic_accessor`の提案。

以前の記事を参照

- [P2689R0 `atomic_accessor` - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P2689R0-atomic_accessor)
- [P2689R1 `atomic_accessor` - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2689R1-atomic_accessor)
- [P2689R2 `atomic_accessor` - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2689R2-atomic_accessor)

このリビジョンでの変更は

- `atomic-ref-bound`を算術型・ポインタ型とそれ以外の型用に分離
    - メンバ型`deference_type`の定義の有無のため
- `atomic-ref-bound`が説明専用であるかどうかについての議論を追加
- メモリオーダーの指定に関する変換コンストラクタを持たないことについての議論を追加
- west `const`スタイルの使用

などです。

- [P2689 進行状況](https://github.com/cplusplus/papers/issues/1354)

### [P2719R0 Type-aware allocation and deallocation functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2719r0.html)

型を指定する形の`new/delete`演算子カスタマイズ方法の提案。

ある型について、`new/delete`演算子をカスタマイズする方法は、クラスの静的メンバ関数として定義するか、グローバルな`new/delete`演算子をオーバーライドするかの2択です。`new/delete`演算子を型ごとにカスタマイズする場合はその型についての知識が必要となりますが、前者の方法だとそれが得られるものの型に対して侵入的にしか定義できません。一方後者の方法は非侵入的に定義できるものの、グローバルな`new/delete`を丸ごと置き換えることになる（型毎にオーバーロード可能なものの、現実には`::operator new(void*)`を丸ごと置換しているケースがほとんど）ため影響範囲が大きく、複数の翻訳単位（ライブラリ）が独自にそれを行っているとODR違反の未定義動作で厄介なバグを抱え込むことになります。

この提案では、ある型についての`new/delete`演算子の非侵入的なカスタマイズ方法を提案するものです。

この提案によるカスタム方法は、既存の`operator new/delete`のオーバーロードがタグ型を取るようになっているのの延長で、ある型`T`についての`new/delete`演算子オーバーロードはタグ型として`std::type_identity<T>`を取るようにするものです。そして、`new/delete`式が演算子を探索する過程を少し調整して、このようなオーバーロードが発見されるようにします。

この提案の前後である`new`演算子呼び出し（`new`式）に対してコンパイラが考慮する`new`演算子のシグネチャ候補と順番は次のように変化します

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// ユーザーの書くnew演算子
new (args...) T(...)

// コンパイラが考慮する演算子
T::operator new(sizeof(T), args...)
::operator new(sizeof(T), args...)
```

</td>
<td valign="top">

```cpp
// ユーザーの書くnew演算子
new (args...) T(...)

// コンパイラが考慮する演算子
T::operator new(sizeof(T), args...)
operator new(sizeof(T), type_identity<T>{}, args…)  // 👈追加
::operator new(sizeof(T), args...)
```

</td>
</tr>
</table>


<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// ユーザーの書くdelete演算子
delete ptr

// コンパイラが考慮する演算子
T::operator delete(void-ptr)
::operator delete(void-ptr)
```

</td>
<td valign="top">

```cpp
// ユーザーの書くdelete演算子
delete ptr

// コンパイラが考慮する演算子
T::operator delete(void-ptr)
operator delete(void-ptr, type_identity<T>{})  // 👈追加
::operator delete(void-ptr)
```

</td>
</tr>
</table>

配列版も同様です。

セキュリティ向上のために、型毎に異なるメモリ領域に配置する（同じ型のオブジェクトを同じメモリ領域に配置する）というテクニックがあり、これによってType Confusion攻撃に対する耐性を向上させることができるようです。実際に、Appleでは自社開発のOSカーネルでこれを導入することでType Confusion脆弱性の軽減に大きな効果があったとのことです（筆者の方はAppleの方）。

カーネルに限らず、セキュリティが重要なコードベースではこのような手法を取り入れることが合理的な場合がありますが、現在のC++の`new/delete`オーバーロードはこのような手法を大規模かつシステム全体で達成することをサポートできていません。この提案の内容はそのような手法を達成するための構成要素であり、間接的にC++プログラムのセキュリティを向上させることに繋がります。

提案文書より、サンプルコード

```cpp
namespace lib {
  struct Foo { };

  void* operator new(std::size_t, std::type_identity<Foo>); // (1)

  struct Foo2 { };
}

struct Bar {
  static void* operator new(std::size_t); // (2)
};

void* operator new(std::size_t); // (3)

void f() {
  new lib::Foo();  // calls (1)
  new Bar();       // calls (2)
  new lib::Foo2(); // (1)が見つかりますがオーバーロード解決に失敗するため、(3)が呼び出される
  new int();       // calls (3)
}
```

現在コンパイラは`new`演算子の探索において、まず対象の型（`new T{}`の`T`）のクラススコープで`T::operator new()`を探索し、見つかればそれを使用します。見つからない場合、次にグローバルの`::operator new()`を探索し、見つかればそれを使用します。どちらかが見つかれば例えばそれがエラーでも探索はそれで終了します。

この提案では、グローバルな`::operator new()`を探索する前に、フリー関数の`operator new()`を考慮するようにします。その際のシグネチャは次のものです

```cpp
operator new(sizeof(T), std::type_identity<T>{}, placement-args...)
```

型`T`に対して第二引数で`std::type_identity<T>`を受け取るようにオーバーロードしておくことで、この挿入された2ステップ目の探索でそれを使わせることができるようになるわけです。そして、この探索はADLによって行われるため、名前空間内で`new/delete`演算子を定義しておくこともでき、これによってODR違反を緩和することができます。

- [型の取り違えとは(Type Confusion) | サイバー攻撃大辞典](https://securitychecklist.net/security/cyber-attack/Type-Confusion.html)
- [P2719 進行状況](https://github.com/cplusplus/papers/issues/1898)

### [P2758R3 Emitting messages at compile time](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2758r3.html)

コンパイル時に任意の診断メッセージを出力できるようにする提案。

以前の記事を参照

- [P2758R0 Emitting messages at compile time - WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P2758R0-Emitting-messages-at-compile-time)
- [P2758R1 Emitting messages at compile time - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2758R1-Emitting-messages-at-compile-time)
- [P2758R2 Emitting messages at compile time - WG21月次提案文書を眺める（2024年102月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2758R2-Emitting-messages-at-compile-time)

このリビジョンでの変更は

- 他の提案（P2741R3及びP2738R1）が採択されていることを前提として提案を整理
- すべてのAPIに追加されるタグについて議論を追記

などです。

このリビジョンで導入されたタグとは、エラーメッセージの種別を表すものです。これは、エラーメッセージを発行するかどうかを制御するためのもので、実装定義の方法で特定のタグを持つコンパイル時メッセージ出力関数の出力を無効化することができます。たとえば

```cpp
std::constexpr_warning(
  "format-too-many-args", // 👈タグの指定
  "Format string consumed {} arguments but {} were provided.",
  current_arg, total);
```

（fmtライブラリ中で）このようなコンパイル時出力が使用されている場合、`-Wno-format-too-many-arg`オプションによってこの出力を無効化する、のような使い方を想定しています。ただし、この制御方法は実装定義とされています。また、タグに使用できるのはコンパイル時の文字列かつ。大文字小文字と数字アンダーバーくらいに制限することを提案しています。これは、コンパイラフラグとしてタグ文字列に対応する文字列をCLIから指定して制御を行うことを意図しているためです。

このリビジョンでは提案する関数は基本的にこのタグを受け取るようになりました

```cpp
namespace std {
  // 定数式中でメッセージを出力
  constexpr void constexpr_print_str(string_view) noexcept;
  constexpr void constexpr_print_str(tag-string, string_view) noexcept;

  // 定数式中で警告メッセージを出力
  constexpr void constexpr_warning_str(tag-string, string_view, string_view) noexcept;
  
  // 呼ばれるとコンパイルエラー、指定されたエラーメッセージを出力
  constexpr void constexpr_error_str(tag-string, string_view) noexcept;
}
```

- [P2758 進行状況](https://github.com/cplusplus/papers/issues/1445)

### [P2761R1 Slides: If structured binding (P0963R1 presentation)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2761r1.pdf)
### [P2786R6 Trivial Relocatability For C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2786r6.pdf)
### [P2822R1 Providing user control of associated entities of class types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2822r1.pdf)
### [P2830R4 Standardized Constexpr Type Ordering](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2830r4.html)
### [P2835R4 Expose std::atomic_ref's object address](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2835r4.html)
### [P2841R3 Concept and variable-template template-parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2841r3.pdf)
### [P2846R2 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2846r2.pdf)
### [P2849R0 async-object - aka async-RAII objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2849r0.pdf)

`sender`チェーンにRAIIリソースを注入するための、非同期オブジェクトの提案。

`sender/receiver`自体は非同期関数の実装の一部であり、P2300のフレームワークでは非同期関数は値・エラー・キャンセルのいずれかの結果によって非同期的に完了します。

非同期関数の内部で使用されるリソース（非同期オブジェクト）は、非道的処理が単一のローカルなブロックに収まるものではないため、通常手動でメモリを管理する必要があります。

`sender`アルゴリズムによるチェーンに対して値を注入するには、`let_value(value, func)`アルゴリズムを使用します。これは、`func(value)`の結果を（`receiver`の値チャネルで）返す`sender`を返すもので、そこから得られる値（`func(value)`の結果）は安定したストレージに保持されることが保証されます。

これと同種なものとして、`let_stop_source(sender, sender(inplace_stop_source&))`というアルゴリズムを考えることができます。これは、`sender`チェーンに対して`inplace_stop_source`を注入し、なおかつそれに安定的なストレージを提供するものです。この延長で、`sender`チェーンに対して多様な非同期リソースを注入するめの`let_xxx`アルゴリズムが個別に考案されつつあります。このことは、このような非同期リソースを`sender`チェーンで扱うための汎用的な設計が欠けていることを表しています。

そのような非同期コードでは多くの場合、`shared_ptr`を使用してアドホックなガーページコレクションが実装されます。このようなアドホックな非同期オブジェクトの非同期的な構築と破棄はある統一的な汎用設計に従っていない場合、汎用的なアルゴリズムからそのような非同期リソースを複数まとめて扱うことを困難にします。

この提案は、`sender/receiver`を用いた非同期オブジェクトの構築と破棄のルールをライブラリに実装する方法についてを提案するものです。

この提案では、非同期オブジェクトのための3つの基本的な要件について定義しています

- 非同期構築（*async constructio*）
    - オブジェクトの中には構築中に実行される非同期関数がある
        - ファイルを開く、通信を確立する、など
    - スレッドをブロックすることなく、構築中に非同期関数を使用できるようにする必要がある
    - コンストラクタはこれを満たすことができない
- 非同期破棄（*async destruction*）
    - オブジェクトの中には破棄中に実行される非同期関数がある
        - ファイルをフラッシュする、通信を中断する、など
    - スレッドをブロックすることなく、破棄中に非同期関数を使用できるようにする必要がある
    - デストラクタはこれを満たすことができない
- 構造化された正しい構築（*structured and correct-by-construction*）
    - ローカルスコープのオブジェクトのルールから派生した、直感的なオブジェクト構築のルール
    - structured concurrencyのコンストラクタ/デストラクタ版

これらの要件の元、この提案ではつぎの3つのものを提案しています

- 非同期オブジェクト
    - 非同期構築が正常に完了するまで使用できない
    - 非同期構築がエラーで完了する場合がある
    - 非同期構築のキャンセルをサポートする
    - 非同期破棄が失敗せず、停止できないことを保証する
- `async_using`アルゴリズム
    - 常に、内部の非同期関数を呼び出す前に非同期構築を完了する
    - 常に、内部の非同期関数が完了する前に非同期破棄を完了する
    - 常に、内部の非同期関数の完了に伴って非同期破棄を呼び出す
    - 常に、複数の非同期オブジェクトの非同期破棄を、その非同期構築の逆順で呼び出す
    - 常に、非同期構築に成功した非同期オブジェクトに対してだけ、非同期破棄を呼び出す
- `async_tuple`
    - 常に、`async_tuple`そのものの非同期構築完了の前に、内包する全ての非同期オブジェクトの非同期構築を完了する
    - 常に、内包する全ての非同期オブジェクトの非同期破棄を、その非同期構築の逆順で呼び出す
    - 常に、非同期構築に成功した内包する非同期オブジェクトに対してだけ、非同期破棄を呼び出す

非同期オブジェクト同士は組み合わせて使用することができ、その要件は次のものです

- 構成（*composition*）
    - 複数の非同期オブジェクトは、ネストせずに同時に使用可能になる
    - オブジェクト間の依存関係はネストによって表現される
    - 構成は、複数のオブジェクトの並行非同期構築をサポートする
    - 構成は、複数のオブジェクトの並行非同期破棄をサポートする

この提案が提供するのは、これらの要件を具体化した`async_object<T>`をはじめとするコンセプトと、`async_using`と`async_tuple`、および`packaged_async_object`（非同期オブジェクトとその非同期コンストラクタ引数をパッケージングするもの）です。

提案より、サンプルコード。

非同期オブジェクト型（`Foo`）の実装例

```cpp
// Fooはint値を格納する非同期オブジェクト
struct Foo {
  // 非同期オブジェクトを定義
  // 非同期オブジェクトはムーブ不可である必要がある
  struct object : __immovable {
    object() = delete;
    int v;
  private:
    // only allow Foo to run the constructor
    friend struct Foo;
    explicit object(int v) noexcept : v(v) {}
  };

  // 構築された非同期オブジェクトのハンドル型
  // これは非同期構築（async_construct()）によって生成される
  using handle = std::reference_wrapper<object>;

  // 非同期オブジェクト用のストレージを予約する型
  // nothrowデフォルト構築可能 かつ ムーブ不可である必要がある
  using storage = std::optional<object>;
  
  // async_construct()は構築された非同期オブジェクトのハンドルで完了するsenderを返す
  auto async_construct(storage& stg, int v) const noexcept {
    return then( just(std::ref(stg), v),
      [](storage& stg, int v) noexcept {
        auto construct = [&]() noexcept { return object{v}; };
        stg.emplace( __conv{construct});
        printf("foo constructed, %d\n", stg.value().v);

        return std::ref(stg.value());
      }
    );
  }

  // async_destruct() はストレージ内の非同期オブジェクトの破棄を実行し、非同期破棄が完了した後に完了するsenderを返す
  auto async_destruct(storage& stg) const noexcept {
    return then( just(std::ref(stg)),
      [](storage& stg) noexcept {
        printf("foo destructed %d\n", stg.value().v);
        stg.reset();
      }
    );
  }
};

// Fooはasync_object
static_assert(async_object<Foo>);
// Fooはintから非同期構築可能
static_assert(async_object_constructible_from<Foo, int>);
```

2つの`Foo`型の非同期オブジェクトを作成し、`sender`式で状態を変更する

```cpp
int main() {
  // 2つの非同期オブジェクトを使用するsender
  auto inner = [](Foo::handle o0, Foo::handle o1) noexcept {
    return then( just(o0, o1),
      [](Foo::handle o0, Foo::handle o1) noexcept {
        auto& ro0 = o0.get();
        auto& ro1 = o1.get();
        ro0.v = ro0.v + ro0.v;
        ro1.v = ro1.v + ro1.v;
        printf("foo pack usage, %d, %d\n", ro0.v, ro1.v);
        fflush(stdout);
        return ro0.v + ro1.v;
      }
    );
  };

  // 非同期オブジェクトとコンストラクタ引数をパッケージング
  packaged_async_object foo7{Foo{}, 7};
  packaged_async_object foo12{Foo{}, 12};

  // ストレージを予約し、2つの非同期オブジェクトを非同期構築し
  // それらが完了してからinnerの処理にそれらのハンドルを渡し
  // innerの処理が完了したら非同期オブジェクトを非同期破棄する
  // そして、それら全てが完了すると完了する非同期処理を表すsender
  auto use_s = async_using(inner, foo7, foo12);
  
  // 非同期処理開始と待機、結果取得
  auto [v] = sync_wait(use_s).value();
  printf("foo pack result %d\n\n", v);
}
```

この提案の内容は純粋なライブラリ機能であり、仮実装が公開されています : https://godbolt.org/z/rrbW6veYd

- [P2849 進行状況](https://github.com/cplusplus/papers/issues/1899)

### [P2876R1 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2876r1.html)
### [P2900R7 Contracts for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2900r7.pdf)
### [P2963R2 Ordering of constraints involving fold expressions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2963r2.pdf)
### [P2964R1 Allowing user-defined types in std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2964r1.html)
### [P2967R1 Relocation Is A Library Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2967r1.pdf)
### [P2971R2 Implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2971r2.pdf)
### [P2976R1 Freestanding Library: algorithm, numeric, and random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2976r1.html)
### [P2988R5 std::optional<T&>](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2988r5.pdf)
### [P2996R3 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r3.html)
### [P3045R1 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3045r1.html)
### [P3051R1 Structured Response Files](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3051r1.html)
### [P3059R1 Making user-defined constructors of view iterators/sentinels private](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3059r1.html)
### [P3064R1 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3064r1.pdf)
### [P3067R0 Provide predefined simd permute generator functions for common operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3067r0.html)

P2664で提案されている、`std::simd`の汎用permute APIを設計し直す提案。

SIMDにおけるpermute命令とは、SIMDレジスタ内で要素を並び替える命令の1つです。ある計算の際に効率的なデータの並びとその後の別の計算の際に効率的なデータの並びが異なる場合など、SIMDレジスタ内にデータを載せたまま並べ替えが必要になることはよくあり、その際にpermute命令を使用できます。

P2664では`std::simd`に対してpermute命令に対応する並べ替えを行うための`std::permute()`を提案していましたが、P2664の`std::permute()`APIはほとんどのユーザーの最も一般的な要求をサポートするように汎用的に設計されていたため、必要なことは何でもできるもののよく使用される特定の並べ替えパターンをシンプルに記述することができず、ユーザーが個別にその操作を行う関数を定義する必要性が頻発することが想定されたようです。

この提案ではそのような並べ替え操作の目的やパターンをまとめて、この浮かび上がった要求を元にして`std::simd`の要素並べ替えを行うフリー関数のセットを特定し提案するものです。

今のところ挙げられているものは次のものです

|関数|説明|
|---|---|
|`take<int>(simd)`|`simd`の先頭から`N`要素を含む新しい`simd`オブジェクトを返す|
|`grow<int>(simd, value={})`|入力された`simd`よりも大きいサイズで、指定された`value`で初期化された新しい要素を含んだ`simd`を返す|
|`stride<int N>(simd)`|入力された`simd`の`N`番目の要素のみを含む新しい`simd`を返す|
|`chunk<int>(simd)`|既存の`simd::split`を名前変更および移動したもの|
|`reverse(simd)`|入力された`simd`と同じサイズで、要素を逆順にした新しい`simd`を返す|
|`repeat_all<int>(simd)`|入力された`simd`を`N`回繰り返した新しい`simd`を返す（例： `repeat_all<3>([a, b])`は`[a, b, a, b, a, b]`になる）|
|`repeat_each<int>(simd)`|入力された`simd`の各要素を`N`回繰り返した新しい`simd`を返する（例： `repeat_each<3>([a, b])`は`[a, a, a, b, b, b ]`になる）|
|`transpose<ROWS, COLS>(simd)`|入力された`simd`を、`ROWS`行と`COLS`列の行優先の行列として扱い、転置した結果（つまり列優先にした）を返す|
|`zip(simd...)`|入力された複数の`simd`の対応する要素を交互に並べて新しい`simd`を生成する。（例： `zip([a, b, c], [0, 1, 2])`は`[a, 0, b, 1, c, 2]`を返す|
|`unzip<N>(simd...)`|入力された`simd`を`N`個の`simd`に分割する。（例： `unzip<2>([a, 0, b, 1, c, 2])`は`make_tuple([a, b, c], [0, 1, 2])`を返す|
|`cat(simd...)`|`simd_cat`の名前変更版|
|`extract<N, M>(simd)`|`[N...M)`の範囲内の要素を含む新しい`simd`を抽出する|
|`rotate<MIDDLE>(simd)`|`simd`の要素を左に回転し、`MIDDLE` インデックスの要素が最初の要素になるようにする|
|`shift_left<N>(simd)/shift_right<N>(simd)`|入力された`simd`と同じサイズで、要素を左または右にシフトし、値初期化された要素を挿入した新しい`simd`を返す|
|`align<N>(simd a, simd b)`|2つの`simd`オブジェクトを受け取り、`cat(a, b)`から`simd`を抽出します|

これらの良く使用する並べ替え操作（順列のジェネレーター関数）をあらかじめ用意しておくことで

- 同じジェネレーター関数を繰り返し何度も重複定義することになるのを回避する
- よく使用する操作について、分かりやすい名前付き関数を提供することで、コードの可読性を向上させる
- よく使用する操作について、あらかじめ用意しておくことでバグの混入を回避する

等の利点があるとしています。

- [P2664R6 Proposal to extend std::simd with permutation API - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2664R6-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2638R0 Intel's response to P1915R0 for std::simd parallelism in TS 2 - WG21月次提案文書を眺める（2022年09月）](https://onihusube.hatenablog.com/entry/2022/10/09/021557#P2638R0-Intels-response-to-P1915R0-for-stdsimd-parallelism-in-TS-2)
- [P3067 進行状況](https://github.com/cplusplus/papers/issues/1900)

### [P3068R2 Allowing exception throwing in constant-evaluation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r2.html)
### [P3085R2 `noexcept` policy for SD-9 (throws nothing)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3085r2.html)
### [P3091R2 Better lookups for `map` and `unordered_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3091r2.html)
### [P3094R2 std::basic_fixed_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3094r2.html)
### [P3096R1 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3096r1.pdf)
### [P3100R0 Undefined and erroneous behaviour are contract violations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3100r0.pdf)

UB（及びEB）を契約違反として扱うようにする提案。

C++言語を安全ではなくしている要因は実行時の未定義動作にあります。正しくコンパイルされたWell-definedなC++プログラムでも、実行時に任意の未定義動作に陥る可能性があり、未定義動作を回避できない場合それはプログラムのバグとして安全性/セキュリティ上の問題を引き起こします。特に、無効なメモリアクセスによる未定義動作は特に大きな問題で、GoogleやMicrosoftの調査によればセキュリティの脆弱性の7割が無効なメモリアクセスによる未定義動作によって発生しているとされます。

近年の安全性・セキュリティの重要性の高まりを受けて、C++プログラムが未定義動作を起こす可能性を減らすための様々な取り組みがなされています。例えば

- コードレビュー
- コーディングガイドラインの適用
- コードの様々場側面を対象にした自動テスト
- 静的解析ツールの使用
- 実行時のサニタイザーの使用

など、これらの手法を正しく適用することで、実行時に発生する可能性のある未定義動作を減らすことができます。

これらのアプローチとは異なり、C++標準化委員会はC++プログラムの未定義動作リスクを低減するために、言語そのものを進化させることができる唯一の立場にあります。C++における未定義動作は基本的に実行時の性質であることから主に2つのアプローチが可能です。

1. 未定義動作に陥るコードパスを静的に検出できる場合、そのプログラムをill-formedにできる
2. 未定義動作に陥るコードパスに実行時に到達した場合に取り得る動作の範囲を指定し、実行時にその動作を緩和する

この2つのアプローチは排他的なものではなく、相互に補完し合うことができます。

一方、現在C++26を目指して契約プログラミング機能の提案（P2900）が進行しています。契約プログラミング機能はC++言語の安全性を高める機能ではあるものの、万能薬ではなく、契約プログラミング機能はすべての未定義動作をコンパイル時に静的に検出可能にするようなものではありません。しかし、コンパイル時に検出されなかったすべての未定義動作に対して実行時にそれをハンドリングして処理するための包括的なフレームワークを、契約プログラミング機能は提供します。

この提案は、契約プログラミング機能を拡張して、未定義動作を契約違反としてハンドリングできるようにしようとするものです。

この提案のアプローチは、明示的な契約アサーションだけに契約セマンティクスを指定するのではなく、実行時に未定義動作に陥る可能性のあるコア言語構成要素に対して暗黙的に契約を指定することで、未定義動作に陥る場合を契約違反として扱えるようにし、それによって契約プログラミング機能のフレームワークの中で未定義動作をハンドリングできるようにすることを目指すものです。

例えば符号付整数の加算を考えてみます。2つの`int`型の値`a, b`を加算する場合、結果が`int`の最大値を超える（オーバーフローする）場合は現在未定義動作とされていますが、これを再解釈して、符号付整数型の加算には加算結果がオーバーフローしないという暗黙の事前条件ある、とすることができます。

符号付整数型の加算が組み込みの`operator+(int, int)`を呼び出して行われると考えると、その組み込み演算子は次のように宣言されているかのように扱われます

```cpp
int operator+(int a, int b)
  pre ((b >= 0 && a <= INT_MAX - b) // 暗黙の事前条件アサーション
   || (b < 0 && a >= INT_MIN - b));
```

この事前条件アサーションを「暗黙的」としているのは、通常の契約注釈がユーザーの手によって明示的に付加されるのに対して、この事前条件アサーションはコンパイラが暗黙的に生成して付加するものだからです。

この符号付整数型の加算オーバーフローと同様に、「操作Xについて、Yが偽（`false`）の場合、動作は未定義」というようなC++標準における未定義動作の出現を、「操作Xは、Yが真（`true`）であるという事前条件を持つ」というように置き換えることができて、明示的な（通常の）契約注釈同様にこの暗黙の契約注釈もまとめて契約プログラミング機能の上で扱うことができるようになります。

こうして実行時にハンドルされうる未定義動作には2つの種類があり、それは、安全なフォールバック動作を定義できるものとできないものです。例えば、符号付整数型の加算のオーバーフローの安全なフォールバック動作はその結果の値が有効な数値になることです。その具体的な数値の性質（飽和演算、ラップアラウンドなど）を指定する代わりに、規格のレベルで未定義動作を解除するには、有効だが未規定な値になると規定するだけで十分です。この数値を計算で使用するとおそらく間違い（バグ）ではあるものの未定義ではなくなります。整数の加算を上記のように組み込み演算子とみなすと、この安全なフォールバック動作はその本体が実行する動作そのものです。

別の例として、未初期化変数を読み取る場合、未定義動作の代わりの安全なフォールバック動作として代わりに未規定だが有効な値（例えばゼロ）を読み取る、とすることで未定義動作を安全に解除することができます。この話をどこかで聞いたことがある人もいるかもしれません、これはP2795R5によって提案されC++26に既に導入されている、Erroneous Behaviour（EB）そのものです。

EBはUB時の動作として安全なフォールバック動作を実装定義で指定し、同時に診断を推奨することでUBを解消しようとする取り組みです。P2795R5で誤ったコードの結果として動作Xを取る、としているところは、この提案において、暗黙の事前条件アサーションが破られた場合の安全なフォールバック動作がXである、というのと全く同じことです。暗黙の契約アサーションがチェックされたかどうかとは関係なく、どちらの場合も誤った状態にあるプログラムの動作について述べており、なおかつその動作は未定義ではなくWell-definedとなります。

このように、P2795R5の「Erroneous Behaviour」とこの提案の「暗黙の契約アサーション違反」という2つの言葉には互換性があります。

そして、P2795R5によればErroneous Behaviourが発生した場合、実装は次のいずれかを行うことが許可されます

- 問題の報告
- プログラムの終了
- 何もしない
    - ただしUBではない

EB時の可能な動作のこのリストは、契約違反が起きた場合の4（+1）つの契約注釈のセマンティクスのサブセットです（quick_enforce, enforce, observe, ignore, assume）。

- 診断を発行 -> observe
- プログラム終了 -> quick_enforce/enforce
- 何もしない -> ignore
    - 安全なフォールバック動作を実行する

逆に、EBのフレームワークにはこのような欠陥のハンドリングに役立つ機能が欠けています。契約プログラミング機能では、契約違反時に違反ハンドラが呼びされ、なおかつこの違反ハンドラはユーザーがカスタマイズできます。EBでは安全なフォールバック動作のない未定義動作を処理できませんが、契約の場合は可能です。

そして、この提案ではC++23以前（契約もEBもない時代）との完全な下位互換を保つオプションとして、契約注釈のセマンティクスにassumeセマンティクスを追加することを提案しています。これは`[[assume]]`属性同様に契約注釈をコードの仮定として利用することが許可されており、なおかつ契約条件はチェックされず違反ハンドラは呼び出されません。契約違反が起こると未定義動作になります。

assumeセマンティクスは従来（現在）のC++と同じ挙動であり、パフォーマンスをとにかく重視する場合に選択できるものです。これは契約プログラミング機能のオーバーヘッドを取り除き、動作とパフォーマンスの両面で現在のC++23以前の動作との後方互換性を保つためのものです。EBの場合、過去の動作に戻すためにEB個別にオプトアウトメカニズム（例えば`[[indeterminate]]`）が必要となり、規格の複雑さの面でもユーザー負担の面でもスケールしません。

その概念に互換性があり、動作状態を包含しており、C++23以前との後方互換性の一括確保も備えていることから、この提案はErroneous Behaviourを完全に包含しているといえます。そのためこの提案では、EBもまたUB同様に暗黙の契約アサーションをもつものとして扱うことを提案しています。

2種類の未定義動作のもう一つ、安全なフォールバック動作を定義できないタイプの未定義動作に対して暗黙的に付加された契約の事をこの提案では、無視できない契約アサーション（Non-ignorable implicit contract assertions）と呼んでいます。

例えば、配列の添え字アクセスを先程と同様に組み込み演算子としてみてみると次のようになります

```cpp
template <typename T, size_t N>
T& subscript(T(&array)[N], size_t index)
  pre(index < N) // 暗黙の事前条件アサーション
{
  return array[index];
}
```

この場合、この暗黙の契約アサーションが破られたときにその本体の動作を安全なフォールバック動作として扱うことはできません。メモリの安全性や型の安全性に違反する操作はこのカテゴリに分類されます。

無視できない契約アサーションに対する契約注釈のセマンティクスは制限され、ignore/observeセマンティクスで評価することができません。指定可能なセマンティクスはquick_enforce/enforce/assumeのみです。これらの評価セマンティクスは例えば、次のような実装戦略にマッピングできます

- quick_enforce : 範囲外アクセスを実行時にトラップするclangの-fbounds-safety
- enforce : アドレスサニタイザーによる実行時の検出と診断発行、およびプログラム中断
- assume : C++23以前（現在）の安全ではないデフォルトの動作

安全なフォールバック動作を持たないC++の未定義動作に対しても、同様に無視できない契約アサーションを持つものとして再解釈することで、同様のマッピングが存在します。

ここでは、契約セマンティクスのマッピングの1つとしてサニタイザーのような外部ツールがあげられています。C++プログラムのためのサニタイザーはいくつかの実装がすでに提供されていますが、いずれの実装もユーザーコードと対話するためのAPI（コールバック）が非常に貧弱であり、その統一的な指針のようなものも存在していません。

この提案では、サニタイザーも含めた外部ツールのユーザーコードとの対話APIとして、契約プログラミング機能の違反ハンドラを使用するようにするアイデアを挙げています。現時点の契約違反ハンドラは現在のサニタイザーが備えるコールバックAPIよりも充実（ユーザーが置換可能、引数で詳細な情報を取得可能）しており、この包括的なAPIによってサニタイザーをC++標準の範囲内に配置することができます。

また、このAPIのサポートは既存のサニタイザーに対して変更を強いるものではありません（そうするかは完全にオプションです）。現在の契約プログラミング機能の仕様では、デフォルトの契約違反ハンドラの動作は実装定義であり、ユーザーが違反ハンドラをカスタムすることを許可しなくても良いとされているため、既存のサニタイザーはすでにそのようなAPIに準拠していると言えます。

- [P3100 進行状況](https://github.com/cplusplus/papers/issues/1901)

### [P3103R2 More bitset operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3103r2.html)
### [P3111R0 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3111r0.html)

`std::atomic`にアトミックリダクション操作を追加する提案。

アトミックリダクション操作とは、アトミックなRMW操作（`fetch_add()`のような操作）ではありますが古い値を実際にはフェッチせず、メモリモデルの観点からも読み取りを粉わないようなRMW操作の事です。

そのような、フェッチされた古い値を破棄するようなアトミックRMW操作を実行する並行アルゴリズムは高性能コンピューティングでは一般的であり、現代のハードウェアはそのような操作に対して効率的な命令を備えています。

例えば次のコードは並列にヒストグラムを求めるものです

```cpp
std::span<unsigned> data;

std::array<std::atomic<unsigned>, N> buckets;

constexpr T bucket_sz = std::numeric_limits<T>::max() / (T)N;

unsigned nthreads = std::thread::hardware_concurrency();

std::for_each_n(std::execution::par_unseq, std::views::iota(0).begin(), nthreads, 
 [&](int thread) {
  unsigned data_per_thread = data.size() / nthreads;
  T* data_thread = data.data() + data_per_thread * thread;

  for (auto e : span<T>(data_thread, data_per_thread)) {
    // ここでアトミック値に対して足しこみ（fetch_add()）が行われている
    buckets[e / bucket_sz].fetch_add(1, std::memory_order_relaxed);
  }
});
```

このコードには次の2つの問題点があります

- 正しさ（UB）
  - アトミック操作が次のいずれも満たしていないため、この並列版`for_each_n`では`execution::par`を使用するべきだった（`par_unseq`を使用しているためにUB）
    - 潜在的に同時実行され、シーケンス化されていないコンテキストでデータ競合が発生する
    - 他の関数呼び出しと同期するため、ベクトル化セーフ
- パフォーマンス
  - このプログラムでアトミックリダクション操作を使用するようにするためには、高度なコンパイラの分析が必要

`std::atomic`でアトミックリダクション操作をサポートすることでこの2つの問題を解決でき、この提案はそれを提案するものです。

この提案では、既存の`std::atomic`および`std::atomic_ref`のメンバ関数である`.fetch_xxx()`に対して`void`戻り値型の`xxx()`メンバ関数を追加することを提案しています。

提案文書より、サンプルコード

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
#include <algorithm>
#include <atomic>
#include <execution>
using namespace std;
using execution::par_unseq;

int main() {
  size_t N = 10000;
  vector<int> v(N, 0);
  atomic<int> atom = 0;
  for_each_n(par_unseq, 
     v.begin(), N,
    [&](auto& e) {
      // UB+SLOW:
      atom.fetch_add(e);
  }); 
  return atom.load();
}
```

</td>
<td valign="top">

```cpp
#include <algorithm>
#include <atomic>
#include <execution>
using namespace std;
using execution::par_unseq;

int main() {
  size_t N = 10000;
  vector<int> v(N, 0);
  atomic<int> atom = 0;
  for_each_n(par_unseq, 
     v.begin(), N,
    [&](auto& e) {
      // OK+FAST
      atom.add(e);  // 👈
  }); 
  return atom.load();
}
```

</td>
</tr>
</table>

また、この延長として、順序付けされていないときの（並列実行時の）読み取りでないアトミックメモリ操作を許可し、浮動小数点演算が結合的であると仮定して浮動小数点数型の算術リダクション操作を拡張することも追加で提案しています。

浮動小数点数の演算のように非結合的な演算では、並列に実行される演算の順序が結果に影響を与える可能性があるため、アトミックリダクション操作の効果が制限されます。例えば、`x = a + (b + c)`という計算を並列に実行する場合、アトミックリダクション操作では`(a + b) + c`や`a + (c + b)`などの異なる順序で計算される可能性があり、浮動小数点演算が結合的ではないことから結果が一致しない可能性があります。この提案の一般化アトミックリダクション操作では、浮動小数点数型のアトミックリダクション操作において浮動小数点演算が結合的であると仮定して実行することを許可することで、実装はこの制限を受けずに最適化が可能になります。

この提案では、一般化アトミックリダクション操作は浮動小数点数型の特殊化のみのメンバ関数として、上記のアトミックリダクション操作とは別名のメンバ関数として追加することを提案しています

```cpp
template <floating-point>
class atomic {
  ...

  // アトミックリダクション操作
  void add(floating-point, memory_order);
  // 一般化アトミックリダクション操作
  void add_generalizedg(floating-point, memory_order);

  ...
};
```

- [P3111 進行状況](https://github.com/cplusplus/papers/issues/1902)

### [P3119R1 Tokyo Technical Fixes to Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3119r1.pdf)
### [P3125R0 Pointer tagging](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3125r0.pdf)

タグ付きポインタをサポートするためのライブラリ機能の提案。

タグ付きポインタとは、ポインタのビットのうち使用されていない部分に情報を埋め込むこんで利用しようとするものです。主に、メモリ安全性の向上のために使用されていますが、これを利用した特殊なデータ構造もあるようです。

現代のC++の環境の多くはポインタのサイズは64bitですが、現状のメモリ容量の場合そのメモリ空間をすべて表現するのに64bitもの長さは必要ありません。アーキテクチャによるようですが、48bit目くらいまでしか使われていないようです。すると、余った上位16bitを無視するようにしてもらえば、その部分を何かしら利用することができます。x64/arm共にこのためのCPU拡張を備えています。

さらに、アドレスがNバイトにアラインされている時そのアドレスはNの倍数になるため、その分の下位数ビット（`log2(N)`ビット）も同様に利用できます。例えば、`int`型が4バイトの場合`int`型変数のアドレスは通常4の倍数の値になるため、下位2ビットはポインタ値に参加していません。

しかし、C++の規格としては有効なポインタの一部のビットを操作することは未定義動作であり、タグ付きポインタは許可されていません。この提案は、特殊なライブラリ関数を通してのみそのような操作を認めるようにしようとするものです。

提案しているのはまず、ポインタからタグ部分を取り出すビットマスクを返す関数です。

```cpp
namespace std {
  template <typename Pointee, size_t Alignment = alignof(Pointee)>
  constexpr auto tag_bit_mask() noexcept -> uintptr_t;
}
```

この`tag_bit_mask()`はポインタ型`Pointee`とアライメント`Alignment`に対して、そのポインタ型のポインタ値のうちタグとして使用可能な部分のビットが1になったビットマスクを返します。下位のビットはアーキテクチャによらず共通（アライメントで決まる）ですが、上位ビットがどこまで利用可能かはアーキテクチャおよびサニタイザーの存在によって変化します。

次に、タグ付きポインタを表す型`std::tagged_pointer<T, Alignment>`を用意して、これに対してタグ付け、タグのクリア、タグに保存されている値の取り出しを行う関数を提案しています。

```cpp
namespace std {
  // ポインタにタグ付けを行う
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto tag_pointer(T* original, uintptr_t value) noexcept -> tagged_pointer<T, Alignment>;

  // タグ付きポインタを元のポインタに戻す
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto untag_pointer(tagged_pointer<T, Alignment> ptr) noexcept -> T*;

  // タグ付きポインタからタグの値を取り出す
  template <typename T, size_t Alignment = alignof(T)>
  constexpr auto tag_value(tagged_pointer<T, Alignment> ptr) noexcept -> uintptr_t;
}
```

この提案のタグ付きポインタサポートは特殊なデータ構造（Hash-Array-Mapped-Trie (HAMT)など）の作成を許可することに重きを置いているため、これらの関数は`constexpr`が付加されています。

`std::tagged_pointer<T, alignment>`は`void*`と同じサイズで`void*`に変換できる必要があるという要件は定まっているものの、それを何にするか（`void*`、`T*`、クラス型など）はまだ決まっていないようです。

- [Memory Tagging Extension: Enhancing memory safety through architecture](https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/enhancing-memory-safety)
- [64bit環境におけるObjective-Cのポインタ | GREE Engineering](https://labs.gree.jp/blog/2015/01/13437/)
- [HWAddressSanitizer  |  Android Open Source Project](https://source.android.com/docs/security/test/hwasan?hl=ja)
- [57-bits の仮想メモリアドレス空間と新機能 UAI が実装される将来の AMD プロセッサ | Coelacanth's Dream](https://www.coelacanth-dream.com/posts/2022/03/12/amd-57bit-addr-uai/)
- [P3125 進行状況](https://github.com/cplusplus/papers/issues/1903)

### [P3126R1 Graph Library: Overview](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3126r1.pdf)
### [P3130R1 Graph Library: Graph Container Interface](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3130r1.pdf)
### [P3131R1 Graph Library: Containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3131r1.pdf)
### [P3137R1 views::to_input](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3137r1.html)
### [P3138R1 views::cache_last](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r1.html)
### [P3139R0 Pointer cast for unique_ptr](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3139r0.html)

`std::const_pointer_cast`と`std::dynamic_pointer_cast`に`std::unique_ptr`のオーバーロードを追加する提案。

`std::uniqur_ptr`に対してポインタのキャスト操作を行うことはそのままではできず、現在のベストプラクティスは、一旦`.release()`してポインタを取り出した後、そのポインタに対してポインタキャストを適用してから、結果のポインタを再び`unique_ptr`でラップする、という手順です。

しかし、この手順は一旦リソースの所有権を手放す必要があるなど、リソース安全な方法とはいえません。

```cpp
auto GetClient() -> std::unique_ptr<const Client>;

// constを外したい
voif example() {
  std::unique_ptr<Client> client;
  // 生ポインタが露出する
  client.reset(const_cast<Client*>(GetClient().release()));

  ..
}

// dynamic_castを適用したい
void UseV2Client(std::unique_ptr<Client>&& client) {
  std::unique_ptr<ClientV2> v2;
  ...
  // dynamic_castが失敗するとリソースリークする
  v2.reset(dynamic_cast<ClientV2*>(client.release()));

  ...
}
```

一方で、`std::shared_ptr`にはそのキャストのためのフリー関数である`std::const_pointer_cast`と`std::dynamic_pointer_cast`が用意されており、これを用いるとこのような危険性を回避することができます。また、Boostには`unique_ptr`に対する`std::const_pointer_cast`と`std::dynamic_pointer_cast`オーバーロードが用意されています。

`std::uniqur_ptr`のポインタキャストという操作をより安全にするために、`std::uniqur_ptr`でも`std::const_pointer_cast`と`std::dynamic_pointer_cast`を使用できるようにする提案です。

方法としては単純に、`std::const_pointer_cast`と`std::dynamic_pointer_cast`に`std::uniqur_ptr`を受け取るオーバーロードを追加することでこれを行おうとしていますが、`std::unique_ptr`特有の事情により少し設計が異なる部分があります。

1つは提案するオーバーロードは`std::uniqur_ptr`の右辺値に対してのみ作用することで、もう1つはカスタムデリータの考慮です。`std::shared_ptr`の場合はカスタムデリータは型消去されて保持されており、キャストの前後でも一貫して元のポインタに対して作用するようにすることで、デリータを考慮する必要はありません。しかし、`std::unique_ptr`の場合はデリータは型の一部であり、キャストにあたってデリータを考慮する必要があります。

`std::unique_ptr<T, D>`を`std::unique_ptr<U>`にキャストする場合、`D`がキャスト後のポインタを削除できるかどうかを考える必要があります。これは単純にデフォルトのデリータを使用している場合にのみその仮定が成り立ちます。一方、`std::unique_ptr<T, D>`は`D`を通してポインタ型をカスタマイズすることができ、保持するものは実際にはポインタではない場合もあります。この場合、ユーザーが指定した`D`はキャスト後のリソースを正しく開放できる場合もあります（これはユーザーが知っています）。

そのため、この提案ではこの2つのユースケースをサポートします。すなわち、キャストは次の2パターンが可能です

1. `std::unique_ptr<T>` -> `std::unique_ptr<U>`の変換
2. `std::unique_ptr<T, D>` -> `std::unique_ptr<U, D>`の変換

提案されている関数

```cpp
namespace std {
  // dynamic_cast
  template<class T, class U>
  constexpr unique_ptr<T> dynamic_pointer_cast(unique_ptr<U>&& r) noexcept;

  template<class T, class D, class U>
  constexpr unique_ptr<T, D> dynamic_pointer_cast(unique_ptr<U, D>&& r) noexcept;

  // const_cast
  template<class T, class U>
  constexpr unique_ptr<T> const_pointer_cast(unique_ptr<U>&& r) noexcept;

  template<class T, class D, class U>
  constexpr unique_ptr<T, D> const_pointer_cast(unique_ptr<U, D>&& r) noexcept;
}
```

この提案のキャスト設計においては、安全であることを重視しています。そのため、この2種類以外のポインタキャスト（`static_cast`と`reinterpret_cast`）に対応する関数は専門知識が必要であり気軽に使用できるものではないとして提案していません。

また、キャストに当たっては静的にその危険性を検出できるものについてはチェックして弾くようにしています。次の表は、この提案のAPIに追加されているガードレールを表したものです

|API|1の変換|2の変換|
|:--|---|---|
|`const_pointer_cast`|`T* -> U*`への`const_cast`が有効であること|変換元の`::pointer`から変換先の`::pointer`への`const_cast`が有効であり、`T, U`はどちらも配列型であるかどちらも異なっている|
|`dynamic_pointer_cast`|`T* -> U*`への`dynamic_cast`が有効であり、`U`は仮想デストラクタを持つ|変換元の`::pointer`から変換先の`::pointer`への`dynamic_cast`が有効であり、`T, U`はどちらも配列型ではない|

表の右列の「変換元の`::pointer`」とは`std::unique_ptr<T, D>::pointer`のことで、「変換先の`::pointer`」とは`std::unique_ptr<U, D>::pointer`のことです。

- [`std::const_pointer_cast` - cpprefjp](https://cpprefjp.github.io/reference/memory/shared_ptr/const_pointer_cast.html)
- [`std::dynamic_pointer_cast` - cpprefjp](https://cpprefjp.github.io/reference/memory/shared_ptr/dynamic_pointer_cast.html)
- [P3139 進行状況](https://github.com/cplusplus/papers/issues/1904)

### [P3149R3 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3149r3.html)
### [P3154R1 Deprecating signed character types in iostreams](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3154r1.html)
### [P3157R1 Generative Extensions for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3157r1.html)
### [P3175R1 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r1.html)
### [P3175R2 Reconsidering the `std::execution::on` algorithm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3175r2.html)
### [P3179R1 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3179r1.html)
### [P3183R1 Contract testing support](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3183r1.pdf)
### [P3210R1 A Postcondition *is* a Pattern Match](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r1.pdf)
### [P3214R0 2024-04 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3214r0.html)

2024年4月に行われた、LEWGにおける投票の結果

次の9つの提案が投票にかけられ、リジェクトされたものはありません

- [P2985R0 A type trait for detecting virtual base classes](https://wg21.link/P2985R0)
- [P2019R5 Thread Attributes](https://wg21.link/P2019R5)
- [P2855R1 Member customization points for Senders and Receivers](https://wg21.link/P2855R1)
- [P3168R1 Give std::optional range support](https://wg21.link/P3168R1)
- [P2075R5 Philox as an extension of the C++ RNG engines](https://wg21.link/P2075R5)
- [P2927R2 Observing exceptions stored in exception_ptr](https://wg21.link/P2927R2)
- [P2997R1 Removing the common reference requirement from the indirectly invocable concepts](https://wg21.link/P2997R1)
- [P2389R1 dextents Index Type Parameter](https://wg21.link/P2389R1)
- [P3201R1 LEWG nodiscard policy](https://wg21.link/P3201R1)

P3201R1とP3201R1以外は、C++26に向けてLWGに転送するための投票です。

また、投票に当たって寄せられたコメントが記載されています。

### [P3228R1 Contracts for C++: Revisiting contract check elision and duplication](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3228r1.pdf)
### [P3234R1 Utility to check if a pointer is in a given range](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3234r1.html)
### [P3235R0 `std::print` more types faster with less memory](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3235r0.html)

`std::print`の効率的な実装をより拡大して適用する提案。

P3107では`std::print`に対して、`std::format()`を使用して一旦`std::string`を得てから出力するのではなく、基底のストリームバッファをロックして直接書き込むようにすることで`std::print`の出力動作を効率化しました。ただし、これはフォーマッタ内でロックを取得するようにしている場合にその型の値に対して`std::print`を同じロックの下で呼び出す場合にデッドロックを引き起こす可能性があったため、`std::enable_nonlocking_formatter_optimization`変数テンプレートの特殊化を`true`で定義する場合にのみ有効になるようにされています。

```cpp
// フォーマットしたい型
struct foo {};

// fooのためのformatter特殊化
template <>
struct std::formatter<foo> {
  ...
};

// P3107の効率的な実装を有効化する
template <>
constexpr bool std::enable_nonlocking_formatter_optimization<foo> = true;
```

P3107では、このオプトインを基本型（`int`等組み込みの型）と文字列型（`std::string/std::string_view`）に対してのみ用意しており、他の標準型のフォーマッタに対しては有効化していませんでした。

この提案は、これら以外のフォーマッタ提供済みの標準型に対してもこのオプトインを有効化しようとするものです。

追加を提案しているものは次のものです

- `<chrono>`関連型
    - ただし、`std::zoned_time`はデフォルトの`TimeZonePtr`に対してのみ提供
- `std::thread::id`
- `<stack_trace>`関連
- `std::filesystem::path`
- `std::pair/std::tuple`
    - 要素型のすべてがオプトイン済みである場合に有効化
- `range`関連
    - `std::vector<bool>`とコンテナアダプタを含む
    - 要素型によらずに有効化
        - 反復処理の場合はデッドロック発生の可能性が低いと考えられるため

また追加の提案として、現在の`std::vprint_(non)unicode`を`std::vprint_(non)unicode_buffered`に、`std::vprint_(non)unicode_locking`を`std::vprint_(non)unicode`に変更することも提案しています。これは、非ロックオーバーロード（現在の`std::vprint_(non)unicode`）が最終的な書き込み時に`std::vprint_(non)unicode_locking`を呼び出すため、命名が誤解を招くということで修正を提案するものです。修正後の名前は、この2つの関数の違いが出力をバッファリング（全体を文字列化してから出力を行う）して行うかどうかという点が明確になります。

この提案C++23へのDRとして、2024年6月の全体会議で採択されています。

- [P3107R0 Permit an efficient implementation of `std::print`](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3107R0-Permit-an-efficient-implementation-of-stdprint)
- [P3107R5 Permit an efficient implementation of `std::print`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3107r5.html)
- [P3235 進行状況](https://github.com/cplusplus/papers/issues/1906)

### [P3236R1 Please reject P2786 and adopt P1144](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3236r1.html)
### [P3238R0 An alternate proposal for naming contract semantics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3238r0.html)

違反ハンドラを呼び出さずに終了する契約セマンティクス（quick_enforce）を、Erroneous Behaviorとして扱うようにする提案。

ここで提案されているのは次の2つの事です

1. 契約違反時に違反ハンドラを呼び出さず即時終了するセマンティクス（quick_enforce）を持つ契約注釈の契約違反時の動作は、Erroneous Behaviorであると指定する
    - その安全なフォールバック動作として、違反ハンドラを呼び出す
2. 契約セマンティクスの名前を変更する
    - ignore -> ignored
    - enforce -> enforced
    - observe -> observed
    - quick_enforce -> erroneous

契約違反時に即時終了するセマンティクスにおいては契約違反は致命的な失敗であり、他の方法でこの動作をフックすることはできません。これをEBとして指定することで、そのまま即時終了することと、安全なフォールバック動作として違反ハンドラを呼び出して簡単な診断を発行して終了することの両方を実装に対して許可することができます。

次にこのことを踏まえたうえでquick_enforceに対する適切な名前を考えます。他の3つの契約セマンティクスの名前は概ね「～ the trueness of a predicate」（「述語の真偽を～する」）の～の部分に当てはまるようになっていますが、quick_enforceはそうではありません。この提案ではそこに当てはまるような名前を考えるのではなく、意味上のerroneousという単語を他の名前になっている動詞の過去形と同じ文法的位置に置くようにしています。すなわち、「A contract violation is treated as ～」（契約違反は、～として扱われる）の～に入るように他の3つの名前を変更し、動詞の過去形にすることを提案しています。

この提案の内容はSG21のレビューにおいて好まれませんでした。

- [P3238 進行状況](https://github.com/cplusplus/papers/issues/1906)

### [P3239R0 A Relocating Swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3239r0.pdf)

リロケーションを用いた`swap`を行う、`swap_representations`の提案。

`swap`のセマンティクスは2つのオブジェクトのオブジェクト表現を交換することです。その操作は実際には、ムーブコンストラクタとムーブ代入演算子（とデストラクタ）によって実行されます。

オブジェクト表現の交換という部分に注目すると`swap`の行うことはリロケーションが行うこととよく似ていることに気づきます。特に、トリビアルリロケーション可能な型なら`swap`は単純な`memcpy`によって実行できます。これによって、`swap`のパフォーマンスを向上させることができます。

しかし、トリビアルなリロケーションのような操作によって2つのオブジェクトの表現を入れ替えることは、C++の非トリビアルな型のオブジェクトについての生存期間ののルールに抵触し、トリビアルリロケーション導入後においても許可されません。

この提案は、リロケーションによる`swap`を行う専用の関数をライブラリに追加し、それを通してのみリロケーションによる`swap`を合法化することを提案するものです。

提案されているのは、`std::swap_representations()`という関数です。同じ型の2つのオブジェクトへの参照を受け取って、それらのオブジェクトの値表現を交換しますが、どちらのオブジェクトの生存期間も終了しません。リロケーション操作を用いるとソースオブジェクトは消えてしまうため通常それは不可能です。そのため、この関数は一種の魔法のように動作する特別な関数です。ただし、安全のため、入力の型`T`はトリビアルリロケーション可能（`is_trivially_relocatable_v<T>`が`true`）でなければなりません。

```cpp
namespace std {
  // 提案するswap_representationsの宣言
  template <bool force, class T>
  void swap_representations(T& a, T& b); 
}
```

テンプレートパラメータの`force`は`T`がポリモルフィックな型の場合にのみ意味を持ちます。ここでの引数は参照であるため、`T`を基底クラスとした派生クラスオブジェクトへの参照が入力される可能性があります。もし、`a`と`b`が同じ基底クラス`T`から派生する別の派生クラスの参照である場合、これは未定義動作になります（`a`と`b`の仮想関数テーブルが異なっているため）。

この関数内からは参照で渡されたものしか見えないためそれを静的に検出できませんが、`swap_representations`利用者が予めこの危険性がない参照を渡すことを知っている場合（例えば、`std::vector`内部で要素型が`T`そのものであることが分かっている場合など）に、`force`パラメータを`true`にして呼び出すことでポリモルフィックな型の値表現を交換できます。逆に、`is_polymorphic_v<T>`が`true`の場合に`force`が`false`と指定されていると、コンパイルエラーになります。

また、`std::swap`がプログラムの観測可能な動作を変更することなくこれを用いて実装可能であることを示す型特性`std::swap_uses_value_representations_v`を用意することも提案しています。型`T`のオブジェクトについての`std::swap`は`std::swap_uses_value_representations_v<T>`が`true`となる場合に`swap_representations`を用いて最適化することができます。

この提案の内容はコア言語の変更を伴わないライブラリ拡張のみであり、なおかつ他のライブラリ機能に影響を及ぼさないものです。しかし、トリビアルリロケーションと共に導入されれば、そのパフォーマンス上の恩恵を最大化することができます。

- [P2786R0 Trivial relocatability options - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2786R0-Trivial-relocatability-options)
- [P3239 進行状況](https://github.com/cplusplus/papers/issues/1908)

### [P3247R1 Deprecate the notion of trivial types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r1.html)
### [P3248R0 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3248r0.html)

`(u)intptr_t`を必須にする提案。

`(u)intptr_t`はポインタ値を整数として保持したい場合に使用でき、変換前後でポインタ値が変化しないことが保証されている整数型のエイリアスです。しかし、このエイリアスはオプションであり、実装は必ずしも定義する必要はありません。

`(u)intptr_t`が存在しない可能性があるという事実によって、移植性を重視するソフトウェアではこの使用を回避する必要があり、そのために余計な作業と潜在的なバグを埋め込む可能性が発生します。

このことは標準ライブラリでも問題になり、P2835（`std::atomic_ref`にポインタ値を取得可能な関数を追加する）やP3125（ポインタの未使用ビット使用のための関数を追加する）などではポインタ値のやり取りのために`(u)intptr_t`を使用しようとしているものの、それがオプショナルであることが問題となっています。

この提案は、`(u)intptr_t`を必須の型エイリアスにしようとするものです。

オプショナルであるとはいえ実際には主要3コンパイラは全てのターゲット向けにこのエイリアスを提供しており、その標準ライブラリ実装も`(u)intptr_t`の存在を仮定して実装されているようです。また、プラットフォームのABIでも`(u)intptr_t`相当の整数型の存在がポインタ型の指定と共に仄めかされているようです。

従って、`(u)intptr_t`を必須にしたとしてもC++のプラットフォームサポートは低下しない、とこの提案では結論付けています。

提案している規格の変更は、`(u)intptr_t`からoptionalであるという指定を取り除くだけです。

- [`std::intptr_t` - cpprefjp](https://cpprefjp.github.io/reference/cstdint/intptr_t.html)
- [P3248 進行状況](https://github.com/cplusplus/papers/issues/1909)

### [P3249R0 A unified syntax for Pattern Matching and Contracts when introducing a new name](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3249r0.pdf)

パターンマッチングと契約プログラミング機能の間で統一的な構文の提案。

パターンマッチング構文においては、パターンの記述内で（マッチしたものを表す）新しい名前を導入する必要があり、P2688のパターンマッチング提案においては`let x => expr;`の様に記述します。また、契約プログラミング機能の事後条件においては、戻り値を参照する名前を導入する必要があり、`post(r : expr)`の様に記述します。

```cpp
int f();

// パターンマッチングの例
void g() {
  int i = f();

  i match {
    42 let val => print(val); // valを導入（val == 42）
    let x => print(x); // xを導入（x != 42）
  }
}

// 契約プログラミング機能の例
int foo()
  post(ret : ret > 0) // retを導入
```

そのコンテキストで必要な変数名を導入するという側面からはこの2つは同じことをしていると見ることができ、同じことをするのに異なる構文を使用しているのは一貫性が無く初学者が覚えづらく、言語を複雑にします。

この提案は、この2つの名前導入の構文を統一することで、習得のしやすさの向上と言語の複雑さの低減を図るものです。

提案では、これらの構文を一貫して`let name => expr`のように統一することを提案しています。

```cpp
int foo()
  post( let r => r > 0) // rを導入
```

すなわち、契約プログラミング機能の構文をパターンマッチングに合わせるものです。

ただし、事後条件（`post()`）内での`let ~`はパターンマッチングではないため、そこでパターンマッチングを書きたい場合は右辺の式内に記述する必要があります。

事後条件として`(ret == 1 or ret == 2 or ret > 100)`という条件を指定したい場合の例

```cpp
// P3210の提案
int foo()
  post (
    1 => true;
    2 => true;
    let ret => ret > 100
  );

// この提案の場合
int foo()
  post ( let ret =>
    ret match {
      1 => true;
      2 => true;
    } or
    ret > 100
  );
```

これが、先行する同種の提案P3210との違いでもあります。

この提案の問題点は、契約プログラミング機能がC++26を目指しているのに対して、パターンマッチング機能はまだその段階にないことです。おそらく、契約プログラミング機能の方が先に完成し標準に取り込まれるでしょう。つまり、パターンマッチングの構文はまだ流動的で、最悪の場合この提案が採択されたうえでパターンマッチングだけ異なる構文になる可能性があります。

ただ、この提案を採択しなければ同じことを行うのに異なる2つの構文が確実に導入されるのに対して、この提案を採択したおけばそれを異なる2つの構文が導入されるかもしれない、まで緩和することができます。

契約プログラミング機能が先に採択されている場合にこの提案が採択されているとすると、パターンマッチングの構文として別のものが提案される場合にそれに対して余分な制約を追加することになります。その場合この提案では、統一構文から逸脱するにせよ整合性を重視するにせよ、それは契約プログラミング機能とは無関係にパターンマッチングが（を議論するEWGが）決定するべき、としています。

- [P3210R0 A Postcondition is a Pattern Match - WG21月次提案文書を眺める（2024年04月）](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3210r0.pdf)
- [P3249 進行状況](https://github.com/cplusplus/papers/issues/1910)

### [P3250R0 C++ contracts with regards to function pointers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3250r0.html)

契約注釈を持つ関数の関数ポインタへの暗黙変換を禁止する提案。

現在の契約プログラミング機能の仕様（P2900）では、現時点で契約チェックが関数の呼び出し側でなされるのか、呼び出し先でなされるのかが未解決のままです。とはいえ、関数ポインタの場合を除いてこれはほぼ問題にならないようです。

また現在の契約プログラミング仕様では、関数ポインタに対する契約の指定は行えません。これは、関数ポインタがそのシグネチャだけ会って居れば変換できてしまうためで、異なる契約条件の変換をどうするかという厄介な問題の議論を先送りにするための制限です。ただし、将来的にそれを有効化した場合、関数ポインタを通して関数が呼び出された場合に契約チェックを正しく行うには必ず呼び出し先でチェックを実行しなければならないことを意味して
います。

ただし、現在の仕様（P2900）では、関数ポインタに対する契約注釈を禁止しているものの、契約注釈を持つ関数の関数ポインタへの変換は禁止していません。これによって、将来的に関数ポインタに対する契約注釈への拡張が行われた場合に問題が起こります。

```cpp
// 契約を持つ関数
void fun(A& a) pre (a.ok());

// 関数型エイリアス
using F = void(A& a);
using G = void(A& a) pre(a.ok()); // 将来可能になったとして

// 関数ポインタ変数の宣言
F* f = fun; // ok、危険、現在から可能
G* g = fun; // ok、安全
```

このように同じ関数に対する関数ポインタでも、契約注釈の情報を保持したものとすべて削除されたものの2種類が共存してしまいます。

この提案は、将来の関数ポインタに対する契約注釈の指定を可能にしておくために、契約を持つ関数からシグネチャがマッチする関数ポインタヘの暗黙変換を禁止するものです。

関数ポインタに契約注釈を行えるようにする場合

- コンパイラは呼び出し先でのチェックを省略して、呼び出し側の（場合によっては省略可能な）契約条件のチェックを抱けを行える
    - コンパイラの証明によって、契約条件のチェックが省略可能な機会が増える
- 異なる契約注釈セット間での関数ポインタの変換
    - より強い契約からより弱い契約へ、またはその逆、の変換など

等のメリットがあります。

将来の関数ポインタのために設計を予約しておく場合、これらのメリットを将来的に導入する時のために設計を開いておき、なおかつ、現在の関数ポインタの使用方法を将来の変更から保護する事にもつながります。

一方、関数ポインタの契約注釈のために設計空間を予約しておく場合

- 関数名に対してアドレスを取る操作は、明示的な変換のみが許可される
- 型推論される場所で関数ポインタを使用できない
  - `auto*`やテンプレート
- P2900は契約注釈はリフレクションに対して不可視であることを決定したが、これによってそれをコンパイル時に検出出来うる

等のデメリットがあります。

提案より、サンプルコード

```cpp
int f(int x) post (r: r != 0);

using function_type = int(*)(int);
auto *fp2 = f; // ERROR
auto *fp3 = (function_type)f; // OK

template <typename FT>
void g(FT func);
g(f); // ERROR
g((function_type)f); // OK
```

契約を持たない関数の関数ポインタへの変換、および（契約有無に関わらず）関数ポインタへの明示的変換は、これまで通りに許可されます。

この提案はSG21のレビューで好まれず、否決されています。

- [P3221R0 Disable pointers to contracted functions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3221R0-Disable-pointers-to-contracted-functions)
- [P3250 進行状況](https://github.com/cplusplus/papers/issues/1911)

### [P3251R0 C++ contracts and coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3251r0.html)

コルーチンに対する契約注釈を許可する提案。

C++26を目指している現在の契約プログラミング機能においては、コルーチンに対する契約は`contract_assert`のみが許可されており、事前・事後条件の指定は禁止されています。これは、コルーチンが中断可能な関数であることから、それらの契約がどのように振舞うべきかのセマンティクスを確立できていないため、その議論と決定を急がないための措置です。

通常の関数に対する事前条件と事後条件は、関数に入る時と関数から戻る時の、パラメータ/戻り値とプログラムの状態についての条件を指定します。

コルーチンはその呼び出しの任意の時点で中断して呼び出し元にリターンすることができ、またその後の任意の時点で再開し再び関数内に入ることができます。C++におけるコルーチンは関数宣言で区別されておらず、その定義を見に行かないとその関数がコルーチンであるかどうかはわかりません。従ってコルーチンに対する事前条件と事後条件で契約可能なのは、コルーチンの開始時点の状態と、中断時点の状態についてのものだけです。

現在の契約プログラミング機能でコルーチンに対する事前・事後条件指定が禁止されているとはいっても、それは実際には簡単に回避できます。例えばコルーチン`f()`があるとき、`auto g() { return f(); }`のようにすればこの`g()`はコルーチンではなくなり、`g()`には通常の関数同様の契約注釈を指定できます。このようにした時の`g()`になされる事前条件と事後条件とは、ちょうどコルーチンの開始時点の状態と中断時点の状態に対する契約として機能し、それはこのようなラッピングを行うユーザーの意図するところと一致するはずです。

ただし通常の関数と異なるところが一点だけあり、それは事後条件からはコルーチン引数を一切参照できないということです（ムーブされている可能性があるため）。コルーチンに対する事後条件のこのコーナーケースを除外（コルーチン事後条件における引数参照の禁止）してまでコルーチン（の直接の戻り値である`awaitable`型）に対して事後条件を指定可能にすることが、事後条件の一貫性を損なうデメリットを上回るかどうかは要検討です。このコーナーケースを回避して一貫性のためにコルーチンに対する事後条件を禁止したとしても大きな問題はないと思われます。

コルーチンに対して事後条件の指定を許可する場合の事を考えます。前述のように、その場合の事後条件はコルーチンが中断した時点での状態に対するものになります。しかしこの場合、コルーチンはまだ実行を開始してさえいない可能性があり、ユーザーがそのような状態についてアサートできることはほとんどありません。

しかし、そのような物理的なコルーチンのインターフェースではなく、論理的なコルーチンのインターフェースを見た時に、コルーチンに対する事後条件とはコルーチンが生成・または返す値（コルーチンの直接の戻り値ではない）に対するものとするのが、ユーザーの期待と合っており望ましいでしょう。ただしこれは、契約注釈がコルーチンであることをほのめかすことなく、関数インターフェースによって自然に伝播される必要があります。

この提案では、コルーチンに対する事後条件の指定は、コルーチンが直接返す値に対して適用するのではなく、そのコルーチンの`awaitable`型と`promise`型に対して適用するようにすることを提案しています。

コルーチンの`promise`型はコルーチンステート上に存在して呼び出し側とコルーチン側をつなぐ役割を持っています。`promise`型の`yield_value()`（`co_yield`に対して呼ばれる）と`return_value()`（`co_return`に対して呼ばれる）は、生成/返される値を受け取って、コルーチンに対する事後条件を事前条件としてその値に対して適用することのできる理想的な場所に位置しています。一方、`awaitable`な型の`await_resume`などはコルーチンに対する事後条件をそのまま自身の事後条件として持たさられる場所に位置しています。また、これらの関数には現在の契約プログラミング機能の仕様においても契約注釈を制限なく行えるため、このために特別な規定を増やす必要はありません。

これを実装する方法は、コルーチンの生成/返す値に対する条件と指定された（と分かっている）コルーチンに対する事後条件の注釈を、コルーチンの返す直接の戻り値型（`awaitable`）の一部（そのメンバ関数に対するもの）として扱う事です。例えば何かしラップを行う型を用意するなどの方法が考えられますが、これを許可するために現在の規定を弄る必要はありません（そこは実装詳細なので）。

現在の（そしておそらくC++26の）契約プログラミング機能の仕様に対して変更が必要なのは、コルーチンである関数に対する事前・事後条件の契約注釈を禁止している文言に対してだけです。コルーチンに対する事後条件は上記のように複雑になり他の関数と少し異なってしまうため有用かどうかは不明ですが、事前条件指定に関しては間違いなく役に立つはず、と主張しています。

結局この提案では

- コルーチンに対する事前条件（と事後条件）の契約注釈を許可する
- コルーチンに対する事前条件（と事後条件）は、`promise`型（および`awaitable`型）の  事前条件と事後条件として扱うようにする

の2つの事を提案しています。

- [P2957R0 Contracts and coroutines - WG21月次提案文書を眺める（2023年08月）](https://onihusube.hatenablog.com/entry/2023/10/14/223052#P2957R0-Contracts-and-coroutines)
- [P3251 進行状況](https://github.com/cplusplus/papers/issues/1912)

### [P3253R0 Distinguishing between member and free coroutines](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3253r0.html)

同じシグネチャを持つメンバ関数とフリー関数のコルーチンを区別するようにする提案。

コルーチンのプロミス型は`std::coroutine_traits<>`のテンプレートパラメータに、コルーチンの戻り値型及び呼び出し時の引数型を入れて特殊化したもの（`std::coroutine_traits<R, Args...>`）が使用され、それに対応するものをあらかじめ用意しておくと（すなわち、コルーチン戻り値型に対して特殊化しておけば）、そのメンバ型（`std::coroutine_traits<R, Args...>::promise_type`）を定義することでコルーチンで使用されるプロミス型をカスタマイズできます。

ところでコルーチンはメンバ関数としても定義することが可能であり、メンバ関数は最初の引数に暗黙に`this`引数を受けており、メンバコルーチンの場合`std::coroutine_traits<R, Args...>`の`Args`の最初には暗黙の`this`引数に対応する型が入っています。

このため、同じ戻り値型を共有するメンバ関数と非メンバ関数のコルーチンで、非メンバコルーチンの方がメンバ関数コルーチンの属するクラスを最初の引数に取る場合、`coroutine_traits`からその区別がつかなくなります。

```cpp
struct S {
  // メンバコルーチン
  R member_coro1(int x, std::string y) const;
  R member_coro2(const S&, int x, std::string y) const;
};

// フリー関数のコルーチン
R free_coro(const S&, int x, std::string y);
```

この`member_coro1()`と`free_coro()`のコルーチンは、プロミス型の導出のために`std::coroutine_traits`の特殊化を、`std::coroutine_traits<R, const S&, int, std::string>`としてクエリします。これはコルーチン戻り値型`R`から見ると`member_coro1()`と`free_coro()`を区別することができず、この2つの関数は同じプロミス型を取得します。

このような`R`には例えば`std::generator`があります。

このことが問題となるのは、`std::generator`のようにアロケータをカスタマイズ可能にしようとする場合です。

コルーチンはコルーチンフレームの確保のために動的メモリ確保を行いますが、これはまずプロミス型のスコープで`operator new()`が探索されます。すなわち、プロミス型で`operator new()`を定義することで動的メモリ確保方法をカスタマイズでき、`std::generator`では3番目のテンプレートパラメータと合わせて任意のアロケータを受け取り、使用することができます。

この`operator new()`の探索は、`promise_type::operator new(std::size_t, Args...)`の様なシグネチャで行われ、後半の引数はコルーチン引数がその順番のまま渡されます。

`std::generator<T, V, Alloc>`の場合、最も分かりやすいアロケータのカスタマイズとして3番目のテンプレートパラメータにアロケータ型を指定する方法があり、この場合にアロケータを初期化するためには`std::allocator_arg_t`のタグ値の後にアロケータを渡す必要があり、これをコルーチン引数列の先頭で行う必要があります。

```cpp
using Generator = std::generator<int, void, std::pmr::polymorphic_allocator<>>;

struct S {
  // メンバコルーチン、カスタムアロケータを受け取ろうとしている
  Generator member_coro1(std::allocator_arg_t,
                         std::pmr::polymorphic_allocator<> alloc,
                         int x) const;
};

// フリー関数のコルーチン1、カスタムアロケータを受け取る
Generator free_coro1(std::allocator_arg_t,
                     std::pmr::polymorphic_allocator<> alloc,
                     int x);

// フリー関数のコルーチン2、カスタムアロケータを受け取ろうとしている
Generator free_coro2(const S&,
                     std::allocator_arg_t,
                     std::pmr::polymorphic_allocator<> alloc,
                     int x);
                     
// フリー関数のコルーチン3、カスタムアロケータを受け取ろうとしている
Generator free_coro3(const S&,
                     const std::vector<int>&,
                     std::allocator_arg_t,
                     std::pmr::polymorphic_allocator<> alloc,
                     int x);
```

ぱっと見ると、`member_coro1()`と`free_coro1()`は正しくアロケータのカスタマイズを行えており、渡したアロケータが使用されるように見えます。一方で、`free_coro2()`と`free_coro3()`は渡す引数順が間違っている（`std::allocator_arg_t`が2番目以降の引数で渡されている）ためアロケータのカスタマイズは上手くいかないように見えます。

実際には、`member_coro1()`と`free_coro1()`、そして`free_coro2()`は渡されたアロケータを使用しますが、`free_coro3()`では使用されません。これは、`member_coro1()`の渡し方をサポートするための副作用です。

前述のように、`member_coro1()`と`free_coro2()`では同じプロミス型が使用されます。すなわち、この2つの関数のシグネチャはプロミス型から見ると同じです（`std::coroutine_traits<Generator, const S&, std::allocator_arg_t, std::pmr::polymorphic_allocator<>, int>::promise_type`）。したがって、探索される`new`演算子のシグネチャは`promise_type::operator new(std::size_t, const S&, std::allocator_arg_t, std::pmr::polymorphic_allocator<>, int)`のようになります。これは`std::allocator_arg_t`が第一引数にわたっていないため本来カスタマイズ対象ではない（標準ライブラリ内におけるuses-allocator constructionと一貫していない）のですが、`std::generator`がこの問題を考慮して設計されているため、これを特別扱いしてサポートするためにこのシグネチャでも`operator new()`のオーバーロードを用意しており、それによってカスタムの`new`演算子が呼ばれてその中で渡されたカスタムアロケータが使用されます。

この特別扱いは`member_coro1()`をサポートするためのものですが、`member_coro1()`と`free_coro2()`では同じプロミス型が使用されているため、`free_coro2()`に対しても使用可能になります。これによって、意図せずに`free_coro2()`は正常に動作しています。導出されるプロミス型が同一になるため、`member_coro1()`だけを受け入れて`free_coro2()`を弾くということはできません。

この問題のために、`std::generator`のようなコルーチン戻り値型の制作者は、`free_coro1()`をサポートする（これは全く正当なもの）ために`std::size_t, std::allocator_arg_t, Alloc`のように3番目の引数でアロケータを受け取る`operator new`オーバーロードと、`member_coro1()`をサポートするために`std::size_t, const S&, std::allocator_arg_t, Alloc`のように4番目の引数でアロケータを受け取る`operator new`オーバーロードの2種類を用意しなければならなくなります。

これによって、アロケータ引数に関してメンバコルーチンとフリー関数のコルーチンの間、また`std::generator`（及び同種のコルーチン戻り値型）と他の標準ライブラリ機能の間で、不必要な矛盾が生じています。

この提案はこの問題の解決のために、最初のプロミス型の探索過程を修正しようとするものです。

この提案では、メンバ関数のコルーチンが`std::coroutine_traits`からメンバ型としてプロミス型を取得する場合、まず最初に`std::coroutine_traits<R, Args...>::promise_type_for_nonstatic_member`が定義されているかをチェックし、定義されているならこれをプロミス型として使用し、定義されていない場合は従来通り`std::coroutine_traits<R, Args...>::promise_type`を使用する、といようにします。

プロミス型の定義方法及びその後の経路に関しては一切変更がありません。この入れ後の`promise_type_for_nonstatic_member`型として指定されているプロミス型からは、そのコルーチンがメンバ関数として定義されていることが分かるため、ここだけで4番目の引数でアロケータを受け取る`operator new`オーバーロードを用意すればメンバコルーチンに対してもアロケータカスタマイズを提供できます。なおかつ、`promise_type_for_nonstatic_member`がプロミス型として取得されるのは非静的メンバのコルーチンからだけなので、フリー関数のコルーチンが子のプロミス型を使用することはありません。

これにより、先程の例の`member_coro1()`と`free_coro1()`の渡し方だけが有効で（サポートされ）、`free_coro2()`（及び`free_coro3()`）の渡し方は有効ではない（サポート外）という弁別が可能になり、問題になっていた非一貫性が解消されます。

この方法では、ユーザーが明示的に`std::coroutine_traits`の特殊化に`promise_type_for_nonstatic_member`を定義しない限り、現在の動作が損なわれることはなく、下位互換性を担保することができます。

この提案は、EWGの初期レビューで好まれなかったようで、否決されています。

- [C++20 コルーチン - cpprefjp](https://cpprefjp.github.io/lang/cpp20/coroutines.html)
- [P3253 進行状況](https://github.com/cplusplus/papers/issues/1912)

### [P3254R0 Reserve identifiers preceded by @ for non-ignorable annotation tokens](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3254r0.html)

`@`から始まるトークン列を予約しておく提案。

C++23ではP2558の採択によって`@`が基本ソース文字集合（言語の構文を記述するために使用される文字の集合）に追加されました。これによって、将来のC++では`@`を何かしらの言語機能のための構文に使用することができます。

そのような言語機能は現在存在していませんが、この提案は、`@`から始まる文字列を将来的に無視できない注釈に使用するために、実質的にユーザー使用できないようにしておく提案です。

現在のC++の属性は無視できるという性質を持つため、何か注釈を行うのに必ずしも最適ではありません。属性は独立した構文空間を持つためその中で使用する名前は既にユーザーが使用しているものと衝突する心配がないという利点がありますが、何か新しい言語機能を追加する場合に無視可能という性質が望ましくなく、必ずしも新しいキーワードの追加や既存キーワード使いまわしを回避できるわけではありません。

`@`を使用したものとして有効なトークンはリテラル以外になく、`@~`のように`@`から始まる文字列を何かしらの注釈として使用することは他の言語でも前例があります。その具体的な提案の検討はここではしていませんが、将来のそうした機能のためにこの構文空間を予約しておくことがこの提案の目的です。

この提案ではそのような注釈の想定される例としていくつかのものをあげています

- 契約注釈
    - `@pre(x > 0)`や`@assert(x > 0)`の様な注釈
- トリビアルリロケーション
    - クラスに対する`@trivially_relocatable`のような注釈によって、クラス型がトリビアルリロケーション可能であることを表明する
- プロファイル注釈
    - P2816で述べられているようなプロファイルの指定を`@enable(ranges)`のように指定する
- `[[no_unique_address]]`の置き換え
    - `[[no_unique_address]]`は実際には無視できる属性ではなかったため、非推奨にして`@no_unique_address`に置き換える

この提案では、`@~`のトークンを単に予約するという文章によって指定するだけではなく、1つのプリプロセッシングトークンにしておくことも提案しています。これは、`@~`のトークンが現在2つのプリプロセッシングトークンとして認識されてしまうためです。これが無いと、例えば`@assert(expr)`のような注釈を導入しても、`assert(expr)`マクロの展開を妨げることができません。同様に、他の`@~`トークンでも先頭の`@`を除いた部分の文字列がすでにマクロとして定義されている場合にそのマクロの展開を防止することができず、これだと予約しておく意味がほとんどありません。

そのため、`@~`を1つのプリプロセッシングトークンとしてプリプロセス時に扱っておくことで、将来的に`@~`を使った注釈を導入する時の問題をあらかじめ取り除いておくことができます。

- [P2558R2 Add @, $, and ` to the basic character set - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2558R2-Add---and--to-the-basic-character-set)
- [P3254 進行状況](https://github.com/cplusplus/papers/issues/1914)

### [P3255R0 Expose whether atomic notifying operations are lock-free](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3255r0.html)

`std::atomic`の通知・待機系関数がロックフリーとは限らない場合がある問題について修正する提案。

`std::atomic`（以下`std::atomic_flag`および`std::atomic_ref`を含む）に対してC++20で追加された通知・待機系関数（`.wait()`、`.notify_~()`）に対しては、その型そのものに対してロックフリーであると指定される場合に（`std::atomic_flag`の場合に常に）当然ロックフリーであり、シグナルセーフであることが期待されます。

しかし実際にはロックフリーではない可能性がありその場合シグナルセーフでもありません。`.wait()`関数はスレッドをブロックするため明らかですが、通知関数についてもロックフリーな実装を取ることができるものの、オブジェクトサイズや環境によってはロックフリーとならない場合があるようです。

これらの問題の解決のため、この提案では次の事を提案しています

- `std::atomic_flag`の通知・待機系関数は、ロックフリーである必要が無いことが明確になるように規定を修正
- `std::atomic`の`is_lock_free`、`is_always_lock_free`、`std::atomic_is_lock_free`のプロパティはアトミックの通知・待機系関数に関してのものではないことを明確になるように規定を修正
    - これらのプロパティの範囲から、通知・待機系関数を除外する
- `std::atomic_flag`、`std::atomic`、`std::atomic_ref`にメンバ関数`.notify_is_lock_free()`とフリー関数の`std::atomic_notify_is_lock_free`、およびメンバ定数の`notify_is_always_lock_free`を追加し、アトミックの通知・待機系関数がロックフリーかどうかはそれらのプロパティが表明するようにする

これによって、通知・待機系関数がロックフリー（でありシグナルセーフ）であるかどうかを正しく判定できるようになります。

- [P3251 進行状況](https://github.com/cplusplus/papers/issues/1912)

### [P3257R0 Make the predicate of `contract_assert` more regular](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3257r0.html)

契約注釈から参照される変数の暗黙`const`化を、`contract_assert`では緩和する提案。

現在の契約プログラミング機能の仕様ではP3071の採択によって、契約注釈内からローカル変数・関数引数を参照すると、それは暗黙的に`const`として扱われます。これは`const`メンバ関数のメンバ変数に対する動作に似ており、オーバーロード解決の結果が変化したり、`map[key]`のように一部の式がエラーになったりすることが知られています。

これにより、`contract_assert()`の内外で同じ式に対するコンパイル結果が明確に変化します

```cpp
void f() {
  int i = 0;
  if (++i < 5) { ... }        // OK
  contract_assert(++i < 5);   // P2900R6: ill-formed、この提案: well-formed
}
```

このように、同じソースコードが近傍に出現していても同じように動作せず、ユーザーの期待に反する可能性があります。ただし、このことは事前条件と事後条件には当てはまりません（宣言で出現し、定義から離れている場合があるため）。

```cpp
void h(int x, int y)
  pre(x > 0)       // ok
  pre(y < 0)       // ok
  pre(++x < 42);   // ill-formed
```

別の問題として、契約条件の評価異数の問題があります。現在使用されている`assert`マクロによる次のようなコードは、単純には`contract_assert()`で置き換えられない可能性があります。

```cpp
  void f() {
#ifndef NDEBUG
    int iter = 0;
#endif
    while (/* something */) {
      assert(++iter < 6);   // 6回以上繰り返されたらバグ
      // ...		  
    }
  }
```

この`iter`変数の宣言を同様にガードする方法が無いのもそうですが、一番の問題は`contract_assert`に指定された述語が無制限に評価される可能性があるためです。

`assert`マクロからの移行の問題であるため、これについても`contract_assert`だけが対象です。

これらの問題の解決のために、この提案は次の事を提案しています

- `contract_assert`ではP3071の変更を元に戻す
    - `contract_assert`の述語内から参照される変数の`const`性は変化しない
- その契約注釈がignoreセマンティクスを持たない場合、`contract_assert()`の述語（条件式）は一回だけ評価されることを規定

これによって、`assert`マクロから`contract_assert`への移行がより簡単になります。

この提案の内容はどちらも好まれなかったようで、SG21のレビューでコンセンサスを得ることができませんでした。

- [P3071R1 Protection against modifications in contracts](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P3071R1-Protection-against-modifications-in-contracts)
- [P3257 進行状況](https://github.com/cplusplus/papers/issues/1916)

### [P3258R0 Formatting `charN_t`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3258r0.pdf)

`charN_t`文字・文字列を`std::fomart`可能にする提案。

`charN_t`とは、`char8_t, char16_t, char32_t`型の事です。これらのユニコード文字型は言語サポートされているにもかかわらず、標準ライブラリのサポートに乏しく、微妙に使いにくい部分がありました。

この提案はその改善の第一歩として、これらのユニコード文字型による文字と文字列を`std::fomrat()/std::print()`でサポートする提案です。

提案では、`char8_t, char16_t, char32_t`の文字と文字列、およびこれらの文字を使った`std::string/std::string_view`及び`range`を`std::format()`による文字列化対象にすることを提案しています。ただし、フォーマット文字列としてこれらのユニコード文字型を使用可能にすることは提案していません。出力のエンコーディングは、現在同様にフォーマット文字列の文字型から静的に決定されます。

`char`と`wchar_t`がフォーマット文字列とフォーマット対象で混在するのは許可されていませんが、この2つの文字型がフォーマット文字列として使用されている場合に`charN_t`をフォーマットすることはサポートされています。

筆者の方は、libc++の`std::format()`実装でこれを実装しても実装上の問題はほとんど発生しなかったと報告しています。

- [P3258 進行状況](https://github.com/cplusplus/papers/issues/1917)

### [P3259R0 const by default](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3259r0.html)

クラス型のオブジェクト宣言時のデフォルトを`const`にする提案。

この提案は、以前のP3218R0で提案されていアプローチの一部（参照セマンティクスを持つ型はデフォルトで`const`が付くようにエイリアスを作る）を言語機能によって実現しようとするものです。P3218R0については以前の記事を参照

- [P3207R0 More & like - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3207R0-More--like)

この提案では、クラス宣言への指定として`const`を付加して宣言できるようにすることを提案しています。

```cpp
// function_refの宣言例

template<class... S>
class function_ref;    // not defined

template<class R, class... ArgTypes>
class function_ref<R(ArgTypes...) cv noexcept(noex)> const  // 👈 const by default
{
  // ...
};
```

このように宣言されたクラス型の変数は、デフォルトの宣言が暗黙的に`const`であるように扱われます。`const`指定されたクラス型から`const`を取り除きこれまで通りの動作（デフォルト非const）をする型を得るには、型名に`mutable`を付加します。

```cpp
void action() {}

void some_other_action() {
  function_ref<void ()> fr1{ action };          // デフォルトの宣言がconst宣言になる
  mutable function_ref<void ()> fr2{ action };  // 非const変数の宣言

  fr1 = function_ref<void ()>{ action };  // ng
  fr2 = function_ref<void ()>{ action };  // ok
  
  std::vector<function_ref<void ()>> v1{ fr1, fr2 };          // ng
  std::vector<mutable function_ref<void ()>> v2{ fr1, fr2 };  // ok
}
```

クラスの`const`指定の逆の指定（つまり今まで通り）として`mutable`も追加することを提案しており、さらにどちらにも引数として`bool`値を取れるようにしています。

```cpp
class a const {};     // デフォルトconst宣言
class b mutable {};   // `class b {};`と同じ
class c const(true) {};   // `class c const {};`と同じ
class d const(false) {};  // `class c mutable {};`と同じ
class e mutable(true) {};   // `class c mutable {};`と同じ
class f mutable(false) {};  // `class c const {};`と同じ
```

`function_ref`や`optional<T&>`などの浅い`const`セマンティクスを持つ参照セマンティクス型をデフォルトで`const`にしておくことで、言語組み込みの左辺値参照との一貫性が高まり、安全に使用しやすくなります。

- [P3259 進行状況](https://github.com/cplusplus/papers/issues/1918)

### [P3263R0 Encoded annotated char](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3263r0.html)

ユーザーが指定したエンコーディングによる文字を表現可能な文字型の提案。

テキストの処理と解釈にはその文字のエンコーディングが重要となります。ユーザーが作成する可能性のあるアプリケーションの範囲を考えると、現状のC++にはソフトウェアでテキストを処理するための単一の方法がありません。

型と文字エンコーディングを対応させることでユーザーが様々なエンコーディングでテキストを識別して管理できるようにするのは望ましい方向性であり、C++でもユニコードに対応する三種類の文字型（`char8_t, char16_t, char32_t`）がコア言語に対して追加されています。しかしこの方法はスケールしませｎ。存在する全ての文字エンコーディングに対して対応する文字型を標準に導入するのは現実的ではなく、追加に当たっては文字型そのものだけではなく他のライブラリユーティリティ（`std::integral, std::string, std::string_view`など）に対する対応も求められます。

この提案は、標準化委員会の関与を必要とすることなくユーザーが独自の文字エンコーディングサポートを追加できるようにするためのライブラリ機能を追加しようとするものです。

文字型の要件としては

- 既存の型の単なるエイリアスとして扱われない一意の型である
    - `using char_iso2022_t = char8_t;`のようなものではない
- 文字として実行できると期待される一般的な操作を適用可能である
    - 文字のコード単位がある値であるかをチェックする（`==`）や、文字があるコード単位の範囲内にある化をチェックする（`> >=`など）など
- ユーザーが独自のエンコーディングを、それに期待されるすべての関連機能と共に、簡単に定義できる
- ユーザーが文字コード単位の幅（文字サイズ）を指定できる
- 変換するのが十分に容易である

ここでは、これらの要件を達成するために、コア言語機能での対応を必要とせず`enum class`を利用するものでもない、ライブラリ機能を導入しようとしています。その文字型は、次の2つのものから構成されます

- エンコーディング注釈型
  - エンコーディングを一意に識別するユーザーが用意する型
- テンプレート化された文字クラス型
  - エンコーディング注釈を受け取り文字操作コードを自動生成するめの標準ライブラリ型

EBCDICをサポートする例

```cpp
// EBCDICエンコーディングのためのエンコーディング注釈型の定義
struct text_encoding_EBCDIC: public std::text_encoding // エンコーディング注釈型であることを示すための基底クラス型
{
	using char_t = char8_t;

	// static constexpr std::string_view id{"EBCDIC"}; //optional, not required
};

// EBCDIC文字型の定義
using char_EBCDIC_t = std::char_enc_t<text_encoding_EBCDIC>;


// EBCDIC文字列型の定義
using string_EBCDIC = std::basic_string<char_EBCDIC_t>;
using string_view_EBCDIC = std::basic_string_view<char_EBCDIC_t>;
```

エンコーディング注釈型は`std::text_encoding`を継承したクラス型として定義し、メンバ型`::char_t`にその表現型を指定します。提案では、表現型としては`bool`ではない符号なし整数型であることを要求していますが、ユニコード文字型のみに制限するオプションもあげています。

エンコーディング注釈型に必要なことはこれだけで、あとはそれを`std::char_enc_t<>`のテンプレートパラメータに渡すことでそのエンコーディングの文字型を得ることができます。`std::char_enc_t<E>`はエンコーディング`E`による文字型として利用可能であるために、`E::char_t`の薄いラッパとなる型です。`std::char_enc_t<E>`では`E::char_t`のものを利用する形で文字演算（ほぼ整数演算）の演算子オーバーロードが定義されており、これによって文字表現型で利用可能な操作をそのまま再利用しながら、なおかつその型とは完全に別の型として扱われる、という性質を達成しています。

また、`std::char_enc_t<E>`は表現型への明示的変換のほか、文字の表現型での値を取得する`.value()`等が用意されていることで、変換も容易に行えるようにしています。

これらの機能は、先に挙げた5つの要件に加えて、標準化委員会の関与を必要とせずに新しい文字型を定義できるという要件をすべて満たすソリューションです。

ただし一つ懸念点があり、文字・文字列リテラル（`'c'や"string"`）がコア言語サポートであるためにこの型のそれを自動で追加できず、ユーザー定義リテラルや変換関数を使用することになりますが、それだと言語のリテラルにある永続的なストレージに配置されるという性質が達成できません。この提案ではこれに対する解決策を見出しておらず、未解決の問題としています。

- [P3263 進行状況](https://github.com/cplusplus/papers/issues/1919)

### [P3264R0 Double-evaluation of preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3264r0.html)

↓

### [P3264R1 Double-evaluation of preconditions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3264r1.html)

事前条件がチェックされる場合に、それが2回以上チェックされる可能性があるという現在の仕様を維持すべきとする提案。

現在の契約プログラミング機能の仕様では、契約注釈の種類を問わず契約条件がチェックされる場合は2回以上チェックされる可能性があるとされています。これには異論もあり、正確に1回・少なくとも上限を設ける・正確に回数を指定する、などの別のアプローチを望む声もあります。

この提案は、事前条件に的を絞ってその利点を説明し、少なくとも事前条件については現在の仕様を維持すべきとする提案です。

ここでは、事前条件の条件式が2回以上チェックされることを許可するようにしておく利点として次の事を挙げています

- 呼び出し側と呼び出される側の両方に対して契約チェックを行う機会を提供できる
    - ビルド済みのライブラリでチェックが有効化されていない場合でも、ライブラリの再コンパイルを必要とせずに呼び出し側でチェックを有効化できる
    - アプリケーションで契約チェックが有効化されていない場合でも、アプリケーションの再コンパイルを必要とせずに呼び出し先でチェックを有効化できる
    - 両側で契約チェックが有効化されていれば、2回チェックされる
- 翻訳単位の片側/両側で契約チェックを有効・無効を切り替えても、ABIに影響を与えない
- 上記の利点をライブラリのグラフ（ライブラリ内で使用されているライブラリ）に拡大しても、同じ利点が得られる
- チェックが有効化されている場合でも効率的
    - 単一評価を保証するための実行時機構の呼び出しが義務付けられない
- これらの利点には説得力があるため、標準が正確に一回だけ評価されるという方向性を採用した場合でも、2回以上評価されるというアプローチは（非標準の拡張として）提供されると思われる

そして、2回以上チェックされる可能性があるとしておくことによって、プログラマは契約条件式内での副作用に頼ったプログラムを書くのを回避するようになる、という副次的効果も得られるはずです。契約条件式の副作用に頼ったプログラムはそれを書いたプログラマ以外がコードを理解することを難しくするとともに、契約注釈を活用する外部ツール（静的解析など）の解析も困難にします。

他の2種類の注釈、事後条件と`contract_assert`の場合、同じように規定しても事前条件程の利点が得られない可能性があるものの、少なくとも事後条件に関しては事前条件の場合と同じ利点がある、としています。

- [P3264 進行状況](https://github.com/cplusplus/papers/issues/1920)

### [P3265R0 Ship Contracts in a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3265r0.html)

↓

### [P3265R1 Ship Contracts in a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3265r1.html)

契約プログラミング機能をまずTSとして出荷すべき、とする提案。

契約プログラミング機能は今のところC++26を目指して進行しています。しかし、EWGに転送された後で、EWGのメンバが考える契約プログラミング機能と現在のそれが少し異なるものであることが表面化し、それによって契約プログラミング機能に対して機能リクエストが噴出しつつあります。

この提案は、契約プログラミング機能の提案（P2900）から期限を取り除いて、まずTSという形で出荷してもう少し時間をかけることを提案するものです。

提案ではその動機として次のものを挙げています

- 実装経験を得る
- 現場での使用経験を得る
- P2900の複数の点（とくに争点となっている）に対するWG21全体のコンセンサスを得る
- 仮想関数、コルーチン、関数ポインタに対する契約についてのコンセンサスが無い
- 安全性の向上
    - 契約注釈は言語の他の部分同様に未定義動作の影響を受けやすく、このことは契約注釈の実行時チェックにとっても静的解析ツールの契約注釈利用時においても問題となる可能性がある

また、契約プログラミング機能に対する機能要求は現在でもいくつも出てきており、それらには以前にはなかったアプローチも含まれています。期限を重視して最小の機能をC++26に入れるMVPのアプローチでは、これらの提案が間に合わないことでそのような別のアプローチへの道を閉ざしてしまう可能性もあります。

この提案はSG21で確認された後EWGでも確認されていますが、まだ何かしらの決定は下されていません。どうやら、契約プログラミング機能の期限を決める責任はEWGにあるようです。

- [P3265 進行状況](https://github.com/cplusplus/papers/issues/1921)

### [P3266R0 non referenceable types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3266r0.html)

型の参照型を取得できないようにするクラスの指定の提案。

この提案は、以前のP3218R0で提案されていアプローチの一部（参照セマンティクスを持つ型はアドレスを取得できない）を発展させたものを言語機能によって実現しようとするものです。P3218R0については以前の記事を参照

- [P3207R0 More & like - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3207R0-More--like)

この提案では、`referenceable(bool)`のようなクラス宣言に対する指定によってそれを行おうとしています

```cpp
template<class... S>
class function_ref;    // not defined

template<class R, class... ArgTypes>
class function_ref<R(ArgTypes...) cv noexcept(noex)> referenceable(false) // 参照できず、コピーのみが可能となる
{
  // ...
};

template <class T>
class optional<T&> referenceable(false) // 同上
{
  // ...
};
```

このように指定して宣言されたクラスは参照で保持することが禁止され、コピーのみしかできなくなります

```cpp
// 参照不可能な型への参照は許可されない
function_ref<void ()>& f(function_ref<void ()>&); // ill-formed
optional<int&>& f(optional<int&>&); // ill-formed

void action() {}

int main()
{
  function_ref<void ()> fr1{ action };

  // 参照不可能な型への参照は許可されない
  function_ref<void ()>& fr2 = fr1; // ill-formed

  int i = 42;
  optional<int&> oi1{ i };  // const by default

  // 参照不可能な型への参照は許可されない
  optional<int&>& oi2 = oi1;  // ill-formed

  return 0;
}
```

デフォルトは`referenceable(true)`であり、これは現在のクラス型の振る舞いです。

```cpp
class a referenceable(false) {}; // 参照不可能な型
class b referenceable(true) {};  // class b {};と同じ
```

これは参照セマンティクスを持つ型の扱いをより言語参照へ近づけるもの（参照の参照を作成できない）であり、これによってダングリング参照の発生を抑制できるとしています。

- [P3266 進行状況](https://github.com/cplusplus/papers/issues/1922)

### [P3267R0 C++ contracts implementation strategies](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3267r0.html)

↓

### [P3267R1 Approaches to C++ Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3267r1.html)

C++契約プログラミング機能の実装戦略についてまとめて比較した文書。

ここでは主に事前条件と事後条件の契約注釈のチェックされるタイミングについての実装戦略のリストアップと比較を行っています。

説明に当たっては、次のような契約されている関数と、それを呼び出す関数および関数ポインタを使ってそれを呼び出す関数の3つで例示しています。

```cpp
// 事前・事後条件を持つ関数f()
int f(int arg)
  pre(arg > 5)
  pre(arg < 2000)
  post(rv: rv % 2 == 0)
{ 
  return arg * 2; 
}

// f()を呼び出すだけの関数g()
int g() {
  return f(25);
}

using function_pointer = int(*)(int);
function_pointer fp = &f;

// f()を関数ポインタ経由で呼び出す関数h()
int h() {
  return fp(40);
}
```

また、チェックされるタイミングの例示のために契約条件チェックを`check()`という関数で表し、条件を最適化に利用するポイント（条件式を仮定として扱うポイント、あるいは契約チェックを省略可能なポイント）を`imply()`という関数で表わしています。これはアサートの持つ役割を分離して、どの性質が許可されるのかを明確にするためです。

そして、ここでは契約注釈のセマンティクスに関してはこの実装戦略に影響しないとして同等に扱っており、契約注釈のセマンティクスは翻訳単位間で一致していることを前提としています。

#### 1. 全て呼び出し先でチェックする

事前条件と事後条件に関する全ての事を関数の定義内で行う方法で、これはもっとも簡単なC++契約プログラミング機能の実装方法です。

```cpp
int f(int arg)
{ 
  check(arg > 5);
  imply(arg > 5);
  check(arg < 2000);
  imply(arg < 2000);

  int rv = arg * 2;
  
  check(rv % 2 == 0);
  imply(rv % 2 == 0);
  
  return rv;
}

int g() {
  return f(25);
}

int h() {
  return fp(40);
}
```

#### 2. 呼び出し側でチェックし、呼び出し先では条件を仮定、事後条件を元のABIエントリポイントでチェック

この文書における元のABIエントリポイントとは、ABIにおける`f()`の呼び出しを表すものの事です。後で出てきますが、このエントリポイントを分割することで契約チェックの異なる実装が可能になります。

このアプローチは、チェックをそれらを包含する影響がある場所（事前条件が真 => 事後条件が真という含意を使用する場所）に配置するか、チェックを省略可能な他の情報が利用できる場所に配置するため、呼び出し側での最適化に適している実装です。

```cpp
int f(int arg)
{ 
  imply(arg > 5);
  imply(arg < 2000);

  int rv = arg * 2;
  
  check(rv % 2 == 0);
  return rv;
}

int g() {
  check(25 > 5);
  check(25 < 2000);

  int rv = f(25);
  
  imply(rv % 2 == 0);
  return rv;
}

int h() {
  return fp(40);
}
```

#### 3. 呼び出し側でチェックし、呼び出し先では条件を仮定、事前条件を元のABIエントリポイントでチェック

2と同様に呼び出し側でチェックを行いますが、`f()`のABIエントリポイントを分割し、事前条件を仮定し事後条件をチェックする別のエントリポイントを挿入します。

```cpp
int f(int arg) 
{
  check(arg > 5);
  check(arg < 2000);

  int rv = f@post-check(arg);
  
  imply(rv % 2 == 0);
  return rv;
}

int f@post-check(int arg)
{ 
  imply(arg > 5);
  imply(arg < 2000);

  int rv = arg * 2;
  
  check(rv % 2 == 0);
  return rv;
}

int g() {
  check(25 > 5);
  check(25 < 2000);

  int rv = f@post-check(25);
  
  imply(rv % 2 == 0);
  return rv;
}

int h() {
  return fp(40);
}
```

#### 4. 両側でチェックする

アプローチ1と同様に元のABIエントリポイントを保持し、なおかつ関数の呼び出し側と呼び出し先の両方でチェックを行います。この方法は一見冗長に見えますが、関数の両サイドに最適化ポイントを提供します。

```cpp
int f(int arg)
{ 
  check(arg > 5);
  imply(arg > 5);
  check(arg < 2000);
  imply(arg < 2000);

  int rv = arg * 2;
  
  check(rv % 2 == 0);
  imply(rv % 2 == 0);
  
  return rv;
}

int g() {
  check(arg > 5);
  check(arg < 2000);

  int rv = f(25);
  
  check(rv % 2 == 0);
  imply(rv % 2 == 0);
  
  return rv;
}

int h() {
  return fp(40);
}
```

#### 5. 遅延チェック

このアプローチと異なり、この方法では契約チェックは通常行われません。契約チェックの実行は外部ユーザー（プロファイラやデバッガなど）が指定する場合に実行時の任意のタイミングで行われます。

```cpp
template <typename T>
struct contract_raii_handle {
  contract_raii_handle(T&& lambda)
  : _check(std::move(lambda))
  , result(2);
  {}
  bool operator()() {
    if (result == 2) {
      result = _check();
    }
    return (bool)result;
  }
};
auto add_pending_contract_check(auto lambda) { return contract_raii_handle<decltype(lambda)>(std::move(lambda)); }

int f(int arg)
{
  auto pre_handle_1 = add_pending_contract_check([=]{ return arg > 5; });
  auto pre_handle_2 = add_pending_contract_check([=]{ return arg < 2000; });
  return arg * 2;
}

int g() {
  check(arg > 5);
  check(arg < 2000);

  int rv = f(25);
  
  auto post_handle_1 = add_pending_contract_check([=]{ return rv % 2 == 0; });
  
  return rv;
}

int h() {
  return fp(40);
}
```

この実装はC++による近似実装であり、より効率的な実装を行うこともできます。

#### 6. 実行時のセマンティクス選択

```cpp
int f(int arg)
{ 
  bool __run_checks = should_check(__func__);
  if (__run_checks) {
    check(arg > 5);
    check(arg < 2000);
  }

  int rv = arg * 2;
  
  if (__run_checks) {
    check(rv % 2 == 0);
  }
  
  return rv;
}

int g() {
  return f(25);
}

int h() {
  return fp(40);
}
```

#### 7. プログラムロード時のセマンティクス選択

6のアプローチにおいて、関数呼び出し時ではなくプログラムロード時に契約チェックを行うかを指定してシンボル解決を行うことで、チェックを行う実装の選択をプログラムロード時に解決するものです。

```cpp
static int f__check(int arg)
{ 
  check(arg > 5);
  check(arg < 2000);

  int rv = arg * 2;
  
  check(rv % 2 == 0);
  
  return rv;
}

static int f__nocheck(int arg)
{ 
  int rv = arg * 2;
  return rv;
}

static void *f__resolver() {
  // As an example of a condition to select on
  // This will be checked on the first invocation of f().
  return getenv("mustgofaster") == nullptr ? &f__check : &f__nocheck;
}

int f(int arg) __attribute__((ifunc("f__resolver")));

int g() {
  return f(25);
}

int h() {
  return fp(40);
}
```

C++プログラムの開始後`main()`が実行されるまでの間にこれを実行することはオーバーヘッドが大きすぎる可能性がありますが、リンカ/ローダーの機能（GNU ifuncなど）を使用することでプログラム開始前のロード時にシンボル解決を行って、オーバーヘッドを削減できます。

#### 比較

各アプローチの特徴は次のようになります

1. 全て呼び出し先でチェックする
    - 特徴: 関数の実装内で全ての契約チェックを行う。ABIの変更は発生しない
    - 利点: 実装がシンプル
    - 欠点: 呼び出し側での最適化の余地がほとんどない
2. 呼び出し側でチェックし、呼び出し先では条件を仮定、事後条件を元のABIエントリポイントでチェック
    - 特徴: 呼び出し側で契約チェックを行い、呼び出し先側は条件を仮定する。事後チェックが元のABIエントリポイントとなるため、ABIの変更は発生しない
    - 利点: 呼び出し側での最適化が可能になる
    - 欠点: 関数ポインタを使用する場合に契約がチェックされない。呼び出し側と呼び出し先でコンパイラフラグが異なっているとチェックされない場合がある
3. 呼び出し側でチェックし、呼び出し先では条件を仮定、事前条件を元のABIエントリポイントでチェック
    - 特徴: 呼び出し側で契約チェックを行い、呼び出し先側は条件を仮定する。事前チェックを元のABIエントリポイントとし、ABIを変更した名前の別のエントリポイントを追加する
    - 利点: 呼び出し側での最適化が可能であり、ABIエントリポイントを変更することで関数ポインタの場合でも契約チェックが可能になる。翻訳単位が分かれていてもチェックが欠落することはない
    - 欠点: 関数ポインタからの呼び出しでチェックを省略できない
4. 両側でチェックする
    - 特徴: 元のABIを維持しながら、呼び出し側と呼び出し先側の両方でチェックを行う
    - 利点: 呼び出し側でも事後条件に関する最適化ポイントが得られる。翻訳単位が分かれていてもそれぞれの側でオンオフを切り替えられ、どちらかの側でチェックが有効になっていればチェックされる
    - 欠点: 契約チェックが重複するため、オーバーヘッドが発生する可能性がある
5. 遅延チェック
    - 特徴: 実際のチェックは行わず、契約を保留にしておき、プロファイラやデバッガなどの外部ツールからの要求に応じて評価する
    - 利点: 高コストな契約チェックを必要な場合にのみ実行できるため、実行時のオーバーヘッドを削減できる
    - 欠点: 契約違反の検出が遅れる可能性がある。この機構そのものに避け難いオーバーヘッドがある
6. 実行時のセマンティクス選択
    - 特徴: グローバルなクエリ関数によって実行時に契約チェックの有効無効を取得し、有効な場合にのみチェックを行う
    - 利点: パッケージマネージャ等のビルド済みライブラリを配布する存在が、契約の有効無効で配布するバイナリを分ける必要が無い
    - 欠点: 実行時のオーバーヘッドが追加される
7. ロード時のセマンティクス選択
    - 特徴: 環境変数などを介して、プログラムロード時に契約チェックを行うかどうかを決定する
    - 利点: 6のアプローチと同じメリットが得られ、実行時オーバーヘッドを回避できる
    - 欠点: 関数のインライン化を阻害する

このような実装を考慮することで、各実装アプローチによる契約条件評価回数を求めることができます。

|アプローチ|評価回数の最小値|評価回数の最大値|
|---|---|---|
|全て呼び出し先でチェック|1|1|
|呼び出し側チェック（3）|0|1|
|呼び出し側チェック（4）|1|1|
|両側チェック|2|2|
|遅延チェック|0|1(∞)|
|実行時セマンティクス選択|0|1|
|ロード時セマンティクス選択|0|1|

この文書はどのアプローチが良いかを提案するものではなく、可能なアプローチを列挙子比較する単一の文書を提供することを目的とするものです。

### [P3268R0 C++ Contracts Constification Challenges Concerning Current Code](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3268r0.html)

契約注釈内での暗黙`const`化の影響を見積もる文書。

現在の契約プログラミング機能の仕様では、契約注釈内から参照される外部のもの（関数引数・ローカル変数）は暗黙に`const`として扱われますが、これに対してコードの他の部分との不一致等の懸念が提起されています。

この文書は、筆者の方の所属する企業のコードベースの調査によって、それがどの程度影響するかを見積もったものです。

結果としては、（このコードベースでは）300個に1個のアサートについて注意が必要（`const`化の影響を受ける可能性がある）で、そのような行は100000行に1行程度発生すると報告しています。

そして、結論としては暗黙`const`化によるコードベースヘの影響は小さく、その仕様を削除する必要は無いとしています。

### [P3269R0 Do Not Ship Contracts as a TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3269r0.pdf)

契約プログラミング機能をTSとして出荷することに反対する提案。

契約プログラミング機能の提案（P2900R6）がEWGに転送されて以降、あるベンダが契約プログラミング機能のある側面について継続的に反対している他、いくつかの側面でEWGで合意が取れていないことが分かりました。それを受けてP3265R0では契約プログラミング機能をTSとして出荷することを提案しています。

この提案は、それとは逆に契約プログラミング機能はTSを目指さずにC++26に導入すべき、とするものです。

提案ではTSではなく直接ISを目指すべき理由として次の事を挙げています

- 契約プログラミング機能はC++の安全性向上に役立つ
    - 安全性の向上は急務
- 将来の拡張のための基礎
    - 現在の契約プログラミング機能は完全なものを目指しておらず、将来拡張可能な現在合意できる最小のもの
    - TSで達成できることは、C++26に入れても達成できる
- Contracts MVPは品質の妥協ではない
    - MVPは機能セットの妥協であり、これはWG21が合意可能な最小のものであって、品質の妥協ではない
    - C++26に間に合わない場合はTSではなくC++29を目指すべき

また、TSが有用ではない理由として次の事を挙げています

- 時間とリソースの非効率な使用
    - TSプロセスは時間と手間がかかる
        - 公開だけで1年かかる
    - そのためのリソースを、現在のP2900R6に対する意見の相違点や問題の解消に費やすべき
    - そもそも、TSに行くべきかを検討するこの時間ももったいない
- 実装経験を得るためにTSは不要
    - 妥当な品質の仕様書とそれを実装する時間と資金があれば、実装経験を得ることができる
    - 仕様書がTSとして公開されているかは重要ではない
- TSは未解決の問題の解決に役立たない
    - TSを公開する前に、TSが回答すべき質問のリストを作成する必要がある
    - P2900R6に対するそのようなリストはすでに得られており、C++26サイクルの残りの時間で解決可能であると見積もられている

最後に、現在のContracts MVP（P2900R6）に対する未解決の問題をここでもまとめています

- 仮想関数に対する契約
    - まだMVPにマージ前だが成熟した提案がすでにあるため、C++26に間に合うと考えられる
- 関数ポインタと契約
    - MVPは既に、関数が関数ポインタから呼ばれる場合でも契約条件がチェックされることを求めている
    - 関数ポインタ自体に対する契約注釈は、現在のC++のモデルに適合しないためMVPの範囲外
- コルーチンに対する契約
    - コルーチンでは事前条件と事後条件がサポートされていない
    - SG21およびEWGのほとんどの人はこれはMVPの範囲外だと考えている
- 評価回数と暗黙`const`について
    - 最近特に議論されている分野であり、提案もいくつも出揃っている
    - 解決策はどれも、どれが間違っているというものではなく、何を優先すべきかが異なるだけ
    - この優先すべきものを決めるだけであり、この作業は既に始まっている
- 違反ハンドラからの例外送出
    - 違反ハンドラからの例外送出を許可する・しないのトレードオフについては、議論し合意を得る必要がある
    - 不可能な作業ではなく、TSは役に立たない
- 標準ライブラリでの契約の使用
    - TSを出荷しても、この問題の解決には役に立たない
    - 現在のところ、標準ライブラリの仕様に契約注釈を規定することは時期尚早であり、実装を許可するものの必須とはしないコンセンサスがある
- 契約と未定義動作
    - 契約注釈は、それが存在する場所よりも後の未定義動作（のタイムトラベル最適化）による影響と、契約条件式内での未定義動作による影響の2種類の影響を受ける
    - いずれの問題も、一定の解決を合意済み
    - 未定義動作を制限するサブセットの利点は不明であり、TSにしたとしてもこの解決に役立たない
    - 契約注釈の問題は、安全ではないことではなく存在しないこと

SG21では契約をTSとしないことに合意が取れているようですが、最終的に決定するのはEWGのようです。

- [P3265 進行状況](https://github.com/cplusplus/papers/issues/1921)

### [P3270R0 Repetition, Elision, and Constification w.r.t. contract_assert](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3270r0.pdf)

`contract_assert`の現在の問題点について、原則に照らして検討する提案。

この提案ではまず、契約注釈の現在の仕様に関する次の2つの問題点

1. 契約条件式内での変数のデフォルト`const`化
2. 実行時の契約条件式の評価回数
    - 2回以上評価される可能性があり、省略可能でもあること

について、特に`contract_assert`がこの懸念点を解消可能であるか、他の契約注釈とどの程度異なる必要があるかなどについて検討しています。

提示されているソリューションにおいては、次の機能単位毎に取り除くとどうなるかについて検討しています

- **EL** (Elision Clause): コンパイル時に述語が常に偽と判断できる場合に、その評価を省略できる規定
- **RE** (Repetition): 述語を複数回評価することを巨kする規定
- **IM** (Implementation Latitude): 一つの翻訳単位内で、全て同じ契約注釈のセマンティクス（チェックするかしないか）を適用することを許可する
    - Cアサートのように、1つのフラグで全ての契約注釈のセマンティクスを一括制御する

提示されているソリューションは次の6つです

- **ソリューション A: C++26では何もせず、C++29を待つ**
    - 利点:  C++29に向けて、あらゆる選択肢を残せる
    - 欠点:  C++26では現状の問題が解決されない
- **ソリューション B: P2900を現状(P2900R7)のまま維持**
    - 利点:
        - `contract_assert`の仕様が、`pre`や`post`と一貫性を保てる
        - ライブラリ側とアプリケーション側で独立したチェックが可能になる
        - 教える内容が少なく、副作用についても深く教えなくて済む
        - `const` 化との整合性が取れる
        - 破壊的な副作用を含む単体テストやベータテストが容易になる
        - デフォルトで副作用の使用を抑止できる
        - 実装の選択肢が最も広範囲に渡る
        - デフォルトの動作を、後方互換性を保ちながらソリューション C、D、E、または F に移行できる
    - 欠点:  現状の問題が解決されない可能性がある
- **ソリューション C: 省略条項 (EL) を削除した P2900 (P2900 - EL)**
    - 利点:
        - 述語を複数回繰り返すことで、破壊的な副作用のテストが可能になる
        - 静的に0であると証明できない冪等な副作用への依存が可能になる
        - デフォルトの動作を、後方互換性を保ちながらソリューション E または F に移行できる
    - 欠点:  副作用の扱いに関する問題が残る可能性がある
- **ソリューション D: 繰り返し (RE) を削除した P2900 (P2900 - RE)**
    - 利点:
        - 表明述語の評価コストが増加することがない
        - 既存の開発者にとって馴染みやすい方法で教えられる
        - デフォルトの動作を、後方互換性を保ちながらソリューション E または F に移行できる
    - 欠点:  柔軟性が低く、いくつかのユースケースに対応できない可能性がある
- **ソリューション E: 省略 (EL) と繰り返し (RE) を削除した P2900 (P2900 - EL - RE)**
    - 利点:
        - ソリューションCとDの利点を併せ持つ
        - デフォルトの動作を、後方互換性を保ちながらソリューション F に移行できる
    - 欠点:  柔軟性がさらに低くなり、適用範囲が限定される
- **ソリューション F: 省略 (EL)、繰り返し (RE) を削除し、翻訳単位ごとに1種類のセマンティクス（チェック済みまたはチェックなし）のみを持つ P2900 (P2900 - EL - RE - IM)**
    - 利点:
        - ソリューションC, D, Eの利点を併せ持つ
        - C の `assert` と同様に動作し、翻訳単位ごとに契約アサーションがすべてチェックされるか、すべてチェックされないかのいずれかになる
    - 欠点:
        - 後方互換性を保つ移行パスがない
        - 柔軟性が最も低く、`pre`や`post`との整合性が低い

そして、この作業の過程で現在の`assert`マクロを完全に代替することのできるソリューションが無いという新たな問題が認識されたため、その対策としてP3290で提案されているソリューションを現在のContracts MVPにマージすることを提案しています。

P3290の詳細は後の方で詳しく説明しますが、概ね次の3つのものからなります

1. 従来のアサーションシステムが契約違反ハンドラを呼び出せるようにするためのAPIの提供
2. C++における`assert`マクロの定義を変更して、`cerr`に診断を出力する代わりに契約違反ハンドラを（条件付きで）呼び出せるようにする
    - これにより、ソースコードの変更なしで（場合によっては再コンパイルなしで）既存のコードは契約違反ハンドラを利用できる
3. `contract_assert`をミラーする新しいキーワードを提供する
    - このキーワードによるアサーションは、デフォルトでC++標準の`assert`マクロとフラグ互換の動作をする
    - 既存のC`assert`からの移行を容易にチェックできる

結論としては、先に挙げた6つのソリューションのいずれよりも、現在のContracts MVPにP3290R0をマージしたもの（P2900R7 + P3290R0）が適しているとして、このソリューションを推しています。

- [P3004R0 Principled Design for WG21 - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3004R0-Principled-Design-for-WG21)
- [P3270 進行状況](https://github.com/cplusplus/papers/issues/1926)

### [P3271R0 Function Usage Types (Contracts for Function Pointers)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3271r0.pdf)

契約注釈を指定可能な新しい関数型の提案。

内部で呼び出す操作を引数で受け取る関数`fancy_calculation()`があるとします。この`fancy_calculation()`は渡される関数に対して次の事を期待しています

- 関数は`int`型の引数を1つだけ取る
- 関数は`int`型の結果を返す
- 関数に渡す引数は正の値
- 関数の結果は正の値であり、渡した数より大きくはならない

例えば次の関数はこの要件を満たすものです

```cpp
int identity( const int x ) { return x; }
int halve ( const int x ) { return x/2; }
```

一方で、満たさないものも容易に考えることができます

```cpp
int twice ( const int x ) { return 2*x; }
```

`fancy_calculation()`のユーザーは関数ポインタや関数参照を使用して`fancy_calculation()`に関数を渡すことができます。

```cpp
int fancy_calculation(int(&f)(int));
```

`fancy_calculation()`は内部で渡された関数を呼び出します。

ユーザーはまた、渡す関数（の候補）に対して契約注釈を指定している場合があります。

```cpp
int identity( const int x ) post( r: r == x );
int halve ( const int x ) post( r: r == x/2 );
int twice ( const int x ) pre( can_multiply(2,x) ) post( r: r == 2*x );
```

`fancy_calculation()`の提供者は契約注釈を使用してこの関数の契約を明文化してチェックを行おうとします

```cpp
int fancy_calculation( int(&op)(int), const int start )
  pre( start >= 0 )
  post( r: r >= 0 )
  post( r: r <= start )
  post( r: r == op(r) );
```

しかし、これらのアサーションは`fancy_calculation()`の動作についてのもので、`fancy_calculation()`が受け取って内部で呼び出す操作（`op`）についてのものではありません。そのようなものを書く方法で現在の契約プログラミング機能でサポートされている方法として、`contract_assert()`によって実際の呼び出し前後でチェックを行う、という方法があります。

```cpp
int fancy_calculation( int(&op)(int), int start ) {
  int current = start;

  while( true )
  {
    contract_assert( current >= 0 ); // our responsibility
    
    int next = op( current );
    
    contract_assert( next >= 0 ); // Not our responsibility: these
    contract_assert( next <= current ); // fail if op was poorly chosen.
    
    if ( current == next )
      break;

    current = next;
  }
  
  return current;
}
```

この方法はあまり良い方法とは言えません。呼び出しが複数回に及ぶ場合冗長でエラーが発生しやすくなり、これらのアサーションのための追加コードが必要になる場合もあります。そして、これらのアサーションは本来`op`を渡すユーザー側に対してその要件を通知するものですが、関数を呼び出すコードからは見えなくなっています。

このような用途に適したソリューションが必要であり、この提案はそのソリューションを提供しようとするものです。

この提案では、いくつかのステップを踏んでそのようなソリューションを構成しています。

#### 1. `fancy_calculation()`が渡される関数に課す要件を名前の下にまとめる

例えば、次のような関数型likeな記述によってその要件を表現します

```cpp
int fancy_op( const int x ) usage
  pre( x >= 0 )
  post( r: r >= 0 )
  post( r: r <= x );
```

これはこの提案で関数利用型（*function usage type*）と呼ばれている、新しい関数型です。この型は`int(int)`な関数が特定の呼び出し元によって使用される方法について記述しています。

#### 2. `fancy_calculation()`で使用するためにある関数を選んだ時点で、その関数が`fancy_op`での使用を意図していることを明示する構文を使用する

```cpp
void print_fancy_results( int start ) {
  const std::array ops = {
    &fancy_op{identity},  // good choice
    &fancy_op{halve},     // good choice
    &fancy_op{twice}      // bad choice!
  };

}
```

`fancy_op{identity}`は`identity()`関数を参照する`fancy_op`型の左辺値式であり、コンパイルの時点で、`fancy_calculation()`に渡す操作の利用契約と選ばれた関数の契約注釈の両方が、それを検証しようとするツールで利用可能になります。ただし、この提案ではこのような検証までも提案はしていません。

#### 3. 型システムによって、使用する関数が選ばれた時点から呼び出される時点までの保管チェーンを作成し、各ステップで保管されている関数が使用方法に適合していることを表明する

```cpp
int fancy_calculation( fancy_op& op, int start );
  // halve/twiceはfancy_op&引数に束縛できないが、fancy_op{halve}/fancy_op{twice}は束縛できる
```

`fancy_op`のポインタ/参照は、単なる`int(int)`のポインタ/参照あるいはほかの関数利用型のポインタ/参照とは型レベルで異なります。想定する実装では、`fancy_op`のポインタ/参照は`int(int)`へのポインタ/参照と同じ実行時表現を持ち、型の区別はコンパイル時とリンク時の処理のために使用されます。

#### 4. `fancy_op`のポインタ/参照を介して間接呼び出しが行われる場合、`fancy_op`で記述されている要件がその呼び出し時に満たされているかチェックされる

ここでチェックされる条件は参照先にある関数の契約注釈とは無関係にチェックされるもので、`fancy_op`の利用側が課す追加条件となる。

```cpp
int fancy_calculation( fancy_op& op, int start ) {
  
  ...
  
  int next = op( current );
  // 実行は次の順序で行われる:
  // fancy_opの事前条件チェック
  // 参照先関数の事前条件チェック
  // 参照先関数の本体実行
  // 参照先関数の事後条件チェック
  // fancy_opの事後条件チェック
  
  ...
}
```

例えばopに`twice`が使用されて、`twice()`の事前条件違反と`fancy_op`の事後条件違反が起こると、`twice()`を選択した誤りがここで検出されます。

この提案はこのように、契約注釈を指定可能な新たな関数型を導入して、それに対する関数参照/ポインタを導入することで、参照される関数の契約とは別に、個別の関数参照/ポインタの用途ごとに特化した契約を持つ関数参照/ポインタを作成できるようにしようとするものです。

この提案では、契約が関数の型を変更すべきではなく、型システムに複雑さを持ち込むべきではなく、既存のコードベースへの統合に過度の変更を要求すべきではないという設計原則を重視しており、これらを達成することでこの提案の変更は、C++プログラムにおける契約と関数ポインタのより堅牢でユーザーフレンドリーな相互作用を目指しています。

この提案はひとまず、MVP後の契約プログラミング機能の拡張案として検討していくことがSG21で確認されています。

- [P3271 進行状況](https://github.com/cplusplus/papers/issues/1927)

### [P3273R0 Introspection of Closure Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3273r0.html)

静的リフレクション機能で、ラムダ式のクロージャ型からの情報取得をサポートする提案。

ラムダ式のクロージャ型はあまり詳細にその型の性質について指定されておらず、特に参照キャプチャした場合にクロージャ型の非静的データメンバに対応する何かが存在するかどうかは未規定とされています。これはラムダ式の実装において最適化を行うことを意図したもののようです。

しかし、C++26へ向けて進行中の静的リフレクション機能（P2996）ではこのために、クロージャ型のレイアウトに関するリフレクションの適用をどうするかが問題となっているようです。

クロージャ型は計算とそれに関するデータをひとまとめにパッケージングして扱うための簡単な方法であり、標準アルゴリズムをはじめとしてC++プログラミングの様々な部分で広く使用されています。特に、CUDAにおいては、GPUでアルゴリズムを実行することを重視しており（標準並列アルゴリズムやThrust）、クロージャ型を特別に扱ってホストとデバイスの両側で透過的に使用できるようにしています。

クロージャ型を静的リフレクションで支障なく扱えることは、GPU以外のメモリアドレス空間を跨いでデータや計算をマーシャリングする必要があるコード（ネットワーク、プロセス間通信、シリアライズなど）においても有用となります。

このような機会を閉ざさないようにするために、この提案はクロージャ型が参照キャプチャした場合のレイアウトを予測可能にすることで、リフレクションにおける適用可能性の問題を解消しようとするものです。

この提案では、参照キャプチャしたラムダ式のクロージャ型に関する現在の規定（参照キャプチャに対応する非静的メンバ変数が存在するかは未規定）を変更して、参照キャプチャの場合でも参照キャプチャした物ごとに参照メンバが存在することを規定（無名かつ宣言準は不定）するようにするものです。

この提案では、既存の実装は全て参照キャプチャを参照またはポインタをクロージャ型のメンバとすることによって実現しているため、この変更によって振る舞いの修正が必要となる実装は存在しないか、存在したとしても大きな影響はないとしています。また、クロージャ型の最適化についても、この変更と静的リフレクションの導入後に、静的リフレクションによってクロージャ型の情報を取得されていたとしてもそのラムダ式を最適化することを妨げることはないとしています。

この提案はSG7を全会一致でパスしてEWGに転送されたようです。

- [P2996R0 Reflection for C++26 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2996R0-Reflection-for-C26)
- [P3273 進行状況](https://github.com/cplusplus/papers/issues/1928)

### [P3274R0 A framework for Profiles development](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3274r0.pdf)
### [P3275R0 Replace simd operator[] with getter and setter functions - or not](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3275r0.pdf)
### [P3276R0 P2900 Is Superior to a Contracts TS](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3276r0.pdf)
### [P3278R0 Analysis of interaction between relocation, assignment, and swap](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3278r0.pdf)
### [P3279R0 CWG2463: What 'trivially fooable' should mean](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3279r0.html)
### [P3281R0 Contact checks should be regular C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3281r0.pdf)
### [P3282R0 Static Storage for C++ Concurrent bounded_queue](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3282r0.html)
### [P3283R0 Adding .first() and .last() to strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3283r0.html)
### [P3284R0 `finally`, `write_env`, and `unstoppable` Sender Adaptors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3284r0.html)
### [P3285R0 Contracts: Protecting The Protector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3285r0.pdf)
### [P3286R0 Module Metadata Format for Distribution with Pre-Built Libraries](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3286r0.pdf)
### [P3287R0 Exploration of namespaces for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3287r0.pdf)
### [P3288R0 std::elide](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3288r0.html)
### [P3289R0 Consteval blocks](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3289r0.html)
### [P3290R0 Integrating Existing Assertions With Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3290r0.pdf)
### [P3292R0 Provenance and Concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3292r0.html)
### [P3293R0 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3293r0.html)
### [P3294R0 Code Injection with Token Sequences](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3294r0.html)
### [P3295R0 Freestanding constexpr containers and constexpr exception types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3295r0.html)
### [P3296R0 let_with_async_scope](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3296r0.html)
### [P3297R0 C++26 Needs Contract Checking](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3297r0.pdf)
### [P3298R0 Implicit user-defined conversion functions as operator.()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3298r0.pdf)
### [P3299R0 Range constructors for std::simd](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3299r0.html)
### [P3301R0 inplace_stoppable_base](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3301r0.html)
### [P3302R0 SG16: Unicode meeting summaries 2024-03-13 through 2024-05-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3302r0.html)
### [P3303R0 Fixing Lazy Sender Algorithm Customization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3303r0.html)
### [P3304R0 SG14: Low Latency/Games/Embedded/Financial Trading virtual Meeting Minutes 2024/04/10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3304r0.pdf)
### [P3305R0 SG19: Machine Learning virtual Meeting Minutes to 2024/04/11-2024/05/09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3305r0.pdf)
### [P3306R0 Atomic Read-Modify-Write Improvements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3306r0.html)
### [P3307R0 Floating-Point Maximum/Minimum Function Objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3307r0.html)
### [P3308R0 mdarray design questions and answers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3308r0.html)
### [P3309R0 constexpr atomic and atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3309r0.html)
### [P3310R0 Solving partial ordering issues introduced by P0522R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3310r0.html)
### [P3311R0 An opt-in approach for integration of traditional assert facilities in C++ contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3311r0.html)
### [P3312R0 Overload Set Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3312r0.pdf)
### [P3313R0 Impacts of noexept on ARM table based exception metadata](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3313r0.html)
### [P3316R0 A more predictable unchecked semantic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3316r0.pdf)
### [P3317R0 Compile time resolved contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3317r0.pdf)
### [P3318R0 Throwing violation handlers, from an application programming perspective](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3318r0.html)
### [P3319R0 Add an iota object for simd (and more)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3319r0.pdf)
### [P3320R0 EWG slides for P3144 "Delete if Incomplete"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3320r0.pdf)
### [P4000R0 To TS or not to TS: that is the question](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p4000r0.pdf)
