# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´09æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers mailing2025-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-09)

å…¨éƒ¨ã§37æœ¬ã‚ã‚Šã¾ã™ã€‚

ã‚‚ãã˜

[:contents]

### [N5020 2026-11 BÃºzios Meeting Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5020.html)
### [P2953R2 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r2.html)
### [P3347R5 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r5.pdf)
### [P3567R1 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r1.html)
### [P3579R2 Fix matching of constant template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r2.html)
### [P3612R0 Harmonize proxy-reference operations (LWG 3638 and 4187)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3612r0.html)

`vector<bool>::reference`ã¨`bitset<N>::reference`ã®é–“ã§ä¸€è²«ã—ãŸIssueè§£æ±ºã‚’è¡Œã†ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯`vector<bool>::reference`ã¨`bitset<N>::reference`ã«é–¢ã™ã‚‹æ¬¡ã®2ã¤ã®ã‚¤ã‚·ãƒ¥ãƒ¼è§£æ±ºã®éš›ã«ã€è¿½åŠ ã™ã‚‹`swap()/operator=`ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å…±é€šåŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [LWG Isse 3638 `vector<bool>::swap(reference, reference)` is useless](https://cplusplus.github.io/LWG/issue3638)
- [LWG Isse 4187 `bitset::reference` should be const-assignable](https://cplusplus.github.io/LWG/issue4187)

P2321ï¼ˆ`views::zip`ã®ææ¡ˆï¼‰ã§ã¯`views::zip`ã®å‹•ä½œã®ãŸã‚ã«`vector<bool>::reference`ã«ä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;

      ...
    };
   };
}
```

ãƒ—ãƒ­ã‚¯ã‚·å‚ç…§å‹ã¯`const`ã§ã‚‚ä»£å…¥å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚‚ã®ã®`vector<bool>::reference`ã¯`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒã£ã¦ã„ãªã‹ã£ãŸãŸã‚ã€å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã—ã¤ã¤ãã‚Œã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã®æ™‚ã€ãã®æˆ»ã‚Šå€¤å‹ã¯`reference`ã®prvalueã§ã¯ãªãã€`const`lvalueã¨ã•ã‚Œã¾ã—ãŸï¼ˆãªãœã‹ã¯ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ï¼‰ã€‚

ã“ã®`vector<bool>::reference`ã¯`std::swap`ãŒæ„å›³é€šã‚Šã«å‹•ä½œã—ãªã„ãŸã‚`swap()`ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€`vector<bool> v`ã«å¯¾ã—ã¦`std::swap(v[1], v[2])`ãŒæ©Ÿèƒ½ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‚ã®ã®ã€`std::swap`ã¯é`const`å‚ç…§ã—ã‹å–ã‚‰ãªã„ãŸã‚å‘¼ã³å‡ºã›ã¾ã›ã‚“ã€‚ã¾ãŸã€å‘¼ã³å‡ºã›ãŸã¨ã—ã¦ã‚‚ã€`std::swap`ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ã‚ã‚‹`Reference t = r1; r1 = r2; r2 = t;`ã®æ§˜ãªäº¤æ›æ“ä½œã¯`vector<bool>::reference`ã®ã‚³ãƒ”ãƒ¼ã¯å‚ç…§ã®ã‚³ãƒ”ãƒ¼ã«ãªã‚‹ãŸã‚ã€å‚ç…§å…ˆã®`bool`å€¤ã‚’äº¤æ›ã—ãªã„ãŸã‚ã§ã™ã€‚

LWG Isse 3638ã¯ã“ã‚Œã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ä¸€æ–¹ã€`vector<bool>::reference`ã¨ã»ã¼åŒã˜å‹•ä½œã‚’ã™ã‚‹ã‚‚ã®ã«ã€`bitset<N>::reference`ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];

      ...
    };
  };
}
```

ã“ã¡ã‚‰ã¯P2321ã§å¤‰æ›´ã•ã‚Œãªã‹ã£ãŸï¼ˆ`bitset`ãŒ`range`ã§ã¯ãªã„ãŸã‚ã¨æ€ã‚ã‚Œã‚‹ï¼‰ãŸã‚ã€`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒãŸãšã€`swap`ã«ã¤ã„ã¦åŒæ§˜ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚LWG Isse 4187ã¯å‰è€…ï¼ˆ`const`ä»£å…¥æ¼”ç®—å­ï¼‰ã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ã“ã‚Œã‚‰2ã¤ã®å‹ã«ã¯å…±é€šç‚¹ãŒå¤šãã‚ã‚‹ã‚‚ã®ã®ã€ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã®è§£æ±ºå¾Œã‚‚å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ä¸€è²«ã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ææ¡ˆã¯ã€ã“ã®ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’åˆã‚ã›ãŸå½¢ã®ä¸€è²«ã—ãŸè§£æ±ºã‚’ä¸¡æ–¹ã®å‹ã«é©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã™ãªã‚ã¡æ¬¡ã®å¤‰æ›´ã‚’é©ç”¨ã—ã¾ã™

- `vector<bool>::reference`
    - ADL `swap()`ã‚’è¿½åŠ 
- `bitset<N>::reference`
    - `const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’è¿½åŠ 
    - ADL `swap()`ã‚’è¿½åŠ 

ææ¡ˆå¾Œã®ä¸¡ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
   };
}
```

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹const ä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;  // ğŸ‘ˆ
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
  };
}
```

`bool&`ã‚’å–ã‚‹2ã¤ã®`swap()`ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€`bool`å‹ã®å·¦è¾ºå€¤`b`ã¨`reference`ã®å·¦è¾ºå€¤`r`ã«å¯¾ã—ã¦`swap(r, b)`ã¨`swap(b, r)`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚ã©ã¡ã‚‰ã®`reference`ã‚‚`bool&`ã‹ã‚‰æš—é»™å¤‰æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã€ã“ã®`swap`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã«ã“ã®2ã¤ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®`default`ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€å®Ÿè£…ã«ã‚ˆã£ã¦ä¸¡ã‚¯ãƒ©ã‚¹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ã«å·®ç•°ãŒã‚ã£ãŸã“ã¨ã‹ã‚‰ã€æ¨™æº–ã¨ã—ã¦ãã‚Œã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã‚’å›é¿ã™ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å®Ÿéš›ã«ã¯ä¸»è¦3å®Ÿè£…å…¨ã¦ã§ãƒˆãƒªãƒ“ã‚¢ãƒ«ã§ã—ãŸãŒã€ã“ã“ã§ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ãŒé‡è¦ã§ã¯ãªã„ã“ã¨ã‹ã‚‰ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åˆã‚ã›ãŸã‚ˆã†ã§ã™ã€‚

- [P3612 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2419)

### [P3666R0 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r0.html)
### [P3688R3 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r3.html)
### [P3695R1 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r1.html)
### [P3702R2 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r2.html)
### [P3754R1 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r1.pdf)
### [P3776R0 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r0.html)
### [P3776R1 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r1.html)
### [P3784R1 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r1.pdf)
### [P3786R0 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r0.pdf)
### [P3811R0 default comparison memory safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3811r0.html)
### [P3812R0 const and & in default member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3812r0.html)
### [P3813R0 execution::task::valueless()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3813r0.pdf)
### [P3815R0 Add scope_association concept to P3149](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3815r0.html)
### [P3816R0 Hashing meta::info](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3816r0.html)
### [P3818R0 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r0.html)
### [P3818R1 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r1.html)
### [P3819R0 Remove evaluation_exception() from contract-violation handling for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)
### [P3820R0 Split constexpr uncaught_exceptions into distinct runtime and consteval functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r0.html)
### [P3820R1 Fix constexpr uncaught_exceptions and current_exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r1.html)
### [P3822R0 Conditional noexcept specifiers in compound requirements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3822r0.html)
### [P3823R0 Wording for US NB comment 10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3823r0.html)
### [P3824R0 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r0.html)
### [P3827R0 Wording for US NB comment 9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3827r0.html)
### [P3829R0 Contracts do not belong in the language](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3829r0.pdf)
### [P3830R0 NB-Commenting is Not a Vehicle for Redesigning inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3830r0.pdf)
### [P3831R0 Contract Labels Should Use Annotation Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3831r0.html)
### [P3832R0 Timed lock algorithms for multiple lockables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3832r0.pdf)
### [P3834R0 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r0.html)
### [P3835R0 Contracts make C++ less safe -- full stop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3835r0.html)
### [P3836R0 Make optional<T&> trivially copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r0.html)
### [P3838R0 Restoring Private Module Fragments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3838r0.pdf)

- [ é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/)
