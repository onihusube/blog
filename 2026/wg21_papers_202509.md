# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´09æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers mailing2025-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-09)

å…¨éƒ¨ã§37æœ¬ã‚ã‚Šã¾ã™ã€‚

ã‚‚ãã˜

[:contents]

### [N5020 2026-11 BÃºzios Meeting Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5020.html)
### [P2953R2 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r2.html)
### [P3347R5 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r5.pdf)
### [P3567R1 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r1.html)
### [P3579R2 Fix matching of constant template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r2.html)
### [P3612R0 Harmonize proxy-reference operations (LWG 3638 and 4187)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3612r0.html)

`vector<bool>::reference`ã¨`bitset<N>::reference`ã®é–“ã§ä¸€è²«ã—ãŸIssueè§£æ±ºã‚’è¡Œã†ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯`vector<bool>::reference`ã¨`bitset<N>::reference`ã«é–¢ã™ã‚‹æ¬¡ã®2ã¤ã®ã‚¤ã‚·ãƒ¥ãƒ¼è§£æ±ºã®éš›ã«ã€è¿½åŠ ã™ã‚‹`swap()/operator=`ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å…±é€šåŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [LWG Isse 3638 `vector<bool>::swap(reference, reference)` is useless](https://cplusplus.github.io/LWG/issue3638)
- [LWG Isse 4187 `bitset::reference` should be const-assignable](https://cplusplus.github.io/LWG/issue4187)

P2321ï¼ˆ`views::zip`ã®ææ¡ˆï¼‰ã§ã¯`views::zip`ã®å‹•ä½œã®ãŸã‚ã«`vector<bool>::reference`ã«ä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;

      ...
    };
   };
}
```

ãƒ—ãƒ­ã‚¯ã‚·å‚ç…§å‹ã¯`const`ã§ã‚‚ä»£å…¥å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚‚ã®ã®`vector<bool>::reference`ã¯`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒã£ã¦ã„ãªã‹ã£ãŸãŸã‚ã€å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã—ã¤ã¤ãã‚Œã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã®æ™‚ã€ãã®æˆ»ã‚Šå€¤å‹ã¯`reference`ã®prvalueã§ã¯ãªãã€`const`lvalueã¨ã•ã‚Œã¾ã—ãŸï¼ˆãªãœã‹ã¯ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ï¼‰ã€‚

ã“ã®`vector<bool>::reference`ã¯`std::swap`ãŒæ„å›³é€šã‚Šã«å‹•ä½œã—ãªã„ãŸã‚`swap()`ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€`vector<bool> v`ã«å¯¾ã—ã¦`std::swap(v[1], v[2])`ãŒæ©Ÿèƒ½ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‚ã®ã®ã€`std::swap`ã¯é`const`å‚ç…§ã—ã‹å–ã‚‰ãªã„ãŸã‚å‘¼ã³å‡ºã›ã¾ã›ã‚“ã€‚ã¾ãŸã€å‘¼ã³å‡ºã›ãŸã¨ã—ã¦ã‚‚ã€`std::swap`ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ã‚ã‚‹`Reference t = r1; r1 = r2; r2 = t;`ã®æ§˜ãªäº¤æ›æ“ä½œã¯`vector<bool>::reference`ã®ã‚³ãƒ”ãƒ¼ã¯å‚ç…§ã®ã‚³ãƒ”ãƒ¼ã«ãªã‚‹ãŸã‚ã€å‚ç…§å…ˆã®`bool`å€¤ã‚’äº¤æ›ã—ãªã„ãŸã‚ã§ã™ã€‚

LWG Isse 3638ã¯ã“ã‚Œã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ä¸€æ–¹ã€`vector<bool>::reference`ã¨ã»ã¼åŒã˜å‹•ä½œã‚’ã™ã‚‹ã‚‚ã®ã«ã€`bitset<N>::reference`ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];

      ...
    };
  };
}
```

ã“ã¡ã‚‰ã¯P2321ã§å¤‰æ›´ã•ã‚Œãªã‹ã£ãŸï¼ˆ`bitset`ãŒ`range`ã§ã¯ãªã„ãŸã‚ã¨æ€ã‚ã‚Œã‚‹ï¼‰ãŸã‚ã€`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒãŸãšã€`swap`ã«ã¤ã„ã¦åŒæ§˜ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚LWG Isse 4187ã¯å‰è€…ï¼ˆ`const`ä»£å…¥æ¼”ç®—å­ï¼‰ã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ã“ã‚Œã‚‰2ã¤ã®å‹ã«ã¯å…±é€šç‚¹ãŒå¤šãã‚ã‚‹ã‚‚ã®ã®ã€ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã®è§£æ±ºå¾Œã‚‚å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ä¸€è²«ã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ææ¡ˆã¯ã€ã“ã®ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’åˆã‚ã›ãŸå½¢ã®ä¸€è²«ã—ãŸè§£æ±ºã‚’ä¸¡æ–¹ã®å‹ã«é©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã™ãªã‚ã¡æ¬¡ã®å¤‰æ›´ã‚’é©ç”¨ã—ã¾ã™

- `vector<bool>::reference`
    - ADL `swap()`ã‚’è¿½åŠ 
- `bitset<N>::reference`
    - `const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’è¿½åŠ 
    - ADL `swap()`ã‚’è¿½åŠ 

ææ¡ˆå¾Œã®ä¸¡ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
   };
}
```

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹const ä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;  // ğŸ‘ˆ
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
  };
}
```

`bool&`ã‚’å–ã‚‹2ã¤ã®`swap()`ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€`bool`å‹ã®å·¦è¾ºå€¤`b`ã¨`reference`ã®å·¦è¾ºå€¤`r`ã«å¯¾ã—ã¦`swap(r, b)`ã¨`swap(b, r)`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚ã©ã¡ã‚‰ã®`reference`ã‚‚`bool&`ã‹ã‚‰æš—é»™å¤‰æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã€ã“ã®`swap`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã«ã“ã®2ã¤ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®`default`ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€å®Ÿè£…ã«ã‚ˆã£ã¦ä¸¡ã‚¯ãƒ©ã‚¹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ã«å·®ç•°ãŒã‚ã£ãŸã“ã¨ã‹ã‚‰ã€æ¨™æº–ã¨ã—ã¦ãã‚Œã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã‚’å›é¿ã™ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å®Ÿéš›ã«ã¯ä¸»è¦3å®Ÿè£…å…¨ã¦ã§ãƒˆãƒªãƒ“ã‚¢ãƒ«ã§ã—ãŸãŒã€ã“ã“ã§ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ãŒé‡è¦ã§ã¯ãªã„ã“ã¨ã‹ã‚‰ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åˆã‚ã›ãŸã‚ˆã†ã§ã™ã€‚

- [P3612 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2419)

### [P3666R0 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r0.html)
### [P3688R3 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r3.html)
### [P3695R1 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r1.html)
### [P3702R2 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r2.html)
### [P3754R1 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r1.pdf)
### [P3776R0 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r0.html)
### [P3776R1 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r1.html)
### [P3784R1 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r1.pdf)
### [P3786R0 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r0.pdf)
### [P3811R0 default comparison memory safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3811r0.html)

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªå®‰å…¨ã§ã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

C++20ã§è¿½åŠ ã•ã‚ŒãŸæ¯”è¼ƒæ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã«ãŠã„ã¦ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã‹ãªã‚Šå˜ç´”ã‹ã¤ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆçš„ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€UBãƒ•ãƒªãƒ¼ã§å®Ÿè£…ã§ãã‚‹ã¯ãšã§ã™ã€‚ã“ã®ææ¡ˆã¯ã€æ¨™æº–ã¨ã—ã¦ãã®ã‚ˆã†ãªå®Ÿè£…ã‚’è¡Œã†ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã§ã™ã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã¯ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

```cpp
class TotallyOrdered : Base {
    string tax_id;
    string first_name;
    string last_name;
public:
  // auto operator<=>(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  std::strong_ordering operator<=>(const TotallyOrdered& that) const {
    if (auto cmp = (Base&)(*this) <=> (Base&)that; cmp != 0) return cmp;
    if (auto cmp = last_name <=> that.last_name; cmp != 0) return cmp;
    if (auto cmp = first_name <=> that.first_name; cmp != 0) return cmp;

    return tax_id <=> that.tax_id;
  }

  // bool operator==(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  bool operator==(const TotallyOrdered& that) const {
    if (!((Base&)(*this) == (Base&)that)) return false;
    if (!(last_name == that.last_name)) return false;
    if (!(first_name == that.first_name)) return false;

    return tax_id == that.tax_id;

  }
};
```

å®Ÿéš›ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã‚‚ã®ã®ã€ã“ã‚Œã¨å¤§ããç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚‚ãªã„ã¯ãšã§ã™ã€‚ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã¯ã€ä½¿ç”¨ã™ã‚‹å„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒæ¼”ç®—å­ï¼ˆ`== <=>`ï¼‰ã‚’é™¤ã„ã¦æœªå®šç¾©å‹•ä½œã‚’æ··å…¥ã•ã›ã‚‹ã“ã¨ãªãå®Ÿè£…ãŒã§ãã‚‹ã¯ãšã§ã™ã€‚ã¾ãŸã€`<=> ==`ãŒãã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ã€ãã“ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹ä»–ã®æ¯”è¼ƒæ¼”ç®—å­ã§ã‚‚åŒæ§˜ã®ä¿è¨¼ã‚’æä¾›ã§ãã¾ã™ã€‚

- [P3811 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2423)

### [P3812R0 `const` and `&` in default member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3812r0.html)

`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’å¯èƒ½ã«ã™ã‚‹ææ¡ˆã€‚

ã‚¯ãƒ©ã‚¹ã®éé™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨ã—ã¦`const`ã‚ã‚‹ã„ã¯å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã¨ã€ãã®ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªããªã‚Šã¾ã™ã€‚

```cpp
// least privilege
class leastp final {
public:
  leastp(std::vector<int>& v, int i)
      : v{v}, i{i} {}

  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ãã‚‹
  leastp(const leastp&) = default;
  leastp(leastp&&) = default;

  // ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªã„ï¼ˆdeleteã•ã‚Œã‚‹
  leastp& operator=(const leastp& other) = default;
  leastp& operator=(leastp&& other) = default;

  // least privilege
  constexpr size_t size() const {
      return v.size();
  }

private:
  std::vector<int>& v;
  const int i;
};
```

ã“ã‚Œã¯ä»£å…¥æ¼”ç®—å­ã‚’æ‰‹æ›¸ããã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã¨æ€ã‚ã‚Œã¾ã™ãŒã€å‚ç…§ã‚„`const`ãƒ¡ãƒ³ãƒã¯åŸºæœ¬çš„ã«ç½®æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã§ã™ã€‚

ã“ã‚Œã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨`*this`ã‚’é…ç½®ã—ãªãŠã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã‚Šã¾ã™

```cpp
class leastp final {
  ...

  leastp& operator=(const leastp& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(other);
    }

    return *this;
  }

  leastp& operator=(leastp&& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(std::move(other));
    }
    
    return *this;
  }

  ...
};
```

ã“ã®ã‚ˆã†ãªå®Ÿè£…ã¯è¤‡é›‘ã§ã‚ã‚Šã€æ­£ã—ãè¨˜è¿°ã™ã‚‹ã“ã¨ãŒå›°é›£ã§ã™ï¼ˆå°‘ã—é–“é•ãˆã‚‹ã¨UBã«çªå…¥ã™ã‚‹ï¼‰ã€‚C++ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«ãŠã„ã¦ã‚‚ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–å¯èƒ½ãªã‚¯ãƒ©ã‚¹ã«`const`ãƒ¡ãƒ³ãƒã‚„å‚ç…§ãƒ¡ãƒ³ãƒã‚’å«ã‚ãªã„ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®ææ¡ˆã¯ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’éé™çš„ãƒ¡ãƒ³ãƒã«æŒã¤ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ã€ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒ`default`æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€é€éçš„ã«ç½®æ›å¯èƒ½ï¼ˆ*transparently replaceable*ï¼‰ã¨ã—ã¦ã€å¯¾å¿œã™ã‚‹ä»£å…¥æ¼”ç®—å­ã‚‚`default`å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã“ã‚Œã«ã‚ˆã£ã¦ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’ä¿æŒã—ãŸã„å ´åˆã«è«¦ã‚ãŸã‚Šä»£ã‚ã‚Šã«ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿æŒã™ã‚‹ãªã©ã®å¿…è¦ãŒãªããªã‚Šã€ä¸Šè¨˜ã®ã‚ˆã†ãªå®Ÿè£…ã‚’å–ã‚‹å ´åˆã®ã‚³ãƒ¼ãƒ‰ã®å¿…è¦æ€§ã‚‚ãªããªã‚Šã€ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚‚ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

- [P3812 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2424)

### [P3813R0 execution::task::valueless()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3813r0.pdf)
### [P3815R0 Add scope_association concept to P3149](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3815r0.html)
### [P3816R0 Hashing meta::info](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3816r0.html)
### [P3818R0 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r0.html)
### [P3818R1 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r1.html)
### [P3819R0 Remove evaluation_exception() from contract-violation handling for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)
### [P3820R0 Split constexpr uncaught_exceptions into distinct runtime and consteval functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r0.html)
### [P3820R1 Fix constexpr uncaught_exceptions and current_exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r1.html)
### [P3822R0 Conditional noexcept specifiers in compound requirements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3822r0.html)
### [P3823R0 Wording for US NB comment 10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3823r0.html)
### [P3824R0 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r0.html)
### [P3827R0 Wording for US NB comment 9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3827r0.html)
### [P3829R0 Contracts do not belong in the language](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3829r0.pdf)
### [P3830R0 NB-Commenting is Not a Vehicle for Redesigning inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3830r0.pdf)
### [P3831R0 Contract Labels Should Use Annotation Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3831r0.html)
### [P3832R0 Timed lock algorithms for multiple lockables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3832r0.pdf)
### [P3834R0 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r0.html)
### [P3835R0 Contracts make C++ less safe -- full stop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3835r0.html)
### [P3836R0 Make optional<T&> trivially copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r0.html)
### [P3838R0 Restoring Private Module Fragments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3838r0.pdf)

- [ é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/)
