# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´09æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers mailing2025-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-09)

å…¨éƒ¨ã§37æœ¬ã‚ã‚Šã¾ã™ã€‚

ã‚‚ãã˜

[:contents]

### [N5020 2026-11 BÃºzios Meeting Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5020.html)
### [P2953R2 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r2.html)
### [P3347R5 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r5.pdf)
### [P3567R1 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r1.html)
### [P3579R2 Fix matching of constant template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r2.html)
### [P3612R0 Harmonize proxy-reference operations (LWG 3638 and 4187)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3612r0.html)

`vector<bool>::reference`ã¨`bitset<N>::reference`ã®é–“ã§ä¸€è²«ã—ãŸIssueè§£æ±ºã‚’è¡Œã†ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯`vector<bool>::reference`ã¨`bitset<N>::reference`ã«é–¢ã™ã‚‹æ¬¡ã®2ã¤ã®ã‚¤ã‚·ãƒ¥ãƒ¼è§£æ±ºã®éš›ã«ã€è¿½åŠ ã™ã‚‹`swap()/operator=`ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å…±é€šåŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [LWG Isse 3638 `vector<bool>::swap(reference, reference)` is useless](https://cplusplus.github.io/LWG/issue3638)
- [LWG Isse 4187 `bitset::reference` should be const-assignable](https://cplusplus.github.io/LWG/issue4187)

P2321ï¼ˆ`views::zip`ã®ææ¡ˆï¼‰ã§ã¯`views::zip`ã®å‹•ä½œã®ãŸã‚ã«`vector<bool>::reference`ã«ä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;

      ...
    };
   };
}
```

ãƒ—ãƒ­ã‚¯ã‚·å‚ç…§å‹ã¯`const`ã§ã‚‚ä»£å…¥å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚‚ã®ã®`vector<bool>::reference`ã¯`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒã£ã¦ã„ãªã‹ã£ãŸãŸã‚ã€å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã—ã¤ã¤ãã‚Œã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã®æ™‚ã€ãã®æˆ»ã‚Šå€¤å‹ã¯`reference`ã®prvalueã§ã¯ãªãã€`const`lvalueã¨ã•ã‚Œã¾ã—ãŸï¼ˆãªãœã‹ã¯ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ï¼‰ã€‚

ã“ã®`vector<bool>::reference`ã¯`std::swap`ãŒæ„å›³é€šã‚Šã«å‹•ä½œã—ãªã„ãŸã‚`swap()`ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€`vector<bool> v`ã«å¯¾ã—ã¦`std::swap(v[1], v[2])`ãŒæ©Ÿèƒ½ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‚ã®ã®ã€`std::swap`ã¯é`const`å‚ç…§ã—ã‹å–ã‚‰ãªã„ãŸã‚å‘¼ã³å‡ºã›ã¾ã›ã‚“ã€‚ã¾ãŸã€å‘¼ã³å‡ºã›ãŸã¨ã—ã¦ã‚‚ã€`std::swap`ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ã‚ã‚‹`Reference t = r1; r1 = r2; r2 = t;`ã®æ§˜ãªäº¤æ›æ“ä½œã¯`vector<bool>::reference`ã®ã‚³ãƒ”ãƒ¼ã¯å‚ç…§ã®ã‚³ãƒ”ãƒ¼ã«ãªã‚‹ãŸã‚ã€å‚ç…§å…ˆã®`bool`å€¤ã‚’äº¤æ›ã—ãªã„ãŸã‚ã§ã™ã€‚

LWG Isse 3638ã¯ã“ã‚Œã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ä¸€æ–¹ã€`vector<bool>::reference`ã¨ã»ã¼åŒã˜å‹•ä½œã‚’ã™ã‚‹ã‚‚ã®ã«ã€`bitset<N>::reference`ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];

      ...
    };
  };
}
```

ã“ã¡ã‚‰ã¯P2321ã§å¤‰æ›´ã•ã‚Œãªã‹ã£ãŸï¼ˆ`bitset`ãŒ`range`ã§ã¯ãªã„ãŸã‚ã¨æ€ã‚ã‚Œã‚‹ï¼‰ãŸã‚ã€`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒãŸãšã€`swap`ã«ã¤ã„ã¦åŒæ§˜ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚LWG Isse 4187ã¯å‰è€…ï¼ˆ`const`ä»£å…¥æ¼”ç®—å­ï¼‰ã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ã“ã‚Œã‚‰2ã¤ã®å‹ã«ã¯å…±é€šç‚¹ãŒå¤šãã‚ã‚‹ã‚‚ã®ã®ã€ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã®è§£æ±ºå¾Œã‚‚å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ä¸€è²«ã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ææ¡ˆã¯ã€ã“ã®ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’åˆã‚ã›ãŸå½¢ã®ä¸€è²«ã—ãŸè§£æ±ºã‚’ä¸¡æ–¹ã®å‹ã«é©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã™ãªã‚ã¡æ¬¡ã®å¤‰æ›´ã‚’é©ç”¨ã—ã¾ã™

- `vector<bool>::reference`
    - ADL `swap()`ã‚’è¿½åŠ 
- `bitset<N>::reference`
    - `const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’è¿½åŠ 
    - ADL `swap()`ã‚’è¿½åŠ 

ææ¡ˆå¾Œã®ä¸¡ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
   };
}
```

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹const ä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;  // ğŸ‘ˆ
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
  };
}
```

`bool&`ã‚’å–ã‚‹2ã¤ã®`swap()`ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€`bool`å‹ã®å·¦è¾ºå€¤`b`ã¨`reference`ã®å·¦è¾ºå€¤`r`ã«å¯¾ã—ã¦`swap(r, b)`ã¨`swap(b, r)`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚ã©ã¡ã‚‰ã®`reference`ã‚‚`bool&`ã‹ã‚‰æš—é»™å¤‰æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã€ã“ã®`swap`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã«ã“ã®2ã¤ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®`default`ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€å®Ÿè£…ã«ã‚ˆã£ã¦ä¸¡ã‚¯ãƒ©ã‚¹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ã«å·®ç•°ãŒã‚ã£ãŸã“ã¨ã‹ã‚‰ã€æ¨™æº–ã¨ã—ã¦ãã‚Œã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã‚’å›é¿ã™ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å®Ÿéš›ã«ã¯ä¸»è¦3å®Ÿè£…å…¨ã¦ã§ãƒˆãƒªãƒ“ã‚¢ãƒ«ã§ã—ãŸãŒã€ã“ã“ã§ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ãŒé‡è¦ã§ã¯ãªã„ã“ã¨ã‹ã‚‰ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åˆã‚ã›ãŸã‚ˆã†ã§ã™ã€‚

- [P3612 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2419)

### [P3666R0 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r0.html)
### [P3688R3 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r3.html)
### [P3695R1 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r1.html)
### [P3702R2 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r2.html)
### [P3754R1 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r1.pdf)
### [P3776R0 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r0.html)
### [P3776R1 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r1.html)
### [P3784R1 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r1.pdf)
### [P3786R0 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r0.pdf)

å›ºå®šã‚µã‚¤ã‚º`std::span`ã«ã‚¿ãƒ—ãƒ«ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã€‚

ã‚¿ãƒ—ãƒ«ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¯å›ºå®šã‚µã‚¤ã‚ºã®å¤šãã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªå‹ã§ã™ã§ã«ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ãŠã‚Šã€æ§‹é€ åŒ–æŸç¸›ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒã‚¤ãƒ³ãƒˆã¨ãªã‚Šã¾ã™ã€‚`std::span`ã¯ã¾ã ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ãªã„ãŸã‚ã€è¿½åŠ ã—ã‚ˆã†ã¨ã™ã‚‹ææ¡ˆã§ã™ã€‚

```cpp
std::span<int, 3> s{...}; 
auto & [x, y, z] = s; // okã€ã“ã®ææ¡ˆå¾Œ

std::vector<std::span<int, 3>> ss{...}; 
auto firsts{ss | std::views::elements<0> 
               | std::ranges::to<vector>()};  // okã€ã“ã®ææ¡ˆå¾Œ
```

å®Ÿã¯ä»¥å‰ã«ã‚‚P1024ã§ã“ã‚Œã¯ææ¡ˆã•ã‚Œã¦ãŠã‚Šã€C++20ã§æ¡æŠã•ã‚Œã¦ã„ãŸã®ã§ã™ãŒã€`std::tuple_element_t<const std::span<T, 3>>`ãŒ`const T`ã«ãªã‚‹ï¼ˆ`T`ã«ãªã£ã¦ã»ã—ã„ï¼‰ã¨ã„ã†å•é¡ŒãŒå ±å‘Šã•ã‚ŒãŸçµæœã€P2116ã§å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã“ã§ã®è¨­è¨ˆã¯ã“ã®å•é¡Œã‚’`std::span`ãŒå‚ç…§ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’æŒã¤å‹ã¨ã—ã¦æ‰±ã†ã“ã¨ã§è§£æ±ºã—ã¦ã„ã¾ã™ã€‚

ã™ãªã‚ã¡ã€`std::span`ã«å¯¾ã™ã‚‹ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ä¿®é£¾å­ã¯ã™ã¹ã¦ç„¡è¦–ã•ã‚Œã¾ã™ã€‚

- `tuple_size<cv1 span<cv2 T, N>>::value == N`
- `tuple_element<I, cv1 span<cv2 T, N>>::type == cv2 T`
- `decltype(get(span<cv T, N>)) == cv T`

å½“ç„¶ã§ã™ãŒã€ã‚¿ãƒ—ãƒ«ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã‚µãƒãƒ¼ãƒˆã¯å›ºå®šã‚µã‚¤ã‚ºï¼ˆ`N != dynamic_extent`ï¼‰ã®å ´åˆã®ã¿ã§ã™ã€‚

- [P3786 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2422)

### [P3811R0 default comparison memory safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3811r0.html)

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªå®‰å…¨ã§ã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

C++20ã§è¿½åŠ ã•ã‚ŒãŸæ¯”è¼ƒæ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã«ãŠã„ã¦ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã‹ãªã‚Šå˜ç´”ã‹ã¤ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆçš„ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€UBãƒ•ãƒªãƒ¼ã§å®Ÿè£…ã§ãã‚‹ã¯ãšã§ã™ã€‚ã“ã®ææ¡ˆã¯ã€æ¨™æº–ã¨ã—ã¦ãã®ã‚ˆã†ãªå®Ÿè£…ã‚’è¡Œã†ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã§ã™ã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã¯ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

```cpp
class TotallyOrdered : Base {
    string tax_id;
    string first_name;
    string last_name;
public:
  // auto operator<=>(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  std::strong_ordering operator<=>(const TotallyOrdered& that) const {
    if (auto cmp = (Base&)(*this) <=> (Base&)that; cmp != 0) return cmp;
    if (auto cmp = last_name <=> that.last_name; cmp != 0) return cmp;
    if (auto cmp = first_name <=> that.first_name; cmp != 0) return cmp;

    return tax_id <=> that.tax_id;
  }

  // bool operator==(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  bool operator==(const TotallyOrdered& that) const {
    if (!((Base&)(*this) == (Base&)that)) return false;
    if (!(last_name == that.last_name)) return false;
    if (!(first_name == that.first_name)) return false;

    return tax_id == that.tax_id;

  }
};
```

å®Ÿéš›ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã‚‚ã®ã®ã€ã“ã‚Œã¨å¤§ããç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚‚ãªã„ã¯ãšã§ã™ã€‚ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã¯ã€ä½¿ç”¨ã™ã‚‹å„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒæ¼”ç®—å­ï¼ˆ`== <=>`ï¼‰ã‚’é™¤ã„ã¦æœªå®šç¾©å‹•ä½œã‚’æ··å…¥ã•ã›ã‚‹ã“ã¨ãªãå®Ÿè£…ãŒã§ãã‚‹ã¯ãšã§ã™ã€‚ã¾ãŸã€`<=> ==`ãŒãã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ã€ãã“ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹ä»–ã®æ¯”è¼ƒæ¼”ç®—å­ã§ã‚‚åŒæ§˜ã®ä¿è¨¼ã‚’æä¾›ã§ãã¾ã™ã€‚

- [P3811 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2423)

### [P3812R0 `const` and `&` in default member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3812r0.html)

`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’å¯èƒ½ã«ã™ã‚‹ææ¡ˆã€‚

ã‚¯ãƒ©ã‚¹ã®éé™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨ã—ã¦`const`ã‚ã‚‹ã„ã¯å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã¨ã€ãã®ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªããªã‚Šã¾ã™ã€‚

```cpp
// least privilege
class leastp final {
public:
  leastp(std::vector<int>& v, int i)
      : v{v}, i{i} {}

  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ãã‚‹
  leastp(const leastp&) = default;
  leastp(leastp&&) = default;

  // ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªã„ï¼ˆdeleteã•ã‚Œã‚‹
  leastp& operator=(const leastp& other) = default;
  leastp& operator=(leastp&& other) = default;

  // least privilege
  constexpr size_t size() const {
      return v.size();
  }

private:
  std::vector<int>& v;
  const int i;
};
```

ã“ã‚Œã¯ä»£å…¥æ¼”ç®—å­ã‚’æ‰‹æ›¸ããã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã¨æ€ã‚ã‚Œã¾ã™ãŒã€å‚ç…§ã‚„`const`ãƒ¡ãƒ³ãƒã¯åŸºæœ¬çš„ã«ç½®æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã§ã™ã€‚

ã“ã‚Œã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨`*this`ã‚’é…ç½®ã—ãªãŠã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã‚Šã¾ã™

```cpp
class leastp final {
  ...

  leastp& operator=(const leastp& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(other);
    }

    return *this;
  }

  leastp& operator=(leastp&& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(std::move(other));
    }
    
    return *this;
  }

  ...
};
```

ã“ã®ã‚ˆã†ãªå®Ÿè£…ã¯è¤‡é›‘ã§ã‚ã‚Šã€æ­£ã—ãè¨˜è¿°ã™ã‚‹ã“ã¨ãŒå›°é›£ã§ã™ï¼ˆå°‘ã—é–“é•ãˆã‚‹ã¨UBã«çªå…¥ã™ã‚‹ï¼‰ã€‚C++ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«ãŠã„ã¦ã‚‚ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–å¯èƒ½ãªã‚¯ãƒ©ã‚¹ã«`const`ãƒ¡ãƒ³ãƒã‚„å‚ç…§ãƒ¡ãƒ³ãƒã‚’å«ã‚ãªã„ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®ææ¡ˆã¯ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’éé™çš„ãƒ¡ãƒ³ãƒã«æŒã¤ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ã€ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒ`default`æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€é€éçš„ã«ç½®æ›å¯èƒ½ï¼ˆ*transparently replaceable*ï¼‰ã¨ã—ã¦ã€å¯¾å¿œã™ã‚‹ä»£å…¥æ¼”ç®—å­ã‚‚`default`å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã“ã‚Œã«ã‚ˆã£ã¦ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’ä¿æŒã—ãŸã„å ´åˆã«è«¦ã‚ãŸã‚Šä»£ã‚ã‚Šã«ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿æŒã™ã‚‹ãªã©ã®å¿…è¦ãŒãªããªã‚Šã€ä¸Šè¨˜ã®ã‚ˆã†ãªå®Ÿè£…ã‚’å–ã‚‹å ´åˆã®ã‚³ãƒ¼ãƒ‰ã®å¿…è¦æ€§ã‚‚ãªããªã‚Šã€ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚‚ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

- [P3812 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2424)

### [P3813R0 execution::task::valueless()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3813r0.pdf)
### [P3815R0 Add `scope_association` concept to P3149](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3815r0.html)

P3149ã®éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—æ©Ÿèƒ½ã«ã€`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã€‚

P3149ã®éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—æ©Ÿèƒ½ã¯ã€2ã¤ã®ã‚¹ã‚³ãƒ¼ãƒ—å‹ï¼ˆ`simple_counting_scope`ã€`counting_scope`ï¼‰ã¨`associate`ã€`spawn`ã€`spawn_future`ãªã©ã®åŸºç¤çš„ãªæ“ä½œã«ã‚ˆã£ã¦æ§‹æˆã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã®ã‚‚ã®ã¯`scope_token`ã¨ã„ã†ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ä¸­å¿ƒã¨ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

```cpp
namespace ex = std::execution;

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¾ã™ã‚‹ç°¡å˜ãªå‹
struct my_window {
  class close_message {};

  ex::sender auto some_work(int message);

  ex::sender auto some_work(close_message message);

  void onMessage(int i) {
    ++count;
    // onã«ã‚ˆã£ã¦schã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§some_workã‚’å®Ÿè¡Œã—
    // ãã®æ“ä½œã¯scopeã«å¯¾å¿œã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹
    ex::spawn(ex::on(sch, some_work(i)), scope);
  }

  void onClickClose() {
    ++count;
    ex::spawn(ex::on(sch, some_work(close_message{})), scope);
  }

  my_window(ex::system_scheduler sch, ex::counting_scope::token scope)
    : sch(sch)
    , scope(scope) {
    // ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½•ã‚‰ã‹ã®æ–¹æ³•ã§Windwoãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ç™»éŒ²ã—
    // `onMessage()`ã¨`onClickClose()`ã®å‘¼ã³å‡ºã—ã‚’å—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
  }

  ex::system_scheduler sch;
  ex::counting_scope::token scope;
  int count{0};
};

int main() {
  // keep track of all spawned work
  ex::counting_scope scope;
  ex::system_context ctx;
  try {
    my_window window{ctx.get_scheduler(), scope.get_token()};
  } catch (...) {
    // do something with exception
  }

  // scopeã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸå…¨ã¦ã®æ“ä½œã®å®Œäº†ã‚’å¾…æ©Ÿã™ã‚‹
  std::this_thread::sync_wait(scope.join());
  
  // ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã¯å®‰å…¨ã«ç ´æ£„ã§ãã‚‹
  // =ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸæ“ä½œã¯ã™ã¹ã¦å®Œäº†ã—ã¦ã„ã‚‹
  return window.count;
}
```

ã‚¹ã‚³ãƒ¼ãƒ—å‹ã¯ã€ãã®ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸéåŒæœŸå‡¦ç†ï¼ˆ`sender`ï¼‰ã«ã‚ˆã‚‹å‡¦ç†ãŒå…¨ã¦çµ‚ã‚ã‚‹ã¾ã§ã€ãã“ã§ä½¿ç”¨ã•ã‚Œã†ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ã‚¹ã‚³ãƒ¼ãƒ—ã¸ã®éåŒæœŸæ“ä½œã®é–¢é€£ä»˜ã‘ã¯`execution::spawn`ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¦ãŠã‚Šã€ã“ã“ã«å‡¦ç†ã‚’è¡¨ã™`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å–å¾—ã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆä¸Šè¨˜ä¾‹ã ã¨`counting_scope::token`ï¼‰ã‚’æ¸¡ã™ã“ã¨ã§ã‚¹ã‚³ãƒ¼ãƒ—ã¨éåŒæœŸå‡¦ç†ã‚’é–¢é€£ä»˜ã‘ã¦ã„ã¾ã™ã€‚

ã‚¹ã‚³ãƒ¼ãƒ—ã¯`.join()`ã«ã‚ˆã£ã¦ã‚¹ã‚³ãƒ¼ãƒ—è‡ªèº«ã®`sender`ã‚’å–å¾—ã§ãã€ãã®`sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸå‡¦ç†ãŒå…¨ã¦çµ‚ã‚ã‚‹ã¾ã§å®Œäº†ã—ãªã„ã‚‚ã®ã§ã™ã€‚ã‚¹ã‚³ãƒ¼ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹ã“ã¨ã§ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å®Ÿè¡Œã•ã‚Œã‚‹éåŒæœŸå‡¦ç†ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒªã‚½ãƒ¼ã‚¹ï¼ˆä¸Šè¨˜ä¾‹ã ã¨`system_context`ã‚„`window`è‡ªèº«ï¼‰ã‚’ãã®å®Œäº†ã¾ã§é©åˆ‡ã«ä¿è­·ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã®ææ¡ˆã¯`scope_association`ã¨ã„ã†ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’å°å…¥ã—ã€ã“ã‚Œã‚’ç”¨ã„ã¦P3149ã§ææ¡ˆã•ã‚Œã¦ã„ã‚‹ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã®å†…éƒ¨è¨­è¨ˆã‚’è¡Œã†ã“ã¨ã§ã€ç¾åœ¨ã®å®Ÿè£…ã‚ˆã‚Šè‰¯ã„å®Ÿè£…ã‚’å–ã‚‹ã“ã¨ãŒã§ãã‚‹ã¨ã—ã¦ã€`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¨ãã‚Œã«ã‚ˆã‚‹å†è¨­è¨ˆã‚’ææ¡ˆã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã¨ã¯ã„ãˆã€ã“ã“ã§ã®å†è¨­è¨ˆã¯å†…éƒ¨ã«é–‰ã˜ãŸã‚‚ã®ã§ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å¤‰æ›´ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã‚Šæ¬¡ã®åˆ©ç‚¹ãŒå¾—ã‚‰ã‚Œã‚‹ã¨ã—ã¦ã„ã¾ã™

- ã‚¹ã‚³ãƒ¼ãƒ—å‹ã¨åŸºç¤æ“ä½œã®ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºã®å‰Šæ¸›
- ãƒ ãƒ¼ãƒ–/ã‚³ãƒ”ãƒ¼ã®å›æ•°ã‚’æ¸›ã‚‰ã›ã‚‹
- å®Ÿè£…ãƒ¢ãƒ‡ãƒ«ãŒç°¡ç´ åŒ–ã•ã‚Œã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã‚„ã™ããªã‚‹

ææ¡ˆã•ã‚Œã¦ã„ã‚‹`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™

```cpp
template <class Assoc>
concept scope_association =
  movable<Assoc> &&
  default_initializable<Assoc> &&
  requires(Assoc assoc) {
    { static_cast<bool>(assoc) } noexcept;
    { assoc.try_associate() } -> same_as<Assoc>;
  };
```

`scope_association`ã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹å‹ã¯ã€`sender`ã¨éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—é–“ã®é–¢é€£ä»˜ã‘ã‚’è¡¨ã™RAIIãƒãƒ³ãƒ‰ãƒ«å‹ã¨ãªã‚Šã¾ã™ã€‚ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‹ã‚‰èª­ã¿å–ã‚Œã‚‹æ€§è³ªã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

- ãƒ ãƒ¼ãƒ–å¯èƒ½
    - ã‚³ãƒ”ãƒ¼ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’æ„å›³
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½
- `bool`ã¸ã®å¤‰æ›ãŒå¯èƒ½
    - æ–‡è„ˆçš„`bool`å¤‰æ›å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’æ„å›³
- `.try_associate()`ã‚’æŒã¤

`scope_association`ãªå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ`assoc`ã¯ã€`bool`å¤‰æ›ã•ã‚Œã¦`true`ã‚’è¿”ã—ãŸå ´åˆï¼ˆâ€œengagedâ€ãªçŠ¶æ…‹ï¼‰ã¯ä½•ã‚‰ã‹ã®`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã®é–“ã§é–¢é€£ä»˜ã‘ãŒæˆç«‹ã—ã¦ã„ã‚‹ã“ã¨ã‚’è¡¨ã—ã€`false`ã‚’è¿”ã—ãŸå ´åˆï¼ˆâ€œdisengagedâ€ãªçŠ¶æ…‹ï¼‰ã¯é–¢é€£ä»˜ã‘ãŒæˆç«‹ã—ã¦ã„ãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚

`.try_associate()`ã«ã¤ã„ã¦ã¯P3149ã®`scope_token`ï¼ˆã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹ï¼‰å‹ã®ãã‚Œã¨å…¨ãåŒã˜æ„å‘³è«–ã¨ãªã‚Šã¾ã™ã€‚

`scope_association`å‹ã¯RAIIãƒãƒ³ãƒ‰ãƒ«ã§ã‚ã‚Šã€ãã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§é–¢é€£ä»˜ã‘ã®é–‹æ”¾å‡¦ç†ï¼ˆ`scope_token`ã®`.disassociate()`ç›¸å½“ï¼‰ã‚’è¡Œã†ã“ã¨ã§é–¢é€£ä»˜ã‘è§£é™¤ã¨ãã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’è‡ªå‹•åŒ–ã—ã¾ã™ã€‚

ã“ã‚Œã‚’ç”¨ã„ã¦ã€P3149ã®`scope_token, associate, spawn, spawn_future, simple_counting_scope, counting_scope`ã‚’å¤‰æ›´ã—ã¾ã™ã€‚

#### `execution::scope_token`

P3149ã®ä¸­å¿ƒæ¦‚å¿µã§ã‚ã‚‹`scope_token`ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ãŒå¤‰ã‚ã‚Šã¾ã™

<table>
<tr>
<th>P3149R11</th>
<th>ã“ã®ææ¡ˆ</th>
</tr>
<tr>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
      { token.try_associate() } -> same_as<bool>;
      { token.disassociate() } noexcept -> same_as<void>;
      { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
    { token.try_associate() } -> scope_association;
    { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
</tr>
</table>

`.try_associate()`ã¯`scope_association`å‹ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¾ã§ã¯é–¢é€£ä»˜ã‘ã®æˆå¦ã‚’è¡¨ã™`bool`å€¤ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸãŒã€`scope_association`å‹ã‚’è¿”ã™ã“ã¨ã§é–¢é€£ä»˜ã‘ãã®ã‚‚ã®ã‚’è¡¨ç¾ã™ã‚‹ã‚‚ã®ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

`scope_association`å‹ã¯ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§é–‹æ”¾å‡¦ç†ã‚’è‡ªå‹•åŒ–ã™ã‚‹ãŸã‚ã€`.disassociate()`ã¯ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

#### `execution::associate`

`associate`ã¯CPOã§ã‚ã‚Šã€`sender auto associate(sender auto&&, scope_token auto) noexcept(...);`ã®æ§˜ãªã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¤ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã¯ã€`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‚’`scope_token`ã‚’ä»‹ã—ã¦é–¢é€£ä»˜ã‘ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚„å½¹å‰²ã¯å¤‰åŒ–ã—ã¾ã›ã‚“ãŒã€è¿”ã•ã‚Œã‚‹`sender`ã®ã‚³ãƒ”ãƒ¼å‹•ä½œãŒå¤‰åŒ–ã—ã¾ã™ã€‚

`associate()`ã«æ¸¡ã•ã‚Œã‚‹`sender`ãŒã‚³ãƒ”ãƒ¼å¯èƒ½ãªå ´åˆã€çµæœã®`associate-sender`ã‚‚ã‚³ãƒ”ãƒ¼å¯èƒ½ã¨ãªã‚Š

- é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„`associate-sender`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã¨ã€å¿…ãšæ–°ã—ã„é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„`associate-sender`ãŒç”Ÿæˆã•ã‚Œã‚‹
- é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹`associate-sender`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã«ã¯ã€ãã‚Œã«å«ã¾ã‚Œã‚‹`associate-data`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã®ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ¬¡ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹
    1. ã‚½ãƒ¼ã‚¹ã®`association.try_associate()`ã‚’å‘¼ã³å‡ºã—ãŸçµæœãŒå®›å…ˆã®`associate-data`ã«æ¸¡ã•ã‚Œã‚‹
    2. çµæœã®é–¢é€£ä»˜ã‘ï¼ˆ`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ãŒengagedçŠ¶æ…‹ãªã‚‰ã°ã€ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ`sender`ã‚’ã‚½ãƒ¼ã‚¹ã‹ã‚‰å®›å…ˆã®`associate-data`ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹
        - å®›å…ˆã®`associate-sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹
    3. ãã†ã§ãªã„å ´åˆã€å®›å…ˆã®`associate-sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„

ã•ã‚‰ã«ã€`operation-state`ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ¬¡ã®äº‹ã‚’ä¿è¨¼ã—ã¾ã™

- ç‹¬è‡ªã®é–¢é€£ä»˜ã‘ï¼ˆ`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã‚’æŒã¤`operation-state`ã¯`operation-state`ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®æœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦ã€é–¢é€£ä»˜ã‘ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹

#### `execution::spawn`/`execution::spawn_future`

å†…éƒ¨çŠ¶æ…‹ã§`scope_token`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã™ã‚‹ä»£ã‚ã‚Šã«`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã™ã‚‹ã‚ˆã†ã«ãªã‚Šã€é–¢é€£ä»˜ã‘ã®è§£é™¤ãŒãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

#### `execution::simple_counting_scope`/`execution::counting_scope`

é–¢é€£ä»˜ã‘ã®è§£é™¤ãŒ`token.try_associate()`ã‹ã‚‰è¿”ã•ã‚Œã‚‹`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã“ã‚Œã‚‰ã®å¤‰æ›´ã¯å‰è¿°ã®ã‚ˆã†ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ãã®APIã«ã¯ã»ã¨ã‚“ã©å½±éŸ¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ã†ãˆã§ã€å†…éƒ¨å®Ÿè£…ã‚’æ”¹å–„ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [P3149R11 async_scope -- Creating scopes for non-sequential concurrency - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´07æœˆï¼‰](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3149R11-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3815 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2426)

### [P3816R0 Hashing `meta::info`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3816r0.html)

`meta::info`ã®ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã€‚

`meta::info`ã¯ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã«ãŠã„ã¦`^^`ï¼ˆãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³æ“ä½œï¼‰ã®æˆ»ã‚Šå€¤ã¨ãªã‚‹ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã§ã‚ã‚Šã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã®ã¿ä½¿ç”¨å¯èƒ½ãªä¸é€æ˜å‹ã§ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã¯ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ãŠã„ã¦ã‚‚è€ƒæ…®ã•ã‚Œã¦ã„ãªã‹ã£ãŸãŸã‚ã€`meta::info`ã¯ãƒãƒƒã‚·ãƒ¥åŒ–å¯èƒ½ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ä¸€æ–¹ã€P3372R3ã§ã¯é€£æƒ³ã‚³ãƒ³ãƒ†ãƒŠã‚’å«ã‚€ã»ã¼ã™ã¹ã¦ã®ã‚³ãƒ³ãƒ†ãƒŠãŒ`constexpr`å¯¾å¿œã—ã¦ãŠã‚Šã€ãã®ãŸã‚ã«ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆãŒé‡è¦ã¨ãªã‚Šã¾ã™ã€‚

ãã®ãŸã‚ã«ã€ã“ã®ææ¡ˆã¯`meta::info`ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã—ã‹ã—`meta::info`ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã®ã¿ä½¿ç”¨å¯èƒ½ãªå‹ã§ã‚ã‚Šã€`std::hash`ã®ç‰¹æ®ŠåŒ–ã«ã‚ˆã‚‹å¯¾å¿œã¯å®Ÿè¡Œæ™‚è¦ä»¶ãŒå¤šãèª²ã›ã‚‰ã‚Œã‚‹ãŸã‚é©ã—ã¦ã„ã¾ã›ã‚“ã€‚ãã®ã»ã‹ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã®ã¿ä½¿ç”¨å¯èƒ½ãªå‹ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã®ãŸã‚ã«ã€`std::consteval_hash<T>`ã‚’è¿½åŠ ã—ã€ãã®`meta::info`ç‰¹æ®ŠåŒ–ã¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ãƒãƒƒã‚·ãƒ¥ã‚µãƒãƒ¼ãƒˆã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚’ææ¡ˆã—ã¦ã„ã¾ã™ã€‚

ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«ã‚ˆã‚‹`mp_unique`å®Ÿè£…ã®ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚`unordered_set`ã‚’ä½¿ç”¨ã™ã‚‹ä¾‹

```cpp
template <typename... Types>
struct type_list {};

template <typename TypeList>
consteval auto mp_unique_reflected() {
  static_assert(std::meta::has_template_arguments(^^TypeList), "mp_unique requires a type_list");
  static_assert(std::meta::template_of(^^TypeList) == ^^type_list, "mp_unique requires a type_list");

  std::unordered_set<std::meta::info, std::consteval_hash<std::meta::info>> seen;
  std::vector<std::meta::info> unique_types;

  for (auto type_info : std::meta::template_arguments_of(^^TypeList)) {
    if (const bool is_unique = seen.insert(type_info).second; is_unique) {
      unique_types.push_back(type_info);
    }
  }

  return std::meta::substitute(^^type_list, unique_types);
}

template <class TypeList>
using mp_unique = [:mp_unique_reflected<TypeList>():];

using input = type_list<int, char, int, string, double, char>;
using filtered = mp_unique<input>;
using expected = type_list<int, char, string, double>;

static_assert(is_same_v<expected, filtered>);
```

`std::hash`ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆ©ç”¨å¯èƒ½ãªã‚ˆã†ã«ãªã£ã¦ãŠã‚‰ãšã€ãã®äºˆå®šã‚‚ãªã„ãŸã‚ã€éé †åºé€£æƒ³ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ä½¿ç”¨ã™ã‚‹ãŸã‚ã«ã¯ãƒãƒƒã‚·ãƒ¥ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒã©ã®ã¿ã¡å¿…è¦ã«ãªã‚Šã¾ã™ã€‚ãã®ãŸã‚æ–°ã—ã„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚å°‚ç”¨ãƒãƒƒã‚·ãƒ¥å‹ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã®éé †åºé€£æƒ³ã‚³ãƒ³ãƒ†ãƒŠã®ä½¿ç”¨æ„Ÿã‚’ä»Šã‚ˆã‚Šæ‚ªãã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã“ã¨ã¯å•é¡Œã§ã¯ã‚ã‚‹ã‚‚ã®ã®ã€ã“ã®ææ¡ˆã¯ãã®è§£æ±ºã‚’è¡Œã†ã“ã¨ã‚’æ„å›³ã—ã¦ã„ã¾ã›ã‚“ã€‚

*ConstevalHash*è¦ä»¶ã¯æ¬¡ã®ã‚ˆã†ã«æŒ‡å®šã•ã‚Œã¦ã„ã¾ã™

- é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹
- ã‚³ãƒ”ãƒ¼æ§‹ç¯‰å¯èƒ½å‹ã¤ç ´æ£„å¯èƒ½
    - *Cpp17CopyConstructible*ã‹ã¤*Cpp17Destructible*
- `consteval`ã‚ªãƒ³ãƒªãƒ¼å‹
- `H`ã®2ã¤ã®å®Ÿä½“ã¯ã€åŒã˜å¼•æ•°ã«å¯¾ã—ã¦åŒã˜å€¤ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ã‚’ä¿è¨¼ã—ãªã„
    - `H`ã¯*ConstevalHash*å‹
    - ç‰¹ã«ã€ç¿»è¨³å˜ä½é–“ã§å€¤ãŒç•°ãªã‚‹ã“ã¨ãŒã‚ã‚‹
- `Key`å‹ã‚’`H`ã®é–¢æ•°å‘¼ã³å‡ºã—å¼•æ•°å‹ã€`h`ã‚’`H`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€`u`ã‚’`Key`ã®å·¦è¾ºå€¤ã€`k`ã‚’`Key`ã«å¤‰æ›å¯èƒ½ãªå‹ã®å€¤ã¨ã—ã¦ã€æ¬¡ã®æ“ä½œãŒæœ‰åŠ¹ã‹ã¤æŒ‡å®šã•ã‚ŒãŸã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’æŒã¤
    - `h(k) -> std::size_t`
        - è¿”ã•ã‚Œã‚‹å€¤ã¯`k`ã®ã¿ã«ä¾å­˜ã™ã‚‹
        - å€¤ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã—ã¦ã‚‚å®‰å®šã—ã¦ã„ã‚‹
            - ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã™ã‚‹ã¨å€¤ãŒå¤‰ã‚ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹
        - 2ã¤ã®ç•°ãªã‚‹å€¤`t1, t2`ã«ã¤ã„ã¦ã€`h(t1) == h(t2)`ã¨ãªã‚‹ç¢ºç‡ã¯éå¸¸ã«å°ã•ãã€`1.0 / numeric_limits<size_t>::max()`ã«è¿‘ããªã‚‹
    - `h(u) -> std::size_t`
        - `u`ã‚’å¤‰æ›´ã—ãªã„

ææ¡ˆæ–‡æ›¸ã‚ˆã‚Šã€å®Ÿè£…ä¾‹

```cpp
template<>
struct consteval_hash<meta::info>
{
  consteval consteval_hash() = default;
  consteval consteval_hash(const consteval_hash<meta::info>&) = default;
  consteval consteval_hash(consteval_hash<meta::info>&&) = default;

  consteval auto operator()(meta::info r) const noexcept -> size_t {
    return __metafunction(meta::detail::__metafn_reflection_hash, r);
  }

private:

  // This unused variable is here to make consteval_hash<> a
  // consteval-only type.
  [[maybe_unused]] const meta::info unused = ^^::;
};
```

- [P3816 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2427)

### [P3818R0 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r0.html)

â†“

### [P3818R1 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r1.html)

ç¾åœ¨ã®ä¾‹å¤–ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ã‚’ç‰¹å®šã®å®šæ•°è©•ä¾¡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§è©•ä¾¡ã—ãªã„ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

C++26ã§ã¯å®šæ•°å¼ã§ã®ä¾‹å¤–é€å‡ºãŒå¯èƒ½ã«ãªã£ã¦ãŠã‚Šã€ãã‚Œã«ä¼´ã£ã¦`std::exception`ã¨ãã®æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ãªã©ã®ä¾‹å¤–é–¢é€£ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãŒå®šæ•°å¼ã§å®Ÿè¡Œå¯èƒ½ã«ãªã£ã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€`std::current_exception()`ã«ã‚ˆã£ã¦`std::exception_ptr`ã‚’å®šæ•°å¼ã§å–å¾—ã—ã¦å‡¦ç†ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```cpp
constexpr auto maybe_throw(int n);

consteval void f() {
  try {
    maybe_throw(1);
  } catch (...) {
    auto exptr = std::current_exception();  // ok
  }
}
```

`std::current_exception()`ã¯å®šæ•°å¼ã§å‘¼ã°ã‚Œã‚‹å ´åˆã€ãã®å®šæ•°è©•ä¾¡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå†…ã§é€å‡ºã•ã‚Œã¦ã„ã‚‹ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—ã—ã¾ã™ã€‚

ã¨ã“ã‚ã§ã€å®šæ•°è©•ä¾¡ã¯`constexpr`å¤‰æ•°ã®åˆæœŸåŒ–ã‚„`consteval`é–¢æ•°å‘¼ã³å‡ºã—ãªã©ã®æ˜ç¤ºçš„ãªè©•ä¾¡ã®é–‹å§‹ä»¥å¤–ã§ã‚‚è¡Œã‚ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ãã®ä¸€ã¤ã¯`const`ãªæ•´æ•°å‹ã®å¤‰æ•°ã®åˆæœŸåŒ–å¼ãŒå®šæ•°è©•ä¾¡å¯èƒ½ãªå ´åˆã§ã€ã“ã®ã‚ˆã†ãªå¤‰æ•°ã‚’*potentially constant*ãªå¤‰æ•°ï¼ˆå®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ï¼‰ã¨å‘¼ã³ã¾ã™ã€‚

```cpp
constexpr int f() {
  return 1;
}

int main() {
  const int n = f();  // nã¯potentially constantãªå¤‰æ•°
}
```

å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã«ã¯æ­£ç¢ºã«ã¯`constexpr`å¤‰æ•°ã‚‚å«ã¿ã¾ã™ãŒã“ã“ã§ã¯ãã‚Œã¯é™¤å¤–ã™ã‚‹ã¨ã—ã¾ã™ã€‚

ã“ã®å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã¯ãã®åˆæœŸåŒ–å­ãŒå®šæ•°è©•ä¾¡å¯èƒ½ã§ã‚ã‚Œã°ã€ãã®çµæœã‚’ç”¨ã„ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆæœŸåŒ–ã•ã‚Œã€å®šæ•°å¼ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ä½¿ç”¨å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã§ã‚ã£ã¦ã‚‚åˆæœŸåŒ–å¼ãŒå®šæ•°è©•ä¾¡å¯èƒ½ã§ãªã‘ã‚Œã°ã€ãã®åˆæœŸåŒ–åŠã³åˆæœŸåŒ–å¼ã®è©•ä¾¡ã¯å®Ÿè¡Œæ™‚ã«è¡Œã‚ã‚Œã¾ã™ã€‚

`std::current_exception()`ãªã©ã®å‘¼ã³å‡ºã—ã¯C++26ã‹ã‚‰å®šæ•°è©•ä¾¡å¯èƒ½ãªå¼ã§ã™ã€‚ä»¥å‰ã¯å®šæ•°è©•ä¾¡å¯èƒ½ã§ã¯ãªã‹ã£ãŸãŸã‚ã“ã®å¤‰æ›´ãŒä¸‹ä½äº’æ›æ€§ã‚’æã­ã‚‹ã“ã¨ã¯ç„¡ã„ã¯ãšã§ã—ãŸãŒã€ã“ã‚Œã‚‰ã®å¼ãŒå®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã®åˆæœŸåŒ–å¼ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã«å‹•ä½œãŒå¤‰åŒ–ã—ã¾ã™ã€‚

```cpp
try {
  // ä¾‹å¤–ã‚’æŠ•ã’ã†ã‚‹ã‚³ãƒ¼ãƒ‰
	...
} catch (const std::exception & exc) {
  // has_exceptionã¯å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã ãŒã€C++23ã¾ã§ã¯ãã®åˆæœŸåŒ–å¼ã¯å®šæ•°è©•ä¾¡å¯èƒ½ã§ã¯ãªã‹ã£ãŸ
	const bool has_exception = (std::current_exception() != nullptr); // å®šæ•°è©•ä¾¡ã•ã‚ŒãŸæ™‚ã«ã¯ãã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«ç¾åœ¨ã®ä¾‹å¤–ã¯å­˜åœ¨ã—ãªã„
	static_assert(has_exception == false); // âœ…ã€has_exceptionã¯å®šæ•°å¼ã§ä½¿ç”¨å¯èƒ½
}
```

`const`ãªæ•´æ•°å‹ï¼ˆ`bool`ã‚’å«ã‚€ï¼‰ã¯å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã§ã™ãŒã€`std::current_exception()`ã®å‘¼ã³å‡ºã—ã¯C++23ã¾ã§ã¯å®šæ•°è©•ä¾¡ä¸å¯èƒ½ã ã£ãŸãŸã‚å®šæ•°è©•ä¾¡ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã—ã‹ã—C++26ã§ã¯å®šæ•°è©•ä¾¡å¯èƒ½ã«ãªã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã“ã®`has_exception`ã®åˆæœŸåŒ–å¼ã¯å®šæ•°å¼ã¨ã—ã¦ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã“ã®å¤‰æ•°ã®åˆæœŸåŒ–ã«ã‚ˆã£ã¦é–‹å§‹ã™ã‚‹å®šæ•°è©•ä¾¡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯ä¾‹å¤–ã¯é€å‡ºã•ã‚Œã¦ã„ãªã„ãŸã‚ã€å®šæ•°å¼ã§ã¯`catch`ã®å†…éƒ¨ã§ã‚ã‚‹ã«ã‚‚ã‹ã‹ã‚ã‚‰ãš`std::current_exception()`ã¯`nullptr`ã‚’è¿”ã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã£ã¦ã€`has_exception`ã¯å®Ÿè¡Œæ™‚ã®ä¾‹å¤–çŠ¶æ…‹ã¨å…¨ãé–¢ä¿‚ãªãå¸¸ã«`false`ã§åˆæœŸåŒ–ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

ææ¡ˆæ–‡æ›¸ã‚ˆã‚Šã€ä»–ã®ä¾‹

```cpp
struct transaction {
	// ...
	void cancel() { /* revert changes */ }
	
	~transaction() {
    // unrollingã¯å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°
		const bool unrolling = std::uncaught_exceptions() > 0;  // falseã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«åˆæœŸåŒ–ã•ã‚Œã‚‹
		
		if (unrolling) { // this will never be evaluated
			log("exception was thrown in a transaction => cancel()");
			cancel();
		}
	}
}
```

å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°`unrolling`ã¯C++26ã‹ã‚‰å®šæ•°å¼ã«ã‚ˆã£ã¦åˆæœŸåŒ–ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã—ã‹ã‚‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®æ„å›³ã¨ã¯å…¨ãç•°ãªã‚‹çµæœã«ã‚ˆã£ã¦åˆæœŸåŒ–ã•ã‚Œã¾ã™ï¼ˆå¸¸ã«`false`ï¼‰ã€‚

ã“ã‚Œã‚‰ã®ã‚ˆã†ã«ã€å¤‰æ•°ã®åˆæœŸåŒ–å¼ã‹ã‚‰é–‹å§‹ã•ã‚Œã‚‹å®šæ•°è©•ä¾¡ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã¯ãã®è©•ä¾¡ã®å†…éƒ¨ã§ä¾‹å¤–ãŒé€å‡ºã•ã‚Œãªã„é™ã‚Šç¾åœ¨ã®ä¾‹å¤–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã™ã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã›ã‚“ã€‚ãã®ãŸã‚ã€å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã®åˆæœŸåŒ–å¼ã§`std::uncaught_exceptions()`ã‚„`std::current_exceptions()`ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¦åˆæœŸåŒ–å¼å…¨ä½“ãŒå®šæ•°è©•ä¾¡ã‹ã®ã†ã ã¨ã€ã“ã‚Œã‚‰ã®é–¢æ•°ã¯å¸¸ã«ç¾åœ¨ã®ä¾‹å¤–ãŒç„¡ã„çŠ¶æ…‹ã§è©•ä¾¡ã•ã‚Œçµæœã‚’å–å¾—ã—ã¾ã™ã€‚

ã“ã®ææ¡ˆã¯ã“ã®å•é¡Œã‚’è§£æ¶ˆã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã€`std::uncaught_exceptions()`ã¨`std::current_exceptions()`ã®`constexpr`ã¯ç¶­æŒã—ãŸã†ãˆã§ã€ã“ã‚Œã‚‰ã®é–¢æ•°ãŒå®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã®åˆæœŸåŒ–ã®ãŸã‚ã«å®šæ•°è©•ä¾¡ã•ã‚Œã‚‹å ´åˆã«å‘¼ã³å‡ºã—ã‚’å®šæ•°å¼ã§ã¯ãªãã™ã‚‹ã“ã¨ã‚’ææ¡ˆã—ã¦ã„ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã‚Šã€ä¸Šè¨˜ã®2ä¾‹ã®ã‚ˆã†ãªã‚±ãƒ¼ã‚¹ã§ã¯`std::uncaught_exceptions()`ã¨`std::current_exceptions()`ã®å‘¼ã³å‡ºã—ãŒå®šæ•°å¼ã§ã¯ãªããªã‚‹ã“ã¨ã§ã€å®šæ•°ã‹ã‚‚ã—ã‚Œãªã„å¤‰æ•°ã®åˆæœŸåŒ–ã¯C++23ã¾ã§ã¨åŒã˜ãå®Ÿè¡Œæ™‚ã«è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã“ã®ææ¡ˆã®å†…å®¹ã«å¯¾å¿œã™ã‚‹NBã‚³ãƒ¡ãƒ³ãƒˆãŒ3ä»¶æå‡ºã•ã‚Œã¦ã„ã‚‹ã‚ˆã†ã§ã€ãã‚Œã‚’å—ã‘ã¦LEWGã§ã“ã®ææ¡ˆã¨ã“ã®å•é¡Œã«ã¤ã„ã¦å¯©è­°ã•ã‚ŒãŸçµæœã€ã“ã®ææ¡ˆã®å¤‰æ›´ã¯å¤§ãã™ãã‚‹ã¨ã—ã¦`std::uncaught_exceptions()`ã¨`std::current_exceptions()`ã‹ã‚‰å˜ã«`constexpr`ã‚’å–ã‚Šé™¤ãã“ã¨ã«è‹¥å¹²ã®åˆæ„ãŒã‚ã£ãŸã‚ˆã†ã§ã™ã€‚ã“ã‚Œã‚’å—ã‘ã¦ã“ã®å•é¡Œã®è§£æ±ºã¯P3842R0ã«å§”ã­ã‚‰ã‚ŒãŸã‚ˆã†ã§ã™ã€‚

- [P3818 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2428)

### [P3819R0 Remove evaluation_exception() from contract-violation handling for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)
### [P3820R0 Split constexpr uncaught_exceptions into distinct runtime and consteval functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r0.html)

ç¾åœ¨ã®ä¾‹å¤–ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°ã‹ã‚‰`constexpr`æŒ‡å®šã‚’å‰Šé™¤ã™ã‚‹ææ¡ˆã€‚

ã“ã®ææ¡ˆã®æŒ‡æ‘˜ã™ã‚‹å•é¡Œã‚„ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³ã¯å°‘ã—ä¸Šã®P3818R1ã¨å…±é€šã—ã¦ã„ã‚‹ã®ã§ãã¡ã‚‰ã‚’ã”è¦§ãã ã•ã„ã€‚

ã“ã®ææ¡ˆã¯P3818R1ã¨ã¯ç•°ãªã‚Šå•é¡Œã«å¯¾ã—ã¦æ¬¡ã®è§£æ±ºç­–ã‚’ææ¡ˆã—ã¦ã„ã¾ã™

- `std::uncaught_exceptions()`ã‹ã‚‰`constexpr`æŒ‡å®šã‚’å‰Šé™¤ã™ã‚‹
    - `std::current_exceptions()`ã¯ãƒãƒ¼ã‚¿ãƒƒãƒ
- å®šæ•°å¼ã§ä½¿ç”¨ã§ãã‚‹å°‚ç”¨ã®`std::consteval_uncaught_exceptions()`ã‚’è¿½åŠ ã™ã‚‹

ã“ã®ææ¡ˆã®å ´åˆã€`std::uncaught_exceptions()`ã¯å®šæ•°å¼ã§ä½¿ç”¨ã§ããªããªã‚Šã€å®šæ•°å¼ã§ä½¿ç”¨ã™ã‚‹ã«ã¯åå‰ã®é•ã†`std::consteval_uncaught_exceptions()`ã‚’ä½¿ã‚ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã£ã¦ã€å®Ÿè¡Œæ™‚ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã§ã‚³ãƒ¼ãƒ‰ã‚’å…±é€šã™ã‚‹å ´åˆã¯`if consteval`ã«ã‚ˆã‚‹åˆ†å²ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸã€`std::current_exceptions()`ã«ã¤ã„ã¦ã¯è¨€åŠã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

P3818R1ã®ã¨ã“ã‚ã§ã‚‚è¿°ã¹ãŸã‚ˆã†ã«ã€çµå±€ã©ã¡ã‚‰ã®è§£æ±ºç­–ã‚‚C++26ã®NBã‚³ãƒ¡ãƒ³ãƒˆè§£æ±ºãƒ•ã‚§ãƒ¼ã‚ºã«å°å…¥ã™ã‚‹ã«ã¯é©ã•ãªã„ã¨ã—ã¦ã€P3824R0ã§`std::uncaught_exceptions()`ã¨`std::current_exceptions()`ã‹ã‚‰å˜ã«`constexpr`ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã‚’C++26å‘ã‘ã®ä¿®æ­£ã¨ã™ã‚‹ã‚ˆã†ã§ã™ã€‚

- [P3820 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2430)

### [P3820R1 Fix constexpr uncaught_exceptions and current_exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r1.html)
### [P3822R0 Conditional noexcept specifiers in compound requirements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3822r0.html)
### [P3823R0 Wording for US NB comment 10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3823r0.html)
### [P3824R0 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r0.html)
### [P3827R0 Wording for US NB comment 9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3827r0.html)
### [P3829R0 Contracts do not belong in the language](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3829r0.pdf)
### [P3830R0 NB-Commenting is Not a Vehicle for Redesigning inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3830r0.pdf)
### [P3831R0 Contract Labels Should Use Annotation Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3831r0.html)
### [P3832R0 Timed lock algorithms for multiple lockables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3832r0.pdf)
### [P3834R0 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r0.html)
### [P3835R0 Contracts make C++ less safe -- full stop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3835r0.html)
### [P3836R0 Make optional<T&> trivially copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r0.html)
### [P3838R0 Restoring Private Module Fragments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3838r0.pdf)

- [ é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/)
