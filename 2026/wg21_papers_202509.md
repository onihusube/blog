# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´09æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers mailing2025-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-09)

å…¨éƒ¨ã§37æœ¬ã‚ã‚Šã¾ã™ã€‚

ã‚‚ãã˜

[:contents]

### [N5020 2026-11 BÃºzios Meeting Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5020.html)
### [P2953R2 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r2.html)
### [P3347R5 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r5.pdf)
### [P3567R1 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r1.html)
### [P3579R2 Fix matching of constant template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r2.html)
### [P3612R0 Harmonize proxy-reference operations (LWG 3638 and 4187)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3612r0.html)

`vector<bool>::reference`ã¨`bitset<N>::reference`ã®é–“ã§ä¸€è²«ã—ãŸIssueè§£æ±ºã‚’è¡Œã†ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯`vector<bool>::reference`ã¨`bitset<N>::reference`ã«é–¢ã™ã‚‹æ¬¡ã®2ã¤ã®ã‚¤ã‚·ãƒ¥ãƒ¼è§£æ±ºã®éš›ã«ã€è¿½åŠ ã™ã‚‹`swap()/operator=`ã®ã‚·ã‚°ãƒãƒãƒ£ã‚’å…±é€šåŒ–ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [LWG Isse 3638 `vector<bool>::swap(reference, reference)` is useless](https://cplusplus.github.io/LWG/issue3638)
- [LWG Isse 4187 `bitset::reference` should be const-assignable](https://cplusplus.github.io/LWG/issue4187)

P2321ï¼ˆ`views::zip`ã®ææ¡ˆï¼‰ã§ã¯`views::zip`ã®å‹•ä½œã®ãŸã‚ã«`vector<bool>::reference`ã«ä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;

      ...
    };
   };
}
```

ãƒ—ãƒ­ã‚¯ã‚·å‚ç…§å‹ã¯`const`ã§ã‚‚ä»£å…¥å¯èƒ½ã§ã‚ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚‚ã®ã®`vector<bool>::reference`ã¯`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒã£ã¦ã„ãªã‹ã£ãŸãŸã‚ã€å¾Œæ–¹äº’æ›æ€§ã‚’ç¶­æŒã—ã¤ã¤ãã‚Œã‚’å¯èƒ½ã«ã™ã‚‹ãŸã‚ã«`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ãŒè¿½åŠ ã•ã‚Œã¾ã—ãŸã€‚ã“ã®æ™‚ã€ãã®æˆ»ã‚Šå€¤å‹ã¯`reference`ã®prvalueã§ã¯ãªãã€`const`lvalueã¨ã•ã‚Œã¾ã—ãŸï¼ˆãªãœã‹ã¯ã‚ˆãã‚ã‹ã‚Šã¾ã›ã‚“ï¼‰ã€‚

ã“ã®`vector<bool>::reference`ã¯`std::swap`ãŒæ„å›³é€šã‚Šã«å‹•ä½œã—ãªã„ãŸã‚`swap()`ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãŒå¿…è¦ã§ã™ã€‚ä¾‹ãˆã°ã€`vector<bool> v`ã«å¯¾ã—ã¦`std::swap(v[1], v[2])`ãŒæ©Ÿèƒ½ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‚‚ã®ã®ã€`std::swap`ã¯é`const`å‚ç…§ã—ã‹å–ã‚‰ãªã„ãŸã‚å‘¼ã³å‡ºã›ã¾ã›ã‚“ã€‚ã¾ãŸã€å‘¼ã³å‡ºã›ãŸã¨ã—ã¦ã‚‚ã€`std::swap`ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ã‚ã‚‹`Reference t = r1; r1 = r2; r2 = t;`ã®æ§˜ãªäº¤æ›æ“ä½œã¯`vector<bool>::reference`ã®ã‚³ãƒ”ãƒ¼ã¯å‚ç…§ã®ã‚³ãƒ”ãƒ¼ã«ãªã‚‹ãŸã‚ã€å‚ç…§å…ˆã®`bool`å€¤ã‚’äº¤æ›ã—ãªã„ãŸã‚ã§ã™ã€‚

LWG Isse 3638ã¯ã“ã‚Œã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ä¸€æ–¹ã€`vector<bool>::reference`ã¨ã»ã¼åŒã˜å‹•ä½œã‚’ã™ã‚‹ã‚‚ã®ã«ã€`bitset<N>::reference`ãŒã‚ã‚Šã¾ã™ã€‚

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];

      ...
    };
  };
}
```

ã“ã¡ã‚‰ã¯P2321ã§å¤‰æ›´ã•ã‚Œãªã‹ã£ãŸï¼ˆ`bitset`ãŒ`range`ã§ã¯ãªã„ãŸã‚ã¨æ€ã‚ã‚Œã‚‹ï¼‰ãŸã‚ã€`const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’æŒãŸãšã€`swap`ã«ã¤ã„ã¦åŒæ§˜ã®å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚LWG Isse 4187ã¯å‰è€…ï¼ˆ`const`ä»£å…¥æ¼”ç®—å­ï¼‰ã«ã¤ã„ã¦ã®ã‚¤ã‚·ãƒ¥ãƒ¼å ±å‘Šã§ã™ã€‚

ã“ã‚Œã‚‰2ã¤ã®å‹ã«ã¯å…±é€šç‚¹ãŒå¤šãã‚ã‚‹ã‚‚ã®ã®ã€ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã®è§£æ±ºå¾Œã‚‚å‹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯ä¸€è²«ã—ã¦ã„ã¾ã›ã‚“ã€‚ã“ã®ææ¡ˆã¯ã€ã“ã®ä¸¡æ–¹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’åˆã‚ã›ãŸå½¢ã®ä¸€è²«ã—ãŸè§£æ±ºã‚’ä¸¡æ–¹ã®å‹ã«é©ç”¨ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã™ãªã‚ã¡æ¬¡ã®å¤‰æ›´ã‚’é©ç”¨ã—ã¾ã™

- `vector<bool>::reference`
    - ADL `swap()`ã‚’è¿½åŠ 
- `bitset<N>::reference`
    - `const`ä¿®é£¾ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­ã‚’è¿½åŠ 
    - ADL `swap()`ã‚’è¿½åŠ 

ææ¡ˆå¾Œã®ä¸¡ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();

      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;

      // æ—¢å­˜ã®ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321ã§è¿½åŠ ã•ã‚ŒãŸä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
   };
}
```

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) noexcept; // ğŸ‘ˆ
      constexpr ~reference();
      
      // boolå‹ã¸ã®æš—é»™å¤‰æ›
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // ä»£å…¥æ¼”ç®—å­
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹const ä»£å…¥æ¼”ç®—å­
      constexpr const reference& operator=(bool x) const noexcept;  // ğŸ‘ˆ
      
      // ã“ã®ææ¡ˆã«ã‚ˆã‚‹ADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // ğŸ‘ˆ
      friend constexpr void swap(reference x, bool& y) noexcept;      // ğŸ‘ˆ
      friend constexpr void swap(bool& x, reference y) noexcept;      // ğŸ‘ˆ

      ...
    };
  };
}
```

`bool&`ã‚’å–ã‚‹2ã¤ã®`swap()`ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã¯ã€`bool`å‹ã®å·¦è¾ºå€¤`b`ã¨`reference`ã®å·¦è¾ºå€¤`r`ã«å¯¾ã—ã¦`swap(r, b)`ã¨`swap(b, r)`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ã§ã™ã€‚ã©ã¡ã‚‰ã®`reference`ã‚‚`bool&`ã‹ã‚‰æš—é»™å¤‰æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã€ã“ã®`swap`ã‚’æ©Ÿèƒ½ã•ã›ã‚‹ãŸã‚ã«ã“ã®2ã¤ã®ã‚ªãƒ¼ãƒãƒ­ãƒ¼ãƒ‰ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®`default`ãŒå‰Šé™¤ã•ã‚Œã¦ã„ã‚‹ã®ã¯ã€å®Ÿè£…ã«ã‚ˆã£ã¦ä¸¡ã‚¯ãƒ©ã‚¹ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ã«å·®ç•°ãŒã‚ã£ãŸã“ã¨ã‹ã‚‰ã€æ¨™æº–ã¨ã—ã¦ãã‚Œã‚’å¼·åˆ¶ã™ã‚‹ã“ã¨ã‚’å›é¿ã™ã‚‹ã“ã¨ã‚’æ„å›³ã—ãŸã‚‚ã®ã§ã™ã€‚ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯å®Ÿéš›ã«ã¯ä¸»è¦3å®Ÿè£…å…¨ã¦ã§ãƒˆãƒªãƒ“ã‚¢ãƒ«ã§ã—ãŸãŒã€ã“ã“ã§ã®ãƒˆãƒªãƒ“ã‚¢ãƒ«æ€§ãŒé‡è¦ã§ã¯ãªã„ã“ã¨ã‹ã‚‰ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«åˆã‚ã›ãŸã‚ˆã†ã§ã™ã€‚

- [P3612 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2419)

### [P3666R0 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r0.html)
### [P3688R3 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r3.html)
### [P3695R1 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r1.html)
### [P3702R2 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r2.html)
### [P3754R1 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r1.pdf)
### [P3776R0 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r0.html)
### [P3776R1 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r1.html)
### [P3784R1 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r1.pdf)
### [P3786R0 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r0.pdf)
### [P3811R0 default comparison memory safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3811r0.html)

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã«å¯¾ã—ã¦ãƒ¡ãƒ¢ãƒªå®‰å…¨ã§ã‚ã‚‹ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

C++20ã§è¿½åŠ ã•ã‚ŒãŸæ¯”è¼ƒæ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã«ãŠã„ã¦ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰ã¯ã‹ãªã‚Šå˜ç´”ã‹ã¤ãƒœã‚¤ãƒ©ãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒˆçš„ãªã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€UBãƒ•ãƒªãƒ¼ã§å®Ÿè£…ã§ãã‚‹ã¯ãšã§ã™ã€‚ã“ã®ææ¡ˆã¯ã€æ¨™æº–ã¨ã—ã¦ãã®ã‚ˆã†ãªå®Ÿè£…ã‚’è¡Œã†ã“ã¨ã‚’è¦æ±‚ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã§ã™ã€‚

ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¯”è¼ƒæ¼”ç®—å­ã®å®Ÿè£…ã¯ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

```cpp
class TotallyOrdered : Base {
    string tax_id;
    string first_name;
    string last_name;
public:
  // auto operator<=>(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  std::strong_ordering operator<=>(const TotallyOrdered& that) const {
    if (auto cmp = (Base&)(*this) <=> (Base&)that; cmp != 0) return cmp;
    if (auto cmp = last_name <=> that.last_name; cmp != 0) return cmp;
    if (auto cmp = first_name <=> that.first_name; cmp != 0) return cmp;

    return tax_id <=> that.tax_id;
  }

  // bool operator==(const TotallyOrdered&) const = default; ã®å®Ÿè£…ã‚¤ãƒ¡ãƒ¼ã‚¸
  bool operator==(const TotallyOrdered& that) const {
    if (!((Base&)(*this) == (Base&)that)) return false;
    if (!(last_name == that.last_name)) return false;
    if (!(first_name == that.first_name)) return false;

    return tax_id == that.tax_id;

  }
};
```

å®Ÿéš›ã«ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã‚‚ã®ã®ã€ã“ã‚Œã¨å¤§ããç•°ãªã‚‹ã‚³ãƒ¼ãƒ‰ãŒç”Ÿæˆã•ã‚Œã‚‹ã“ã¨ã‚‚ãªã„ã¯ãšã§ã™ã€‚ã“ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãŠã„ã¦ã¯ã€ä½¿ç”¨ã™ã‚‹å„ã‚µãƒ–ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ¯”è¼ƒæ¼”ç®—å­ï¼ˆ`== <=>`ï¼‰ã‚’é™¤ã„ã¦æœªå®šç¾©å‹•ä½œã‚’æ··å…¥ã•ã›ã‚‹ã“ã¨ãªãå®Ÿè£…ãŒã§ãã‚‹ã¯ãšã§ã™ã€‚ã¾ãŸã€`<=> ==`ãŒãã®ã‚ˆã†ã«ãªã£ã¦ã„ã‚Œã°ã€ãã“ã‹ã‚‰ç”Ÿæˆã•ã‚Œã‚‹ä»–ã®æ¯”è¼ƒæ¼”ç®—å­ã§ã‚‚åŒæ§˜ã®ä¿è¨¼ã‚’æä¾›ã§ãã¾ã™ã€‚

- [P3811 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2423)

### [P3812R0 `const` and `&` in default member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3812r0.html)

`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã‚’å¯èƒ½ã«ã™ã‚‹ææ¡ˆã€‚

ã‚¯ãƒ©ã‚¹ã®éé™çš„ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨ã—ã¦`const`ã‚ã‚‹ã„ã¯å‚ç…§ãƒ¡ãƒ³ãƒã‚’æŒã¤ã¨ã€ãã®ã‚¯ãƒ©ã‚¹ã®ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªããªã‚Šã¾ã™ã€‚

```cpp
// least privilege
class leastp final {
public:
  leastp(std::vector<int>& v, int i)
      : v{v}, i{i} {}

  // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ãã‚‹
  leastp(const leastp&) = default;
  leastp(leastp&&) = default;

  // ä»£å…¥æ¼”ç®—å­ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå®Ÿè£…ã§ããªã„ï¼ˆdeleteã•ã‚Œã‚‹
  leastp& operator=(const leastp& other) = default;
  leastp& operator=(leastp&& other) = default;

  // least privilege
  constexpr size_t size() const {
      return v.size();
  }

private:
  std::vector<int>& v;
  const int i;
};
```

ã“ã‚Œã¯ä»£å…¥æ¼”ç®—å­ã‚’æ‰‹æ›¸ããã™ã‚‹ã“ã¨ã‚’è€ƒãˆã‚‹ã¨åˆ†ã‹ã‚Šã‚„ã™ã„ã¨æ€ã‚ã‚Œã¾ã™ãŒã€å‚ç…§ã‚„`const`ãƒ¡ãƒ³ãƒã¯åŸºæœ¬çš„ã«ç½®æ›å¯èƒ½ã§ã¯ãªã„ãŸã‚ã§ã™ã€‚

ã“ã‚Œã‚’å®Ÿè£…ã—ã‚ˆã†ã¨ã™ã‚‹ã¨`*this`ã‚’é…ç½®ã—ãªãŠã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°æ¬¡ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã‚Šã¾ã™

```cpp
class leastp final {
  ...

  leastp& operator=(const leastp& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(other);
    }

    return *this;
  }

  leastp& operator=(leastp&& other) {
    if (this != &other) {
      // *thisã‚’ä¸€æ—¦ç ´æ£„
      this->~leastp();

      // ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’ç”¨ã„ã¦thisã®å ´æ‰€ã«æ–°ã—ã„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ§‹ç¯‰
      new (this) leastp(std::move(other));
    }
    
    return *this;
  }

  ...
};
```

ã“ã®ã‚ˆã†ãªå®Ÿè£…ã¯è¤‡é›‘ã§ã‚ã‚Šã€æ­£ã—ãè¨˜è¿°ã™ã‚‹ã“ã¨ãŒå›°é›£ã§ã™ï¼ˆå°‘ã—é–“é•ãˆã‚‹ã¨UBã«çªå…¥ã™ã‚‹ï¼‰ã€‚C++ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã«ãŠã„ã¦ã‚‚ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–å¯èƒ½ãªã‚¯ãƒ©ã‚¹ã«`const`ãƒ¡ãƒ³ãƒã‚„å‚ç…§ãƒ¡ãƒ³ãƒã‚’å«ã‚ãªã„ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¦ã„ã¾ã™ã€‚

ã“ã®ææ¡ˆã¯ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’éé™çš„ãƒ¡ãƒ³ãƒã«æŒã¤ã‚¯ãƒ©ã‚¹ã«ãŠã„ã¦ã€ã‚³ãƒ”ãƒ¼/ãƒ ãƒ¼ãƒ–ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãŒ`default`æŒ‡å®šã•ã‚Œã¦ã„ã‚‹ãªã‚‰ã°ã€é€éçš„ã«ç½®æ›å¯èƒ½ï¼ˆ*transparently replaceable*ï¼‰ã¨ã—ã¦ã€å¯¾å¿œã™ã‚‹ä»£å…¥æ¼”ç®—å­ã‚‚`default`å®Ÿè£…ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã“ã‚Œã«ã‚ˆã£ã¦ã€`const`/å‚ç…§ãƒ¡ãƒ³ãƒã‚’ä¿æŒã—ãŸã„å ´åˆã«è«¦ã‚ãŸã‚Šä»£ã‚ã‚Šã«ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿æŒã™ã‚‹ãªã©ã®å¿…è¦ãŒãªããªã‚Šã€ä¸Šè¨˜ã®ã‚ˆã†ãªå®Ÿè£…ã‚’å–ã‚‹å ´åˆã®ã‚³ãƒ¼ãƒ‰ã®å¿…è¦æ€§ã‚‚ãªããªã‚Šã€ã‚³ã‚¢ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚‚ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

- [P3812 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2424)

### [P3813R0 execution::task::valueless()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3813r0.pdf)
### [P3815R0 Add `scope_association` concept to P3149](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3815r0.html)

P3149ã®éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—æ©Ÿèƒ½ã«ã€`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã€‚

P3149ã®éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—æ©Ÿèƒ½ã¯ã€2ã¤ã®ã‚¹ã‚³ãƒ¼ãƒ—å‹ï¼ˆ`simple_counting_scope`ã€`counting_scope`ï¼‰ã¨`associate`ã€`spawn`ã€`spawn_future`ãªã©ã®åŸºç¤çš„ãªæ“ä½œã«ã‚ˆã£ã¦æ§‹æˆã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã‚‰ã®ã‚‚ã®ã¯`scope_token`ã¨ã„ã†ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ä¸­å¿ƒã¨ã—ã¦è¨­è¨ˆã•ã‚Œã¦ã„ã¾ã™ã€‚

```cpp
namespace ex = std::execution;

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¾ã™ã‚‹ç°¡å˜ãªå‹
struct my_window {
  class close_message {};

  ex::sender auto some_work(int message);

  ex::sender auto some_work(close_message message);

  void onMessage(int i) {
    ++count;
    // onã«ã‚ˆã£ã¦schã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§some_workã‚’å®Ÿè¡Œã—
    // ãã®æ“ä½œã¯scopeã«å¯¾å¿œã™ã‚‹ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚Œã‚‹
    ex::spawn(ex::on(sch, some_work(i)), scope);
  }

  void onClickClose() {
    ++count;
    ex::spawn(ex::on(sch, some_work(close_message{})), scope);
  }

  my_window(ex::system_scheduler sch, ex::counting_scope::token scope)
    : sch(sch)
    , scope(scope) {
    // ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ä½•ã‚‰ã‹ã®æ–¹æ³•ã§Windwoãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã«ç™»éŒ²ã—
    // `onMessage()`ã¨`onClickClose()`ã®å‘¼ã³å‡ºã—ã‚’å—ã‘ä»˜ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
  }

  ex::system_scheduler sch;
  ex::counting_scope::token scope;
  int count{0};
};

int main() {
  // keep track of all spawned work
  ex::counting_scope scope;
  ex::system_context ctx;
  try {
    my_window window{ctx.get_scheduler(), scope.get_token()};
  } catch (...) {
    // do something with exception
  }

  // scopeã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸå…¨ã¦ã®æ“ä½œã®å®Œäº†ã‚’å¾…æ©Ÿã™ã‚‹
  std::this_thread::sync_wait(scope.join());
  
  // ã™ã¹ã¦ã®ãƒªã‚½ãƒ¼ã‚¹ã¯å®‰å…¨ã«ç ´æ£„ã§ãã‚‹
  // =ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸæ“ä½œã¯ã™ã¹ã¦å®Œäº†ã—ã¦ã„ã‚‹
  return window.count;
}
```

ã‚¹ã‚³ãƒ¼ãƒ—å‹ã¯ã€ãã®ã‚¹ã‚³ãƒ¼ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸéåŒæœŸå‡¦ç†ï¼ˆ`sender`ï¼‰ã«ã‚ˆã‚‹å‡¦ç†ãŒå…¨ã¦çµ‚ã‚ã‚‹ã¾ã§ã€ãã“ã§ä½¿ç”¨ã•ã‚Œã†ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿è­·ã™ã‚‹ãŸã‚ã®ã‚‚ã®ã§ã™ã€‚ã‚¹ã‚³ãƒ¼ãƒ—ã¸ã®éåŒæœŸæ“ä½œã®é–¢é€£ä»˜ã‘ã¯`execution::spawn`ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã¦ãŠã‚Šã€ã“ã“ã«å‡¦ç†ã‚’è¡¨ã™`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‹ã‚‰å–å¾—ã—ãŸãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆä¸Šè¨˜ä¾‹ã ã¨`counting_scope::token`ï¼‰ã‚’æ¸¡ã™ã“ã¨ã§ã‚¹ã‚³ãƒ¼ãƒ—ã¨éåŒæœŸå‡¦ç†ã‚’é–¢é€£ä»˜ã‘ã¦ã„ã¾ã™ã€‚

ã‚¹ã‚³ãƒ¼ãƒ—ã¯`.join()`ã«ã‚ˆã£ã¦ã‚¹ã‚³ãƒ¼ãƒ—è‡ªèº«ã®`sender`ã‚’å–å¾—ã§ãã€ãã®`sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸå‡¦ç†ãŒå…¨ã¦çµ‚ã‚ã‚‹ã¾ã§å®Œäº†ã—ãªã„ã‚‚ã®ã§ã™ã€‚ã‚¹ã‚³ãƒ¼ãƒ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’é©åˆ‡ã«ç®¡ç†ã™ã‚‹ã“ã¨ã§ã€ã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å®Ÿè¡Œã•ã‚Œã‚‹éåŒæœŸå‡¦ç†ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒªã‚½ãƒ¼ã‚¹ï¼ˆä¸Šè¨˜ä¾‹ã ã¨`system_context`ã‚„`window`è‡ªèº«ï¼‰ã‚’ãã®å®Œäº†ã¾ã§é©åˆ‡ã«ä¿è­·ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã®ææ¡ˆã¯`scope_association`ã¨ã„ã†ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’å°å…¥ã—ã€ã“ã‚Œã‚’ç”¨ã„ã¦P3149ã§ææ¡ˆã•ã‚Œã¦ã„ã‚‹ã“ã‚Œã‚‰ã®æ©Ÿèƒ½ã®å†…éƒ¨è¨­è¨ˆã‚’è¡Œã†ã“ã¨ã§ã€ç¾åœ¨ã®å®Ÿè£…ã‚ˆã‚Šè‰¯ã„å®Ÿè£…ã‚’å–ã‚‹ã“ã¨ãŒã§ãã‚‹ã¨ã—ã¦ã€`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¨ãã‚Œã«ã‚ˆã‚‹å†è¨­è¨ˆã‚’ææ¡ˆã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã¨ã¯ã„ãˆã€ã“ã“ã§ã®å†è¨­è¨ˆã¯å†…éƒ¨ã«é–‰ã˜ãŸã‚‚ã®ã§ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å¤‰æ›´ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã“ã‚Œã«ã‚ˆã‚Šæ¬¡ã®åˆ©ç‚¹ãŒå¾—ã‚‰ã‚Œã‚‹ã¨ã—ã¦ã„ã¾ã™

- ã‚¹ã‚³ãƒ¼ãƒ—å‹ã¨åŸºç¤æ“ä½œã®ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºã®å‰Šæ¸›
- ãƒ ãƒ¼ãƒ–/ã‚³ãƒ”ãƒ¼ã®å›æ•°ã‚’æ¸›ã‚‰ã›ã‚‹
- å®Ÿè£…ãƒ¢ãƒ‡ãƒ«ãŒç°¡ç´ åŒ–ã•ã‚Œã€ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã‚„ã™ããªã‚‹

ææ¡ˆã•ã‚Œã¦ã„ã‚‹`scope_association`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã¯æ¬¡ã®ã‚ˆã†ãªã‚‚ã®ã§ã™

```cpp
template <class Assoc>
concept scope_association =
  movable<Assoc> &&
  default_initializable<Assoc> &&
  requires(Assoc assoc) {
    { static_cast<bool>(assoc) } noexcept;
    { assoc.try_associate() } -> same_as<Assoc>;
  };
```

`scope_association`ã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹å‹ã¯ã€`sender`ã¨éåŒæœŸã‚¹ã‚³ãƒ¼ãƒ—é–“ã®é–¢é€£ä»˜ã‘ã‚’è¡¨ã™RAIIãƒãƒ³ãƒ‰ãƒ«å‹ã¨ãªã‚Šã¾ã™ã€‚ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‹ã‚‰èª­ã¿å–ã‚Œã‚‹æ€§è³ªã¯æ¬¡ã®ã‚ˆã†ã«ãªã‚Šã¾ã™

- ãƒ ãƒ¼ãƒ–å¯èƒ½
    - ã‚³ãƒ”ãƒ¼ä¸å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’æ„å›³
- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ§‹ç¯‰å¯èƒ½
- `bool`ã¸ã®å¤‰æ›ãŒå¯èƒ½
    - æ–‡è„ˆçš„`bool`å¤‰æ›å¯èƒ½ã§ã‚ã‚‹ã“ã¨ã‚’æ„å›³
- `.try_associate()`ã‚’æŒã¤

`scope_association`ãªå‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ`assoc`ã¯ã€`bool`å¤‰æ›ã•ã‚Œã¦`true`ã‚’è¿”ã—ãŸå ´åˆï¼ˆâ€œengagedâ€ãªçŠ¶æ…‹ï¼‰ã¯ä½•ã‚‰ã‹ã®`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã®é–“ã§é–¢é€£ä»˜ã‘ãŒæˆç«‹ã—ã¦ã„ã‚‹ã“ã¨ã‚’è¡¨ã—ã€`false`ã‚’è¿”ã—ãŸå ´åˆï¼ˆâ€œdisengagedâ€ãªçŠ¶æ…‹ï¼‰ã¯é–¢é€£ä»˜ã‘ãŒæˆç«‹ã—ã¦ã„ãªã„ã“ã¨ã‚’è¡¨ã—ã¾ã™ã€‚

`.try_associate()`ã«ã¤ã„ã¦ã¯P3149ã®`scope_token`ï¼ˆã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹ï¼‰å‹ã®ãã‚Œã¨å…¨ãåŒã˜æ„å‘³è«–ã¨ãªã‚Šã¾ã™ã€‚

`scope_association`å‹ã¯RAIIãƒãƒ³ãƒ‰ãƒ«ã§ã‚ã‚Šã€ãã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§é–¢é€£ä»˜ã‘ã®é–‹æ”¾å‡¦ç†ï¼ˆ`scope_token`ã®`.disassociate()`ç›¸å½“ï¼‰ã‚’è¡Œã†ã“ã¨ã§é–¢é€£ä»˜ã‘è§£é™¤ã¨ãã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚’è‡ªå‹•åŒ–ã—ã¾ã™ã€‚

ã“ã‚Œã‚’ç”¨ã„ã¦ã€P3149ã®`scope_token, associate, spawn, spawn_future, simple_counting_scope, counting_scope`ã‚’å¤‰æ›´ã—ã¾ã™ã€‚

#### `execution::scope_token`

P3149ã®ä¸­å¿ƒæ¦‚å¿µã§ã‚ã‚‹`scope_token`ã¯æ¬¡ã®ã‚ˆã†ã«å®šç¾©ãŒå¤‰ã‚ã‚Šã¾ã™

<table>
<tr>
<th>P3149R11</th>
<th>ã“ã®ææ¡ˆ</th>
</tr>
<tr>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
      { token.try_associate() } -> same_as<bool>;
      { token.disassociate() } noexcept -> same_as<void>;
      { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
    { token.try_associate() } -> scope_association;
    { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
</tr>
</table>

`.try_associate()`ã¯`scope_association`å‹ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã“ã‚Œã¾ã§ã¯é–¢é€£ä»˜ã‘ã®æˆå¦ã‚’è¡¨ã™`bool`å€¤ã‚’è¿”ã—ã¦ã„ã¾ã—ãŸãŒã€`scope_association`å‹ã‚’è¿”ã™ã“ã¨ã§é–¢é€£ä»˜ã‘ãã®ã‚‚ã®ã‚’è¡¨ç¾ã™ã‚‹ã‚‚ã®ã‚’è¿”ã™ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

`scope_association`å‹ã¯ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§é–‹æ”¾å‡¦ç†ã‚’è‡ªå‹•åŒ–ã™ã‚‹ãŸã‚ã€`.disassociate()`ã¯ä¸è¦ã«ãªã‚Šã¾ã™ã€‚

#### `execution::associate`

`associate`ã¯CPOã§ã‚ã‚Šã€`sender auto associate(sender auto&&, scope_token auto) noexcept(...);`ã®æ§˜ãªã‚·ã‚°ãƒãƒãƒ£ã‚’æŒã¤ã‚‚ã®ã§ã™ã€‚ã“ã‚Œã¯ã€`sender`ã¨ã‚¹ã‚³ãƒ¼ãƒ—ã‚’`scope_token`ã‚’ä»‹ã—ã¦é–¢é€£ä»˜ã‘ã‚’è¡ŒãŠã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹ã‚„å½¹å‰²ã¯å¤‰åŒ–ã—ã¾ã›ã‚“ãŒã€è¿”ã•ã‚Œã‚‹`sender`ã®ã‚³ãƒ”ãƒ¼å‹•ä½œãŒå¤‰åŒ–ã—ã¾ã™ã€‚

`associate()`ã«æ¸¡ã•ã‚Œã‚‹`sender`ãŒã‚³ãƒ”ãƒ¼å¯èƒ½ãªå ´åˆã€çµæœã®`associate-sender`ã‚‚ã‚³ãƒ”ãƒ¼å¯èƒ½ã¨ãªã‚Š

- é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„`associate-sender`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã¨ã€å¿…ãšæ–°ã—ã„é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„`associate-sender`ãŒç”Ÿæˆã•ã‚Œã‚‹
- é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹`associate-sender`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ã«ã¯ã€ãã‚Œã«å«ã¾ã‚Œã‚‹`associate-data`ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€ãã®ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ¬¡ã®ã‚ˆã†ã«å‹•ä½œã™ã‚‹
    1. ã‚½ãƒ¼ã‚¹ã®`association.try_associate()`ã‚’å‘¼ã³å‡ºã—ãŸçµæœãŒå®›å…ˆã®`associate-data`ã«æ¸¡ã•ã‚Œã‚‹
    2. çµæœã®é–¢é€£ä»˜ã‘ï¼ˆ`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ãŒengagedçŠ¶æ…‹ãªã‚‰ã°ã€ãƒ©ãƒƒãƒ—ã•ã‚ŒãŸ`sender`ã‚’ã‚½ãƒ¼ã‚¹ã‹ã‚‰å®›å…ˆã®`associate-data`ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹
        - å®›å…ˆã®`associate-sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹
    3. ãã†ã§ãªã„å ´åˆã€å®›å…ˆã®`associate-sender`ã¯é–¢é€£ä»˜ã‘ã‚‰ã‚Œã¦ã„ãªã„

ã•ã‚‰ã«ã€`operation-state`ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¯æ¬¡ã®äº‹ã‚’ä¿è¨¼ã—ã¾ã™

- ç‹¬è‡ªã®é–¢é€£ä»˜ã‘ï¼ˆ`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã‚’æŒã¤`operation-state`ã¯`operation-state`ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®æœ€å¾Œã®ã‚¹ãƒ†ãƒƒãƒ—ã¨ã—ã¦ã€é–¢é€£ä»˜ã‘ã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’å‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹

#### `execution::spawn`/`execution::spawn_future`

å†…éƒ¨çŠ¶æ…‹ã§`scope_token`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã™ã‚‹ä»£ã‚ã‚Šã«`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä¿æŒã™ã‚‹ã‚ˆã†ã«ãªã‚Šã€é–¢é€£ä»˜ã‘ã®è§£é™¤ãŒãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

#### `execution::simple_counting_scope`/`execution::counting_scope`

é–¢é€£ä»˜ã‘ã®è§£é™¤ãŒ`token.try_associate()`ã‹ã‚‰è¿”ã•ã‚Œã‚‹`scope_association`ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã«ã‚ˆã£ã¦è¡Œã‚ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

ã“ã‚Œã‚‰ã®å¤‰æ›´ã¯å‰è¿°ã®ã‚ˆã†ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ãã®APIã«ã¯ã»ã¨ã‚“ã©å½±éŸ¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãã®ã†ãˆã§ã€å†…éƒ¨å®Ÿè£…ã‚’æ”¹å–„ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

- [P3149R11 async_scope -- Creating scopes for non-sequential concurrency - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2025å¹´07æœˆï¼‰](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3149R11-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3815 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/2426)

### [P3816R0 Hashing meta::info](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3816r0.html)
### [P3818R0 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r0.html)
### [P3818R1 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r1.html)
### [P3819R0 Remove evaluation_exception() from contract-violation handling for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)
### [P3820R0 Split constexpr uncaught_exceptions into distinct runtime and consteval functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r0.html)
### [P3820R1 Fix constexpr uncaught_exceptions and current_exception](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r1.html)
### [P3822R0 Conditional noexcept specifiers in compound requirements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3822r0.html)
### [P3823R0 Wording for US NB comment 10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3823r0.html)
### [P3824R0 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r0.html)
### [P3827R0 Wording for US NB comment 9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3827r0.html)
### [P3829R0 Contracts do not belong in the language](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3829r0.pdf)
### [P3830R0 NB-Commenting is Not a Vehicle for Redesigning inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3830r0.pdf)
### [P3831R0 Contract Labels Should Use Annotation Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3831r0.html)
### [P3832R0 Timed lock algorithms for multiple lockables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3832r0.pdf)
### [P3834R0 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r0.html)
### [P3835R0 Contracts make C++ less safe -- full stop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3835r0.html)
### [P3836R0 Make optional<T&> trivially copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r0.html)
### [P3838R0 Restoring Private Module Fragments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3838r0.pdf)

- [ é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/)
