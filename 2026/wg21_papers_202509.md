# ［C++］WG21月次提案文書を眺める（2025年09月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-09](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-09)

全部で37本あります。

もくじ

[:contents]

### [N5020 2026-11 Búzios Meeting Information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5020.html)
### [P2953R2 Forbid defaulting operator=(X&&) &&](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2953r2.html)
### [P3347R5 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r5.pdf)
### [P3567R1 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r1.html)
### [P3579R2 Fix matching of constant template parameters when matching template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3579r2.html)
### [P3612R0 Harmonize proxy-reference operations (LWG 3638 and 4187)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3612r0.html)

`vector<bool>::reference`と`bitset<N>::reference`の間で一貫したIssue解決を行う提案。

この提案は`vector<bool>::reference`と`bitset<N>::reference`に関する次の2つのイシュー解決の際に、追加する`swap()/operator=`のシグネチャを共通化しようとするものです。

- [LWG Isse 3638 `vector<bool>::swap(reference, reference)` is useless](https://cplusplus.github.io/LWG/issue3638)
- [LWG Isse 4187 `bitset::reference` should be const-assignable](https://cplusplus.github.io/LWG/issue4187)

P2321（`views::zip`の提案）では`views::zip`の動作のために`vector<bool>::reference`に代入演算子が追加されており、これは

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();

      // bool型への暗黙変換
      constexpr operator bool() const noexcept;

      // 既存の代入演算子
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321で追加された代入演算子
      constexpr const reference& operator=(bool x) const noexcept;

      ...
    };
   };
}
```

プロクシ参照型は`const`でも代入可能である必要があったものの`vector<bool>::reference`は`const`修飾された代入演算子を持っていなかったため、後方互換性を維持しつつそれを可能にするために`const`修飾された代入演算子が追加されました。この時、その戻り値型は`reference`のprvalueではなく、`const`lvalueとされました（なぜかはよくわかりません）。

この`vector<bool>::reference`は`std::swap`が意図通りに動作しないため`swap()`のカスタマイズが必要です。例えば、`vector<bool> v`に対して`std::swap(v[1], v[2])`が機能する必要があるものの、`std::swap`は非`const`参照しか取らないため呼び出せません。また、呼び出せたとしても、`std::swap`のデフォルト実装である`Reference t = r1; r1 = r2; r2 = t;`の様な交換操作は`vector<bool>::reference`のコピーは参照のコピーになるため、参照先の`bool`値を交換しないためです。

LWG Isse 3638はこれについてのイシュー報告です。

一方、`vector<bool>::reference`とほぼ同じ動作をするものに、`bitset<N>::reference`があります。

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) = default;
      constexpr ~reference();
      
      // bool型への暗黙変換
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // 代入演算子
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];

      ...
    };
  };
}
```

こちらはP2321で変更されなかった（`bitset`が`range`ではないためと思われる）ため、`const`修飾された代入演算子を持たず、`swap`について同様の問題があります。LWG Isse 4187は前者（`const`代入演算子）についてのイシュー報告です。

これら2つの型には共通点が多くあるものの、両方のイシューの解決後も型のインターフェースは一貫していません。この提案は、この両方のイシューを合わせた形の一貫した解決を両方の型に適用しようとするものです。

すなわち次の変更を適用します

- `vector<bool>::reference`
    - ADL `swap()`を追加
- `bitset<N>::reference`
    - `const`修飾された代入演算子を追加
    - ADL `swap()`を追加

提案後の両クラスのインターフェース

```cpp
namespace std {
  template<class Allocator>
  class vector<bool, Allocator> {
    public:  
    ...
     
    class reference {
      friend class vector;
      constexpr reference() noexcept;
    public:
      constexpr reference(const reference&) noexcept; // 👈
      constexpr ~reference();

      // bool型への暗黙変換
      constexpr operator bool() const noexcept;

      // 既存の代入演算子
      constexpr reference& operator=(const bool x) noexcept;
      constexpr reference& operator=(const reference& x) noexcept;
      
      // P2321で追加された代入演算子
      constexpr const reference& operator=(bool x) const noexcept;
      
      // この提案によるADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // 👈
      friend constexpr void swap(reference x, bool& y) noexcept;      // 👈
      friend constexpr void swap(bool& x, reference y) noexcept;      // 👈

      ...
    };
   };
}
```

```cpp
namespace std {
  template<size_t N>
  class bitset {
  public:
    ...

    class reference {
    public:
      constexpr reference(const reference&) noexcept; // 👈
      constexpr ~reference();
      
      // bool型への暗黙変換
      constexpr operator bool() const noexcept;                  // for x = b[i];
      
      // 代入演算子
      constexpr reference& operator=(bool x) noexcept;           // for b[i] = x;
      constexpr reference& operator=(const reference&) noexcept; // for b[i] = b[j];
      
      // この提案によるconst 代入演算子
      constexpr const reference& operator=(bool x) const noexcept;  // 👈
      
      // この提案によるADL swap()
      friend constexpr void swap(reference x, reference y) noexcept;  // 👈
      friend constexpr void swap(reference x, bool& y) noexcept;      // 👈
      friend constexpr void swap(bool& x, reference y) noexcept;      // 👈

      ...
    };
  };
}
```

`bool&`を取る2つの`swap()`オーバーロードは、`bool`型の左辺値`b`と`reference`の左辺値`r`に対して`swap(r, b)`と`swap(b, r)`を機能させるためのオーバロードです。どちらの`reference`も`bool&`から暗黙変換可能ではないため、この`swap`を機能させるためにこの2つのオーバロードが必要になります。

コピーコンストラクタの`default`が削除されているのは、実装によって両クラスのデストラクタのトリビアル性に差異があったことから、標準としてそれを強制することを回避することを意図したものです。コピーコンストラクタは実際には主要3実装全てでトリビアルでしたが、ここでのトリビアル性が重要ではないことからデストラクタに合わせたようです。

- [P3612 進行状況](https://github.com/cplusplus/papers/issues/2419)

### [P3666R0 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r0.html)
### [P3688R3 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r3.html)
### [P3695R1 Deprecate implicit conversions between Unicode character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r1.html)
### [P3702R2 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r2.html)
### [P3754R1 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r1.pdf)
### [P3776R0 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r0.html)
### [P3776R1 More trailing commas](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3776r1.html)
### [P3784R1 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r1.pdf)
### [P3786R0 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r0.pdf)

固定サイズ`std::span`にタプルプロトコルサポートを追加する提案。

タプルプロトコルは固定サイズの多くのライブラリ型ですでにサポートされており、構造化束縛のカスタマイズポイントとなります。`std::span`はまだサポートしていないため、追加しようとする提案です。

```cpp
std::span<int, 3> s{...}; 
auto & [x, y, z] = s; // ok、この提案後

std::vector<std::span<int, 3>> ss{...}; 
auto firsts{ss | std::views::elements<0> 
               | std::ranges::to<vector>()};  // ok、この提案後
```

実は以前にもP1024でこれは提案されており、C++20で採択されていたのですが、`std::tuple_element_t<const std::span<T, 3>>`が`const T`になる（`T`になってほしい）という問題が報告された結果、P2116で削除されています。ここでの設計はこの問題を`std::span`が参照セマンティクスを持つ型として扱うことで解決しています。

すなわち、`std::span`に対するトップレベルの修飾子はすべて無視されます。

- `tuple_size<cv1 span<cv2 T, N>>::value == N`
- `tuple_element<I, cv1 span<cv2 T, N>>::type == cv2 T`
- `decltype(get(span<cv T, N>)) == cv T`

当然ですが、タプルプロトコルサポートは固定サイズ（`N != dynamic_extent`）の場合のみです。

- [P3786 進行状況](https://github.com/cplusplus/papers/issues/2422)

### [P3811R0 default comparison memory safety](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3811r0.html)

デフォルト比較演算子の実装に対してメモリ安全であることを要求するようにする提案。

C++20で追加された比較演算子のデフォルト実装において生成されるコードはかなり単純かつボイラープレート的なコードであり、UBフリーで実装できるはずです。この提案は、標準としてそのような実装を行うことを要求するようにする提案です。

デフォルト比較演算子の実装は例えば次のようになります

```cpp
class TotallyOrdered : Base {
    string tax_id;
    string first_name;
    string last_name;
public:
  // auto operator<=>(const TotallyOrdered&) const = default; の実装イメージ
  std::strong_ordering operator<=>(const TotallyOrdered& that) const {
    if (auto cmp = (Base&)(*this) <=> (Base&)that; cmp != 0) return cmp;
    if (auto cmp = last_name <=> that.last_name; cmp != 0) return cmp;
    if (auto cmp = first_name <=> that.first_name; cmp != 0) return cmp;

    return tax_id <=> that.tax_id;
  }

  // bool operator==(const TotallyOrdered&) const = default; の実装イメージ
  bool operator==(const TotallyOrdered& that) const {
    if (!((Base&)(*this) == (Base&)that)) return false;
    if (!(last_name == that.last_name)) return false;
    if (!(first_name == that.first_name)) return false;

    return tax_id == that.tax_id;

  }
};
```

実際にコンパイラがこのようなコードを生成するわけではないものの、これと大きく異なるコードが生成されることもないはずです。このようなコードにおいては、使用する各サブオブジェクトの比較演算子（`== <=>`）を除いて未定義動作を混入させることなく実装ができるはずです。また、`<=> ==`がそのようになっていれば、そこから生成される他の比較演算子でも同様の保証を提供できます。

- [P3811 進行状況](https://github.com/cplusplus/papers/issues/2423)

### [P3812R0 `const` and `&` in default member functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3812r0.html)

`const`/参照メンバを持つクラスの代入演算子のデフォルト実装を可能にする提案。

クラスの非静的メンバ変数として`const`あるいは参照メンバを持つと、そのクラスの代入演算子はデフォルト実装できなくなります。

```cpp
// least privilege
class leastp final {
public:
  leastp(std::vector<int>& v, int i)
      : v{v}, i{i} {}

  // コンストラクタはデフォルト実装できる
  leastp(const leastp&) = default;
  leastp(leastp&&) = default;

  // 代入演算子はデフォルト実装できない（deleteされる
  leastp& operator=(const leastp& other) = default;
  leastp& operator=(leastp&& other) = default;

  // least privilege
  constexpr size_t size() const {
      return v.size();
  }

private:
  std::vector<int>& v;
  const int i;
};
```

これは代入演算子を手書ききすることを考えると分かりやすいと思われますが、参照や`const`メンバは基本的に置換可能ではないためです。

これを実装しようとすると`*this`を配置しなおす必要があります。例えば次のような実装になります

```cpp
class leastp final {
  ...

  leastp& operator=(const leastp& other) {
    if (this != &other) {
      // *thisを一旦破棄
      this->~leastp();

      // コピーコンストラクタを用いてthisの場所に新しいオブジェクトを構築
      new (this) leastp(other);
    }

    return *this;
  }

  leastp& operator=(leastp&& other) {
    if (this != &other) {
      // *thisを一旦破棄
      this->~leastp();

      // ムーブコンストラクタを用いてthisの場所に新しいオブジェクトを構築
      new (this) leastp(std::move(other));
    }
    
    return *this;
  }

  ...
};
```

このような実装は複雑であり、正しく記述することが困難です（少し間違えるとUBに突入する）。C++コアガイドラインにおいてもコピー/ムーブ可能なクラスに`const`メンバや参照メンバを含めないことが推奨されています。

この提案は、`const`/参照メンバを非静的メンバに持つクラスにおいて、コピー/ムーブコンストラクタが`default`指定されているならば、透過的に置換可能（*transparently replaceable*）として、対応する代入演算子も`default`実装できるようにするものです。

これによって、`const`/参照メンバを保持したい場合に諦めたり代わりにポインタを保持するなどの必要がなくなり、上記のような実装を取る場合のコードの必要性もなくなり、コアガイドラインも不要になります。

- [P3812 進行状況](https://github.com/cplusplus/papers/issues/2424)

### [P3813R0 execution::task::valueless()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3813r0.pdf)
### [P3815R0 Add `scope_association` concept to P3149](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3815r0.html)

P3149の非同期スコープ機能に、`scope_association`コンセプトを追加する提案。

P3149の非同期スコープ機能は、2つのスコープ型（`simple_counting_scope`、`counting_scope`）と`associate`、`spawn`、`spawn_future`などの基礎的な操作によって構成されており、これらのものは`scope_token`というコンセプトを中心として設計されています。

```cpp
namespace ex = std::execution;

// ウィンドウを表現する簡単な型
struct my_window {
  class close_message {};

  ex::sender auto some_work(int message);

  ex::sender auto some_work(close_message message);

  void onMessage(int i) {
    ++count;
    // onによってschのコンテキストでsome_workを実行し
    // その操作はscopeに対応するスコープに関連付けられる
    ex::spawn(ex::on(sch, some_work(i)), scope);
  }

  void onClickClose() {
    ++count;
    ex::spawn(ex::on(sch, some_work(close_message{})), scope);
  }

  my_window(ex::system_scheduler sch, ex::counting_scope::token scope)
    : sch(sch)
    , scope(scope) {
    // このクラスを何らかの方法でWindwoフレームワークに登録し
    // `onMessage()`と`onClickClose()`の呼び出しを受け付けられるようにする
  }

  ex::system_scheduler sch;
  ex::counting_scope::token scope;
  int count{0};
};

int main() {
  // keep track of all spawned work
  ex::counting_scope scope;
  ex::system_context ctx;
  try {
    my_window window{ctx.get_scheduler(), scope.get_token()};
  } catch (...) {
    // do something with exception
  }

  // scopeに関連付けられた全ての操作の完了を待機する
  std::this_thread::sync_wait(scope.join());
  
  // すべてのリソースは安全に破棄できる
  // =スコープに関連付けられた操作はすべて完了している
  return window.count;
}
```

スコープ型は、そのスコープに関連付けられた非同期処理（`sender`）による処理が全て終わるまで、そこで使用されうるリソースを保護するためのものです。スコープへの非同期操作の関連付けは`execution::spawn`によって行われており、ここに処理を表す`sender`とスコープから取得したトークン（上記例だと`counting_scope::token`）を渡すことでスコープと非同期処理を関連付けています。

スコープは`.join()`によってスコープ自身の`sender`を取得でき、その`sender`は関連付けられた処理が全て終わるまで完了しないものです。スコープオブジェクトを適切に管理することで、スコープ内で実行される非同期処理で使用されるリソース（上記例だと`system_context`や`window`自身）をその完了まで適切に保護することができます。

この提案は`scope_association`というコンセプトを導入し、これを用いてP3149で提案されているこれらの機能の内部設計を行うことで、現在の実装より良い実装を取ることができるとして、`scope_association`コンセプトとそれによる再設計を提案するものです。

とはいえ、ここでの再設計は内部に閉じたものでインターフェースを変更するものではありません。これにより次の利点が得られるとしています

- スコープ型と基礎操作のバイナリサイズの削減
- ムーブ/コピーの回数を減らせる
- 実装モデルが簡素化され、カスタマイズしやすくなる

提案されている`scope_association`コンセプトは次のようなものです

```cpp
template <class Assoc>
concept scope_association =
  movable<Assoc> &&
  default_initializable<Assoc> &&
  requires(Assoc assoc) {
    { static_cast<bool>(assoc) } noexcept;
    { assoc.try_associate() } -> same_as<Assoc>;
  };
```

`scope_association`のモデルとなる型は、`sender`と非同期スコープ間の関連付けを表すRAIIハンドル型となります。コンセプトから読み取れる性質は次のようになります

- ムーブ可能
    - コピー不可能であることを意図
- デフォルト構築可能
- `bool`への変換が可能
    - 文脈的`bool`変換可能であることを意図
- `.try_associate()`を持つ

`scope_association`な型のオブジェクト`assoc`は、`bool`変換されて`true`を返した場合（“engaged”な状態）は何らかの`sender`とスコープの間で関連付けが成立していることを表し、`false`を返した場合（“disengaged”な状態）は関連付けが成立していないことを表します。

`.try_associate()`についてはP3149の`scope_token`（のモデルとなる）型のそれと全く同じ意味論となります。

`scope_association`型はRAIIハンドルであり、そのデストラクタで関連付けの開放処理（`scope_token`の`.disassociate()`相当）を行うことで関連付け解除とそのクリーンアップ処理を自動化します。

これを用いて、P3149の`scope_token, associate, spawn, spawn_future, simple_counting_scope, counting_scope`を変更します。

#### `execution::scope_token`

P3149の中心概念である`scope_token`は次のように定義が変わります

<table>
<tr>
<th>P3149R11</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
      { token.try_associate() } -> same_as<bool>;
      { token.disassociate() } noexcept -> same_as<void>;
      { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
<td valign="top">

```cpp
template <class Token>
concept scope_token =
  copyable<Token> &&
  requires(Token token) {
    { token.try_associate() } -> scope_association;
    { token.wrap(declval<test-sender>()) } -> sender_in<test-env>;
  };
```

</td>
</tr>
</table>

`.try_associate()`は`scope_association`型を返すようになります。これまでは関連付けの成否を表す`bool`値を返していましたが、`scope_association`型を返すことで関連付けそのものを表現するものを返すようになります。

`scope_association`型はデストラクタで開放処理を自動化するため、`.disassociate()`は不要になります。

#### `execution::associate`

`associate`はCPOであり、`sender auto associate(sender auto&&, scope_token auto) noexcept(...);`の様なシグネチャを持つものです。これは、`sender`とスコープを`scope_token`を介して関連付けを行おうとするものです。

インタフェースや役割は変化しませんが、返される`sender`のコピー動作が変化します。

`associate()`に渡される`sender`がコピー可能な場合、結果の`associate-sender`もコピー可能となり

- 関連付けられていない`associate-sender`をコピーすると、必ず新しい関連付けられていない`associate-sender`が生成される
- 関連付けられている`associate-sender`をコピーするには、それに含まれる`associate-data`をコピーする必要があり、そのコピーコンストラクタは次のように動作する
    1. ソースの`association.try_associate()`を呼び出した結果が宛先の`associate-data`に渡される
    2. 結果の関連付け（`scope_association`オブジェクト）がengaged状態ならば、ラップされた`sender`をソースから宛先の`associate-data`にコピーする
        - 宛先の`associate-sender`は関連付けられている
    3. そうでない場合、宛先の`associate-sender`は関連付けられていない

さらに、`operation-state`のデストラクタは次の事を保証します

- 独自の関連付け（`scope_association`オブジェクト）を持つ`operation-state`は`operation-state`のデストラクタの最後のステップとして、関連付けのデストラクタを呼び出す必要がある

#### `execution::spawn`/`execution::spawn_future`

内部状態で`scope_token`オブジェクトを保持する代わりに`scope_association`オブジェクトを保持するようになり、関連付けの解除がデストラクタによって行われるようになります。

#### `execution::simple_counting_scope`/`execution::counting_scope`

関連付けの解除が`token.try_associate()`から返される`scope_association`オブジェクトのデストラクタによって行われるようになります。

これらの変更は前述のようにユーザー向きのAPIにはほとんど影響がありません。そのうえで、内部実装を改善しようとするものです。

- [P3149R11 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3149R11-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3815 進行状況](https://github.com/cplusplus/papers/issues/2426)

### [P3816R0 Hashing `meta::info`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3816r0.html)

`meta::info`のハッシュサポートを追加する提案。

`meta::info`はリフレクション機能において`^^`（リフレクション操作）の戻り値となるリフレクションオブジェクトの型であり、コンパイル時にのみ使用可能な不透明型です。コンパイル時のハッシュサポートはリフレクションにおいても考慮されていなかったため、`meta::info`はハッシュ化可能ではありません。

一方、P3372R3では連想コンテナを含むほぼすべてのコンテナが`constexpr`対応しており、そのためにハッシュサポートが重要となります。

そのために、この提案は`meta::info`のコンパイル時ハッシュサポートを追加しようとするものです。

しかし`meta::info`はコンパイル時にのみ使用可能な型であり、`std::hash`の特殊化による対応は実行時要件が多く課せられるため適していません。そのほかのコンパイル時にのみ使用可能な型のコンパイル時ハッシュサポートのために、`std::consteval_hash<T>`を追加し、その`meta::info`特殊化としてコンパイル時ハッシュサポートを追加することを提案しています。

リフレクションによる`mp_unique`実装の、コンパイル時`unordered_set`を使用する例

```cpp
template <typename... Types>
struct type_list {};

template <typename TypeList>
consteval auto mp_unique_reflected() {
  static_assert(std::meta::has_template_arguments(^^TypeList), "mp_unique requires a type_list");
  static_assert(std::meta::template_of(^^TypeList) == ^^type_list, "mp_unique requires a type_list");

  std::unordered_set<std::meta::info, std::consteval_hash<std::meta::info>> seen;
  std::vector<std::meta::info> unique_types;

  for (auto type_info : std::meta::template_arguments_of(^^TypeList)) {
    if (const bool is_unique = seen.insert(type_info).second; is_unique) {
      unique_types.push_back(type_info);
    }
  }

  return std::meta::substitute(^^type_list, unique_types);
}

template <class TypeList>
using mp_unique = [:mp_unique_reflected<TypeList>():];

using input = type_list<int, char, int, string, double, char>;
using filtered = mp_unique<input>;
using expected = type_list<int, char, string, double>;

static_assert(is_same_v<expected, filtered>);
```

`std::hash`はコンパイル時に利用可能なようになっておらず、その予定もないため、非順序連想コンテナをコンパイル時に使用するためにはハッシュのカスタマイズがどのみち必要になります。そのため新しいコンパイル時専用ハッシュ型を追加することはコンパイル時の非順序連想コンテナの使用感を今より悪くすることはありません。このことは問題ではあるものの、この提案はその解決を行うことを意図していません。

*ConstevalHash*要件は次のように指定されています

- 関数オブジェクト型
- コピー構築可能勝つ破棄可能
    - *Cpp17CopyConstructible*かつ*Cpp17Destructible*
- `consteval`オンリー型
- `H`の2つの実体は、同じ引数に対して同じ値を生成することを保証しない
    - `H`は*ConstevalHash*型
    - 特に、翻訳単位間で値が異なることがある
- `Key`型を`H`の関数呼び出し引数型、`h`を`H`のオブジェクト、`u`を`Key`の左辺値、`k`を`Key`に変換可能な型の値として、次の操作が有効かつ指定されたセマンティクスを持つ
    - `h(k) -> std::size_t`
        - 返される値は`k`のみに依存する
        - 値はコンパイルを繰り返し実行しても安定している
            - ソースコードを変更すると値が変わる可能性がある
        - 2つの異なる値`t1, t2`について、`h(t1) == h(t2)`となる確率は非常に小さく、`1.0 / numeric_limits<size_t>::max()`に近くなる
    - `h(u) -> std::size_t`
        - `u`を変更しない

提案文書より、実装例

```cpp
template<>
struct consteval_hash<meta::info>
{
  consteval consteval_hash() = default;
  consteval consteval_hash(const consteval_hash<meta::info>&) = default;
  consteval consteval_hash(consteval_hash<meta::info>&&) = default;

  consteval auto operator()(meta::info r) const noexcept -> size_t {
    return __metafunction(meta::detail::__metafn_reflection_hash, r);
  }

private:

  // This unused variable is here to make consteval_hash<> a
  // consteval-only type.
  [[maybe_unused]] const meta::info unused = ^^::;
};
```

- [P3816 進行状況](https://github.com/cplusplus/papers/issues/2427)

### [P3818R0 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r0.html)

↓

### [P3818R1 constexpr exception fix for potentially constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3818r1.html)

現在の例外をチェックする関数を特定の定数評価コンテキストで評価しないようにする提案。

C++26では定数式での例外送出が可能になっており、それに伴って`std::exception`とその派生クラスなどの例外関連のユーティリティが定数式で実行可能になっています。例えば、`std::current_exception()`によって`std::exception_ptr`を定数式で取得して処理することができます。

```cpp
constexpr auto maybe_throw(int n);

consteval void f() {
  try {
    maybe_throw(1);
  } catch (...) {
    auto exptr = std::current_exception();  // ok
  }
}
```

`std::current_exception()`は定数式で呼ばれる場合、その定数評価コンテキスト内で送出されている例外オブジェクトを取得します。

ところで、定数評価は`constexpr`変数の初期化や`consteval`関数呼び出しなどの明示的な評価の開始以外でも行われることがあります。その一つは`const`な整数型の変数の初期化式が定数評価可能な場合で、このような変数を*potentially constant*な変数（定数かもしれない変数）と呼びます。

```cpp
constexpr int f() {
  return 1;
}

int main() {
  const int n = f();  // nはpotentially constantな変数
}
```

定数かもしれない変数には正確には`constexpr`変数も含みますがここではそれは除外するとします。

この定数かもしれない変数はその初期化子が定数評価可能であれば、その結果を用いてコンパイル時に初期化され、定数式のコンテキストで使用可能になります。定数かもしれない変数であっても初期化式が定数評価可能でなければ、その初期化及び初期化式の評価は実行時に行われます。

`std::current_exception()`などの呼び出しはC++26から定数評価可能な式です。以前は定数評価可能ではなかったためこの変更が下位互換性を損ねることは無いはずでしたが、これらの式が定数かもしれない変数の初期化式に使用されている場合に動作が変化します。

```cpp
try {
  // 例外を投げうるコード
	...
} catch (const std::exception & exc) {
  // has_exceptionは定数かもしれない変数だが、C++23まではその初期化式は定数評価可能ではなかった
	const bool has_exception = (std::current_exception() != nullptr); // 定数評価された時にはそのコンテキストに現在の例外は存在しない
	static_assert(has_exception == false); // ✅、has_exceptionは定数式で使用可能
}
```

`const`な整数型（`bool`を含む）は定数かもしれない変数ですが、`std::current_exception()`の呼び出しはC++23までは定数評価不可能だったため定数評価されることはありませんでした。しかしC++26では定数評価可能になることによってこの`has_exception`の初期化式は定数式としてコンパイル時に実行されます。この変数の初期化によって開始する定数評価コンテキストでは例外は送出されていないため、定数式では`catch`の内部であるにもかかわらず`std::current_exception()`は`nullptr`を返します。

これによって、`has_exception`は実行時の例外状態と全く関係なく常に`false`で初期化されることになります。

提案文書より、他の例

```cpp
struct transaction {
	// ...
	void cancel() { /* revert changes */ }
	
	~transaction() {
    // unrollingは定数かもしれない変数
		const bool unrolling = std::uncaught_exceptions() > 0;  // falseでコンパイル時に初期化される
		
		if (unrolling) { // this will never be evaluated
			log("exception was thrown in a transaction => cancel()");
			cancel();
		}
	}
}
```

定数かもしれない変数`unrolling`はC++26から定数式によって初期化されるようになります。しかも、ユーザーの意図とは全く異なる結果によって初期化されます（常に`false`）。

これらのように、変数の初期化式から開始される定数評価コンテキストではその評価の内部で例外が送出されない限り現在の例外オブジェクトが存在する状態になりません。そのため、定数かもしれない変数の初期化式で`std::uncaught_exceptions()`や`std::current_exceptions()`が使用されていて初期化式全体が定数評価かのうだと、これらの関数は常に現在の例外が無い状態で評価され結果を取得します。

この提案はこの問題を解消しようとするもので、`std::uncaught_exceptions()`と`std::current_exceptions()`の`constexpr`は維持したうえで、これらの関数が定数かもしれない変数の初期化のために定数評価される場合に呼び出しを定数式ではなくすることを提案しています。

これにより、上記の2例のようなケースでは`std::uncaught_exceptions()`と`std::current_exceptions()`の呼び出しが定数式ではなくなることで、定数かもしれない変数の初期化はC++23までと同じく実行時に行われるようになります。

この提案の内容に対応するNBコメントが3件提出されているようで、それを受けてLEWGでこの提案とこの問題について審議された結果、この提案の変更は大きすぎるとして`std::uncaught_exceptions()`と`std::current_exceptions()`から単に`constexpr`を取り除くことに若干の合意があったようです。これを受けてこの問題の解決はP3842R0に委ねられたようです。

- [P3818 進行状況](https://github.com/cplusplus/papers/issues/2428)

### [P3819R0 Remove evaluation_exception() from contract-violation handling for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3819r0.pdf)

`std::contracts::contract_violation::evaluation_exception()`を削除する提案。

C++26 Contracts機能における違反ハンドラの引数型である`std::contracts::contract_violation`型には、その違反ハンドラが契約述語からの例外送出によって呼び出されていた場合にその例外オブジェクトを取得するための関数`.evaluation_exception()`が用意されています。

```cpp
void handle_contract_violation (const contract_violation& cv) {
  if (auto exptr = cv.evaluation_exception(); exptr != nullptr) {
    // 例外処理
    ...
  }
}
```

違反ハンドラを呼び出した契約違反が契約述語が`false`を返したことによって起きていた場合、`.evaluation_exception()`は`nullptr`を返します。

契約違反が例外によって起きたかどうかということ自体は`.detection_mode()`が`std::detection_mode::evaluation_exception`であるかを調べることによっても行えます。こちらの場合は再スローを行うことで現在の例外をキャッチすることができます。

```cpp
void handle_contract_violation (const contract_violation& cv) {
  if (cv.detection_mode() == detection_mode::evaluation_exception) {
  try {
    throw;
  } catch (std::exception& e) {
    // 例外処理
    ...
  }
}
```

この方法は`.detection_mode()`のチェックを忘れた場合に失敗するか、悪い場合は関係ない例外を処理してしまう可能性があります（違反ハンドラ自体は`catch`節の中でも呼ばれる）。`.evaluation_exception()`はこのような冗長なチェックを回避して、違反ハンドラの呼び出しの原因となった例外オブジェクトに簡単にアクセスするために追加されたものです。

`.evaluation_exception()`は`.detection_mode()`を用いた方法の構文糖衣として提案されましたが、現在の例外ではなく違反ハンドラの呼び出しの原因となった例外オブジェクトを常に取得するものであり、このことに実装上の問題がありました。

```cpp
void handle_contract_violation (const contract_violation& cv) {
  // ...
  try {
    // ...
    throw X;
  } catch (...) {
    if (cv.detection_mode() == detection_mode::evaluation_exception) {
      // 現在の例外オブジェクトをXであり、契約述語から送出されたものではない
      auto evaluation_exception_ptr = cv.evaluation_exception();
      // evaluation_exception_ptrはXではなく元の例外を処理する
    }
  }
}
```

このような動作を実現するためには、契約違反の原因となった例外オブジェクトを通常の例外状態から退避しておく必要があります。一部の実装ではそのために例外オブジェクトのコピーを行う必要があり、そのコピーコンストラクタを通して例外送出による契約違反と違反ハンドラ呼び出しの間にユーザーコードが実行されてしまう可能性があります。

違反ハンドラは契約違反が起きている状況（スタック破損などが起きている可能性がある）で実行することが想定されているため、そのような状況に対してある程度堅牢に記述することができる一方、例外オブジェクトのコピーコンストラクタはそうではなく、スタックトレースを取得しようとしてスタックを走査する可能性があります。そして、これがセキュリティ上の脆弱性につながる可能性があります（破壊されたスタックを走査するコードを通して任意の場所にジャンプさせることで、任意のコードを実行する）。

Itanium ABIを採用するプラットフォームでは例外オブジェクトのコピーを回避する実装が知られている一方、Windows ABIでは現時点でそのような実装を確認できていません。`.evaluation_exception()`を今のまま導入しようとすると、このようなセキュリティリスクを回避するための要件をC++の例外システムに新たに課すことになります。

これらの問題のため、この提案では`.evaluation_exception()`が全てのプラットフォームで安全に実装可能であることが確認されるまで標準に導入しないようにすることを提案しています。

前述のように、問題はあるものの`.detection_mode()`のチェックと`std::current_exception()`という代替手段があるため、`.evaluation_exception()`を削除しても同等のことができなくなるわけではありません。こちらの方法の場合でも例外のコピーは発生しえますが、それは違反ハンドラ内のユーザーコードで見えている物であり制御可能なものです。

この提案はNBコメント解決として2025年11月の全体会議でC++26向けに採択され、C++26に適用されています。

- [P3227R1 Fixing the library API for contract violation handling - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3227R1-Fixing-the-library-API-for-contract-violation-handling)
- [P3819 進行状況](https://github.com/cplusplus/papers/issues/2429)

### [P3820R0 Split constexpr `uncaught_exceptions` into distinct runtime and consteval functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r0.html)

↓

### [P3820R1 Fix constexpr `uncaught_exceptions` and `current_exception`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3820r1.html)

`std::uncaught_exceptions()`と`std::current_exceptions()`から`constexpr`指定を削除する提案。

この提案の指摘する問題やモチベーションは少し上のP3818R1と共通しているのでそちらをご覧ください。

この提案はP3818R1とは異なり問題に対して次の解決策を提案しています

- `std::uncaught_exceptions()`から`constexpr`指定を削除する
- 定数式で使用できる専用の`std::consteval_uncaught_exceptions()`を追加する
    - 呼び出された定数評価の中での例外をカウントする
- `std::current_exceptions()`は、呼び出されたのと同じ定数評価の中で送出され現在処理中の例外が存在する場合にのみ定数式となる、ように変更
- 定数式で使用できる専用の`std::consteval_current_exception()`を追加する
    - （呼び出された時点での）現在の定数評価内で送出された現在処理中の例外オブジェクトへのポインタを返し、それ以外の場合は`nullptr`を返す

この提案の場合、`std::uncaught_exceptions()`は定数式で使用できなくなり、定数式で使用するには名前の違う`std::consteval_uncaught_exceptions()`を使わなければなりません。これによって、実行時とコンパイル時でコードを共通する場合は`if consteval`による分岐が必要になります。`std::current_exceptions()`は少し異なり、定数式で呼ばれたときに`nullptr`を返さない場合にのみ定数評価可能になります。

P3818R1のところでも述べたように、結局どちらの提案もC++26のNBコメント解決フェーズに導入するには適さないとして、P3824R0にて`std::uncaught_exceptions()`と`std::current_exceptions()`から`constexpr`を削除することのみをC++26向けの修正とするようです。

- [P3820 進行状況](https://github.com/cplusplus/papers/issues/2430)

### [P3822R0 Conditional noexcept specifiers in compound requirements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3822r0.html)
### [P3823R0 Wording for US NB comment 10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3823r0.html)

`trivially_relocatable_if_eligible`などの文脈依存キーワードを削除する提案。

これは提出されたNBコメントの一つに対応するものです。ここでの主張はP1144での主張の一部でもあります。

- [P1144R13 `std::is_trivially_relocatable`](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P1144R13-stdis_trivially_relocatable)

`trivially_relocatable_if_eligible`や`replaceable_if_eligible`はリロケーションに関連して追加されたもので、クラスの宣言に対して付与して、そのクラスがリロケーション（特にトリビアルなリロケーション）が可能であることをクラスのプロパティとして追加するものです。

```cpp
struct Y trivially_relocatable_if_eligible {};
```

これには次のような問題点が指摘されています

- 在野の主要なプロジェクト/ライブラリにおいて使用されている・求められている意味論と整合しないため、使用できない
- 現在リロケーションを利用している実装は、C++26モード以外ではこのキーワードを使用できない
- C++26モードでも、`optional`や`inplace_vector`をサポートするには不十分なことが分かっている

このような理由から、これらの文脈依存キーワードはC++26では一旦削除してC++29以降に向けて再検討することを求めるのが、NBコメント（US NB comment 10）の内容です。ただし、リロケーションというコア言語およびライブラリの仕様そのものを削除することは提案していません。

- [P3823 進行状況](https://github.com/cplusplus/papers/issues/2432)

### [P3824R0 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r0.html)
### [P3827R0 Wording for US NB comment 9](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3827r0.html)
### [P3829R0 Contracts do not belong in the language](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3829r0.pdf)
### [P3830R0 NB-Commenting is Not a Vehicle for Redesigning inplace_vector](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3830r0.pdf)
### [P3831R0 Contract Labels Should Use Annotation Syntax](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3831r0.html)
### [P3832R0 Timed lock algorithms for multiple lockables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3832r0.pdf)
### [P3834R0 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r0.html)
### [P3835R0 Contracts make C++ less safe -- full stop](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3835r0.html)
### [P3836R0 Make optional<T&> trivially copyable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r0.html)
### [P3838R0 Restoring Private Module Fragments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3838r0.pdf)

- [ 進行状況](https://github.com/cplusplus/papers/issues/)
