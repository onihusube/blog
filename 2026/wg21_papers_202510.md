# ［C++］WG21月次提案文書を眺める（2025年10月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-10)

全部で74本あります。

もくじ

[:contents]

### [N5021 2026-11 Búzios Meeting Information (rev. 1)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5021.html)

2026年11月にブラジルのブジオスで行われる全体会議のインフォメーション。

以前のもの（N5020）の更新版の様です。

### [N5022 WG21 agenda: 3-8 November 2025, Kona, HI, USA](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5022.html)

2025年11月にコナで行われる会議のアジェンダ。

### [N5023 2025-11 Kona meeting information (rev. 1)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5023.pdf)

2025年11月にハワイのコナで行われる全体会議のインフォメーション。

以前のもの（N4977）の更新版の様です。

### [N5024 2026-03 London meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5024.pdf)

2026年03月にイギリスのロンドンで行われる全体会議のインフォメーション。

予定（2026年03月23日～28日）と場所、ホテルの案内などが記載されています。

### [N5027 2025-10 WG21 admin telecon meeting (revised 2025-09-29)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5027.pdf)

11月の全体会議に先立って行われる、WG21管理者ミーティングの案内。

### [N5028 C++26 CD summary of voting and comments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5028.pdf)

C++26 CD（N5013）に対して提出されたNBコメントをまとめた文書。

### [P1708R10 Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1708r10.pdf)
### [P2034R5 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2034r5.pdf)
### [P2728R8 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2728r8.html)
### [P3086R5 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3086r5.html)
### [P3091R5 Better lookups for `map` , `unordered_map`, and `flat_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3091r5.html)
### [P3099R0 User-defined error messages for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3099r0.pdf)

契約アサーションにユーザーがエラーメッセージを指定できるようにする提案。

C++26 Contractsでは、3種類の契約アサーションはいずれも契約条件式のみを取り、契約違反が発生した場合はデフォルトの違反ハンドラによって何かしらの診断メッセージが発行されます（おそらく、違反を起こしたアサーションのソースコード位置と条件式の文字列化などの情報が出力される）。

これらのアサーションにユーザーが追加のエラーメッセージを指定できると、出力されたエラーメッセージからその契約違反が発生した原因や解決方法などを素早く理解するために役立ちます。Cのアサートもそのような機能を持っていませんでしたが、`assert(expr && "Reason")`の様なワークアラウンドによって実質的に同じことが可能でした（これは契約アサーションでも可能です）。また、多くの非標準のアサーションライブラリではそのような追加の診断メッセージ指定をサポートしている場合がほとんどです。

また、C++26 Contractsの場合は違反ハンドラのカスタマイズによってそのようなエラー情報の扱いをユーザーが変更することができるため、違反ハンドラからでもユーザー指定のメッセージにアクセスできる必要があります。

ClangによるC++26 Contractsの先行実装では、ベンダー属性を利用してこれをサポートしています。

```cpp
T& operator[] (size_t i) 
  pre [[clang::contract_message("Out-of-bounds access")]] (i < size()); 
```

この提案は、このclangの実装経験を参考にしつつ、契約アサーションにおいてユーザー指定のエラーメッセージをサポートしようとするものです。

提案では、エラーメッセージの指定方法は`static_assert`と構文的にも意味的にも同等なものになるようにしています。

```cpp
T& operator[] (size_t i)
  pre (i < size(), "Out-of-bounds access");
```

3種類のアサーションすべてで、`contract_assert(expr, message)`のように契約条件式の後にエラーメッセージを指定します。この構文は、`static_assert`と一貫することに加えて条件式の前にメッセージが来ない事や構文ノイズが少ないことなどから選択されています。

このエラーメッセージはコンパイル時の文字列である必要があり、C++26の`static_assert`のエラーメッセージとして有効な文字列と同じものを受け付けます（文字列リテラルだけでなく、コンパイル時`std::string`などを渡せる）。実行時文字列をサポートしようとすると、契約違反が起きてから違反ハンドラが呼び出されるまでの間にユーザーコードを実行する必要性が生じてしまい、これはセキュリティリスクの懸念があるためここではサポートを延期しています（P3819R0の`contract_violation::evaluation_exception()`と同じ理由）。

違反ハンドラの引数である`std::contracts::contract_violation`オブジェクトからは`.message()`という新しいAPIによってこのメッセージを取得できるようにします。

```cpp
namespace std::contracts {
  class contract_violation{

    ...

    const char* message() const noexcept; 
    
    ...
  };
}
```

デフォルトの違反ハンドラおよび定数式における契約違反時の診断メッセージについては、このユーザー指定エラーメッセージを含めるようにすることを推奨事項としています（現在でも診断メッセージの出力は推奨事項）。

この提案によって、`static_assert(expr, message)`は定数評価中にenforceセマンティクスで評価された`contract_assert(expr, message)`と同等になるようになります。また、`contract_assert(false, message)`とすることで定数評価中に任意のメッセージを出力できるようにもなり、P2758R5で提案されている機能の一部を包含してもいます。

- [P3819R0 Remove `evaluation_exception()` from contract-violation handling for C++26 - WG21月次提案文書を眺める（2025年09月）](https://onihusube.hatenablog.com/entry/2026/01/31/012640#P3819R0-Remove-evaluation_exception-from-contract-violation-handling-for-C26)
- [P2758R5 Emitting messages at compile time - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2758R5-Emitting-messages-at-compile-time)
- [C++26 `static_assert`の診断メッセージにユーザーが生成した文字列の指定を許可 [P2741R3] - cpprefjp](https://cpprefjp.github.io/lang/cpp26/user-generated_static_assert_messages.html)
- [P3099 進行状況](https://github.com/cplusplus/papers/issues/2444)

### [P3255R2 Expose whether atomic notifying operations are lock-free](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3255r2.html)
### [P3351R3 views::scan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3351r3.html)
### [P3385R6 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r6.html)
### [P3401R1 Proxy Creation Facilities: Enriching Proxy Construction for Pointer-Semantics Polymorphism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3401r1.html)
### [P3411R4 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r4.html)
### [P3505R1 Fix the default floating-point representation in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3505r1.html)
### [P3567R2 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r2.html)
### [P3578R1 What is "Safety"?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3578r1.pdf)
### [P3584R1 Proxy Facade Builder: Enriching Facade Construction for Pointer-Semantics Polymorphism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3584r1.html)
### [P3603R1 Consteval-only Values and Consteval Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3603r1.html)
### [P3606R1 On Overload Resolution, Exact Matches and Clever Implementations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3606r1.html)
### [P3643R2 std::to_signed and std::to_unsigned](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r2.html)
### [P3655R3 cstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r3.html)
### [P3663R3 Future-proof `submdspan-mapping`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r3.html)
### [P3666R1 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r1.html)
### [P3669R3 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r3.html)
### [P3684R0 Fix erroneous behaviour termination semantics for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3684r0.pdf)
### [P3688R4 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r4.html)
### [P3695R2 Deprecate implicit conversions between char8_t and char16_t, char32_t, or wchar_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r2.html)
### [P3702R3 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r3.html)
### [P3724R1 Integer division](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3724r1.html)
### [P3732R1 Numeric Range Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3732r1.html)
### [P3733R1 More named universal character escapes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3733r1.html)
### [P3737R1 std::array is a wrapper for an array!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3737r1.html)
### [P3739R3 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r3.html)
### [P3779R1 reserve() and capacity() for flat containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3779r1.pdf)
### [P3786R1 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r1.pdf)
### [P3800R0 2025-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3800r0.html)

2025年7月に行われた、LEWGにおける投票の結果。

次の提案が投票にかけられ、C++29に向けてLWGに転送されました。

- [P3125R5 constexpr pointer tagging](https://wg21.link/P3125R5)
- [P3778R0 Fix for type_order template definition](https://wg21.link/P3778R0)

また、投票の際に寄せられたコメントが記載されています。

### [P3804R0 Iterating on `parallel_scheduler`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3804r0.html)

`parallel_scheduler`の設計を洗練させるための提案。

P2079R10で提案されC++26にマージ済みの`parallel_scheduler`は、投入された処理の並行実行をサポートする`scheduler`です。提案段階でもかなり時間をかけて議論されていたのですが、WDへ入った後にも設計の懸念がいくつかあるようで、この提案はそれを改善することを目指すものです。

ここで提案されているのは次のことです

- 軽微な設計の修正
    1. `receiver_proxy::try_query`は`const`修飾できる
        - 現在されていないが、できない理由はない 
    2. `receiver_proxy`には仮想デストラクタは必要ない
        - 多態的に破棄されることがないため 
    3. `receiver_proxy::try_query`はストップトークンとして`inplace_stop_token`しか受け付けず、任意のストップトークンを使用できない
        - `inplace_stop_token`とその他の任意のストップトークンの間に実装定義のマッピングをサポートすることを推奨し、そのようなマッピングが存在する場合はクエリが成功するようにする
        - このようなメカニズムは他のプロパティにも役立つ可能性がある
    4. `receiver_proxy::try_query`がサポートするプロパティのリストが実装定義となっていること
        - これは次のユースケースのサポートを意図したもの
            1. 実装者がサポートするプロパティを追加したい場合
            2. 実装者が特定のプロパティをサポートしたくない場合
        - プロパティのリストを厳密に規定してしまうとどちらもサポートできなくなってしまうため、この提案では現状維持を推奨している
- より影響の大きい設計上の懸念事項
    1. `receiver_proxy::try_query`では、サポートされるクエリのリストを定義する必要がある 
        - `parallel_scheduler`のバックエンドが個別のライブラリとして別にコンパイルされる場合に、`receiver`のプロパティ（環境とそのクエリ）を解決する方法がない
        - 現在のところそのような実装は確立していないため、現状維持
- 命名について
    1. `system_context_replaceability`は置換可能性APIが含まれる名前空間に使用する適切な名前ではない 
        - `parallel_scheduler`は以前は`system_scheduler`という名前で、`system_context_replaceability`はその時の名残が残っている
        - いくつか名前の候補を提示してLEWGに委ねる
- 文言の不足
    1. `parallel_scheduler`における`bulk_unchunked/bulk_chunked`のカスタマイズに関する文言が十分に明確ではない
        - `bulk_unchunked/bulk_chunked`のカスタマイズが必須と指定されているがその詳細は説明されていない
        - また、カスタマイズ部分では実行ポリシーが考慮されていない
        - P3862R0を基礎とするソリューションを構築する（後のリビジョン？

この提案はC++26に間に合わせようとはしていませんが、関連するNBコメントが提出されているようです。

- [P2079R10 Parallel Scheduler - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P2079R10-Parallel-Scheduler)
- [P3804 進行状況](https://github.com/cplusplus/papers/issues/2447)

### [P3810R1 hardened memory safety guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3810r1.html)
### [P3824R1 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r1.html)
### [P3826R0 Defer Sender Algorithm Customization to C++29](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3826r0.html)

`sender`アルゴリズムのカスタマイズをC++29まで延期する提案。

C++26では、`std::execution`と呼ばれる並行・非同期処理の構成や実行制御のためのフレームワークとなるライブラリが導入されています。`std::execution`では、実際の非同期処理を構成するために`sender`アルゴリズムというものが用意されており、これは`sender`という抽象によって表現される非同期処理のより柔軟な構成をサポートするための共通部品となるものです（STLにおけるイテレータに対するアルゴリズムとの対応から、`sender`アルゴリズムと呼ばれます）。

```cpp
namespace ex = std::execution;

// scheduler: 処理の実行場所を指定する
ex::scheduler auto sc = ...:

// sender: 非同期処理を構成する
ex::sender auto async_work =
  ex::starts_on(sc, ex::just(10)) | 
  ex::then([](int n) {
    return n * n;
  }) |
  ex::then([](int n) {
    std::println("{}", n);
    return n;
  });

// receiver: 非同期処理の結果を受信するコールバック
ex::receiver auto re = ...;

// operation_state: 実行可能な状態の非同期処理
ex::operation_state auto os = ex::connect(async_work, re);

// 非同期処理の実行開始
ex::start(os);

// 終了の待機（receiver/operation_stateによって方法が異なる
re.wait();

// 結果の取得（receiverから取得する、receiverによって方法が異なる
auto n = re.result();
```

ここでの`ex::just`や`ex::then`などが`sender`アルゴリズムです。このほかにもいくつかの`sender`アルゴリズムが用意されており、このように`|`によってチェーンすることで非同期処理の構成をサポートします。

これらの`sender`アルゴリズムはそれぞれがCPOとして定義されており、ユーザーの用意した`sender`によるカスタマイズをサポートしています。これはユーザーの実行環境や要件に対応したより効率的な`sender`アルゴリズムの処理を可能にするための機構であり、ハードウェアベンダやその利用者が利用することを想定しています。

通常、`sender`アルゴリズムのカスタマイズはその目指す方向性から`scheduler`に対して行われますが、`sender`チェーンによる非同期操作では`scheduler`は上から入れる（上記例のように）ことも、下から入れる（チェーンの下方、あるいは`receiver`経由）こともできます。当初の`sender`アルゴリズムは上からのカスタマイズしか考慮していなかったものの、下から入れる場合のカスタマイズ（*Late customization*）をサポートするために途中で変更されています（P2999R3）。

しかし、その設計はまだ安定しておらず、その後も`sender`アルゴリズムのカスタマイズについては問題点がいくつか指定されています（P3718R0など）。これらの修正は可能ではあるもののその設計検討にはさらに時間をかける必要があり、C++26のタイムフレームの中で行うのは困難です（この提案の提出時点でC++26の機能追加フェーズは終わっています）。

そのため、この提案は`sender`アルゴリズムのカスタマイズをC++26ではオフにしておいて、カスタマイズについてより堅牢な設計をC++29で再導入しようとするものです。

P3718R0（未適用）時点での`sender`アルゴリズムのカスタマイズでは`sender`アルゴリズムの呼び出し時（*Early customization*）と`receiver`との接続時（*Late customization*）の2か所でのカスタマイズの検出とディスパッチをサポートしています。前述のように、カスタマイズは`scheduler`に対して行われるため、`sender`アルゴリズムは自身がどこで（どの`scheduler`で）実行されて完了するかを知る必要があります。

しかし多くの場合、`sender`は自身がどこで開始されるかを知らない限り、どこで完了するかが分からない、という問題があります。例えば、`ex::just()`はどこで開始されてもその場所で完了するものの、どこで開始されるかは単に`ex::just(10)`の様に呼び出された時点（*Early customization*時）には分からず、*Late customization*を待つ必要があります。

また、`ex::then(sndr, fn)`の場合もそれは同様な場合があり（`sndr`による、例えば`ex::just()`の場合など）、その場合は呼び出し時点のカスタマイズは行われず*Late customization*時に`receiver`の持つ情報に基づいて実行開始場所を取得し、カスタマイズが行われます。しかし、P3718R0で提案されているAPIではこの場合にこのような情報を取得することができない場合があります。

提案文書より、サンプル

```cpp
// GPU実行scheduler
ex::scheduler auto gpu = ...:

// GPU上で実行したい処理
auto ex::sender sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);

// GPU上で実行し結果を待機
std::this_thread::sync_wait(std::move(sndr));
```

`gpu`はGPU上で処理を実行する`scheduler`であり、`fn`はGPU上で実行されます。そのため、`ex::then`はGPU実装のためのカスタマイズを利用する必要があります。P3718R0のAPIではそれは次のように判定されます

- *Early customization*時、`starts_on(gpu, just()) | then(fn)`式の実行中、`then`CPOは`starts_on(gpu, just())`の`sender`に次のように完了する場所をクエリする

```cpp
auto&& tmp1 = ex::starts_on(gpu, ex::just());
auto dom1 = ex::get_domain(ex::get_env(tmp1));
```

- それを受けて`starts_on`の`sender`は次のように`just`の`sender`に完了する場所をクエリする

```cpp
auto&& tmp2 = ex::just();
auto dom2 = ex::get_domain(ex::get_env(tmp2));
```

- `just`の完了場所は開始場所が分かるまで分からないため、ここではその情報は入手できず、`dom2`は`default_domain`となり、これが`starts_on`のドメインとして`dom1`に返される
    - しかしこれは誤りであり、`starts_on`はGPU上で完了する
- `then`CPOは`default_domain`を利用してカスタマイズの検索を行い、デフォルト実装を使用する
- `then`の`sender`が`sync_wait`の`receiver`に接続されると、*Late customization*が試みられる
- `ex::connect`は`sync_wait`の`receiver`に`then`の`sender`の開始場所を問い合わせる

```cpp
auto dom3 = ex::get_domain(ex::get_env(rcvr));
```

- `sync_wait`自体は現在のスレッドで開始するため、ここでも`default_domain`が返されて、`dom3`は`default_domain`となる
- このドメインを使用してカスタマイズを検索するため、*Late customization*でも`then`のGPU実装は検索されない

このように、この例ではGPU上での`then`のためにデフォルト実装（実質的にCPU用のもの）が使用されることになりますが。これは望ましい状況ではありません。

このような問題の解決のための設計はおおむね完了しているようですが（提案のappendixで説明されています）、まだ実環境で動作したものではなく、精査が完了していないようです。このためDRプロセスに委ねることには不安があるようで（C++20 rangeの経験からの様子）、かといってC++26から`std::execution`全体あるいは`sender`アルゴリズムを削除することはC++における非同機構の導入と採択を実質的に3年遅らせることになります。

そのためこの提案では、`sender`アルゴリズムのカスタマイズ機構だけをC++26から削除して、それ以外の部分は維持することを提案しています。

これによりカスタマイズに関連する

- `default_domain`
- `transform_sender`
- `transform_env`
- `apply_sender`
- `get_domain`

などは削除されます。

C++29で復帰する予定のカスタマイズにおいては、*Early customization*を削除し*Late customization*のみにしたうえで、`sender`の完了スケジューラ（完了する場所）の問い合わせ時に開始場所についての情報を一緒に渡すようにするようです。

例えば、現在の`ex::get_completion_scheduler`クエリを拡張して、`sender`と`receiver`両方の環境を渡せるようにします。

```cpp
auto sch = get_completion_scheduler<set_value_t>(get_env(S), get_env(R));
```

*Late customization*は実質的に`ex::connect`によって呼び出される`connect`操作のカスタマイズによって行われ、C++29では`ex::connect`は次の2種類のドメインを計算します

- 開始ドメイン（*Starting domain*）: `get_domain(get_env(rcvr))`
- 完了ドメイン（*Completion domain*）: `get_completion_domain<set_value_t>(get_env(sndr), get_env(rcvr))`

これらの情報を利用して、`connect`フェーズにおいて正確なカスタマイズの検出とディスパッチを行えるようになります。

- [P2999R0 Sender Algorithm Customization - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2999R0-Sender-Algorithm-Customization)
- [P3718R0 Fixing Lazy Sender Algorithm Customization, Again - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3718R0-Fixing-Lazy-Sender-Algorithm-Customization-Again)
- [P3826 進行状況](https://github.com/cplusplus/papers/issues/2448)

### [P3828R0 Rename the "to_input" view to "as_input"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3828r0.pdf)
### [P3834R1 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r1.html)
### [P3836R1 Make optional<T&> trivially copyable (US NB comment 134)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r1.html)
### [P3841R0 Proposal for `std::constructor` Function Object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3841r0.html)

コンストラクタを関数オブジェクトとして扱うためのユーティリティの提案。

メンバ関数やフリー関数等通常の関数は、`<functional>`にあるようなユーティリティや`std::function`とそのファミリーを使用するなどして様々に活用することができます。しかし、これらのものに対してコンストラクタを関数と同じように扱わせることはできません。

コンストラクタを関数のように扱うためにはラッパが必要であり、この提案では`std::constructor<T>()`としてそれを提案しています。

提案文書より、`std::size_t`の範囲`input`があり、その要素の値によるサイズの`std::vector`の`std::vector`を得るような処理を書く例

```cpp
std::vector<std::vector<int>> result;
result.reserve(std::distance(input));
for (auto sz : input) {
  result.emplace_back(sz);
}
```

`input`が`input_range`である場合に2回のイテレーションが可能ではない場合があり、`emplace_back()`のループは範囲から直接構築するよりも非効率となります。

`range`ベースの現代的なソリューション

```cpp
auto result = input
    | std::views::transform([] (size_t sz) {
        return std::vector<int>(sz);
      }
    | std::ranges::to<std::vector>();
```

まだラムダ式が簡潔ではありません。

この提案

```cpp
auto result = input
    | std::views::transform(std::constructor<std::vector<int>>())
    | std::ranges::to<std::vector>();
```

`std::constructor<T>()`はコンストラクタオーバーロードの集合をCallableに変換します。これによって、コンストラクタを関数オブジェクトとして扱うことができ、既に関数オブジェクトを扱うことのできる場所で使用できるようになります。

`std::constructor<T>()`の宣言例

```cpp
namespace std {

  template <typename T>
  struct constructor {
    template <typename... Args>
    static constexpr T operator()(Args&&... args) noexcept(std::is_nothrow_constructible_v<T, Args...>) 
    {
      return T(std::forward<Args>(args)...);
    };
  };
}
```

- [P3841 進行状況](https://github.com/cplusplus/papers/issues/2450)

### [P3842R0 A conservative fix for constexpr uncaught_exceptions() and current_exception()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3842r0.html)
### [P3843R0 Reconsider R0 of P3774 (Rename std::nontype) for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3843r0.html)
### [P3844R0 Restore simd::vec broadcast from int](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3844r0.pdf)
### [P3845R0 Make std::execution's monadic operations naming scheme consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3845r0.html)
### [P3846R0 C++26 Contracts, reasserted](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3846r0.pdf)
### [P3849R0 SIS/TK611 considerations on Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3849r0.pdf)
### [P3851R0 Position on contracts assertion for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3851r0.pdf)
### [P3853R0 A thesis+antithesis=synthesis rumination on Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3853r0.html)
### [P3855R0 New Reflection metafunction - is_destructurable_type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3855r0.pdf)
### [P3856R0 New Reflection metafunction - is_destructurable_type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3856r0.pdf)
### [P3857R0 Policy: A function named `get` should return only on success](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3857r0.html)
### [P3858R0 A Lifetime-Management Primitive for Trivially Relocatable Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3858r0.pdf)
### [P3859R0 Assertions are not necessarily for changing program behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3859r0.html)
### [P3860R0 Proposed Resolution for NB Comment GB13-309 atomic_ref is not convertible to atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3860r0.html)
### [P3861R0 Pragmatic approach to standard structural types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3861r0.pdf)
### [P3862R0 Postpone `basic_string::subview` and wait for `cstring_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3862r0.html)
### [P3863R0 Minimal fix for CWG3003 (CTAD from template template parameters)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3863r0.pdf)
### [P3864R0 Correctly rounded floating-point maths functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3864r0.html)
### [P3865R0 Class template argument deduction (CTAD) for type template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3865r0.pdf)
### [P3866R0 V2: An Evolution Path for the Standard Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3866r0.pdf)
### [P3867R0 define_static_string as a STATICALLY_WIDEN replacement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3867r0.pdf)
### [P3868R0 Allow #line before module declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3868r0.html)
### [P3870R0 Renaming std::nontype to std::tag](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3870r0.pdf)
### [P3872R0 2025-10 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3872r0.html)
### [P3874R0 Safety Strategy Requirements for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3874r0.pdf)
### [P3875R0 Defining -ffast-math is hard!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3875r0.pdf)

- [ 進行状況](https://github.com/cplusplus/papers/issues/)
