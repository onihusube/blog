# ［C++］WG21月次提案文書を眺める（2025年10月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-10](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-10)

全部で74本あります。

もくじ

[:contents]

### [N5021 2026-11 Búzios Meeting Information (rev. 1)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5021.html)

2026年11月にブラジルのブジオスで行われる全体会議のインフォメーション。

以前のもの（N5020）の更新版の様です。

### [N5022 WG21 agenda: 3-8 November 2025, Kona, HI, USA](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5022.html)

2025年11月にコナで行われる会議のアジェンダ。

### [N5023 2025-11 Kona meeting information (rev. 1)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5023.pdf)

2025年11月にハワイのコナで行われる全体会議のインフォメーション。

以前のもの（N4977）の更新版の様です。

### [N5024 2026-03 London meeting information](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5024.pdf)

2026年03月にイギリスのロンドンで行われる全体会議のインフォメーション。

予定（2026年03月23日～28日）と場所、ホテルの案内などが記載されています。

### [N5027 2025-10 WG21 admin telecon meeting (revised 2025-09-29)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5027.pdf)

11月の全体会議に先立って行われる、WG21管理者ミーティングの案内。

### [N5028 C++26 CD summary of voting and comments](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5028.pdf)

C++26 CD（N5013）に対して提出されたNBコメントをまとめた文書。

### [P1708R10 Basic Statistics](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1708r10.pdf)
### [P2034R5 Partially Mutable Lambda Captures](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2034r5.pdf)
### [P2728R8 Unicode in the Library, Part 1: UTF Transcoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2728r8.html)
### [P3086R5 Proxy: A Pointer-Semantics-Based Polymorphism Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3086r5.html)
### [P3091R5 Better lookups for `map` , `unordered_map`, and `flat_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3091r5.html)
### [P3099R0 User-defined error messages for contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3099r0.pdf)

契約アサーションにユーザーがエラーメッセージを指定できるようにする提案。

C++26 Contractsでは、3種類の契約アサーションはいずれも契約条件式のみを取り、契約違反が発生した場合はデフォルトの違反ハンドラによって何かしらの診断メッセージが発行されます（おそらく、違反を起こしたアサーションのソースコード位置と条件式の文字列化などの情報が出力される）。

これらのアサーションにユーザーが追加のエラーメッセージを指定できると、出力されたエラーメッセージからその契約違反が発生した原因や解決方法などを素早く理解するために役立ちます。Cのアサートもそのような機能を持っていませんでしたが、`assert(expr && "Reason")`の様なワークアラウンドによって実質的に同じことが可能でした（これは契約アサーションでも可能です）。また、多くの非標準のアサーションライブラリではそのような追加の診断メッセージ指定をサポートしている場合がほとんどです。

また、C++26 Contractsの場合は違反ハンドラのカスタマイズによってそのようなエラー情報の扱いをユーザーが変更することができるため、違反ハンドラからでもユーザー指定のメッセージにアクセスできる必要があります。

ClangによるC++26 Contractsの先行実装では、ベンダー属性を利用してこれをサポートしています。

```cpp
T& operator[] (size_t i) 
  pre [[clang::contract_message("Out-of-bounds access")]] (i < size()); 
```

この提案は、このclangの実装経験を参考にしつつ、契約アサーションにおいてユーザー指定のエラーメッセージをサポートしようとするものです。

提案では、エラーメッセージの指定方法は`static_assert`と構文的にも意味的にも同等なものになるようにしています。

```cpp
T& operator[] (size_t i)
  pre (i < size(), "Out-of-bounds access");
```

3種類のアサーションすべてで、`contract_assert(expr, message)`のように契約条件式の後にエラーメッセージを指定します。この構文は、`static_assert`と一貫することに加えて条件式の前にメッセージが来ない事や構文ノイズが少ないことなどから選択されています。

このエラーメッセージはコンパイル時の文字列である必要があり、C++26の`static_assert`のエラーメッセージとして有効な文字列と同じものを受け付けます（文字列リテラルだけでなく、コンパイル時`std::string`などを渡せる）。実行時文字列をサポートしようとすると、契約違反が起きてから違反ハンドラが呼び出されるまでの間にユーザーコードを実行する必要性が生じてしまい、これはセキュリティリスクの懸念があるためここではサポートを延期しています（P3819R0の`contract_violation::evaluation_exception()`と同じ理由）。

違反ハンドラの引数である`std::contracts::contract_violation`オブジェクトからは`.message()`という新しいAPIによってこのメッセージを取得できるようにします。

```cpp
namespace std::contracts {
  class contract_violation{

    ...

    const char* message() const noexcept; 
    
    ...
  };
}
```

デフォルトの違反ハンドラおよび定数式における契約違反時の診断メッセージについては、このユーザー指定エラーメッセージを含めるようにすることを推奨事項としています（現在でも診断メッセージの出力は推奨事項）。

この提案によって、`static_assert(expr, message)`は定数評価中にenforceセマンティクスで評価された`contract_assert(expr, message)`と同等になるようになります。また、`contract_assert(false, message)`とすることで定数評価中に任意のメッセージを出力できるようにもなり、P2758R5で提案されている機能の一部を包含してもいます。

- [P3819R0 Remove `evaluation_exception()` from contract-violation handling for C++26 - WG21月次提案文書を眺める（2025年09月）](https://onihusube.hatenablog.com/entry/2026/01/31/012640#P3819R0-Remove-evaluation_exception-from-contract-violation-handling-for-C26)
- [P2758R5 Emitting messages at compile time - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2758R5-Emitting-messages-at-compile-time)
- [C++26 `static_assert`の診断メッセージにユーザーが生成した文字列の指定を許可 [P2741R3] - cpprefjp](https://cpprefjp.github.io/lang/cpp26/user-generated_static_assert_messages.html)
- [P3099 進行状況](https://github.com/cplusplus/papers/issues/2444)

### [P3255R2 Expose whether atomic notifying operations are lock-free](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3255r2.html)
### [P3351R3 views::scan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3351r3.html)
### [P3385R6 Attributes reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3385r6.html)
### [P3401R1 Proxy Creation Facilities: Enriching Proxy Construction for Pointer-Semantics Polymorphism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3401r1.html)
### [P3411R4 `any_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r4.html)
### [P3505R1 Fix the default floating-point representation in std::format](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3505r1.html)
### [P3567R2 `flat_meow` Fixes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3567r2.html)
### [P3578R1 What is "Safety"?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3578r1.pdf)
### [P3584R1 Proxy Facade Builder: Enriching Facade Construction for Pointer-Semantics Polymorphism](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3584r1.html)
### [P3603R1 Consteval-only Values and Consteval Variables](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3603r1.html)
### [P3606R1 On Overload Resolution, Exact Matches and Clever Implementations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3606r1.html)
### [P3643R2 std::to_signed and std::to_unsigned](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r2.html)
### [P3655R3 cstring_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r3.html)
### [P3663R3 Future-proof `submdspan-mapping`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r3.html)
### [P3666R1 Bit-precise integers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3666r1.html)
### [P3669R3 Non-Blocking Support for `std::execution`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r3.html)
### [P3684R0 Fix erroneous behaviour termination semantics for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3684r0.pdf)

erroneous behaviourにおける終了動作についての調整を行う提案。

EBについては以前の記事を参照

- [［C++］UBとEB](https://onihusube.hatenablog.com/entry/2023/12/11/000000)

最終的なC++26仕様においてEBの動作としては、実行時にEBが起こる場合に実装は診断メッセージを発行したうえでその後（未規定の時間経過後）プログラムを終了する、という動作が許可されています。これにより、EBが発生するとその後プログラムはエラー状態になり、その後任意の時点で突然終了する可能性があります。

C++26のEB（未初期化変数読み取り）に関する現在の実装には2つの方向性があります

1. 自動変数をゼロないし固定のパターンを持つ値に初期化することでその読み取り時（EB時）に安全な値を読み出すようにする
    - GCC/Clangが`-ftrivial-auto-var-init`を介して提供している
    - この実装では未定義動作は排除されるものの、推奨されるEBの診断動作を全く行わない
2. EBとなる未初期化変数読み取りを実際に検出する
    - Memory Sanitizerによる実装
    - EB（未初期化変数読み取り）の発生後しばらく経つと診断メッセージを発行して終了する

C++コードが最適化後の機械語命令列にどのようにマッピングされるかは直観的に理解しにくい場合が多いため、未初期化変数読み取りの様なチェックは通常コンパイル後のコードへの検出機能の組み込みによって行われます（Sanitizerがまさにそうです）。

特に、未初期化変数読み取りが発生する場所はその後に続く計算処理に巻き込まれることで、ソースコード上で特定できる場所よりも後の計算処理内部であることがあり、診断とプログラム終了もその場所で行われることになります。このような実装戦略を反映しているのがC++26の規定にある遅延終了セマンティクスです。

ただし、Memory Sanitizerの実装はEB発生後その特定を無限に遅延するわけではありません。あくまで、実際のソースコード位置よりもかなり離れた場所で検出と診断・プログラム終了が行われる可能性がある、というだけです。Memory Sanitizerはその実装として、未初期化変数読み取りの結果未初期化である値が原因として異なる動作をした評価を補足することに重点を置いています。

そのため、Memory Sanitizerの動作を適合実装として維持するためにEB発生後のプログラムがいつでもそのEBを根拠として終了できる許可を与える必要はありません。現在の規定では、EB発生とその検出後にタイマーを設定し任意の時間経過後に突然プログラムを終了するような異常な実装は不必要に許可されています。このような動作はソフトウェアの予測可能性と信頼性の向上に対して逆行する行いであり、考慮する必要はありません。

また、P3100R4では未初期化変数読み取り以外のUBについて、その妥当なデフォルト動作をEBとして置換しようとしていますが、これらのUB(EB)の場合は遅延終了が意味を持たないものがあり、遅延終了を許可することでEBの結果として生じる誤った値（Erroneous Value）とP3100R4で提案されている暗黙の契約違反との間の意味の一貫性の確立が妨げられます。

この提案では、このような問題の解決のためにEB発生後の遅延終了を削除することを提案しています。その代わりに、EBによって生成されるErroneous Valueがそれを使用する演算等を介して伝播するようにしています。

結果がErroneous Valueに依存するような操作はすべてErroneous Valueを生成するため、そのような操作はすべてEBとなります。実装は最初にEBが起きた場所ではなく、このようにErroneous Valueの伝播とともに発生するEBのどこかでEBの検知とプログラム終了という動作を取ることができます。これはMemory Sanitizerの実装動作ですが、GCC/Clangの実装動作のように最初に読みだすErroneous Valueを特定の値に初期化し、あとはそのまま続行するという動作も引き続き許可されます。

現在の実装ではErroneous Valueを読み取るとその値はクリーンアップされて有害ではなくなるというアプローチをとっているものの、その代償にプログラム全体が有害な状態になってしまっています。Erroneous Valueがデータとともに伝播するようにすることで、問題のあるデータの範囲をプログラム全体からErroneous Valueを扱うプログラムの一部に限定し現実的な実装をカバーするのに十分な程度にErroneousな範囲を広げつつ、EB発生後任意のタイミングでの突然の終了の様な動作を拒否することができます。

すなわちこの提案によって、EBの発生したプログラムはエラー状態に陥り予期しない終了の脅威に晒され続ける、ということは無くなります。ただし、Memory Sanitizerの実装のように、最も都合の良いタイミングでEBを検知し終了するための最大限の柔軟性を提供しています。

この提案の後では、EBについて次のような性質が実現されます

- Memory Sanitizerなど、未初期化の値の使用をトラップする既存の実装は適合実装のまま
    - 何らの変更を加えることなく現在の動作を維持できる
- プログラムがEBによって終了した場合、プログラム開始から終了までの間でEBを発生させた可能性のある実行の全てを特定することなく、終了の理由を局所的に推論できるようになる
- プログラムが実行状態にあり、EBを発生させるような操作を行っていない場合、それより以前のEBによって終了しないことが保証される

この提案については、対応するNBコメントが提出されているようです。

- [P3100R4 A framework for systematically addressing undefined behaviour in the C++ Standard - WG21月次提案文書を眺める（2025年08月）](https://onihusube.hatenablog.com/entry/2026/01/18/210314#P3100R4-A-framework-for-systematically-addressing-undefined-behaviour-in-the-C-Standard)
- [P3684 進行状況](https://github.com/cplusplus/papers/issues/2445)

### [P3688R4 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r4.html)
### [P3695R2 Deprecate implicit conversions between char8_t and char16_t, char32_t, or wchar_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3695r2.html)
### [P3702R3 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r3.html)
### [P3724R1 Integer division](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3724r1.html)
### [P3732R1 Numeric Range Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3732r1.html)
### [P3733R1 More named universal character escapes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3733r1.html)
### [P3737R1 std::array is a wrapper for an array!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3737r1.html)
### [P3739R3 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r3.html)
### [P3779R1 reserve() and capacity() for flat containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3779r1.pdf)
### [P3786R1 Tuple protocol for fixed-size spans](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3786r1.pdf)
### [P3800R0 2025-07 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3800r0.html)

2025年7月に行われた、LEWGにおける投票の結果。

次の提案が投票にかけられ、C++29に向けてLWGに転送されました。

- [P3125R5 constexpr pointer tagging](https://wg21.link/P3125R5)
- [P3778R0 Fix for type_order template definition](https://wg21.link/P3778R0)

また、投票の際に寄せられたコメントが記載されています。

### [P3804R0 Iterating on `parallel_scheduler`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3804r0.html)

`parallel_scheduler`の設計を洗練させるための提案。

P2079R10で提案されC++26にマージ済みの`parallel_scheduler`は、投入された処理の並行実行をサポートする`scheduler`です。提案段階でもかなり時間をかけて議論されていたのですが、WDへ入った後にも設計の懸念がいくつかあるようで、この提案はそれを改善することを目指すものです。

ここで提案されているのは次のことです

- 軽微な設計の修正
    1. `receiver_proxy::try_query`は`const`修飾できる
        - 現在されていないが、できない理由はない 
    2. `receiver_proxy`には仮想デストラクタは必要ない
        - 多態的に破棄されることがないため 
    3. `receiver_proxy::try_query`はストップトークンとして`inplace_stop_token`しか受け付けず、任意のストップトークンを使用できない
        - `inplace_stop_token`とその他の任意のストップトークンの間に実装定義のマッピングをサポートすることを推奨し、そのようなマッピングが存在する場合はクエリが成功するようにする
        - このようなメカニズムは他のプロパティにも役立つ可能性がある
    4. `receiver_proxy::try_query`がサポートするプロパティのリストが実装定義となっていること
        - これは次のユースケースのサポートを意図したもの
            1. 実装者がサポートするプロパティを追加したい場合
            2. 実装者が特定のプロパティをサポートしたくない場合
        - プロパティのリストを厳密に規定してしまうとどちらもサポートできなくなってしまうため、この提案では現状維持を推奨している
- より影響の大きい設計上の懸念事項
    1. `receiver_proxy::try_query`では、サポートされるクエリのリストを定義する必要がある 
        - `parallel_scheduler`のバックエンドが個別のライブラリとして別にコンパイルされる場合に、`receiver`のプロパティ（環境とそのクエリ）を解決する方法がない
        - 現在のところそのような実装は確立していないため、現状維持
- 命名について
    1. `system_context_replaceability`は置換可能性APIが含まれる名前空間に使用する適切な名前ではない 
        - `parallel_scheduler`は以前は`system_scheduler`という名前で、`system_context_replaceability`はその時の名残が残っている
        - いくつか名前の候補を提示してLEWGに委ねる
- 文言の不足
    1. `parallel_scheduler`における`bulk_unchunked/bulk_chunked`のカスタマイズに関する文言が十分に明確ではない
        - `bulk_unchunked/bulk_chunked`のカスタマイズが必須と指定されているがその詳細は説明されていない
        - また、カスタマイズ部分では実行ポリシーが考慮されていない
        - P3862R0を基礎とするソリューションを構築する（後のリビジョン？

この提案はC++26に間に合わせようとはしていませんが、関連するNBコメントが提出されているようです。

- [P2079R10 Parallel Scheduler - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P2079R10-Parallel-Scheduler)
- [P3804 進行状況](https://github.com/cplusplus/papers/issues/2447)

### [P3810R1 hardened memory safety guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3810r1.html)
### [P3824R1 Static storage for braced initializers NBC examples](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3824r1.html)
### [P3826R0 Defer Sender Algorithm Customization to C++29](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3826r0.html)

`sender`アルゴリズムのカスタマイズをC++29まで延期する提案。

C++26では、`std::execution`と呼ばれる並行・非同期処理の構成や実行制御のためのフレームワークとなるライブラリが導入されています。`std::execution`では、実際の非同期処理を構成するために`sender`アルゴリズムというものが用意されており、これは`sender`という抽象によって表現される非同期処理のより柔軟な構成をサポートするための共通部品となるものです（STLにおけるイテレータに対するアルゴリズムとの対応から、`sender`アルゴリズムと呼ばれます）。

```cpp
namespace ex = std::execution;

// scheduler: 処理の実行場所を指定する
ex::scheduler auto sc = ...:

// sender: 非同期処理を構成する
ex::sender auto async_work =
  ex::starts_on(sc, ex::just(10)) | 
  ex::then([](int n) {
    return n * n;
  }) |
  ex::then([](int n) {
    std::println("{}", n);
    return n;
  });

// receiver: 非同期処理の結果を受信するコールバック
ex::receiver auto re = ...;

// operation_state: 実行可能な状態の非同期処理
ex::operation_state auto os = ex::connect(async_work, re);

// 非同期処理の実行開始
ex::start(os);

// 終了の待機（receiver/operation_stateによって方法が異なる
re.wait();

// 結果の取得（receiverから取得する、receiverによって方法が異なる
auto n = re.result();
```

ここでの`ex::just`や`ex::then`などが`sender`アルゴリズムです。このほかにもいくつかの`sender`アルゴリズムが用意されており、このように`|`によってチェーンすることで非同期処理の構成をサポートします。

これらの`sender`アルゴリズムはそれぞれがCPOとして定義されており、ユーザーの用意した`sender`によるカスタマイズをサポートしています。これはユーザーの実行環境や要件に対応したより効率的な`sender`アルゴリズムの処理を可能にするための機構であり、ハードウェアベンダやその利用者が利用することを想定しています。

通常、`sender`アルゴリズムのカスタマイズはその目指す方向性から`scheduler`に対して行われますが、`sender`チェーンによる非同期操作では`scheduler`は上から入れる（上記例のように）ことも、下から入れる（チェーンの下方、あるいは`receiver`経由）こともできます。当初の`sender`アルゴリズムは上からのカスタマイズしか考慮していなかったものの、下から入れる場合のカスタマイズ（*Late customization*）をサポートするために途中で変更されています（P2999R3）。

しかし、その設計はまだ安定しておらず、その後も`sender`アルゴリズムのカスタマイズについては問題点がいくつか指定されています（P3718R0など）。これらの修正は可能ではあるもののその設計検討にはさらに時間をかける必要があり、C++26のタイムフレームの中で行うのは困難です（この提案の提出時点でC++26の機能追加フェーズは終わっています）。

そのため、この提案は`sender`アルゴリズムのカスタマイズをC++26ではオフにしておいて、カスタマイズについてより堅牢な設計をC++29で再導入しようとするものです。

P3718R0（未適用）時点での`sender`アルゴリズムのカスタマイズでは`sender`アルゴリズムの呼び出し時（*Early customization*）と`receiver`との接続時（*Late customization*）の2か所でのカスタマイズの検出とディスパッチをサポートしています。前述のように、カスタマイズは`scheduler`に対して行われるため、`sender`アルゴリズムは自身がどこで（どの`scheduler`で）実行されて完了するかを知る必要があります。

しかし多くの場合、`sender`は自身がどこで開始されるかを知らない限り、どこで完了するかが分からない、という問題があります。例えば、`ex::just()`はどこで開始されてもその場所で完了するものの、どこで開始されるかは単に`ex::just(10)`の様に呼び出された時点（*Early customization*時）には分からず、*Late customization*を待つ必要があります。

また、`ex::then(sndr, fn)`の場合もそれは同様な場合があり（`sndr`による、例えば`ex::just()`の場合など）、その場合は呼び出し時点のカスタマイズは行われず*Late customization*時に`receiver`の持つ情報に基づいて実行開始場所を取得し、カスタマイズが行われます。しかし、P3718R0で提案されているAPIではこの場合にこのような情報を取得することができない場合があります。

提案文書より、サンプル

```cpp
// GPU実行scheduler
ex::scheduler auto gpu = ...:

// GPU上で実行したい処理
auto ex::sender sndr = ex::starts_on(gpu, ex::just()) | ex::then(fn);

// GPU上で実行し結果を待機
std::this_thread::sync_wait(std::move(sndr));
```

`gpu`はGPU上で処理を実行する`scheduler`であり、`fn`はGPU上で実行されます。そのため、`ex::then`はGPU実装のためのカスタマイズを利用する必要があります。P3718R0のAPIではそれは次のように判定されます

- *Early customization*時、`starts_on(gpu, just()) | then(fn)`式の実行中、`then`CPOは`starts_on(gpu, just())`の`sender`に次のように完了する場所をクエリする

```cpp
auto&& tmp1 = ex::starts_on(gpu, ex::just());
auto dom1 = ex::get_domain(ex::get_env(tmp1));
```

- それを受けて`starts_on`の`sender`は次のように`just`の`sender`に完了する場所をクエリする

```cpp
auto&& tmp2 = ex::just();
auto dom2 = ex::get_domain(ex::get_env(tmp2));
```

- `just`の完了場所は開始場所が分かるまで分からないため、ここではその情報は入手できず、`dom2`は`default_domain`となり、これが`starts_on`のドメインとして`dom1`に返される
    - しかしこれは誤りであり、`starts_on`はGPU上で完了する
- `then`CPOは`default_domain`を利用してカスタマイズの検索を行い、デフォルト実装を使用する
- `then`の`sender`が`sync_wait`の`receiver`に接続されると、*Late customization*が試みられる
- `ex::connect`は`sync_wait`の`receiver`に`then`の`sender`の開始場所を問い合わせる

```cpp
auto dom3 = ex::get_domain(ex::get_env(rcvr));
```

- `sync_wait`自体は現在のスレッドで開始するため、ここでも`default_domain`が返されて、`dom3`は`default_domain`となる
- このドメインを使用してカスタマイズを検索するため、*Late customization*でも`then`のGPU実装は検索されない

このように、この例ではGPU上での`then`のためにデフォルト実装（実質的にCPU用のもの）が使用されることになりますが。これは望ましい状況ではありません。

このような問題の解決のための設計はおおむね完了しているようですが（提案のappendixで説明されています）、まだ実環境で動作したものではなく、精査が完了していないようです。このためDRプロセスに委ねることには不安があるようで（C++20 rangeの経験からの様子）、かといってC++26から`std::execution`全体あるいは`sender`アルゴリズムを削除することはC++における非同機構の導入と採択を実質的に3年遅らせることになります。

そのためこの提案では、`sender`アルゴリズムのカスタマイズ機構だけをC++26から削除して、それ以外の部分は維持することを提案しています。

これによりカスタマイズに関連する

- `default_domain`
- `transform_sender`
- `transform_env`
- `apply_sender`
- `get_domain`

などは削除されます。

C++29で復帰する予定のカスタマイズにおいては、*Early customization*を削除し*Late customization*のみにしたうえで、`sender`の完了スケジューラ（完了する場所）の問い合わせ時に開始場所についての情報を一緒に渡すようにするようです。

例えば、現在の`ex::get_completion_scheduler`クエリを拡張して、`sender`と`receiver`両方の環境を渡せるようにします。

```cpp
auto sch = get_completion_scheduler<set_value_t>(get_env(S), get_env(R));
```

*Late customization*は実質的に`ex::connect`によって呼び出される`connect`操作のカスタマイズによって行われ、C++29では`ex::connect`は次の2種類のドメインを計算します

- 開始ドメイン（*Starting domain*）: `get_domain(get_env(rcvr))`
- 完了ドメイン（*Completion domain*）: `get_completion_domain<set_value_t>(get_env(sndr), get_env(rcvr))`

これらの情報を利用して、`connect`フェーズにおいて正確なカスタマイズの検出とディスパッチを行えるようになります。

- [P2999R0 Sender Algorithm Customization - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2999R0-Sender-Algorithm-Customization)
- [P3718R0 Fixing Lazy Sender Algorithm Customization, Again - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3718R0-Fixing-Lazy-Sender-Algorithm-Customization-Again)
- [P3826 進行状況](https://github.com/cplusplus/papers/issues/2448)

### [P3828R0 Rename the "to_input" view to "as_input"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3828r0.pdf)
### [P3834R1 Defaulting the Compound Assignment Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3834r1.html)
### [P3836R1 Make optional<T&> trivially copyable (US NB comment 134)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3836r1.html)
### [P3841R0 Proposal for `std::constructor` Function Object](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3841r0.html)

コンストラクタを関数オブジェクトとして扱うためのユーティリティの提案。

メンバ関数やフリー関数等通常の関数は、`<functional>`にあるようなユーティリティや`std::function`とそのファミリーを使用するなどして様々に活用することができます。しかし、これらのものに対してコンストラクタを関数と同じように扱わせることはできません。

コンストラクタを関数のように扱うためにはラッパが必要であり、この提案では`std::constructor<T>()`としてそれを提案しています。

提案文書より、`std::size_t`の範囲`input`があり、その要素の値によるサイズの`std::vector`の`std::vector`を得るような処理を書く例

```cpp
std::vector<std::vector<int>> result;
result.reserve(std::distance(input));
for (auto sz : input) {
  result.emplace_back(sz);
}
```

`input`が`input_range`である場合に2回のイテレーションが可能ではない場合があり、`emplace_back()`のループは範囲から直接構築するよりも非効率となります。

`range`ベースの現代的なソリューション

```cpp
auto result = input
    | std::views::transform([] (size_t sz) {
        return std::vector<int>(sz);
      }
    | std::ranges::to<std::vector>();
```

まだラムダ式が簡潔ではありません。

この提案

```cpp
auto result = input
    | std::views::transform(std::constructor<std::vector<int>>())
    | std::ranges::to<std::vector>();
```

`std::constructor<T>()`はコンストラクタオーバーロードの集合をCallableに変換します。これによって、コンストラクタを関数オブジェクトとして扱うことができ、既に関数オブジェクトを扱うことのできる場所で使用できるようになります。

`std::constructor<T>()`の宣言例

```cpp
namespace std {

  template <typename T>
  struct constructor {
    template <typename... Args>
    static constexpr T operator()(Args&&... args) noexcept(std::is_nothrow_constructible_v<T, Args...>) 
    {
      return T(std::forward<Args>(args)...);
    };
  };
}
```

- [P3841 進行状況](https://github.com/cplusplus/papers/issues/2450)

### [P3842R0 A conservative fix for constexpr uncaught_exceptions() and current_exception()](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3842r0.html)

C++26では、`uncaught_exceptions()`と`current_exception()`を定数式で使用できないようにしておく提案。

P3818とP3820で、`uncaught_exceptions()`と`current_exception()`を単純に`constexpr`指定してしまうと破壊的変更となることが報告されており、それぞれ異なる解決策が提案されています。

LEWGでの協議の結果、C++26ではこれらの関数から`constexpr`を外しておくことで問題が起こらないようにする、ことが決定されました。この提案はそのための文言を提案するものです。

C++26の期限もあるため、代替案の追加や緩和策の導入などはいずれも行われず、C++26では定数式で使用できなくするのみです。

- [P3818R1 constexpr exception fix for potentially constant initialization - WG21月次提案文書を眺める（2025年09月）](https://onihusube.hatenablog.com/entry/2026/01/31/012640#P3818R1-constexpr-exception-fix-for-potentially-constant-initialization)
- [P3820R1 Fix constexpr uncaught_exceptions and current_exception - WG21月次提案文書を眺める（2025年09月）](https://onihusube.hatenablog.com/entry/2026/01/31/012640#P3820R1-Fix-constexpr-uncaught_exceptions-and-current_exception)
- [P3842 進行状況](https://github.com/cplusplus/papers/issues/2451)

### [P3843R0 Reconsider R0 of P3774 (Rename `std::nontype`) for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3843r0.html)

`std::nontype`を`std::constant_arg_t`にリネームしないようにすることを推奨する提案

この提案は、P3774R0で提案されていた（R1で撤回された）`std::fn`の方向性に賛同し、`std::nontype`を`std::constant_wrapper`とは明確に異なるものとしてその方向に進化させていこうとするものです。

経緯等はP3774R0を参照

- [P3774R0 Rename std::nontype, and make it broadly useful - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3774R0-Rename-stdnontype-and-make-it-broadly-useful)

`std::constant_wrapper`と`std::nontype`はどちらもNTTPを利用した`constexpr`関数引数を実現するためのソリューションですが、`std::nontype`はほぼ`std::function_ref`におけるメンバ関数の適切なサポートのためにのみ使用されるものであり、`std::constant_wrapper`のように汎用的なものではありません。

しかし、`std::constant_arg_t`という名前は`std::constant_wrapper`と非常に良く似ており、一見するとどちらを使用するべきかが分からない所があります。定義などは`std::constant_arg_t`の方がシンプルなのでそちらを好んで使用する人もいるかもしれません。これにより、`constexpr`関数引数という問題に対するソリューションとなる語彙型が2つ存在することになります。そして、それら2つの型の間には一切の互換性がありません。

現在の命名（`std::constant_arg_t`）はこの問題について真剣に検討された上でのものではありません。

P3774R0では、`std::fn_t`という名前にリネームするとともに、関数呼び出し演算子を備えることで`std::constant_wrapper`とは異なる役割を与えようとしていました。

`std::fn_t`はコンパイル時に既知の関数のラッパとして、`std::function_ref`で`std::nontype`と同様に使用できるほか、次のように他の場所でも使用できます

- 連想コンテナの比較関数やハッシュ関数の指定のために使用できる
- アルゴリズムに渡す述語などのcallbleとして使用できる

そしてどちらの場合でも、関数ポインタのサイズオーバーヘッドを削減しながらインライン化を可能にします。

これらのことから、この提案ではP3774R0の方向性を再検討することを目指しています。ただし、`std::fn_t`という名前には異論もあったことなどから、リネーム先を`std::fn_t`ではなく`std::function_wrapper`にしています。

- [P3775R0 Slides for P3774R0 - Rename `std::nontype`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3775r0.html)
- [P3843 進行状況](https://github.com/cplusplus/papers/issues/2452)

### [P3844R0 Restore `simd::vec` broadcast from `int`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3844r0.pdf)

std::simdの暗黙変換が可能なブロードキャストコンストラクタを復帰させる提案。

Parallelism TSだったころのstd::simdでは、`vec<float>() + 1`の様な構築（右オペランド）が可能であり、これはブロードキャストコンストラクタにおいて要素型と異なる型の値（特に整数型の値）を意図的に受け入れるようにしていることによります。

このようなAPIの意図は、浮動小数点演算コードでは`* 2`のような整数定数倍において`* 2.0`のように記述するよりもそのまま`* 2`とすることが多いため、これをそのままstd::simdでもサポートするためです。

```cpp
float f(float x) { return x * 2; }    // converts 2 to float (at compile time)
float g(float x) { return x * 2.; }   // converts x to double (at run time)
float h(float x) { return x * 2.f; }  // no conversions
```

これと同等の表現をサポートするために、std::simdのブロードキャストコンストラクタは当初、`int`型を特別扱いして暗黙変換（縮小変換）を許可するようにしていました。

```cpp
// 当初のstd::simd
using floatv = std::experimental::native_simd<float>;

floatv f(floatv x) { return x * 2; }    // converts 2 to float and broadcasts (at compile time)
floatv g(floatv x) { return x * 2.; }   // ill-formed
floatv h(floatv x) { return x * 2.f; }  // broadcasts 2.f to floatv
```

このコードは最終的なC++26 std::simdにおいてそのまま動作しません。少なくとも`f`に対しては変更が必要です。

```cpp
using floatv = std::simd::vec<float>;

floatv f(floatv x) { return x * 2std::cw<2>; }
```

std::simdではこのように、整数定数の様なものを扱う際には`std::constant_rapeer`を使用する必要があります。しかし、これにはコンパイルのコストがかかるため、それが望ましくない場合は`2.f`のように`float`値を直接使用することが推奨されます。

ただし、8bitや16bitの整数型を要素としている場合など、対応するリテラルが無い場合は明示的変換を使用する必要があります。

```cpp
template <simd_integral V>
V f(V x) {
  return x + 1; // ill-formed for V::value_type = (u)int8_t, (un)int16_t, and uint32_t
}
```

しかし、明示的変換を行うと値を変更してしまうような変換が診断されなくなり、バグの元となります。

```cpp
template <simd_floating_point V>
V f(V x) {
  return x + V(0x5EAF00D);
}

f(vec<double>()); // OK

// compiles but
// adds 99282960 instead of 99282957
f(vec<float>());

// compiles but
// adds infinity instead of 99282957
f(vec<std::float16_t>());
```

ここでも、`x + std::cw<0x5EAF00D>`のように書いておけばこのような変換はエラーになりますが、`std::cw`は冗長でコンパイルコストも高いため、実際にはほぼ使用されないと思われます。

この提案は、当初のstd::simdが持っていたブロードキャストコンストラクタでの整数型の特別扱いを復帰させて、`std::cw`を介さなくても同じ結果が得られるようにするものです。

上記の例のこの提案後

```cpp
template <simd_floating_point V>
V f(V x) {
  return x + 0x5EAF00D; // std::cwも明示的変換も不要
}

f(vec<double>()); // OK

// ill-formed: uncaught exception on
// value-changing conversion
f(vec<float>());

// ill-formed: uncaught exception on
// value-changing conversion
f(vec<std::float16_t>());
```

このようなチェックは`std::cw`による`constexpr`引数が無いと行えないため、C++26のstd::simdでは整数型の特別扱いを行うコンストラクタは削除された上で`std::cw`を使うように変更されていました。

この提案では、`consteval`コンストラクタとコンパイル時例外によって`std::cw`を使用しなくても同等のチェックとエラー化を達成できるため、それを提案しています。

`consteval`コンストラクタの追加については2つの方法を提示したうえで、算術型からの変換コンストラクタを`consteval`にする方法を提案しています（もう一つは`explicit`コンストラクタとコンセプトの制約順序によって`consteval`コンストラクタの呼び出し機会を制限したうえで現在のコンストラクタを維持する方法）。

再現コードで示すと次のようになります

```cpp
template <class From, class To>
concept simd-broadcast-arg = constructible_from<To, From>;

template <class From, class To>
concept simd-consteval-broadcast-arg
  = simd-broadcast-arg<From, To>
      && convertible_to<From, To>
      && is_arithmetic_v<remove_cvref_t<From>>
      && !value-preserving-convertible-to<From, To>;

template <class T>
class basic_vec {
public:
  template <simd-broadcast-arg<T> U>
  constexpr explicit(see below) basic_vec(U&&); // #1

  template <simd-consteval-broadcast-arg<T> U>
  consteval basic_vec(U&&); // #2
};
```

`simd-consteval-broadcast-arg`は`simd-broadcast-arg`を包摂していることによって、オーバロード解決においてより優先されます。`value-preserving-convertible-to<U, T>`は算術型`U`から`T`への変換が値を保持しない変換となる場合のみ選択されるためのコンセプトです。これにより、暗黙変換/明示的変換の両方において、要素型への変換が縮小変換となるような場合は`consteval`コンストラクタ（`#2`）が選択されます。

`#2`のコンストラクタ内では変換に際して値が失われる（変換後に等しい値にならない）場合に例外を送出することでコンパイルエラーになります。

値を保持する変換については`#1`を選択し、算術型以外の型に対しても`#1`が選択されます。

この提案はC++26を目指していますが、専用の例外型の導入（というかどのような例外を投げるか）についてはC++26では行わないようにしています（ここでの目的はコンパイル時の診断の向上であって、例外をキャッチして処理することを目指していないため）。

- [P3844 進行状況](https://github.com/cplusplus/papers/issues/2453)

### [P3845R0 Make `std::execution`'s monadic operations naming scheme consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3845r0.html)

`std::execution`のモナド的操作に該当する操作の名前を標準ライブラリの既存のものと一貫させる提案。

`std::execution`の`sender`アルゴリズムの中には、`sender`をモナドと見た時にモナドに対する典型的な操作に該当するものがいくつかあります。標準ライブラリ中では`std::optional`/`std::expected`がモナド的な型であり、それらはよく似たモナド的操作のAPIを備えています。しかし、同じモナド的操作に対応するAPIでもこの両者の間で名前が大きく異なっています。

この提案は、既存のモナド的操作（ほぼ`std::optional`/`std::expected`のモナド的操作API）にあわせて、`std::execution`の一部の`sender`アルゴリズムの名前を変更しようとするものです。

名前の変更してるものとその変更先候補は次のものです

- `std::execution::then` -> `std::execution::transform`
- `std::execution::let_value` -> `std::execution::and_then`
- `std::execution::let_error` -> `std::execution::or_else_error`
- `std::execution::let_stopped` -> `std::execution::or_else_stopped`

`execution::then`は`T`で値完了する`sender`と`T -> U`の関数`f`を受け取って、`sender`が値完了した場合にその結果に`f`を適用した値で完了する`sender`を返すものです。これは、`views::transform`（`T`の範囲と`T -> U`の関数`f`を受け取って、各要素を`f`で変換した`U`の範囲を返す）、`std::optional<T>::transform`（`optional<T>`と`T -> U`の関数`f`を受け取って、`optional`が値を持っている場合にその値に`f`を適用した結果を保持する`optional<U>`を返す）、`std::expected<T, E>::transform`（`expected<T, E>`と`T -> U`の関数`f`を受け取って、`expected`が正常値を保持している場合にその値に`f`を適用した結果を保持する`expected<U, E>`を返す）と対応しており、これはモナドに対する`map`と呼ばれる操作です。

`execution::let_value`は`T`で値完了する`sender`と`T -> sender`の関数`f`を受け取って、`sender`が値完了した場合にその結果に`f`を適用した`sender`を返すものです。これは、`std::optional<T>::and_then`（`optional<T>`と`T -> optional<U>`の関数`f`を受け取って、`optional`が値を持っている場合にその値に`f`を適用した結果の`optional<U>`を返す）、`std::expected<T, E>::and_then`（`expected<T, E>`と`T -> expected<U, E>`の関数`f`を受け取って、`expected`が正常値を保持している場合にその値に`f`を適用した結果の`expected<U, E>`を返す）と対応しており、これはモナドに対する`bind`と呼ばれる操作です。

`execution::let_error`は`E`でエラー完了する`sender`と`E -> sender`の関数`f`を受け取って、`sender`がエラー完了した場合にその結果に`f`を適用した`sender`を返すものです。`execution::let_stopped`は`sender`と`void -> sender`の関数`f`を受け取って、`sender`が停止した場合に`f`を呼びだした結果の`sender`を返すものです。これらは、`std::optional<T>::or_else`（`optional<T>`と`void -> optional<T>`の関数`f`を受け取って、`optional`が無効値を保持している場合に`f`を呼びだした結果の`optional<T>`を返す）、`std::expected<T, E>::or_else`（`expected<T, E>`と`E -> expected<T, F>`の関数`f`を受け取って、`expected`がエラー状態の場合にそのエラー値に`f`を適用した結果の`expected<T, F>`を返す）と対応しており、これらはモナドの失敗チャネルにおける`bind`操作です。

ただし、`sender`はエラーと停止の2つの失敗チャネルを持っており、`execution::let_error`と`execution::let_stopped`はそれに対応しています。この2つに同じ`or_else`という名前を使うことはできないため、`or_else`を基本にしつつもこの2つのチャネルに対応した命名にする必要があります。

この提案ではその命名として、`or_else_error`と`or_else_stopped`を採用しています。

提案文書より、サンプルコード

変更前（現在）
```cpp
// The whole flow for transforming incoming requests into responses
sender auto snd =
    // get a sender when a new request comes
    schedule_request_start(the_read_requests_ctx)
    // make sure the request is valid; throw if not
    | let_value(validate_request)
    // process the request in a function that may be using a different execution resource
    | let_value(handle_request)
    // If there are errors transform them into proper responses
    | let_error(error_to_response)
    // If the flow is cancelled, send back a proper response
    | let_stopped(stopped_to_response)
    // write the result back to the client
    | let_value(send_response)
    // done
    ;
```

変更後
```cpp
// The whole flow for transforming incoming requests into responses
sender auto snd =
    // get a sender when a new request comes
    schedule_request_start(the_read_requests_ctx)
    // make sure the request is valid; throw if not
    | and_then(validate_request)
    // process the request in a function that may be using a different execution resource
    | and_then(handle_request)
    // If there are errors transform them into proper responses
    | or_else_error(error_to_response)
    // If the flow is cancelled, send back a proper response
    | or_else_stopped(stopped_to_response)
    // write the result back to the client
    | and_then(send_response)
    // done
    ;
```

- [P3845 進行状況](https://github.com/cplusplus/papers/issues/2454)

### [P3846R0 C++26 Contracts, reasserted](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3846r0.pdf)
### [P3849R0 SIS/TK611 considerations on Contract Assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3849r0.pdf)
### [P3851R0 Position on contracts assertion for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3851r0.pdf)
### [P3853R0 A thesis+antithesis=synthesis rumination on Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3853r0.html)

Contracts機能に関して、P3640のアプローチを再考し、ホワイトペーパーとして両者の対照実験をしてから標準に導入する提案。

P3640R0では契約アサーションのデフォルトの評価セマンティクスを*enforce*固定にしておき評価セマンティクスを可変にしないようにすることと、可変セマンティクスはラベルによって可能にするようにすることを提案しています。

この提案では、P3640のアプローチの場合デフォルトの構文がその動作の不確実さや複雑さを伴うことなく、シンプルに使用することができ、異なる翻訳単位でセマンティクスのモードが異なる場合のABIに関する問題や最適化に関する問題と無縁になるとして、このアプローチの採用を推奨しています。

```cpp
void f(int x) pre(x >= 0);  // C++26時点
// P2900: 評価セマンティクスが柔軟であり、コンパイラオプションや違反ハンドラによって動作を調整可能
// P3640: 評価セマンティクスが固定

void f(int x) pre<somelabel>(x >= 0); // 将来の拡張
// P2990: 評価セマンティクスの固定など、評価セマンティクス等の振る舞いをより明示的に指定できる
// P3640: 評価セマンティクスの柔軟性など、振る舞いをより細かく制御できる
```

すなわち、`pre, post, contract_assert`といった最短の構文に対して、P2900は汎用的な機能を持たせようとしており、P3640はシンプルな機能を持たせようとしています。それにより、P3640はでは最短の構文の意味も理解しやすくなります。

さらに、デフォルトのセマンティクスを*quick enforce*にしておけば違反ハンドラが必要なくなり、最短の構文の単純さはさらに高まります。

このアプローチは、Fedoraとその派生となるLinuxディストリビューションにおいて配布されているC++プログラム/ライブラリのデフォルトの設定でもあります（コンパイラが提供する堅牢化機能を有効化して配布するのがデフォルトになっている）。これは数年前から行われていることですが、それらのディストリビューションのユーザーには受け入れられており、パフォーマンスや突然のクラッシュが問題になるようなことは無かったようです。

したがって、P3640のアプローチはすでに実装経験があり、既存の慣行の一つでもあります。

また、後からP2900の上にP3640を導入することは、互換性を破壊せずにはできません。

そして、P2900のContracts機能には実装経験や展開の経験が皆無であり、C++26でこれを導入することは、本番環境で試験的な機能の実験を行うようなものです。

最終的に次のようなことを提案しています

- C++26からContractsを削除する
- P2900とP3640の両方をホワイトペーパーまたはTSとして出荷し、この両方を切り替えることのできるメカニズムを提供する
    - おそらく、コンパイラオプション
- 実装者や教育者の力を借りてこの試験的Contracts機能の対照実験を行い、実装と展開の経験を得る

P3640とP2900のどちらがユーザーにとって好ましいのかの判断も含めて、Contracts機能の実装経験を得ることを重視しています。

- [P3640R0 Make contracts reliable by default - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3640R0-Make-contracts-reliable-by-default)
- [P3853 進行状況](https://github.com/cplusplus/papers/issues/2458)

### [P3855R0 New Reflection metafunction - is_destructurable_type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3855r0.pdf)
### [P3856R0 New Reflection metafunction - is_destructurable_type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3856r0.pdf)
### [P3857R0 Policy: A function named `get` should return only on success](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3857r0.html)
### [P3858R0 A Lifetime-Management Primitive for Trivially Relocatable Types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3858r0.pdf)
### [P3859R0 Assertions are not necessarily for changing program behavior](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3859r0.html)
### [P3860R0 Proposed Resolution for NB Comment GB13-309 atomic_ref is not convertible to atomic_ref](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3860r0.html)
### [P3861R0 Pragmatic approach to standard structural types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3861r0.pdf)
### [P3862R0 Postpone `basic_string::subview` and wait for `cstring_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3862r0.html)
### [P3863R0 Minimal fix for CWG3003 (CTAD from template template parameters)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3863r0.pdf)
### [P3864R0 Correctly rounded floating-point maths functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3864r0.html)
### [P3865R0 Class template argument deduction (CTAD) for type template template parameters](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3865r0.pdf)
### [P3866R0 V2: An Evolution Path for the Standard Library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3866r0.pdf)
### [P3867R0 define_static_string as a STATICALLY_WIDEN replacement](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3867r0.pdf)
### [P3868R0 Allow #line before module declarations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3868r0.html)
### [P3870R0 Renaming std::nontype to std::tag](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3870r0.pdf)
### [P3872R0 2025-10 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3872r0.html)
### [P3874R0 Safety Strategy Requirements for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3874r0.pdf)
### [P3875R0 Defining -ffast-math is hard!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3875r0.pdf)

- [ 進行状況](https://github.com/cplusplus/papers/issues/)
