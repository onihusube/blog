# ［C++］WG21月次提案文書を眺める（2025年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-07)

全部で143本あります。

もくじ

[:contents]

### [N5012 WG21 2025-06 Sofia Admin telecon minutes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5012.pdf)

2025年6月2日に行われた、WG21管理者ミーティングの議事録。

前回からどのような活動があったかや、Sofia会議で何をするかなどの報告がなされています。

### [N5016 WG21 June 2025 Sofia Hybrid meeting Minutes of Meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5016.pdf)

2025年6月にSofiaで行われた全体会議の議事録。

最終日に行われた全体会議での各グループの作業報告と、全体投票の様子が記録されています。

### [P0085R2 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r2.html)

↓

### [P0085R3 Oo... adding a coherent character sequence to begin octal-literals](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0085r3.html)

8進リテラルの新しいプリフィックスの提案。

以前の記事を参照

- [P0085R1 Oo... adding a coherent character sequence to begin octal-literals - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P0085R1-Oo-adding-a-coherent-character-sequence-to-begin-octal-literals)

R2での変更は

- 整数リテラルと字句規則の不一致を修正
- プログラマが8進リテラルを10進と勘違いしてしまう例を拡張
- Effects on existing codeを拡張
- `'`のエンコーディングを修正

このリビジョンでの変更は

- 壊れていたユニコード文字を修正
- Wikipediaの引用を更新
- 8進数値`none`（`0o0`）の仕様を修正
- この提案では`std::format`については扱わないようにした

などです。

- [P0085 進行状況](https://github.com/cplusplus/papers/issues/2055)

### [P0260R18 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r18.html)

↓


### [P0260R19 C++ Concurrent Queues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0260r19.html)

標準ライブラリに並行キューを追加するための設計を練る提案。

以前の記事を参照

- [P0260R5 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年01月）](https://onihusube.hatenablog.com/entry/2023/02/12/210302#P0260R5-C-Concurrent-Queues)
- [P0260R7 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P0260R7-C-Concurrent-Queues)
- [P0260R8 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0260R8-C-Concurrent-Queues)
- [P0260R9 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P0260R9-C-Concurrent-Queues)
- [P0260R10 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P0260R10-C-Concurrent-Queues)
- [P0260R11 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P0260R11-C-Concurrent-Queues)
- [P0260R13 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P0260R13-C-Concurrent-Queues)
- [P0260R14 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P0260R14-C-Concurrent-Queues)
- [P0260R16 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P0260R16-C-Concurrent-Queues)
- [P0260R17 C++ Concurrent Queues - ［C++］WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P0260R17-C-Concurrent-Queues)

R18での変更は

- 設計セクションに、（提案している）概念がFIFO順序付けを必要としないことを明記
- 非ブロッキング`pop`操作の不公平性に関する注記を追加
- spurious failureに関する文言を`mutex::try_lock`と整合させた
- SC-for-DRFのacquire/releaseに関する注記を追加

このリビジョンでの変更は

- `std::conqueue_errc`を`std::conqueue_status`にリネーム

などです。

- [P0260 進行状況](https://github.com/cplusplus/papers/issues/99)

### [P0870R6 A proposal for a type trait to detect narrowing conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0870r6.html)

↓

### [P0870R7 A proposal for a type trait to detect narrowing conversions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0870r7.html)

型`T`が別の型`U`へ縮小変換（*narrowing conversion*）を起こさずに変換可能かを調べるメタ関数`is_convertible_without_narrowing<T, U>`を追加する提案。

以前の記事を参照

- [P0870R2 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年04月）](https://onihusube.hatenablog.com/entry/2020/05/01/194425#P0870R2--A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- [P0870R3 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年05月）](https://onihusube.hatenablog.com/entry/2020/06/01/001003#P0870R3--A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- [P0870R4 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2020年10月）](https://onihusube.hatenablog.com/entry/2020/11/02/221657#P0870R4-A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
- [P0870R5 A proposal for a type trait to detect narrowing conversions - ［C++］WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P0870R5-A-proposal-for-a-type-trait-to-detect-narrowing-conversions)
 
R6での変更は

- 設計上の決定事項について詳細を追加

このリビジョンでの変更は

- 機能テストマクロを修正し、freestandingを追加
- LWGに関する注記を追加

などです。

- [P0870 進行状況](https://github.com/cplusplus/papers/issues/724)

### [P0876R21 fiber_context - fibers without scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p0876r21.pdf)

スタックフルコルーチンのためのコンテキストスイッチを担うクラス、`fiber_context`の提案。

以前の記事を参照

- [P0876R11 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2022年10月）](https://onihusube.hatenablog.com/entry/2022/11/13/233529#P0876R11-fiber_context---fibers-without-scheduler)
- [P0876R12 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P0876R12-fiber_context---fibers-without-scheduler)
- [P0876R13 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2023年04月）](https://onihusube.hatenablog.com/entry/2023/04/23/192236#P0876R13-fiber_context---fibers-without-scheduler)
- [P0876R14 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P0876R14-fiber_context---fibers-without-scheduler)
- [P0876R15 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P0876R15-fiber_context---fibers-without-scheduler)
- [P0876R16 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P0876R16-fiber_context---fibers-without-scheduler)
- [P0876R17 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P0876R17-fiber_context---fibers-without-scheduler)
- [P0876R18 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P0876R18-fiber_context---fibers-without-scheduler)
- [P0876R19 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P0876R19-fiber_context---fibers-without-scheduler)
- [P0876R20 `fiber_context` - fibers without scheduler - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P0876R20-fiber_context---fibers-without-scheduler)

このリビジョンでの変更は

- P3472R1を適用
    - `fiber_context::can_resume()`を`const`にする
- 提案する文言から“Instantiating”と“instance”を削除する
- 付録A/Bの不適切な動作は、[except]に対する変更提案が適用される前の実装でのみ確認されていることを明記
- “Recent WG21 History”セクションを追加

などです。

- [P0876 進行状況](https://github.com/cplusplus/papers/issues/117)

### [P1040R8 `std::embed` and `#depend`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1040r8.html)

`#embed`のライブラリ関数版である`std::embed`の提案。

以前の記事を参照

- [P1040R7 `std::embed` and `#depend` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P1040R7-stdembed-and-depend)

このリビジョンでの変更は

- EWGは翻訳単位固有の依存関係（translation-unit specific dependencies）について合意
    - モジュールに関しては後日検討
- 翻訳単位ベースの依存関係の文言を統一し、§ 5.3.5 Modules 関連の議論を削除
- § 5.3.9 UTF-8 Only? に、`std::u8string_view/std::string_view/std::wstring_view`引数のオーバーロードを用意することになった実装経験について追記
- § 5.3.7 Optional Limit と § 5.3.8 Optional Offset に`limit`と`offset`の根拠について追記
- § 5.3.6 Statically Polymorphic で、`std::bit_cast`の改善の必要性について言及することで、`std::embed<TYPE>(...)`をコンパイル時の`reinterpret_cast`を実現する手段として位置付けていることを明確化

などです。

- [P1040 進行状況](https://github.com/cplusplus/papers/issues/1993)

### [P1306R5 Expansion statements](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p1306r5.html)

コンパイル時にステートメントをループ生成することのできる、展開ステートメントの提案。

以前の記事を参照

- [P1306R2 Expansion statements - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P1306R2-Expansion-statements)
- [P1306R3 Expansion statements - ［C++］WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P1306R3-Expansion-statements)
- [P1306R4 Expansion statements - ［C++］WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P1306R4-Expansion-statements)

このリビジョンでの変更は、文章と文言を書き直したことのみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P1306 進行状況](https://github.com/cplusplus/papers/issues/156)

### [P2079R9 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r9.html)

↓

### [P2079R10 Parallel Scheduler](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2079r10.html)

ハードウェアの提供するコア数（スレッド数）に合わせた固定サイズのスレッドプールを提供する*Scheduler*の提案。

- [P2079R1 Parallel Executor - ［C++］WG21月次提案文書を眺める（2020年8月）](https://onihusube.hatenablog.com/entry/2020/09/18/222444#P2079R1--Parallel-Executor)
- [P2079R2 System execution context - ［C++］WG21月次提案文書を眺める（2022年1月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2079R2-System-execution-context)
- [P2079R3 System execution context - ［C++］WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/08/11/193828#P2079R3-System-execution-context)
- [P2079R4 System execution context - ［C++］WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2079R4-System-execution-context)
- [P2079R5 System execution context - ［C++］WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2079R5-System-execution-context)
- [P2079R6 System execution context - ［C++］WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2079R6-System-execution-context)
- [P2079R7 System execution context - ［C++］WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2079R7-Parallel-scheduler)
- [P2079R8 Parallel Scheduler - ［C++］WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2079R8-Parallel-Scheduler)

R9での変更は

- 文言の改善
- `try_query`にクエリパラメータを追加
- バックエンド関数で使用していた`uint32_t`を`size_t`に変更
- `system_context_replaceability`のreceiverクラス名を`receiver_proxy`に変更

このリビジョンでの変更は、提案する文言の改善のみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P2079 進行状況](https://github.com/cplusplus/papers/issues/806)

### [P2319R5 Prevent path presentation problems](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2319r5.html)

`filesystem::path`の`.string()`メンバ関数を非推奨にする提案。

以前の記事を参照

- [P2319R0 Prevent path presentation problems - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P2319R0-Prevent-path-presentation-problems)
- [P2319R1 Prevent path presentation problems - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P2319R1-Prevent-path-presentation-problems)
- [P2319R2 Prevent path presentation problems - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2319R2-Prevent-path-presentation-problems)
- [P2319R4 Prevent path presentation problems - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2319R4-Prevent-path-presentation-problems)

このリビジョンでの変更は

- Annex Dのエントリを簡素化し、`string`と`generic_string`をそれぞれ`system_encoded_string`と`generic_system_encoded_string`で定義
- [depr.move.iter.elem]などの他のエントリとの整合性を保つため、エントリの形式を変更
- `__cpp_lib_format_path`の値をバンプするようにした

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P2319 進行状況](https://github.com/cplusplus/papers/issues/1987)

### [P2414R8 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r8.pdf)

↓

### [P2414R9 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r9.pdf)

Pointer lifetime-end zapと呼ばれる問題の解決策の提案。

以前の記事を参照

- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R1 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2414R1-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R2 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2414R2-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R4 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P2414R4-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R5 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2414R5-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R6 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2414R6-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R7 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2414R7-Pointer-lifetime-end-zap-proposed-solutions)

R8での変更は

- P2188R1に従う変更
    - `usable_ptr<T>`を`bag_of_bits_ptr<T>`にリネーム
    - `make_usable_ptr()`を`launder_bag_of_bits_ptr()`にリネーム

このリビジョンでの変更は

- `bag_of_bits_ptr<T>`と`launder_bag_of_bits_ptr()`を別の提案に分離
    - P3790R0（下の方）に分離

などです。

この提案は既存の標準文言の調整を行う変更のみになり、次のことを提案しています

1. アトミック操作を再定義し、将来のポインタ値を生成して格納するようにする
2. `volatile`ポインタに対する操作を、将来のポインタ値を生成して格納するようにする

将来のポインタ（prospective pointer）（値）とは、生存期間開始前（である可能性のある）オブジェクトへのポインタ値のことで、zap問題の主題である参照先オブジェクトの寿命が尽きた後のポインタ（無効なポインタ）とは異なり、（参照先オブジェクトの寿命が開始される前でも）ポインタ値に対する一部の操作が許可されます。

将来のポインタ値を生成する方法は、無効なポインタのポインタ値を`uintptr_t`にキャストしてから元に戻すことです（これによってポインタのprovenanceを破棄する）。この提案では、アトミックポインタに対する操作と`volatile`ポインタへのアクセスの際に無効なポインタをこのようなキャストによって将来のポインタに戻すようにする（as-ifなので実際にこのキャストを実行するわけではない）ことで、これらの操作において無効なポインタを使用できるようにしています。

この提案はEWGのレビューを通過し、C++29に向けてCWGのレビュー中です。どうやらDRとなるようです（おそらくC++11）。

- [P2414 進行状況](https://github.com/cplusplus/papers/issues/1084)

### [P2664R11 Extend `std::simd` with permutation API](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2664r11.html)

`std::simd`に、permute操作のサポートを追加する提案。

以前の記事を参照

- [P2664R0 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2022年11月）](https://onihusube.hatenablog.com/entry/2022/12/25/175304#P2664R0-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R1 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2664R1-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R3 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2664R3-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R4 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2664R4-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R5 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2664R5-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R6 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P2664R6-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R7 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P2664R7-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R8 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2664R8-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R9 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2664R9-Proposal-to-extend-stdsimd-with-permutation-API)
- [P2664R10 Proposal to extend `std::simd` with permutation API - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2664R10-Proposal-to-extend-stdsimd-with-permutation-API)

このリビジョンでの変更は、LWGレビューを受けての文言更新のみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P2664 進行状況](https://github.com/cplusplus/papers/issues/1383)

### [P2781R9 `std::constexpr_wrapper`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2781r9.html)

コンパイル時定数オブジェクトを生成するクラスの提案。

以前の記事を参照

- [P2781R2 `std::constexpr_v` - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2781R2-stdconstexpr_v)
- [P2781R3 `std::constexpr_v` - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2781R3-stdconstexpr_v)
- [P2781R4 `std::constexpr_v` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2781R4-stdconstexpr_wrapper)
- [P2781R5 `std::constexpr_wrapper` - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2781R5-stdconstexpr_wrapper)
- [P2781R8 `std::constexpr_wrapper` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2781R8-stdconstexpr_wrapper)

このリビジョンでの変更は

- `cw-fixed-value`の型と、`std::constexpr_wrapper`メンバ変数は説明専用とする
- いくつかの場所で`constinit`を`constexpr`に修正
- `operator->*`の実装から“e.operator”を削除
- `std::cw`の目的に関するセクションの段落4を削除
- 例を修正
- その他文言の改善・修正

などです。

この提案は2025年6月の全体会議で承認され、C++26に採択されています。

- [P2781 進行状況](https://github.com/cplusplus/papers/issues/1458)

### [P2876R3 Proposal to extend std::simd with more constructors and accessors](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2876r3.html)

`std::simd`に対して、利便性向上のために標準ライブラリにあるデータ並列型等のサポートを追加する提案。

以前の記事を参照

- [P2876R0 Proposal to extend std::simd with more constructors and accessors - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2876R0-Proposal-to-extend-stdsimd-with-more-constructors-and-accessors)
- [P2876R1 Proposal to extend std::simd with more constructors and accessors - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2876R1-Proposal-to-extend-stdsimd-with-more-constructors-and-accessors)
- [P2876R2 Proposal to extend std::simd with more constructors and accessors - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2876R2-Proposal-to-extend-stdsimd-with-more-constructors-and-accessors)

このリビジョンでの変更は

- `std::bitset`への変換演算子を削除
- LWGフィードバックを適用
- その他文言の修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P2876 進行状況](https://github.com/cplusplus/papers/issues/1531)

### [P2929R1 `simd_invoke`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2929r1.html)

`std::simd`で組み込み関数の使用を簡易にする呼び出しラッパ関数の提案。

以前の記事を参照

- [P2929R0 `simd_invoke` - WG21月次提案文書を眺める（2023年07月）](https://onihusube.hatenablog.com/entry/2023/09/23/203644#P2929R0-simd_invoke)

このリビジョンでの変更は良くわかりません（R0と全く同じに見える）。

- [P2929 進行状況](https://github.com/cplusplus/papers/issues/1603)

### [P2996R13 Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2996r13.html)

値ベースの静的リフレクションの提案。

以前の記事を参照

- [P2996R0 Reflection for C++26 - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P2996R0-Reflection-for-C26)
- [P2996R1 Reflection for C++26 - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2996R1-Reflection-for-C26)
- [P2996R2 Reflection for C++26 - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P2996R2-Reflection-for-C26)
- [P2996R3 Reflection for C++26 - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P2996R3-Reflection-for-C26)
- [P2996R4 Reflection for C++26 - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P2996R4-Reflection-for-C26)
- [P2996R5 Reflection for C++26 - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P2996R5-Reflection-for-C26)
- [P2996R7 Reflection for C++26 - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P2996R7-Reflection-for-C26)
- [P2996R8 Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2996R8-Reflection-for-C26)
- [P2996R9 Reflection for C++26 - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2996R9-Reflection-for-C26)
- [P2996R10 Reflection for C++26 - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2996R10-Reflection-for-C26)
- [P2996R11 Reflection for C++26 - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P2996R11-Reflection-for-C26)
- [P2996R12 Reflection for C++26 - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2996R12-Reflection-for-C26)

このリビジョンでの変更は

- コア言語の文言の変更
    - 静的匿名共用体のメンバをハンドリング
      - [CWG 3026](https://cplusplus.github.io/CWG/issues/3026.html)の修正案を統合
    - P3687R0からのEWGの更新を適用
      - splice template argumentsを削除
      - かっこで囲まれていないスプライス式をテンプレート引数で使用するとill-formed
      - オペランドが`using`宣言子である`^^`はill-formed
- ライブラリの文言変更
    - `reflect_constant/reflect_object/reflect_function`の使用の更新

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P2996 進行状況](https://github.com/cplusplus/papers/issues/1668)

### [P3008R6 Atomic floating-point min/max](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3008r6.html)

浮動小数点数型の`std::atomic`における`fetch_max()/fetch_min()`の問題を解消する提案。

以前の記事を参照

- [P3008R0 Atomic floating-point min/max - WG21月次提案文書を眺める（2023年10月）](https://onihusube.hatenablog.com/entry/2024/01/08/203712#P3008R0-Atomic-floating-point-minmax)
- [P3008R1 Atomic floating-point min/max - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3008R1-Atomic-floating-point-minmax)
- [P3008R2 Atomic floating-point min/max - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3008R2-Atomic-floating-point-minmax)
- [P3008R3 Atomic floating-point min/max - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3008R3-Atomic-floating-point-minmax)
- [P3008R4 Atomic floating-point min/max - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3008R4-Atomic-floating-point-minmax)
- [P3008R5 Atomic floating-point min/max - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3008R5-Atomic-floating-point-minmax)

このリビジョンでの変更は

- オブジェクト値の文言を変更
- `NaN`に関するremarkを明確化
- `fetch_XXX`の対応関係を明確化
- `value_type`の修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3008 進行状況](https://github.com/cplusplus/papers/issues/1672)

### [P3044R2 `sub-string_view` from `string`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3044r2.pdf)

`std::string`から直接`string_view`を取得する関数を追加する提案。

以前の記事を参照

- [P3044R0 sub-string_view from string - WG21月次提案文書を眺める（2024年01月）](https://onihusube.hatenablog.com/entry/2024/03/10/170322#P3044R0-sub-string_view-from-string)
- [P3044R1 sub-string_view from string - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3044R1-sub-string_view-from-string)

このリビジョンでの変更は

- `string_view::subview`を`freestanding-deleted`指定

などです。

- [P3044 進行状況](https://github.com/cplusplus/papers/issues/1737)

### [P3045R6 Quantities and units library](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3045r6.html)

物理量と単位を扱うライブラリ機能の提案。

以前の記事を参照

- [P3045R0 Quantities and units library - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3045R0-Quantities-and-units-library)
- [P3045R1 Quantities and units library - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3045R1-Quantities-and-units-library)
- [P3045R3 Quantities and units library - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3045R3-Quantities-and-units-library)
- [P3045R4 Quantities and units library - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3045R4-Quantities-and-units-library)
- [P3045R5 Quantities and units library - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3045R5-Quantities-and-units-library)

このリビジョンでの変更は

- Dependencies on other proposals の更新
- Constraining a variable on the stack の拡張
- Usage examples のリンク更新
- Scaling overflow prevention を追加
- Concepts の更新
- Storage tankの例を更新
- Safe operations of vector and tensor quantities の更新
- Superpowers of the unit one の更新
- Symbols of scaled units の更新
- 共通単位のテキスト出力において、“EQUIV{…}” を “[…]” で置換
- Inconsistencies with `std::chrono::duration` を追加
- Complex operations を追加
- Integer division を拡張
- Bikeshedding concepts を追加
- Supported operations and their results を更新
- Equality and equivalence を拡張
- Obtaining common entities を Arithmetics に変更
- Negative constants を追加
- その他の章におけるクリーンアップ

などです。

- [P3045 進行状況](https://github.com/cplusplus/papers/issues/1752)

### [P3060R3 Add `std::views::indices(n)`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3060r3.html)

0から指定した数の整数シーケンスを生成するRangeアダプタ、`views::indices`の提案。

以前の記事を参照

- [P3060R0 Add `std::ranges::upto(n)` - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P3060R0-Add-stdrangesupton)
- [P3060R1 Add `std::ranges::upto(n)` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3060R1-Add-stdviewsupton)
- [P3060R2 Add `std::ranges::indices(n)` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3060R2-Add-stdviewsindicesn)

このリビジョンでの変更は、

- 機能テストマクロの追加

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3060 進行状況](https://github.com/cplusplus/papers/issues/1727)

### [P3091R4 Better lookups for map , unordered_map, and flat_map](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3091r4.html)

連想コンテナからキーによって要素を検索するより便利な関数の提案。

以前の記事を参照

- [P3091R0 Better lookups for `map` and `unordered_map` - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3091R0-Better-lookups-for-map-and-unordered_map)
- [P3091R1 Better lookups for `map` and `unordered_map` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3091R1-Better-lookups-for-map-and-unordered_map)
- [P3091R2 Better lookups for `map` and `unordered_map` - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3091R2-Better-lookups-for-map-and-unordered_map)
- [P3091R3 Better lookups for `map` and `unordered_map` - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3091R3-Better-lookups-for-map-and-unordered_map)

このリビジョンでの変更は

- N5008にリベース
- `constexpr`を追加
- `flat_map`のサポートを追加
- 機能テストマクロのtypoを修正
- LEWGでの投票結果を追加
- `.get`という名前を維持し、`.lookup`に変更しないようにした

などです。

- [P3091 進行状況](https://github.com/cplusplus/papers/issues/1759)

### [P3096R10 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r10.pdf)

↓

### [P3096R11 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r11.pdf)

↓

### [P3096R12 Function Parameter Reflection in Reflection for C++26](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3096r12.pdf)

C++26に向けた静的リフレクションに対して、関数仮引数に対するリフレクションを追加する提案。

以前の記事を参照

- [P3096R0 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3096R0-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R1 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3096R1-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R2 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3096R2-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R3 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3096R3-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R5 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3096R5-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R7 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3096R7-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R8 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P3096R8-Function-Parameter-Reflection-in-Reflection-for-C26)
- [P3096R9 Function Parameter Reflection in Reflection for C++26 - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3096R9-Function-Parameter-Reflection-in-Reflection-for-C26)

R10での変更は

- P2996R12と文言を整合させた
- LWG等からのフィードバックによる文言の更新

R11での変更は

- CWGのフィードバックによる文言の更新

このリビジョンでの変更は

- `identifier_of()`と`has_identifier()`の文言を更新
- `has_default_argument()`の"Constant When"を削除
- LEWG/EWGの投票結果を追加

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3096 進行状況](https://github.com/cplusplus/papers/issues/1764)

### [P3100R3 Implicit contract assertions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r3.pdf)

UB（及びEB）を契約違反として扱うようにする提案。

以前の記事を参照

- [P3100R0 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3100R0-Undefined-and-erroneous-behaviour-are-contract-violations)
- [P3100R1 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3100R1-Undefined-and-erroneous-behaviour-are-contract-violations)
- [P3100R2 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3100R2-Implicit-contract-assertions)

このリビジョンでの変更は

- P2843R3の採択を受けて、UBのリストからプリプロセッサのUBを削除

などです。

- [P3100 進行状況](https://github.com/cplusplus/papers/issues/1901)

### [P3104R4 Bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3104r4.html)

`<bit>`にビット置換系操作を追加する提案

以前の記事を参照

- [P3104R0 Bit permutations - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3104R0-Bit-permutations)
- [P3104R2 Bit permutations - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3104R2-Bit-permutations)
- [P3104R3 Bit permutations - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3104R3-Bit-permutations)

このリビジョンでの変更は

- § 6.6 Why no SIMD support? で`std::simd`サポートがないことを説明
- 数式の表示の調整
- その他文言の修正

などです。

- [P3104 進行状況](https://github.com/cplusplus/papers/issues/1768)

### [P3111R7 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r7.html)

↓

### [P3111R8 Atomic Reduction Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3111r8.html)

`std::atomic`にアトミックリダクション操作を追加する提案。

以前の記事を参照

- [P3111R0 Atomic Reduction Operations - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3111R0-Atomic-Reduction-Operations)
- [P3111R2 Atomic Reduction Operations - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3111R2-Atomic-Reduction-Operations)
- [P3111R3 Atomic Reduction Operations - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3111R3-Atomic-Reduction-Operations)
- [P3111R5 Atomic Reduction Operations - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3111R5-Atomic-Reduction-Operations)
- [P3111R6 Atomic Reduction Operations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3111R6-Atomic-Reduction-Operations)

R7での変更は

- レビューノートを更新
- セクション順序を標準に合わせて変更
- P3008によって追加された不要な文言を削除

このリビジョンでの変更は

- 浮動小数点数アトミックの`min/max`に関してP3008の最新リビジョンを反映

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3111 進行状況](https://github.com/cplusplus/papers/issues/1902)

### [P3149R11 async_scope -- Creating scopes for non-sequential concurrency](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3149r11.html)

P2300のExecutorライブラリについて、並列数が実行時に決まる場合の並行処理のハンドリングを安全に行うための機能を提供する提案。

以前の記事を参照

- [P3149R0 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年02月）](https://onihusube.hatenablog.com/entry/2024/05/18/235613#P3149R0-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R2 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3149R2-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R3 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3149R3-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R5 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3149R5-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R6 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3149R6-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R8 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3149R8-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R9 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3149R9-async_scope----Creating-scopes-for-non-sequential-concurrency)
- [P3149R10 async_scope -- Creating scopes for non-sequential concurrency - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3149R10-async_scope----Creating-scopes-for-non-sequential-concurrency)

このリビジョンでの変更は

- `async_scope_token`を`scope_token`にリネーム
- `nest`を`associate`にリネーム
    - P3865R0から
- `stop-when`の定義を形式化し、`spawn_future`と`counting_scope::token::wrap`を`stop-when`に基づいて再定義
- P3557R2に従い、`impls-for::<associate_t>`に`check-types`を追加
- `join-t`の`noexcept`を修正
- LWGのフィードバックを適用
- セクション1~6を更新

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3149 進行状況](https://github.com/cplusplus/papers/issues/1800)

### [P3179R9 C++ parallel range algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3179r9.html)

Rangeアルゴリズムを`ExecutionPolicy`に対応させる提案。

以前の記事を参照

- [P3179R0 C++ parallel range algorithms - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3179R0-C-parallel-range-algorithms)
- [P3179R1 C++ parallel range algorithms - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3179R1-C-parallel-range-algorithms)
- [P3179R2 C++ parallel range algorithms - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3179R2-C-parallel-range-algorithms)
- [P3179R3 C++ parallel range algorithms - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3179R3-C-parallel-range-algorithms)
- [P3179R4 C++ parallel range algorithms - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3179R4-C-parallel-range-algorithms)
- [P3179R5 C++ parallel range algorithms - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3179R5-C-parallel-range-algorithms)
- [P3179R7 C++ parallel range algorithms - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3179R7-C-parallel-range-algorithms)
- [P3179R8 C++ parallel range algorithms - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3179R8-C-parallel-range-algorithms)

このリビジョンでの変更は、文言の改善のみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3179 進行状況](https://github.com/cplusplus/papers/issues/1815)

### [P3211R1 `views::flat_map`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3211r1.html)

`views::transform`と`views::join`の合成に対応する操作であるRangeアダプタ、`views::flat_map`の提案。

以前の記事を参照

- [P3211R0 `views::transform_join` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3211R0-viewstransform_join)

このリビジョンでの変更は

- `transform_join`を`flat_map`にリネーム
    - 他言語や関連する領域ではこの操作は`flat_map`と呼ばれることが一般的だったため
- `flat_map_view`クラスを導入することにした
- 関連する最適化について議論を追加

などです。

このリビジョンでは、R0とは異なり`views::flat_map`を既存の`views::transform`と`views::join`の単純な合成によって定義しないようになっています。これは

- `base()`で元の範囲を取得できない
    - `transform | join`だと`transform_view`が取得されてしまう
- `transform`の結果である内側の範囲をキャッシュできない
    - `transform | join`だと、`join`は入力範囲の内側範囲がどのように生成されているか（生成のコストなど）を認識できず、繰り返しの呼び出しにおいて都度間接参照する
    - `cache_latest`はこの問題を緩和するが、`input_range`になってしまう
    - 独自の`view`型なら内側範囲がどのように生成されているかを認識できるためその結果をキャッシュでき、キャッシュは内部的に処理されるため範囲のカテゴリに影響を与えない
- 不必要な入力範囲のプロパティ保持のための不要なインスタンス化が発生する
    - `flat_map`はその性質上`bidirectional_range`にしかならないが、`transform`はランダムアクセス性を可能なら維持しようとする
    - 不要なインスタンス化とコードの肥大化を招きうる

などの理由によります。合成による定義は確かに単純ですが、少なくともこの`flat_map`の場合は独自の`view`を提供するメリットが上回るという判断です。

- [P3211 進行状況](https://github.com/cplusplus/papers/issues/1862)

### [P3216R1 `views::slice`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3216r1.html)

元の範囲の連続した一部分を切り出すRangeアダプタ、`views::slice`の提案。

以前の記事を参照

- [P3216R0 `views::slice` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3216R0-viewsslice)

このリビジョンでの変更は

- SG9のフィードバックに基づいて、`slice_view`を導入する

などです。

このリビジョンでは、R0とは異なり`views::slice`を既存の`views::drop`と`views::take`の単純な合成によって定義しないようになっています。これは

- `base()`で元の範囲を取得できない
- `reserve_hint()`を常に提供できない
    - `views::drop`は入力が`approximately_sized_range`である場合にのみ`reserve_hint()`を提供するため、合成だと常に`reserve_hint()`を提供できない
    - しかし、`views::slice(start, end)`は`end - start`を`reserve_hint()`として常に提供できるはずであり、独自`view`にすることでこれが可能になる
- パフォーマンスの問題
    - 合成だと、複数のイテレータラッパの生成と間接参照が発生するため、オーバーヘッドがある
    - 単一の`slice_view`なら、より最適化しやすくなることが期待される
- 境界処理の一元化
    - 合成だと、範囲の境界チェックや範囲外逸脱防止処理が2つのアダプタに分散して実行され、冗長なチェックが発生する可能性がある
    - 単一の`slice_view`ならより一貫した境界チェックを行うことができ、行われることも把握しやすくなる
- デバッグしやすさの向上
    - 合成による`view`型はネストした型が生成されているためデバッグしづらい
- 将来の拡張性
    - 合成の場合、`views::slice`の機能拡張をしようとすると`drop, take`の両方の事を考慮しなければならない
    - 単一の`slice_view`ならそれらとは無関係に検討できる

などの理由によります。

- [P3216 進行状況](https://github.com/cplusplus/papers/issues/1865)

### [P3220R1 `views::take_before`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3220r1.html)

入力の範囲を指定した値が最初に出現する位置を終端として切り出すRangeアダプタ、`views::delimit`の提案。

以前の記事を参照

- [P3220R0 `views::delimit` - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3220R0-viewsdelimit)

このリビジョンでの変更は

- `views::delimit`を`views::take_before`にリネーム
- `views::take_before(p, '\0')`などにおいて、条件付きで`borrowed_range`となるようにした
    - スカラ型の値は番兵に保存することで、イテレータが`view`型の状態に依存しないようにする

などです。

- [P3220 進行状況](https://github.com/cplusplus/papers/issues/1868)

### [P3223R2 Making std::istream::ignore less surprising](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3223r2.html)

`istream::ignore()`の第二引数に負の値を与えた場合の動作を修正する提案。

以前の記事を参照

- [P3223R0 Making `std::basic_istream::ignore` less surprising - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P3223R0-Making-stdbasic_istreamignore-less-surprising)
- [P3223R1 Making `std::istream::ignore` less surprising - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3223R1-Making-stdistreamignore-less-surprising)

このリビジョンでの変更は

- 追加するオーバーロードからデフォルト引数を削除
- Annex Cのエントリを追加
- LEWGレビュー結果を追加
- その他文章の修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3223 進行状況](https://github.com/cplusplus/papers/issues/1871)

### [P3248R4 Require [u]intptr_t](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3248r4.html)

`(u)intptr_t`を必須にする提案。

以前の記事を参照

- [P3248R0 Require [u]intptr_t - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3248R0-Require-uintptr_t)
- [P3248R1 Require [u]intptr_t - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3248R1-Require-uintptr_t)
- [P3248R2 Require [u]intptr_t - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3248R2-Require-uintptr_t)
- [P3248R3 Require [u]intptr_t - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3248R3-Require-uintptr_t)

このリビジョンでの変更は

- この変更の影響を受ける標準ライブラリ内のものに対するクリーンアップを行った
- LEWGレビュー結果を追加

などです。

- [P3248 進行状況](https://github.com/cplusplus/papers/issues/1909)

### [P3290R3 Integrating Existing Assertions With Contracts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3290r3.pdf)

既存のアサーション機構に契約プログラミング機能を統合する提案。

以前の記事を参照

- [P3290R0 Integrating Existing Assertions With Contracts - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3290R0-Integrating-Existing-Assertions-With-Contracts)
- [P3290R1 Integrating Existing Assertions With Contracts - WG21月次提案文書を眺める（2024年07月）](https://onihusube.hatenablog.com/entry/2025/01/13/204945#P3290R1-Integrating-Existing-Assertions-With-Contracts)
- [P3290R2 Integrating Existing Assertions With Contracts - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3290R2-Integrating-Existing-Assertions-With-Contracts)

このリビジョンでの変更は

- P2900R14採択後のWDにリベース
- `source_location::current()`の使用法を明記し、実装上の選択肢について議論を追加
- `nothrow_t`引数の位置を引数の最初に変更
- 実装経験について追記
- `detection_mode::manual`を`detection_mode::unspecified`にリネーム
- `<assert.h>`と`<cassert>`の両方を処理するようにする

などです。

- [P3290 進行状況](https://github.com/cplusplus/papers/issues/1943)

### [P3293R3 Splicing a base class subobject](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3293r3.html)

リフレクション機能において、基底クラスのサブオブジェクトへアクセスする簡単な方法を提供する提案。

以前の記事を参照

- [P3293R0 Splicing a base class subobject - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3293R0-Splicing-a-base-class-subobject)
- [P3293R1 Splicing a base class subobject - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3293R1-Splicing-a-base-class-subobject)
- [P3293R2 Splicing a base class subobject - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3293R2-Splicing-a-base-class-subobject)

このリビジョンでの変更は

- P2996R13にリベース
- 時間の都合により、基底クラスサブオブジェクトへのポインタを取得する機能を削除

などです。

基底クラスサブオブジェクトへのポインタを取得する機能とは、型`T`の基底クラス型`B`のリフレクション`base`を用いて`&[:base:]`の様にスプライスした時に適切にオフセットされたメンバポインタ`B T::*`を取得できるようにする機能の事です。このような機能は現在の言語機能に対応するものが無かったため、議論に時間がかかることが予想され、それによってこの提案からは外されました。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3293 進行状況](https://github.com/cplusplus/papers/issues/1945)

### [P3347R3 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r3.pdf)

無効化されたポインタに対する一部の演算を明示的に許可する提案。

以前の記事を参照

- [P3347R0 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3347R0-InvalidProspective-Pointer-Operations)
- [P3347R1 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3347R1-InvalidProspective-Pointer-Operations)
- [P3347R2 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3347R2-InvalidProspective-Pointer-Operations)

このリビジョンでの変更は

- 非直接ポインタアクセスの例を追加
- フィードバックを受けて、提案する文言の修正
- pointer trapの表現について代替案を追加

などです。

- [P3347 進行状況](https://github.com/cplusplus/papers/issues/2019)

### [P3348R4 C++26 should refer to C23 not C17](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3348r4.pdf)

Cへの参照をC17からC23へ更新する提案。

以前の記事を参照

- [P3348R0 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3348R0-C26-should-refer-to-C23-not-C17)
- [P3348R1 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3348R1-C26-should-refer-to-C23-not-C17)
- [P3348R2 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3348R2-C26-should-refer-to-C23-not-C17)
- [P3348R3 C++26 should refer to C23 not C17 - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P3348R3-C26-should-refer-to-C23-not-C17)

このリビジョンでの変更は

- `realloc`の仕様から“behavior is undefined unless”という不要な文言を削除
- [c.mb.wcs]の`cuchar()`に関するdrafting noteを明確化
- [ctime.syn]から`asctime(), ctime()`を削除し、それらの文言を[depr.format]に追加
- [cstdint.syn]の編集について文脈を追加
- [diff.char16]に変更を追加

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3348 進行状況](https://github.com/cplusplus/papers/issues/2020)

### [P3383R3 `mdspan.at()`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3383r3.html)

`std::mdspan`に`.at()`メンバ関数を追加する提案。

以前の記事を参照

- [P3383R0 `mdspan.at()` - WG21月次提案文書を眺める（2024年09月）](https://onihusube.hatenablog.com/entry/2025/02/24/215818#P3383R0-mdspanat)
- [P3383R1 `mdspan.at()` - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3383R1-mdspanat)
- [P3383R2 `mdspan.at()` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3383R2-mdspanat)

このリビジョンでの変更は

- 段落8と9の入れ替え
- `indices`の代わりに`I`を使用（インデックス引数のパック名）

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3383 進行状況](https://github.com/cplusplus/papers/issues/2040)

### [P3394R4 Annotations for Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3394r4.html)

C++任意のエンティティ（宣言）に対して静的リフレクションのためのアノテーションを付加できるようにする提案。

以前の記事を参照

- [P3394R0 Annotations for Reflection - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3394R0-Annotations-for-Reflection)
- [P3394R1 Annotations for Reflection - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3394R1-Annotations-for-Reflection)
- [P3394R2 Annotations for Reflection - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3394R2-Annotations-for-Reflection)
- [P3394R3 Annotations for Reflection - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3394R3-Annotations-for-Reflection)

このリビジョンでの変更は

- 文言の改善
- 属性とアノテーションを同じ場所（`attribute-specifier`）に配置する機能の削除

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3394 進行状況](https://github.com/cplusplus/papers/issues/2074)

### [P3411R3 any_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3411r3.html)

`view`を型消去するための`view`、`any_view`の提案。

以前の記事を参照

- [P3411R0 `any_view` - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3411R0-any_view)
- [P3411R1 `any_view` - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3411R1-any_view)
- [P3411R2 `any_view` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3411R2-any_view)

このリビジョンでの変更は

- `contiguous` rangeの扱いについて修正

などです。

- [P3411 進行状況](https://github.com/cplusplus/papers/issues/2082)

### [P3433R1 Allocator Support for Operation States](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3433r1.pdf)

`operation_state`型において、アロケータを認識し伝播可能にする提案。

以前の記事を参照

- [P3433R0 Allocator Support for Operation States - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3433R0-Allocator-Support-for-Operation-States)

このリビジョンでの変更は

- 文言の改善
- 説明専用`allocator-aware-move`を`allocator-aware-forward`に変更

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3433 進行状況](https://github.com/cplusplus/papers/issues/2098)

### [P3439R3 Chained comparisons: Safe, correct, efficient](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3439r3.pdf)

誤って書かれることの多い、連鎖比較を意図通りに動作するようにする提案。

以前の記事を参照

- [P3439R0 Chained comparisons: Safe, correct, efficient - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3439R0-Chained-comparisons-Safe-correct-efficient)
- [P3439R1 Chained comparisons: Safe, correct, efficient - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3439R1-Chained-comparisons-Safe-correct-efficient)
- [P3439R2 Chained comparisons: Safe, correct, efficient - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3439R2-Chained-comparisons-Safe-correct-efficient)

このリビジョンでの変更は

- EWGの推奨に基づいて、（連鎖比較を）ill-formedではなく非推奨とする
- フィードバックによる文言の改善

などです。

- [P3439 進行状況](https://github.com/cplusplus/papers/issues/2103)

### [P3440R1 Add `n_elements` named constructor to `std::simd`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3440r1.html)

先頭`N`個のビットが立った`simd_mask`を作成するためのファクトリ関数を追加する提案。

以前の記事を参照

- [P3440R0 Add `n_elements` named constructor to `std::simd` - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3440R0-Add-n_elements-named-constructor-to-stdsimd)

このリビジョンでの変更は

- オリジナル`std::simd`提案の現状に合わせて文言を更新

などです。

- [P3440 進行状況](https://github.com/cplusplus/papers/issues/2104)

### [P3480R6 `std::simd` is a `range`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3480r6.pdf)

`std::simd`を`range`にする提案。

以前の記事を参照

- [P3480R0 std::simd is a range - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3480R0-stdsimd-is-a-range)
- [P3480R2 std::simd is a range - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3480R2-stdsimd-is-a-range)
- [P3480R3 std::simd is a range - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3480R3-stdsimd-is-a-range)
- [P3480R4 std::simd is a range - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3480R4-stdsimd-is-a-range)
- [P3480R5 std::simd is a range - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3480R5-stdsimd-is-a-range)

このリビジョンでの変更は

- `offset_`が0から`size()`の範囲内にとどまるという事前条件を追加
- 内部コンストラクタを説明専用かつ`private`にする
- 不要な`std::`の削除
- `data_`を初期化する前に`addressof`を取得する
- `operator*`の不要な事前条件を削除する
- 可能な限り多くの演算を`+= -=`で表現する
- `basic_simd`と`basic_simd_mask`の`begin/end`にインライン実装を追加
- `begin/end`に加えて、`private`イテレータコンストラクタに`noexcept`を付加
- 差分と等価比較の`noexcept`を追加
- `+`と`-`には値渡し引数を使用する

などです。

- [P3480 進行状況](https://github.com/cplusplus/papers/issues/2134)

### [P3481R4 `std::execution::bulk()` issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r4.html)

↓

### [P3481R5 `std::execution::bulk()` issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3481r5.html)

`std::execution::bulk()`の改善提案。

以前の記事を参照

- [P3481R0 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3481R0-Summarizing-stdexecutionbulk-issues)
- [P3481R1 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3481R1-stdexecutionbulk-issues)
- [P3481R2 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3481R2-stdexecutionbulk-issues)
- [P3481R3 Summarizing `std::execution::bulk()` issues - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P3481R3-stdexecutionbulk-issues)

R4での変更は

- 文言の改善
- `bulk_unchunked`に実行ポリシーを追加
- 並行スケジューラ用の`bulk_unchunked`における余分なチェックを削除

このリビジョンでの変更は

- LWGフィードバックによる文言の修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3481 進行状況](https://github.com/cplusplus/papers/issues/2135)

### [P3491R3 `define_static_{string,object,array}`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3491r3.html)

コンパイル時に構築した文字列や配列などを静的ストレージに昇格させて実行時に持ち越せるようにするライブラリ機能の提案。

以前の記事を参照

- [P3491R0 `define_static_{string,object,array}` - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3491R0-define_static_stringobjectarray)
- [P3491R1 `define_static_{string,object,array}` - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3491R1-define_static_stringobjectarray)
- [P3491R2 `define_static_{string,object,array}` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3491R2-define_static_stringobjectarray)

このリビジョンは

- P3617R0の内容をマージ

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3491 進行状況](https://github.com/cplusplus/papers/issues/2158)

### [P3503R3 Make type-erased allocator use in promise and packaged_task consistent](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3503r3.html)

`std::promise`と`std::packaged_task`のアロケータ対応における問題を修正する提案。

以前の記事を参照

- [P3503R0 Make type-erased allocator use in promise and packaged_task consistent - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3503R0-Make-type-erased-allocator-use-in-promise-and-packaged_task-consistent)
- [P3503R2 Make type-erased allocator use in promise and packaged_task consistent - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3503R2-Make-type-erased-allocator-use-in-promise-and-packaged_task-consistent)

R1およびこのリビジョンでの変更は、文言の修正のみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3503 進行状況](https://github.com/cplusplus/papers/issues/2164)

### [P3540R2 `#embed` Parameter offset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3540r2.html)

`#embed`にオフセットパラメータを渡せるようにする提案。

以前の記事を参照

- [P3540R0 `#embed` Parameter offset - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3540R0-embed-Parameter-offset)
- [P3540R1 `#embed` Parameter offset - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3540R1-embed-Parameter-offset)

このリビジョンでの変更は

- R1で行われた設計変更について詳細に説明を追加
- 文言や文章のtypo修正
- パラメータ順序に制限がないことについて説明等を追加

などです。

オフセット引数は、`#embed <sdk/jump.wav> offset(2) limit(2)`のように指定して

- `offset(N)`はリソースの最大サイズに達するまで、`N`バイト分の項目を破棄する
- `offset(0)`はno-op
- `offset(N)`がリソースのサイズ以上の場合、リソースサイズは0とみなされる
- `limit`は`offset`の後に適用される
    - `offset`は元のファイルサイズに対して適用される
- パラメータ順序によって結果は変わらない

のような動作をします。

- [P3540 進行状況](https://github.com/cplusplus/papers/issues/2177)

### [P3552R3 Add a Coroutine Task Type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3552r3.html)

`std::execution`に対応したコルーチン`task`型の提案。

以前の記事を参照

- [P3552R0 Add a Coroutine Lazy Type - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3552R0-Add-a-Coroutine-Lazy-Type)
- [P3552R1 Add a Coroutine Lazy Type - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3552R1-Add-a-Coroutine-Task-Type)
- [P3552R2 Add a Coroutine Task Type - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3552R2-Add-a-Coroutine-Task-Type)

このリビジョンでの変更は

- LWGフィードバックによる文言の修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3552 進行状況](https://github.com/cplusplus/papers/issues/2200)

### [P3557R3 High-Quality Sender Diagnostics with Constexpr Exceptions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3557r3.html)

`std::execution`における、エラーメッセージ出力を改善する提案。

以前の記事を参照

- [P3557R0 High-Quality Sender Diagnostics with Constexpr Exceptions - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3557R0-High-Quality-Sender-Diagnostics-with-Constexpr-Exceptions)
- [P3557R1 High-Quality Sender Diagnostics with Constexpr Exceptions - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3557R1-High-Quality-Sender-Diagnostics-with-Constexpr-Exceptions)
- [P3557R2 High-Quality Sender Diagnostics with Constexpr Exceptions - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3557R2-High-Quality-Sender-Diagnostics-with-Constexpr-Exceptions)

このリビジョンでの変更は

- 33.9.12.10 [exec.split]の文言変更を削除
- 未規定の例外型はすべて`std::exception`から派生することを必須とする
- `not-a-sender::get_completion_signatures()`を他の全ての`get_completion_signatures()`メンバ関数との一貫性を持たせるために、`constexpr`から`consteval`に変更
- 再配置された`not-a-sender`仕様に注釈をつけ、現在のWDと比較して定義がどのように変化したかを示す
- markdownの修正

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3557 進行状況](https://github.com/cplusplus/papers/issues/2203)

### [P3560R2 Error Handling in Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3560r2.html)

静的リフレクション機能におけるエラーハンドリング方法として例外を採用すべきとする提案。

以前の記事を参照

- [P3560R0 Error Handling in Reflection - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3560R0-Error-Handling-in-Reflection)
- [P3560R1 Error Handling in Reflection - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3560R1-Error-Handling-in-Reflection)

このリビジョンでの変更は

- 文言の修正
- P2996R13にリベース

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3560 進行状況](https://github.com/cplusplus/papers/issues/2206)

### [P3566R2 You shall not pass char* - Safety concerns working with unbounded null-terminated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3566r2.pdf)

その長さが静的に既知ではない文字列（`const char*`）を受け取る`std::string`/`std::string_view`のコンストラクタを置き換える提案。

以前の記事を参照

- [P3566R0 You shall not pass `char*` - Safety concerns working with unbounded null-terminated strings - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3566R0-You-shall-not-pass-char---Safety-concerns-working-with-unbounded-null-terminated-strings)
- [P3566R1 You shall not pass `char*` - Safety concerns working with unbounded null-terminated strings - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3566R1-You-shall-not-pass-char---Safety-concerns-working-with-unbounded-null-terminated-strings)

このリビジョンでの変更は

- P3655R2への参照を追加
- コピーオーバーロードに関する説明を追加
- Qtについての実験を追加
- `nullptr`を空文字列として扱うことを提案していることを明確化

などです。

- [P3566 進行状況](https://github.com/cplusplus/papers/issues/2210)

### [P3570R2 optional variants in sender/receiver](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3570r2.html)

並行キューの`async_pop()`の最適な戻り値型を探る提案。

以前の記事を参照

- [P3570R0 optional variants in sender/receiver - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3570R0-optional-variants-in-senderreceiver)
- [P3570R1 optional variants in sender/receiver - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3570R1-optional-variants-in-senderreceiver)

このリビジョンでの変更は

- 機能テストマクロを追加する代わりに、`__cpp_lib_senders`の値をバンプする
- adapterという言葉をadaptorに統一
- `as_awaitable`のプロセス中に、具体的な変換プロセスを指定
- 文言の改善

などです。

このリビジョンでもR0から変わらず、提示されていたオプションのうちOption2.bを採用しています。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3570 進行状況](https://github.com/cplusplus/papers/issues/2249)

### [P3601R0 Slides for P3407R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3601r0.pdf)

P3407R1の紹介スライド。

P3407R1については以前の記事を参照

- [P3407R1 Make idiomatic usage of `offsetof` well-defined - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3407R1-Make-idiomatic-usage-of-offsetof-well-defined)

P3407R1のモチベーションなどが簡単に紹介されています。

### [P3642R1 Carry-less product: `std::clmul`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r1.html)

↓

### [P3642R2 Carry-less product: `std::clmul`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3642r2.html)

整数のキャリーレス乗算を行う関数の提案。

以前の記事を参照

- [P3642R0 Carry-less product: `std::clmul` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3642R0-Carry-less-product-stdclmul)

R1での変更は

- 提案する文言の誤った式を修正
- HWサポートについて`VPCLMULQDQ`を追加
- §2. Introductionにおける`std::unsigned_integral`の不適切な使用を修正
- N5008とP3161R4にリベース
- モチベーションについて参照を追加

このリビジョンでの変更は

- 非wide版について`std::simd`サポートを追加
- コードスタイルを標準に合わせる
- `std::clmul_wide()`の詳細な設計説明を§5.2. Widening operationに追加
- 設計をP3161R4から分離
- 文言の改善
- P3691R1の`std::simd`命名変更に合わせてリベース

などです。

- [P3642 進行状況](https://github.com/cplusplus/papers/issues/2279)

### [P3647R0 Slides for P3642R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3647r0.html)

P3642R1の紹介スライド。

P3642R1(R2)に関してはすぐ上をご覧ください。

キャリーレス乗算機能の必要性などが簡単に説明されています。

### [P3655R2 `zstring_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3655r2.html)

null終端文字列専用の`std::string_view`の提案。

以前の記事を参照

- [P3655R0 `zstring_view` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3655R0-zstring_view)
- [P3655R1 `zstring_view` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3655R1-zstring_view)

このリビジョンでの変更は

- NVIDIAでの実装経験の追加
- 固定長配列から構築するコンストラクタを追加
- 事前条件をさらに追加
- イテレータ/範囲コンストラクタを追加しない理由の説明を追加
- フォーマッタ追加
- 文字列中にnull文字が入っている場合のセキュリティリスクについて参照を追加

などです。

- [P3655 進行状況](https://github.com/cplusplus/papers/issues/2285)

### [P3663R2 Future-proof `submdspan-mapping`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3663r2.html)

`submdspan()`が`submdspan_mapping`を呼び出す場合について、将来的な拡張を考慮しておくようにする提案。

以前の記事を参照

- [P3663R0 Future-proof `submdspan-mapping`? - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3663R0-Future-proof-submdspan-mapping)
- [P3663R1 Future-proof `submdspan-mapping`? - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3663R1-Future-proof-submdspan-mapping)

このリビジョンでの変更は

- 実装リンクを追加
- `canonical-ice`の実装経験に基づく変更
    - 戻り値を`std::constant_wrapper`ではなく`std::cw`を使用して指定する
    - `std::cw`の前に、`index-cast`を`IndexType`にキャストする
- `check-static-bounds`の実装経験に基づく変更
    - 文言において、`sk`ではなく`Sk{}`のみを使用するように修正
        - これにより、すべての式が有効な定数式になる
    - `check-static-bounds`は、すべてのスライスをパラメータパックで受け取るのではなく、一つのスライス型のみをテンプレート引数で受け取るように変更
    - 文言において、型が`integral-constant-like`の場合のみデフォルト構築可能であることを仮定するようにした
- `submdspan`の“Effects: Equivalent to”の指定コードを修正
- LWGのフィードバックによる文言の修正
- `canonical-ice`が値`Value`に対して`cw<IndexType(Value)>`か`IndexType(Value)`のどちらかを返すようにする
- 実装に関する議論を拡張し、予備的なベンチマークを追加

などです。

- [P3663 進行状況](https://github.com/cplusplus/papers/issues/2292)

### [P3668R2 Defaulting Postfix Increment and Decrement Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3668r2.html)

後置インクリメント/デクリメント演算子を`default`定義できるようにする提案。

以前の記事を参照

- [P3668R0 Defaulting Postfix Increment and Decrement Operations - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P3668R0-Defaulting-Postfix-Increment-and-Decrement-Operations)
- [P3668R1 Defaulting Postfix Increment and Decrement Operations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3668R1-Defaulting-Postfix-Increment-and-Decrement-Operations)

このリビジョンでの変更は

- ターゲットをCWGに変更
- 投票結果を追加
- 初期化構文には`()`を使用するように変更
- P2952がC++26に入らなかったことを受けてステータスを更新
- ライブラリ文言の変更に関する提案の参照を追加

などです。

- [P3668 進行状況](https://github.com/cplusplus/papers/issues/2298)

### [P3669R2 Non-Blocking Support for std::execution](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3669r2.html)

`operation_state`の開始操作がブロッキングするかどうかを取得するインターフェースを追加する提案。

以前の記事を参照

- [P3669R0 Non-Blocking Support for `std::execution` - WG21月次提案文書を眺める（2025年04月）](https://onihusube.hatenablog.com/entry/2025/10/17/135531#P3669R0-Non-Blocking-Support-for-stdexecution)
- [P3669R1 Non-Blocking Support for `std::execution` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3669R1-Non-Blocking-Support-for-stdexecution)

このリビジョンでの変更は

- 根拠を追記
- `concurrent_scheduler`を`try_scheduler`に変更
- 使用例を追加

などです。

- [P3669 進行状況](https://github.com/cplusplus/papers/issues/2299)

### [P3687R1 Final Adjustments to C++26 Reflection](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3687r1.html)

P2996のリフレクション機能に対する修正の提案。

以前の記事を参照

- [P3687R0 Final Adjustments to C++26 Reflection - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3687R0-Final-Adjustments-to-C26-Reflection)

このリビジョンでの変更は

- エンティティプロキシのリフレクションをTU-local値とするための文言を追加
- [namespace.udecl]の文言を修正
- typo修正

などです。

この提案はすでにP2996にマージされています。

- [P3687 進行状況](https://github.com/cplusplus/papers/issues/2317)

### [P3688R1 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r1.html)

ASCIIに関連する文字の判定・処理関数群を提供する提案。

以前の記事を参照

- [P3688R0 ASCII character utilities - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3688R0-ASCII-character-utilities)

このリビジョンでの変更は

- `is_ascii_digit()`の`base`引数の事前条件が堅牢化対象ではない理由を説明
- [tab:headers.cpp]への追記漏れを修正

などです。

- [P3688 進行状況](https://github.com/cplusplus/papers/issues/2318)

### [P3690R1 Consistency fix: Make simd reductions SIMD-generic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3690r1.pdf)

`std::simd`専用となっている一部の操作をジェネリックにする提案。

以前の記事を参照

- [P3690R0 Consistency fix: Make simd reductions SIMD-generic - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3690R0-Consistency-fix-Make-simd-reductions-SIMD-generic)

このリビジョンでの変更は

- 文言の修正
- 例の修正

などです。

- [P3690 進行状況](https://github.com/cplusplus/papers/issues/2320)

### [P3691R1 Reconsider naming of the namespace for "std::simd"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3691r1.pdf)

`std::simd`の名前空間構造を再考する提案。

以前の記事を参照

- [P3691R0 Reconsider naming of the namespace for “std::simd” - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3691R0-Reconsider-naming-of-the-namespace-for-stdsimd)

このリビジョンでの変更は

- SIMD型名を`std::simd::vec`に変更する
- 新しい命名に合わせた編集者向けの指示を追加

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3691 進行状況](https://github.com/cplusplus/papers/issues/2321)

### [P3692R1 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r1.pdf)

P3064R2を要約した文書、および現在の実装ではOOTAが起こらないことを明確化する提案。

以前の記事を参照

- [P3692R0 How to Avoid OOTA Without Really Trying - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3692R0-How-to-Avoid-OOTA-Without-Really-Trying)

このリビジョンでの変更は

- 連絡先情報の追加
- 構文上の依存関係のサブセットであり、意味上の依存関係のスーパーセットである“preserved dependencies”を定義
- その他文章の修正

などです。

- [P3692 進行状況](https://github.com/cplusplus/papers/issues/2322)

### [P3697R1 Minor additions to C++26 standard library hardening](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3697r1.html)

堅牢化された事前条件をさらに追加する提案。

以前の記事を参照

- [P3697R0 Minor additions to C++26 standard library hardening - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3697R0-Minor-additions-to-C26-standard-library-hardening)

このリビジョンでの変更は、文言の修正のみです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3697 進行状況](https://github.com/cplusplus/papers/issues/2327)

### [P3699R1 Rename `conqueue_errc`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3699r1.html)

P0260の`conqueue_errc`をリネームする提案。

以前の記事を参照

- [P3699R0 Rename `conqueue_errc` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3699R0-Rename-conqueue_errc)

このリビジョンでの変更は

- 名前のオプションをさらに追加した

などです。

- [P3699 進行状況](https://github.com/cplusplus/papers/issues/2329)

### [P3705R1 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r1.html)

↓

### [P3705R2 A Sentinel for Null-Terminated Strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3705r2.html)

文字列範囲内の終端文字（`\0`）を見つけるとそこで終端を示す番兵型の提案。

以前の記事を参照

- [P3705R0 A Sentinel for Null-Terminated Strings - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3705R0-A-Sentinel-for-Null-Terminated-Strings)

R1での変更は

- モチベーションセクションにおけるoff-by-oneを修正
- argvとenvironを使用した例を追加
- `unchecked_take_before`の設計の代替案を追加

このリビジョンでの変更は

- `unchecked_take_before`と値渡し設計の代替案を削除
- SG9レビューの議事録と投票結果を追加
- `null_term`を`std::views`に移動
- 機能テストマクロを追加
- 命名に関する議論を追加
- `initializer_list`の相互作用を避けるため、`iter_value_t<I>{}`ではなく`iter_value_t<I>()`を使用する

などです。

- [P3705 進行状況](https://github.com/cplusplus/papers/issues/2334)

### [P3709R1 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r1.html)

↓

### [P3709R2 Reconsider parallel ranges::rotate_copy and ranges::reverse_copy](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3709r2.html)

並行アルゴリズム版の`ranges::rotate_copy`、`ranges::reverse_copy`の戻り値についての再設計の提案。

以前の記事を参照

- [P3709R0 Reconsider parallel `ranges::rotate_copy` and `ranges::reverse_copy` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3709R0-Reconsider-parallel-rangesrotate_copy-and-rangesreverse_copy)

R1での変更は

- 編集上の修正
- 提案する文言を追加

このリビジョンでの変更は

- `reverse_copy, rotate_copy`の戻り値型のメンバ変数名に関する考慮事項を追加

などです。

この提案は、2025年6月の全体会議で採択され、C++26に導入されています。

- [P3709 進行状況](https://github.com/cplusplus/papers/issues/2337)

### [P3711R1 Safer StringViewLike Functions for Replacing char* strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3711r1.pdf)

`char*`文字列の使用を排除するためのユーティリティ関数の提案。

以前の記事を参照

- [P3711R0 Safer StringViewLike Functions for Replacing char* strings - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3711R0-Safer-StringViewLike-Functions-for-Replacing-char-strings)

このリビジョンでの変更は

- `starts_with, join, is_empty_or_null`の代替実装例を追加
- SG23の投票結果を追加

などです。

この提案はLEWGのレビューにおいてより時間をかけて検討することを否決されており、リジェクトされています。

- [P3711 進行状況](https://github.com/cplusplus/papers/issues/2339)

### [P3713R0 2025-05 Library Evolution Poll Outcomes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3713r0.html)

2025年5月に行われた、LEWGにおける投票の結果。

次の提案が投票にかけられ、C++29にむけてLWGに転送されました。

- [P3391R0 constexpr std::format](https://wg21.link/P3391R0)

### [P3718R0 Fixing Lazy Sender Algorithm Customization, Again](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3718r0.html)

`std::execution`に対するP2999R3の問題点を修正する提案。

P2999については以前の記事を参照

- [P2999R3 Sender Algorithm Customization - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2999R3-Sender-Algorithm-Customization)

ここでは主に、`continues_on`と`schedule_from`の扱うドメイン（`sender`アルゴリズムがカスタマイズの探索を行う範囲・環境、あるいは`sender`の完了地点の宣言そのもの）に関する問題の修正が提案されています。

1. `get-domain-late()`における`continues_on`と`schedule_from`の取り違え
    - その説明の中で`continues_on`と`schedule_from`の役割が逆になって扱われている
2. 遅延カスタマイズの場合のドメインの問い合わせ先の間違い
    - ある`sender`が`connect`された時、ドメインの問い合わせ先をその`sender`に対して行っていた
    - ある`sender`自身のドメインと先行`sender`のドメインが一致する場合は問題ないものの一致しない場合に問題になる
        - `continues_on`は自身の完了地点と先行`sender`の完了地点が異なる（=ドメインが異なる）可能性があるため、問題が起こりうる
3. `get-domain-late()`が優先使用するドメインが誤っている
    -  `get-domain-late()`は渡された`sender`のドメインを、`receiver`のドメインよりも優先する
    -  `sender`は自身がどこで完了するかを知ることができ、`receiver`は処理（後続`sender`）がどこで開始されるかを知っている
    -  `sender`が開始される場所に基づいてディスパッチを行う場合、`sender`ではなく`receiver`に問い合わせるべき

`continues_on`と`schedule_from`はコンテキストの遷移を扱う`sender`アルゴリズムであるため、ドメインの取得に関して他の一般の`sender`アルゴリズムと異なる特別な対応が必要になります。

ここでは次の解決策を提案しています

1. デフォルト実装を持たない非転送のクエリを行う、`get_domain_override`クエリを追加
2. `get_scheduler`クエリに意味を持たせるため、操作の作成に使用した`receiver`の環境に関連付けられた`scheduler`の実行エージェント上で操作を開始することを要求する
3. `SCHED-ATTRS`と`SCHED-ENV`の定義を調整し、`get_domain`クエリの転送を回避する
4. 説明専用の`completion-domain`ヘルパの定義を簡素化し、設定可能なデフォルトを不要にする
5. `get_domain_override(get_env(schedule_from(sch, sndr)))`が`sch`のドメインを返すことを規定
6. `get_domain_override(get_env(continues_on(sndr, sch)))`が`sndr`のドメインを返すことを規定
7. `get_domain_override(get_env(starts_on(sch, sndr)))`が`sch`のドメインを返すことを規定
8. `get-domain-late(sndr, env, def)`は次のいずれかと等価である必要がある
    - `get_domain_override(get_env(sndr))`: この式がwell-formedの場合
    - `get_domain(env)`: そうではなく、この式がwell-formedの場合
    - `get_domain(get_scheduler(env))`: そうではなく、この式がwell-formedの場合
    - それ以外の場合: `def`
9.  `sync_wait`および`sync_wait_with_variant`はカスタマイズを探索する際に`get-domain-late(sndr, sync-wait-env{}, get-domain-early(sndr))`を使用することを指定

これらの事は、NVIDIAのCCCLというライブラリ向けのGPUスケジューラを再実装している際に発見されたもののようで、CCCLライブラリおよびstdexecにおいてこれらの設計は実装済みであるようです。

- [P3718 進行状況](https://github.com/cplusplus/papers/issues/2350)

### [P3719R0 `std::is_vector_bool_reference`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3719r0.html)

`std::vector<bool>`を検出する型特性を追加する提案。

例えば次のようにある関数のオーバーロードを特定の型ごとに用意しなければならない場合

```cpp
// シリアライズライブラリなど、型ごとのread()関数オーバーロードが大量にある
void read(bool& b);
void read(int& b);
void read(long& b);
void read(long long& b);
// ... many more
```

このとき、`std::vector<bool>`（の要素型）にも対応する必要があることに気づきます。移植性のある方法として次のように書くとおおむねうまくいきます

```cpp
void read(std::vector<bool>::reference b);
```

しかし、アロケータがカスタマイズされた`std::vector<bool, MyAllocator>`のようなものにこれでは対応できないことがあります。なぜなら、`std::vector<bool, MyAllocator>::reference`と`std::vector<bool>::reference`が実装によっては異なる型である場合もそうでない場合もあるためです。実際、libstdc++では同じ型であり、MSVC STLでは異なる型になります。

このような場合にアロケータをテンプレート化するだけではこれを解決できません。

```cpp
template <typename Alloc>
void read(std::vector<bool, Alloc>::reference b);
```

このような関数テンプレートにおいては、`Alloc`は推論できないコンテキストにあるため推論に失敗します。

この提案では、`std::vector<bool>::reference`をアロケータ型によらずに識別するために、`std::is_vector_bool_reference<T>`型特性を追加することを提案しています。このような型特性は標準においても説明専用の`is-vector-bool-reference`として存在しているため、これをユーザーが使用できるようにするだけです。

`std::is_vector_bool_reference<T>`は、`T`が任意のアロケータ型`Alloc`に対する`std::vector<bool, Alloc>::reference`型を示しており、かつ`std::vector<bool, Alloc>`がプログラム定義の特殊化（ユーザー定義特殊化）ではない場合に`true`を返すものです。

これを用いると、先ほどのオーバーロードの問題はシンプルに書くことができるようになります

```cpp
template <typename BitReference>
    requires std::is_vector_bool_reference_v<BitReference>
void read(BitReference b);
```

- [P3719 進行状況](https://github.com/cplusplus/papers/issues/2351)

### [P3721R0 Slides for P3639R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3721r0.html)

P3639R0の紹介スライド。

P3639R0については以前の記事を参照

- [P3639R0 The _BitInt Debate - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3639R0-The-_BitInt-Debate)

P3639R0の内容が簡単に解説されています。

### [P3722R0 Slides for P3568R1](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3722r0.html)

P3568R1の紹介スライド。

- [P3568R1 break label; and continue label; - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3568R1-break-label-and-continue-label)

主に構文候補の選択過程（WG14 N3355を採用）と、その構文の問題点の解消（重複ラベルの許可）についてを説明しています。

### [P3724R0 Integer division](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3724r0.html)

商と剰余を様々な丸めモードで計算するライブラリ関数の提案。

C++の現在の`/`は切り捨て除算を行います。しかし、丸めモードは切り捨てだけではなく他のものも有用と思われます。また、標準の丸め方法では割られる数が負の場合などに剰余が負の値になる場合もあり、この動作も望ましくありません。

このような問題を回避するのは非常に単純に思えますが、実際には`/`に存在する未定義動作を回避しながら丸め方法を変更するのは驚くほど難しく、少し調べて出てくるような方法はほとんどが間違っているか、問題を抱えています（提案文書にはその例がいくつか掲載されています）。さらに、剰余に関しても整数オーバーフローを回避する必要性によってゼロ方向以外の丸めモードで正しく計算するのは困難です。

この提案は丸め方法を指定して商と剰余を求めるライブラリ関数を追加することで、現在の`/`および`%`に代わって所望の丸め方法で商と剰余を求める方法を提供しようとするものです。

提案文書より、サンプルコード

```cpp
const int bucket_size = 1000;
int elements = 100;

int buckets_required = elements / bucket_size; // WRONG, zero
int buckets_required = std::div_to_inf(elements, bucket_size); // OK, one bucket
```

提案している関数は、その名前が商を計算するものは`div_`、剰余を計算するものは`div_rem_`で始まり、それに続いて丸め方法が指定される形の命名になっています。

```cpp
namespace std {
  template<class T>
    constexpr T div_to_zero(T x, T y);
  template<class T>
    constexpr T div_away_zero(T x, T y);
  template<class T>
    constexpr T div_to_inf(T x, T y);
  template<class T>
    constexpr T div_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_to_odd(T x, T y);
  template<class T>
    constexpr T div_to_even(T x, T y);
  template<class T>
    constexpr T div_ties_to_zero(T x, T y);
  template<class T>
    constexpr T div_ties_away_zero(T x, T y);
  template<class T>
    constexpr T div_ties_to_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr T div_ties_to_odd(T x, T y);
  template<class T>
    constexpr T div_ties_to_even(T x, T y);

  template<class T>
    constexpr div_result<T> div_rem_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_to_even(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_away_zero(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_neg_inf(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_odd(T x, T y);
  template<class T>
    constexpr div_result<T> div_rem_ties_to_even(T x, T y);
}
```

`div_rem_`関数の戻り値型の`div_result<T>`は商と剰余の値を同時に保持している集成体型です。

```cpp
namespace std {
  template<class T>
  struct div_result {
    T quotient;
    T remainder;

    friend auto operator<=>(const div_result&, const div_result&) = default;
  };
}
```

非常にたくさんの関数がありますが、`div_`と`div_rem_`で変種は共通しており、それはすべて丸めモードの違いです。

- `to_zero`
    - ゼロ方向丸め
    - `/`と同じ動作
- `away_zero`
    - ゼロと逆方向への丸め
- `to_inf`
    - 正の無限大方向への丸め（切り上げ
- `to_neg_inf`
    - 負の無限大方向への丸め（切り捨て
- `to_odd`
    - 奇数丸め
- `to_even`
    - 偶数丸め
- `ties_to_zero`
    - 最近接丸め（最も近い整数への丸め
    - 最も近い整数が2つある場合はゼロ方向（絶対値の小さいほう）へ丸める
- `ties_away_zero`
    - 最近接丸め
    - 最も近い整数が2つある場合は絶対値の大きいほうへ丸める
- `ties_to_inf`
    - 最近接丸め
    - 最も近い整数が2つある場合は正の無限大方向（大きいほう）へ丸める
- `ties_to_neg_inf`
    - 最近接丸め
    - 最も近い整数が2つある場合は負の無限大方向（小さいほう）へ丸める
- `ties_to_odd`
    - 最近接丸め
    - 最も近い整数が2つある場合は奇数のほうへ丸める
- `ties_to_even`
    - 最近接丸め
    - 最も近い整数が2つある場合は偶数のほうへ丸める

これに加えて、除算の剰余を常に負の無限大方向へ丸める`std::mod()`も用意しています。

```cpp
namespace std{
  template<class T>
    constexpr T mod(T x, T y);
}
```

これは、剰余の符号が割る数と同じになり、モジュラー演算を意図するところで有効に使用できるため専用の関数として用意されています。

- [P3724 進行状況](https://github.com/cplusplus/papers/issues/2354)

### [P3725R0 Filter View Extensions for Input Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3725r0.pdf)

↓

### [P3725R1 Filter View Extensions for Input Ranges](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3725r1.pdf)

`views::filter`の問題点を軽減しようとする提案。

P3329R0で指摘されているように、`views::filter`には落とし穴がいくつかあります。

- [P3329R0 Healing the C++ Filter View - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3329R0-Healing-the-C-Filter-View)

この提案でもいくつか新しいサンプルが提供されていますが、この提案はそれらの問題を緩和しようとするものです。

ここでの変更は

- `filter_view`に`begin()/end()`の`const`オーバーロードを追加
    - 使用可能なのは、入力範囲（`const`化したもの）が`input_range`でしかない場合
- `views::filter`の入力範囲が`input_range`でしかない場合は、フィルタ結果要素の変更を許可する
    - 現在は未定義動作
- `views::input_filter`アダプタの追加
    - 入力範囲に`views::to_input`を適用して使用する`views::filter`
    - 他の変更と合わせて、`input_range`にしかならないことで要素の変更（ムーブ）を許可するなど、既知の問題を緩和する

などです。

提案文書より、サンプルコード

```cpp
auto large = [](const auto& s) { return s.size() > 5; }; 
auto sub = coll1 | std::views::filter(large) 
                 | std::views::reverse 
                 | std::views::as_rvalue 
                 | std::ranges::to<std::vector>(); 
```

このコードは、`as_rvalue`によってフィルタ後要素をムーブしていることによって未定義動作となっています。実装が同じフィルタ後イテレータを2回以上間接参照したりすると問題が起こります。

```cpp
auto large = [](const auto& s) { return s.size() > 5; }; 
auto sub = coll1 | std::views::input_filter(large) 
                 | std::views::reverse 
                 | std::views::as_rvalue 
                 | std::ranges::to<std::vector>();  // コンパイルエラー
```

`views::filter`を使用したままではこの提案でもこの問題は緩和されませんが、`views::input_filter`を使用する場合コンパイルエラーとして問題が報告されるようになります。

```cpp
void constIterate(const auto& coll);  // 引数をconstで受ける

std::vector<std::string> coll3{"Amsterdam", "Berlin", "Cologne", "LA"};

auto large = [](const auto& s) { return s.size() > 5; };
constIterate(coll3 | std::views::filter(large));  // コンパイルエラー
```

現在の`views::filter`はconst-iterableではないためエラーになりますが、`views::input_filter`を使用することで使用できるようになります。

SG9のレビューにおいては大きな反対意見はなかったようで、LEWGに転送されることが投票で可決されています。

- [P3725 進行状況](https://github.com/cplusplus/papers/issues/2355)

### [P3726R0 Adjustments to Union Lifetime Rules](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3726r0.html)

トリビアルな共用体を定数式で使用可能にするために制限を緩和する提案。

P3074R7では、共用体を使用した次のような実装による`inplace_vector`を定数式で使用可能にするための共用体のルールの調整が行われました。

```cpp
template <typename T, size_t N>
struct FixedVector {
  union { T storage[N]; };
  size_t size = 0;

  constexpr FixedVector() = default;

  constexpr ~FixedVector() {
    std::destroy(storage, storage + size);
  }

  constexpr auto push_back(T const& v) -> void {
    ::new (storage + size) T(v);
    ++size;
  }
};

constexpr auto silly_test() -> size_t {
  FixedVector<std::string, 3> v;
  v.push_back("some sufficiently longer string");
  return v.size;
}

static_assert(silly_test() == 1);
```

ここでの`union { T storage[N]; };`の役割は定数式で使用可能な遅延初期化用ストレージです。以前はこれが定数式で使用可能ではありませんでしたが、P3074R7にて定数式で使用可能になるようにいくつかの調整が加えられ、C++26で利用可能になっています。

P3074R7の変更はおおむね次のものです

- 共用体にトリビアルなデフォルトコンストラクタとトリビアルなデストラクタを暗黙的に定義させる
- 共用体の最初のメンバがimplicit-lifetime typeである場合、そのメンバの生存期間を暗黙的に開始する

しかし、その後寄せられたフィードバックによってこれだけでは目的を達成できないことが分かりました。

問題は、次のようなコードがP3074R7によって振る舞いが変わることです

```cpp
union U { int a, b; };

template<U u>
class X {};

constexpr U make() { U u; return u; }

void f(X<make()>) {}
```

P3074R7以前は、`X<make()>`のNTTPはアクティブメンバを持たない共用体オブジェクトだったのでNTTPとして有効でした。しかし、P3074R7の変更によってこの`u`は最初のメンバの生存期間暗黙的に開始されることによってアクティブメンバを持つため、NTTPとして使用できずコンパイルエラーとなります。

また、仮にコンパイルが通ったとすると、アクティブメンバを持つことからマングル名を変更する必要があるため、ABI破損を引き起こす可能性があります。

アクティブメンバを持つようになるとNTTPとして適格でなくなるのは少し複雑ですが、まず[expr.const]にある定数式の制限のうち、*prvalue*式の結果オブジェクトの構成要素の値（*constituent value*）についての制限があり、そこではスカラ型の構成要素の値は不定値もしくはerroneous valueを持っていてはならない、という規定があります。

そして、この構成要素の値の定義は次のようになっています

> The constituent values of an object `o` are
> 
>   - if `o` has scalar type, the value of `o`;
>   - otherwise, the constituent values of any direct subobjects of `o` other than inactive union members.

問題は2つ目の条件で、共用体型を含むクラス型の場合、構成要素の値とはそのサブオブジェクトの構成要素の値の集合の事を言っており、そこには共用体の非アクティブメンバは含まれません。

共用体先頭のimplicit-lifetime typeメンバの生存期間が開始されるとそのメンバがアクティブメンバになるものの、その値は初期化されていないため不定値を持つことになります。

これによって、スカラ型メンバのみで構成されている共用体がNTTP（というか定数式内*prvalue*）として使用される際の振る舞いが変化しています。

このため、P3074R7の目的はまた達成されていません

```cpp
constexpr std::inplace_vector<int, 4> v = {1, 2}; // ng
```

このコードは先ほどの`FixedVector`の実装と同じ実装になる場合、`union { int storage[4]; }`が使用されるものの、最初の2つの要素だけが初期化されて残りの要素は初期化されないことで不定値を持ち、コンパイルエラーになります。

ここでの問題は次の2点です

1. 共用体が定数式で意図しないタイミングでアクティブメンバを持ってしまうこと
2. 構成要素の値の制限

この提案はこれら2つの問題をそれぞれ解決しようとするものです。

1つ目の問題についてはP3074R7の変更をrevertし、トリビアルな共用体のimplicit-lifetime typeメンバの生存期間が自動開始されるポイントをplacement newまで遅延します。


```cpp
template <typename T, size_t N>
struct FixedVector {
  union { T storage[N]; };  // P3074R7はここで暗黙的にstorageの生存期間が開始されていた
  size_t size = 0;

  constexpr FixedVector() = default;

  constexpr ~FixedVector() {
    std::destroy(storage, storage + size);
  }

  constexpr auto push_back(T const& v) -> void {
    ::new (storage + size) T(v);  // この提案では、このアクセス時に暗黙的にstorageの生存期間を開始する
    ++size;
  }
};

constexpr auto silly_test() -> size_t {
 FixedVector<std::string, 3> v;
 v.push_back("some sufficiently longer string");
 return v.size;
}

static_assert(silly_test() == 1);
```

元々の問題の一部は、placement newの際に`storage`メンバにアクセスしたときにその生存期間が開始されていない事だったので、placement newアクセス時にそれが暗黙的に行われるようになることで元の問題を解決できます。そして、`union U { int a, b; };`の様な共用体は再びアクティブメンバを持たなくなります。

2つ目の問題については、構成要素の値の定義を変更して、共用体内配列の各要素の初期化状態について歯抜けを許容するようにします。これにより、共用体内配列のどこかの要素が初期化されていなくても、それは非アクティブメンバと同様に構成要素の値としてカウントされ無くなるため、配列そのものの生存期間が開始されている場合にも共用体の構成要素の値内に不定値が含まれなくなります。

これらの修正（特に2つ目）によって、先ほどの`inplace_vector`の例は定数式で動作するようになります。

```cpp
constexpr std::inplace_vector<int, 4> v = {1, 2}; // ok、この提案後
```

この提案はこの記事執筆時点（C++26の機能凍結後）でもまだ採択前ですが、トリビアルな共用体について多数のNBコメントが寄せられており、その解決のために遅れてC++26に採択される予定です。

- [P3074R7 trivial unions (was `std::uninitialized<T>`) - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3074R7-trivial-unions-was-stduninitialized)
- [P3726 進行状況](https://github.com/cplusplus/papers/issues/2356)

### [P3727R0 Update Annex E based on Unicode 15.1 UAX #31](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3727r0.pdf)

C++標準文書のAnnex E（UAX31への参照）の記述をUnicode 15.1に合わせて更新する提案。

背景等はP3717R0を参照

- [P3717R0 Update Annex E onto Unicode 16 - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3717R0-Update-Annex-E-onto-Unicode-16)

この提案では、P3717とは異なり、Unicode 16ではなくUnicode 15.1でのUAX31の形式に合わせて更新しようとしています。主な変更はP3717同様に「UAX31-R1a Restricted Format Characters」に関する記述を削除することで、こちらの提案は[CWG Issue 2843](https://cplusplus.github.io/CWG/issues/2843.html)の解決のみを（Unicode 15.1で）行うことを意図したものの様です。

SG16などでのレビューの結果、結局[CWG Issue 2843](https://cplusplus.github.io/CWG/issues/2843.html)の変更を採用することになったようです。

- [CWG Issue 2843. Undated reference to Unicode makes C++ a moving target](https://cplusplus.github.io/CWG/issues/2843.html)
- [P3727 進行状況](https://github.com/cplusplus/papers/issues/2357)

### [P3729R0 Aligning span and string_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3729r0.pdf)

`std::span`と`std::string_view`のインターフェース共通化を図る提案。

`std::span`と`std::string_view`はそれぞれ、配列/文字列のビューとなるクラスです。とはいえ、`std::string_view`が文字列に特化しているだけで、二つのクラスの実装はほぼ同じになり、その扱いや性質もかなり共通しています。

しかし、`std::span`と`std::string_view`は標準コンテナのインターフェースに準拠したインターフェースについては共通しているものの、それ以外の部分はそれほど共通のインターフェースにはなっていません。

この提案は、`std::span`と`std::string_view`からそれぞれにだけしかないインターフェースについて、特にサブセット化APIの共通化を行おうとするものです。

提案するインターフェースの追加は次のようになります

```cpp
template<typename charT, typename traits = char_traits<charT>> 
struct basic_string_view { 
  ...

  // runtime subsetting: 
  constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view subview(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view first(size_type count) const; // この提案
  constexpr basic_string_view last(size_type count) const;  // この提案
  
  // in place shrinking: 
  constexpr void remove_prefix(size_type n); 
  constexpr void remove_suffix(size_type n); 

  ...
};

template<typename T, size_type E = dynamic_extent> 
struct span { 
  ...

  // compile-time subsetting: 
  template<size_t Offset, size_t Count = dynamic_extent> 
  constexpr span<T, /*see below*/> subspan() const; 
  template<size_t Count> 
  constexpr span<T, Count> first() const; 
  template<size_t Count> 
  constexpr span<T, Count> last() const; 

  // runtime subsetting: 
  constexpr span subspan(size_type pos = 0, size_type n = dynamic_extent) const; 
  constexpr span first(size_type count) const; 
  constexpr span last(size_type count) const; 

  // in place shrinking: 
  constexpr void remove_prefix(size_type n) requires(E == dynamic_extent); // この提案
  constexpr void remove_suffix(size_type n) requires(E == dynamic_extent); // この提案

  ...
};
```

すなわち、`std::span` -> `std::string_view`には

- `.first(n)` : 先頭`n`文字の`string_view`を返す
- `.last(n)` : 後ろ`n`文字の`string_view`を返す

が移植され、`std::string_view` -> `std::span`には

- `.remove_prefix(n)` : 先頭`n`要素の`span`を返す
- `.remove_suffix(n)` : 後ろ`n`要素の`span`を返す

が移植されます。

さらに、`std::string_view`に関する変更は`std::string`に対しても適用されます

```cpp
template<typename charT, typename traits = char_traits<charT>, typename Allocator = allocator<charT>> 
struct basic_string { 
  ...

  //runtime subsetting: 
  constexpr basic_string substr(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view<charT, traits> subview(size_type pos = 0, size_type n = npos) const; 
  constexpr basic_string_view<charT, traits> first(size_type count) const; // この提案
  constexpr basic_string_view<charT, traits> last(size_type count) const;  // この提案
  
  ...
};
```

`std::string_view v`、`std::span<T> p`、`std::string s`があるとして

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// removing leading elements 
v.remove_prefix(5); 
p = p.subspan(5); 
s.erase(s.begin(), s.begin() + 5); 

// removing trailing elements 
v.remove_suffix(3); 
p = p.subspan(0, p.size() - 3); 
s.erase(s.end() - 3, s.end());
```

</td>
<td valign="top">

```cpp
// removing leading elements 
v.remove_prefix(5); 
p.remove_prefix(5); 
//s.remove_prefix(5); 提案しない

// removing trailing elements 
v.remove_suffix(3); 
p.remove_suffix(3); 
//s.remove_suffix(3); 提案しない
```

</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// getting leading elements 
auto l4v = v.subview(0, 4);
auto l4p = p.first(4);
auto l4s = s.subview(0, 4);

// getting trailing elements 
auto t2v = v.subview(v.size() - 2);
auto t2p = p.last(2);
auto t2s = s.subview(s.size() - 2);
```

</td>
<td valign="top">

```cpp
// getting leading elements 
auto l4v = v.first(4);
auto l4p = p.first(4);
auto l4s = s.first(4);

// getting trailing elements 
auto t2v = v.last(2);
auto t2p = p.last(2);
auto t2s = s.last(2);
```

</td>
</tr>
</table>

- [P3729 進行状況](https://github.com/cplusplus/papers/issues/2358)

### [P3730R0 Slides for P3104R3](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3730r0.html)

P3104R3の紹介スライド。

- [P3104R3 Bit permutations - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3104R3-Bit-permutations)

P3104R3で提案されている4つのビット操作関数の簡単な説明が行われています。

### [P3731R0 `#embed` Preprocessor Parameter Order](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3731r0.html)

`#embed`ディレクティブの引数指定について順番を指定するようにする提案。

`#embed`ディレクティブは読み込むバイナリリソースについて、読み込みの仕方などについてを指定する4つのオプションがあります。そのうち`limit`オプションは読み込むサイズを制限するものです。

```cpp
constexpr const unsigned char sound_signature[] = {
// a hypothetical resource
#embed <sdk/jump.wav> limit(2+2)
};
```

また、P3540で提案中のオプションとして`offset`があり、これは読み取るバイナリリソースの開始位置を指定するものです。

```cpp
constexpr const unsigned char truncated_sound_signature[] = {
// a hypothetical resource
#embed <sdk/jump.wav> offset(2) limit(2)
};
```

このオプションは排他的ではなく、同時に指定して効果を重複させることができます。その際、オプションの指定順には意味がなく、どのような順序で指定しても同じ動作をします。

しかし、（おそらくP3540の議論中に）このオプションの指定順序、特に`limit`と`offset`の順序が混乱をもたらす可能性があるとの指摘があったようです。その際寄せられた意見の中には、`limit`の後に`offset`を指定された場合にコンパイルエラーを出すべき、というものもあったようです。

この提案はそれを受けて、オプションの順番を規定するための文言を提供しようとするものです。ここでは、次の二種類の文言が用意されています

1. オプションの順番を規定し、違反をコンパイルエラーとする文言
2. オプションの順番を規定し、違反を警告とすることを推奨する文言

提案ではこの選択を委員会の決定に委ねています。

いずれの文言でも、ここで提案している順序付けは次のようなものです

- `offset`は`limit`の前
- `limit`は`if_empty, prefix, suffix`の前
- `limit`がない場合でも、`offset`は`if_empty, prefix, suffix`の前

`#embed`はC23で先んじて採択されているため、clang/gccの新しいものであれば実装済みです。さらにそこでは、実装定義のオプションとして`offset`オプション（`gnu::offset`/`clang::offset`）が実装されていますが、現在の`#embed`が意図するようにオプションの指定順によらず正しく動作しています。

- [P3540R1 #embed Parameter offset - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3540R1-embed-Parameter-offset)
- [#embedディレクティブ - yohhoyの日記](https://yohhoy.hatenadiary.jp/entry/20220915/p1)
- [P3731 進行状況](https://github.com/cplusplus/papers/issues/2360)

### [P3732R0 Numeric Range Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3732r0.html)

`<numeric>`ヘッダにある数値アルゴリズムのRange版を追加する提案。

C++20でアルゴリズムのRange対応がなされ、C++26では並行アルゴリズムのRange対応がなされています。しかし、そのどちらにおいても意図的に数値アルゴリズムは除外されています。これは数値アルゴリズムは通常のアルゴリズムとは少し異なる要件を持っていることから、まとめて扱えない（あるいは扱うべきではない）と判断されているためだと思われます。

C++26で通常のアルゴリズムが並行アルゴリズムまで含めて（ほぼすべて）Range対応したことで、その設計を踏襲する形で数値アルゴリズムのRange対応（並行版も含めて）を行おうとするのがこの提案のようです。

ただし、全ての数値アルゴリズムに対してRange版を追加することは提案しておらず、ここでは次のものだけを提案しています

- `std::reduce`
- `std::transform_reduce`
    - 単項/二項両方
- `std::inclusive_scan`
- `std::exclusive_scan`
- `std::transform_inclusive_scan`
- `std::transform_exclusive_scan`

これ以外のものはRangeアダプタ等既存のもので代替できるか、設計について特別な議論が必要となるためここでは除外しています。

そして、提案されているこれらのRange版アルゴリズムは、`<algorithm>`にあるものとは異なり射影をサポートしません。これは、`reduce, inclusive_scan, exclusive_scan`で射影を指定することは、それらに対応する（射影なし）`transform`版を使用することと同等になるためです。

```cpp
struct foo {};

std::vector<std::tuple<int, foo, std::string>> v1 = 
{
  {5, {}, "five"}, {7, {}, "seven"}, {11, {}, "eleven"}
};

constexpr int init = 3;

// reduce with projection get_element<0>
auto result_proj =
  std::ranges::reduce(v1, init, std::plus{}, get_element<0>{});
assert(result_proj == 26);

// transform_reduce with unary transform get_element<0>
auto result_xform =
  std::ranges::transform_reduce(v1, init, std::plus{}, get_element<0>{});
assert(result_xform == 26);

// reduce with transform_view (no projection)
auto result_xv = std::ranges::reduce(
  std::views::transform(v1, get_element<0>{}), init, std::plus{});
assert(result_xv == 26);
```

※ここでの`get_element`はP2769R3で提案されているもので、まだ正式機能ではありません。tuple-likeあるいは構造体から指定したインデックス番目の要素を抽出するものです。

Rangeアルゴリズムにおける射影の提供する一番のメリットは、要素の引き当てと変換という2つの操作を分離して指定することで可読性を向上させ、なおかつ最適化機会を提供することにあります。数値アルゴリズムの場合、そのインターフェースのために射影を用意せずとも同等の事を達成できます。

また、既存の`fold`アルゴリズム（`ranges::reduce`に最も近い動作をする）はすべて射影を取らないこともこの根拠としています。

`transform_reduce`に射影を追加しないのは、`transform_reduce`のための演算の指定と射影の指定の順序が曖昧になるためです。

```cpp
struct bar {
  std::string s;
  int i;
};

std::vector<std::tuple<int, std::string, bar>> v = 
{
  { 5,   "five", {"x", 13}},
  { 7,  "seven", {"y", 17}},
  {11, "eleven", {"z", 19}}
};

constexpr int init = 3;

// 射影されてから（get_element<2>で`bar`を取り出してから）、単項演算（get_element<1>）が適用される
// first get bar, then get bar::i
auto result_proj = std::ranges::transform_reduce(
  v, init, std::plus{}, get_element<1>{}, get_element<2>{});  // 適用の順序が逆に見える
assert(result_proj == 52);

// first get bar, then get bar::i
auto getter = [] (auto t) {
  return get_element<1>{}(get_element<2>{}(t)); // imagine that get_element works for structs
};
auto result_no_proj = std::ranges::transform_reduce(
  v, init, std::plus{}, getter);
assert(result_no_proj == 52);
```

二項の`transform_reduce`は`views::zip_transform`を用いて`ranges::reduce`によって同等の事を達成することができますが、可読性を損なうことや`zip_transform_view`という別のレイヤが介在することによる最適化機会の損失などの理由により二項の`transform_reduce`もRange対応させることを提案しています。

この時、二項の`ranges::transform_reduce`だけは射影があったほうがパフォーマンス上のメリットがある場合があります（要素の一部の抽出をしながら`transform_reduce`する際に、`views::transform`が必要になる）が、インターフェースの一貫性と可読性を優先させ、これに対しても射影サポートは追加していません。

これら一連の議論では`(transform_)reduce`で代表して説明しましたが、`inclusive_scan, exclusive_scan`でも同様の事が言えます。

さらに、利便性のための`ranges::reduce`のラッパアルゴリズムを提供することも提案しています。

- `ranges::sum(rng)`: `ranges::reduce(rng, range_value_t<R>(), plus{})`
    - 要素型をデフォルト構築したものを初期値として、`rng`の総和を求める
    - 演算の順序が不定な`std::accumulate`のデフォルト動作に対応
- `ranges::product(rng)`: `ranges::reduce(rng, range_value_t<R>(1), multiplies{})`
    - 要素型をデフォルト構築したものを初期値として、`rng`の総乗を求める
- `ranges::dot(x, y)`: `ranges::transform_reduce(x, y, T(), plus{}, multiplies{})`
    - `T = decltype(declval<range_value_t<X>>() * declval<range_value_t<Y>>())`
    - 2つの範囲のドット積を求める

要素型の決定などの細部はもう少し複雑になります。これらは`ranges::reduce`にデフォルト引数を一切持たせないようにすることを選択したことによって生まれるラッパです。

ラッパも含めたすべてのアルゴリズムは対応する並行アルゴリズムもRange版が用意されます。

これらのアルゴリズムの入力と出力の型は次のように決定されています

- 並行アルゴリズムは、`sized_range`かつ`random_access_range`を入力とする
- 非並行アルゴリズムは、`sized_range`かつ`forward_range`を入力とする
- `inclusive_scan, exclusive_scan`の戻り値型は`in_out_result`のエイリアス
    - 出力の最後の要素の一つ後ろへのイテレータと、入力の最後の要素の一つ後ろへのイテレータ、を返す
- `reduce`系操作では、計算結果の値のみを直接返す
    - `in_value_result`のような型でイテレータを返さない
- 出力引数（範囲への出力）は出力イテレータではなく出力範囲を取る
    - イテレータ出力オーバーロードは提案していない

特に、この提案は非並行アルゴリズムで範囲出力にイテレータではなく`output_range`を取る初めてのものとなります（`inclusive_scan, exclusive_scan`）。

この提案の設計は多くの部分で既存の類似物の設計を踏襲しています。例えば

- `ranges::fold_left`,`ranges::fold_right`と同じ制約によって二項演算を制約し、戻り値型を導出する
- C++17とlinalgを模倣して、`GENERALIZED_NONCOMMUTATIVE_SUM`と`GENERALIZED_SUM`を用いて`reduce`と`*_scan`の動作を指定する
- それ以外のところでは、P3179R8（並行Rangeアルゴリズム提案）のアプローチに従う
- P2248R8（Rangeアルゴリズムにおいて値の指定に`{}`初期化を使用できるようにする）の内容を適用

などです。

- [P3732 進行状況](https://github.com/cplusplus/papers/issues/2361)

### [P3733R0 More named universal character escapes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3733r0.html)

名前付きユニバーサル文字名のエイリアス名について、C++で使用可能ではないものを使用できるようにする提案。

C++23では文字/文字列リテラルにおけるエスケープ文字の一種として`\N{NO-BREAK SPACE}`のようにユニコード文字の名前を指定する形のユニバーサル文字名が使用可能になっています。この名前はユニコード標準で規定されているもので、一部の文字に対してはエイリアスとして複数の名前が対応する場合があります。

```cpp
static_assert(u8'\N{LINE FEED}' == u8'\N{NEW LINE}'); // ✅
```

このエイリアスもユニコード標準で規定されているもので、エイリアスにはいくつかの種類があります

- correction Aliases : 誤った文字名が割り当てられてしまった場合の代替表記
- control Aliases : 制御文字のエイリアス
- alternate Aliases : 広く使用されている代替名のエイリアス
- figment Aliases : 文書化されたものの標準では採用されなかったエイリアス
    - 現在次の3つのみ
    - U+0080 PADDING CHARACTER
    - U+0081 HIGH OCTET PRESET
    - U+0099 SINGLE GRAPHIC CHARACTER INTRODUCER
- abbreviation Aliases : 一般的な略語によるエイリアス

ユニコード標準の意図として、一度公開した名前はたとえそれが間違っているものだったとしても変更せず、代わりのエイリアスを提供することによって修正するという方針があります（すなわち、安定性を強く保証している）。correctionエイリアスはそのためにあるものです。

これらのうち、C++標準ではfigmentとabbreviationのエイリアスが除外されており、使用できません。この提案は、これらのエイリアスを使用可能にすることを提案しています。

なぜこのようになっているかというと、P2071R2（ユニコード文字名エスケープの提案）の議論と採択の当時のC++が参照していたユニコード標準が古かったため（正確には参照先が異なったため）、これらのエイリアスが含まれていなかったからの様です。

しかしその後P2736R2の採択によって参照先が更新されたためこのような制限は無くなっており、C++標準の文書の変更のみでこれらのエイリアスに対応することができます。

この提案で使用可能になるエイリアスの例

```cpp
using namespace std::literals;

// U+007F
static_assert(u8'\N{DELETE}' == u8'\N{DEL}'); // `DEL`はabbreviationエイリアス

// U+0081
static_assert(u8"\u{0081}"sv == u8"\N{HIGH OCTET PRESET}"sv); // `HIGH OCTET PRESET`はfigmentエイリアス
```

- [C++23 名前付きユニバーサルキャラクタ名 [P2071R2] - cpprefjp](https://cpprefjp.github.io/lang/cpp23/named_universal_character_escapes.html)
- [Unicode alias names and abbreviations - Wikipedia](https://en.wikipedia.org/wiki/Unicode_alias_names_and_abbreviations)
- [P2736R2 Referencing the Unicode Standard - WG21月次提案文書を眺める（2023年02月）](https://onihusube.hatenablog.com/entry/2023/03/19/184146#P2736R2-Referencing-the-Unicode-Standard)
- [P3733 進行状況](https://github.com/cplusplus/papers/issues/2362)

### [P3734R0 Not all predicates must be regular](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3734r0.html)

述語を使用するアルゴリズムに対する、その述語が要素を変更しないという要件を緩和する提案。

`std::find_if`など（その`range`版も含めて）述語を受け取るアルゴリズムにおいて述語は`regular_invocable`によって制約されており（`indirect_unary_predicate` -> `predicate`を通して）、それによって述語の呼び出しを通じた範囲要素の変更やその他副作用が禁止されています。

しかし、範囲のイテレーションを一回で済ませることを意図してこれらのアルゴリズムの述語において要素を変更したい場合があり、特に要素を一回しか参照しないアルゴリズムではそれを行ったとしても動作には影響がないはずです。

`ranges::remove_if`による例

```cpp
bool allowed_in_id(char c) {
  return c >= 'a' && c <= 'z';
}

void sanitize_id(std::string& id) {
  auto removed_range = std::ranges::remove_if(id, [](char& c) {
    if (c == ' ') {
      c = '-';  // 👈 ここで要素を変更している
      return false;
    }
    return not allowed_in_id(c);
  });

  id.erase(removed_range.begin(), removed_range.end());
}
```

このコードは`"abc //def"`の様な文字列入力を`"abc-def"`のように変換するものです。これは`[a-z]`とスペース以外の文字を`remove_if`した後でスペースを`-`に置き換えるような2回のアルゴリズムを伴うコードよりも効率的なものです。しかし、前述のように`remove_if`（`ranges`版でなくても）はその述語が要素を変更することを許可しておらず、違反すると未定義動作となるためこのコードは合法ではありません。

しかし一方で、`remove_if`はその動作に当たって要素を一回しか参照しないため、その一回の参照時にその要素を変更したとしてもその動作がおかしくなることはありません。上記の例はそのことを仮定しており、標準ライブラリの複雑な要件を良く知らない一般ユーザーにとっては自然な推論となるはずです。

この提案は、述語を受け取るアルゴリズムのうち要素を一度しか参照しないなどの事から要素を変更しても問題ないものについては、述語に対する`regular_invocable`の要件を緩和することを提案するものです。

ここでの対象は次のものです

- `all_of`
- `any_of`
- `none_of`
- `find`系
- `find_last`系
- `count`系
- `mismatch`
- `equal`
- `starts_with`
- `copy_if`
- `replace`系
- `remove`系
- `is_partitioned`/`partition`

`regular_invocable`の制約は意味論的なものであり、この提案が採択されても実装を何か変更する必要はないはずです（制約を除いて）。

このような変更に対する懸念の一つはこれら範囲を変更しないアルゴリズムの冪等性が失われるというものだと思われますが、実際には現状でもその保証は無く、未定義動作の上に成り立っている淡い期待のみであり、実装によって何か静的・動的にチェックされているものではありません。範囲を変更する述語を渡さない限り現在の推論が失われるものでもないため、現状より悪くなるものではないとしています。

- [P3734 進行状況](https://github.com/cplusplus/papers/issues/2363)

### [P3735R0 `partial_sort_n`, `nth_element_n`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3735r0.html)

中間イテレータを指定する必要があるアルゴリズムについて、その必要のないバージョンを追加する提案。

`partial_sort`アルゴリズムは、範囲の`N`要素分の部分ソートを行うアルゴリズムであり、実行後の範囲は先頭`N`個がソートされた状態になります。この時、この`N`は数値で指定するのではなく、イテレータで指定する必要があります。

```cpp
#include <ranges>
#include <algorithm>
#include <vector>
#include <print>

int main() {
  constexpr int N = 5;
  std::vector vec = {5, 3, 10, 4, 1, 11, 0, 9};

  std::println("before: {}", vec);

  std::ranges::partial_sort(vec, vec.begin() + N);

  std::println("after: {}", vec);
}
```
```
before: [5, 3, 10, 4, 1, 11, 0, 9]
after: [0, 1, 3, 4, 5, 11, 10, 9]
```

`partial_sort`で部分ソートしたい要素数`N`をイテレータで指定する際は、`begin() + N`のようなイテレータの進め方がなされることが多々あります。これは当然、`N`が範囲の長さを超えていれば未定義動作となります。筆者の方の経験によれば、このように未定義動作に陥っているコードを何度も見てきたとのことです。

安全に書く方法としては`std::ranges::next()`を使用する方法があります

```cpp
std::ranges::partial_sort(vec, std::ranges::next(vec.begin(), N, vec.end()));
```

しかしこれはあまりにも冗長で、バグの本質的原因を解決するものでもありません。このバグは、アルゴリズムがユーザーにイテレータの加算を強いていることが原因です。そのため、`N`を直接アルゴリズムに指定できれば解決されるはずです。

```cpp
std::ranges::partial_sort(vec, N);
```

この提案は、`partial_sort`の様に中間イテレータをとるアルゴリズムについてこのように処理数`N`を直接指定できるようにする`~_n`バージョンを追加しようとするものです。ここで提案しているのは次の2種類のアルゴリズムです

- `partial_sort_n` : `partial_sort`
- `nth_element_n` : `nth_element`

他のアルゴリズムはランダムアクセスイテレータを使用していないなどの問題からここでは対象にしていません。また、変更は`range`版だけでなく旧来の非`range`アルゴリズムに対しても行うことを提案しています。

SG9のレビューではこの提案の方向性が好まれたようで、おおむね受け入れられてLEWGに転送されています。ただし、命名については`_n`ではなく`_at_most`が好まれたようです。

- [`std::partial_sort` - cpprefjp](https://cpprefjp.github.io/reference/algorithm/partial_sort.html)
- [P3735 進行状況](https://github.com/cplusplus/papers/issues/2364)

### [P3736R0 Slides against P2971R3 - No implication for C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3736r0.html)

P2971に反対することを説明するスライド。

P2971については以前の記事を参照

- [P2971R3 Implication for C++ - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2971R3-Implication-for-C)

P2971で提案されている`=>`演算子に反対するいくつかの理由が説明されています。

### [P3737R0 `std::array` is a wrapper for an array!](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3737r0.html)

`std::array`の実装自由度を制限する提案。

`std::array`の実装については標準はあまり多くを語っていないものの生配列をラップした集成体型によるものと理解されており、現在の標準ライブラリ実装はそのようになっています。その実装方法についてはほぼ他の選択肢が無いのですが、より細かい実装については指定していない部分も多く、例えば次のような実装が準拠実装となります

```cpp
struct alignas(1024) malice_and_evil {
  constexpr malice_and_evil() { }
  malice_and_evil(const malice_and_evil&) { }
};

template <typename T, size_t N>
struct array {
  T __array[N];
  malice_and_evil evil;
};
```

このように実装された`std::array`はコピーが定数式にならず、要素型に関わらずトリビアルコピー可能ではなく、サイズとアライメントは`T[N]`よりも大きくなります。

この提案は、`std::array`の実装自由度を制限することでこのようなおかしな準拠実装を排除し、`std::array`が生配列の単純なラッパとなるようにしようとするものです。また、`std::array<T, 0>`の実装についてを細かく規定するようにしています。要素数がゼロの`std::array`については実装もそれぞれ微妙に異なっているようで、この提案では`std::array<T, 0>`が満たすべき実装の制約についてを追加しています。

- `T`がトリビアルコピー可能・標準レイアウト・構造的な型、のいずれか（もしくはすべて）であるなら、`std::array`もそうなる
- `std::array`は基底クラスを持たず、単一の公開非`static`メンバとして`N`要素の生配列を持つ
- `std::array<T, 0>`
    - 配列メンバ変数を持たない
      - 代わりに、未規定のトリビアルコピー可能で標準レイアウトな空の集成体型`U`の非`static`メンバ変数を持つ
      - `U`のサイズとアライメントは`1 ~ sizeof(T)`の間で実装定義
    - 値表現は空
    - イテレータ取得関数はすべて値初期化された結果を返す
    - `fill()/swap()`は関数本体が空で例外を送出しない
    - `[], front(), back()`の末尾に実行が到達すると`std::terminate`

などの制限を加えることを提案しています。

- [P3737 進行状況](https://github.com/cplusplus/papers/issues/2366)

### [P3738R0 Make `std::make_from_tuple` SFINAE friendly](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3738r0.pdf)

`std::make_from_tuple`をSFINAE friendlyにする提案。

[LWG Issue 3528](https://cplusplus.github.io/LWG/issue3528)の採択によって、`std::make_from_tuple()`の説明専用関数である`make-from-tuple-impl()`に対して`requires`節による制約が追加されました。

```cpp
template<class T, class Tuple, size_t... I>
  requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...> // 👈 これが追加
constexpr T make-from-tuple-impl(Tuple&& t, index_sequence<I...>) {
  return T(get<I>(std::forward<Tuple>(t))...);
}
```

しかし、これによって`std::make_from_tuple()`が呼び出し可能かどうかをSFINAEによって調べるコードがハードエラーを起こすようになる場合があります。

```cpp
template <typename T, typename Tuple, typename = void>
inline constexpr bool has_make_from_tuple = false;

template <typename T, typename Tuple>
inline constexpr bool has_make_from_tuple<
  T, Tuple,
  std::void_t<decltype(std::make_from_tuple<T>(std::declval<Tuple>()))>> = true;

struct A {
  int a;
};

// make_from_tuple()呼び出しにおいて集成体初期化は考慮されない
static_assert(!has_make_from_tuple<int*, std::tuple<A*>>);  // ng、`static_assert`ではない理由によってエラーになる
```

これは、`std::make_from_tuple()`の実装が内部で`make-from-tuple-impl()`と同等の関数を呼び出すようにしている場合、追加された制約を満たさない場合に`std::make_from_tuple()`関数定義内でエラーになることでハードエラーになってしまっています。

```cpp
template<class T, class Tuple, size_t... I>
  requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...> // A
constexpr T make-from-tuple-impl(Tuple&& t, index_sequence<I...>) {
  return T(get<I>(std::forward<Tuple>(t))...);
}

template<class T, class Tuple, size_t... I>
constexpr T make_from_tuple(Tuple&& t, index_sequence<I...>) {
  return make-from-tuple-impl(std::forward<Tuple>(t));  // Aの制約が満たされない場合、ここでエラーになってしまう
}
```

この提案は、この`make-from-tuple-impl()`に追加された制約を`std::make_from_tuple()`の宣言に移すことで、制約が満たされない場合に`std::make_from_tuple()`の宣言で置換可能なエラーになるようにしようとするものです。

- [LWG Issue 3528. make_from_tuple can perform (the equivalent of) a C-style cast](https://cplusplus.github.io/LWG/issue3528)
- [P3738 進行状況](https://github.com/cplusplus/papers/issues/2367)

### [P3739R0 Standard Library Hardening - using `std::optional`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r0.html)

↓

### [P3739R1 Standard Library Hardening - using `std::optional`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r1.html)

`std::inplace_vector`において、`std::optional<T&>`を利用して堅牢化モードを導入する提案。

この提案では、`std::inplace_vector`特有のメンバ関数で現在ポインタを返しているものについて`std::optional<T&>`を代わりに返すようにすることで、`std::optional<T&>`のモナド/`range`インターフェースを利用できるようになるとともに、一部の安全ではないアクセスも堅牢化モードによるnullチェックされることにより安全性を高めようとするものです。

提案しているのは、コンテナの末尾要素を追加を試行する`try_~`系の3つの関数です

```cpp
namespace std {
  template<class T, size_t N>
  class inplace_vector {
  
    ...

    // 現在の宣言
    template<class... Args>
    constexpr pointer try_emplace_back(Args&&... args);

    constexpr pointer try_push_back(const T& x);
    
    constexpr pointer try_push_back(T&& x);

    // この提案
    template<class... Args>
    constexpr optional<T&> try_emplace_back(Args&&... args);

    constexpr optional<T&> try_push_back(const T& x);
    
    constexpr optional<T&> try_push_back(T&& x);

  };
}
```

これらの関数は`inplace_vector`の末尾に要素を追加を試みて、そのキャパシティ余裕が無い場合に`nullptr`を返すものです。この提案ではポインタの代わりに`optional<T&>`を使用することでこのインターフェースをより安全にしようとしています。

```cpp
int main() {
  std::inplace_vector<int, 5> vec = {1, 2, 3, 4, 5};

  // 現在
  if (auto ptr = vec.try_push_back(6); ptr != nullptr) {
    // 成功した時の処理
  }

  // この提案
  vec.try_push_back(7).and_then([](int& n) {
    // 成功した時の処理
  });
}
```

- [P3739 進行状況](https://github.com/cplusplus/papers/issues/2368)

### [P3740R0 Last chance to fix `std::nontype`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3740r0.html)

↓

### [P3740R1 Last chance to fix `std::nontype`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3740r1.html)

`std::nontype`の使用を再考する提案。

`std::nontype`は`std::function_ref`のメンバ関数ポインタ対応を行うために追加されたユーティリティで、メンバ関数ポインタをNTTPとして持っておくことで本来関数ポインタを保存するためのストレージを対応する`this`を保存するために使用できるようにするものです。

```cpp
void f(std::fuction_ref<int(int)> func);

struct S {
  int m(int) {
    ...
  }
};

int main() {
  S s{};

  f({std::nontype<&S::m>, s});  // ok、function_refでメンバ関数ポインタと対応するthisを束縛する
}
```

`std::nontype`がない場合、別途ファクトリ関数と専用コンストラクタを用意して対応する必要があるなど、`std::nontype`と比較すると複雑なアプローチをとる必要がありました。

しかし、C++26の他の機能の導入などの結果として、この`std::nontype`にはいくつかの問題が生じています。

- `std::constant_wrapper`と機能が重複する（P2781
- non-type template parameterという言葉はconstant template parameterに変更された（P2841

どちらも最終的にはC++26に導入されています（この提案の提出時点ではP2781はまだ入っていませんでした）。そのため、`std::nontype`の名前を変更するのか、`std::constant_wrapper`で置き換えるのか、あるいはこのままいくのか、を決めなければなりません。

ここでは`std::nontype`の必要性などから初めて様々な選択肢を検討した結果

- `std::nontype`を`std::constant_wrapper`で置き換える
- `std::nontype`をリネームする

のどちらかが良いとして、両方に対応する文言変更を提案しています。

- [P2511R0 Beyond operator(): NTTP callables in type-erased call wrappers - WG21月次提案文書を眺める（2022年01月）](https://onihusube.hatenablog.com/entry/2022/02/19/181101#P2511R0-Beyond-operator-NTTP-callables-in-type-erased-call-wrappers)
- [P2472R1 make function_ref more functional - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P2472R1-make-function_ref-more-functional)
- [P3740 進行状況](https://github.com/cplusplus/papers/issues/2369)

### [P3741R0 views::set_operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3741r0.html)

集合演算を行うRangeアダプタの提案。

ソート済み範囲を集合と見立てて差集合や共通部分などの集合演算を行う操作は、アルゴリズムとしては存在しています。しかし、アルゴリズムの場合は出力の範囲を別に用意する必要があります。

一方、Rangeアダプタとしてこれを実行できれば、遅延評価されることによって出力用の範囲は必要なくなり、オンザフライで集合演算を実行できます。

```cpp
// アルゴリズムによる集合演算
std::vector<int> diff;
ranges::set_difference(v1, v2, std::back_inserter(diff));

// Rangeアダプタによる集合演算
auto diff = v1 | views::set_difference(v2);
```

この提案は、既存の集合演算アルゴリズムに対応する集合演算を行うRangeアダプタを提案するものです。ここでは、`std::include`を除いた4つの集合演算

- `std::set_union`
- `std::set_intersection`
- `std::set_difference`
- `std::set_symmetric_difference`

に対応するRangeアダプタ

- `views::set_union`
- `views::set_intersection`
- `views::set_difference`
- `views::set_symmetric_difference`

を提案しています。

これらのRangeアダプタはそれぞれ専用の`view`型を持ちますが、それぞれの集合演算の性質を踏まえて制約等は大きく2つのタイプに分かれます

```cpp
// set_intersectionとset_differenceのview型の制約
template<view V1, view V2>
  requires input_range<V1> && input_range<V2> &&
           indirect_strict_weak_order<ranges::less, iterator_t<V1>, iterator_t<V2>>
class set_[intersection|difference]_view;
```
```cpp
// set_unionとset_symmetric_differenceのview型の制約
template<view V1, view V2>
  requires input_range<V1> && input_range<V2> &&
           indirect_strict_weak_order<ranges::less, iterator_t<V1>, iterator_t<V2>> &&
           concatable<V1, V2>
class set_[union|symmetric_difference]_view;
```

前者は片方の範囲（`V1`）の要素型を結果とすればよいのに対して、後者は両方の範囲の要素型を結果とする必要があるため、`concatable<V1, V2>`の違いがあります。

どのアダプタも範囲`v1, v2`に対して`v1 | views::set_xxx(v2)`の様にパイプライン記法で記述できるようにしています。

4つのアダプタ（`view`）いずれの場合でもそのイテレータによって演算が行われます。まずイテレータが構築されると`satisfy()`関数（その集合演算に対応した要素判定関数）によって最初の出力要素が特定され、その後は`++`でイテレータが進むごとに次の集合要素を特定していきます。動作としては`views::filter`に近いです。

この`satisfy()`関数では2つの入力範囲の両方を順番に進めていく必要があるため、イテレータは2つの入力範囲のイテレータと番兵を共に保持している必要があります。

```cpp
// set_intersectionのviewのイテレータの実装イメージ
class set_intersection_view::iterator {
  iterator_t<V1> current1_;
  sentinel_t<V1> end1_;
  iterator_t<V2> current2_;
  sentinel_t<V2> end2_;

  constexpr void satisfy() {
    while (current1_ != end1_ && current2_ != end2_) {
      // V1の中から次の有効な要素を探す処理
      ...
    }
  }

  constexpr iterator(iterator_t<V1> current1, sentinel_t<V1> end1,
                     iterator_t<V2> current2, sentinel_t<V2> end2)
    : current1_(std::move(current1)), end1_(end1),
      current2_(std::move(current2)), end2_(end2) {
    satisfy();
  } 

public:
  constexpr decltype(auto) operator*() const { return *current1_; }

  constexpr iterator&
  operator++() {
    ++current1_;
    ++current2_;
    satisfy();
    return *this;
  }

  friend constexpr bool operator==(const iterator& x, default_sentinel_t) {
    return x.current1_ == x.end1_ || x.current2_ == x.end2_;
  }
};
```

基本的にはこのようなイテレータ実装の細部を少しづつ調整することで4つの`view`を実装することができます。`set_union`/`set_symmetric_difference`の場合は両方のイテレータから値を読み取る必要があるため、ある時点でどちらのイテレータを使用するべきかを表すフラグが一つ必要になります。

その他の性質は次のようになっています

- `range`カテゴリ: もっとも強くても`forward_range`
- `common_range`: ×
- `borrowed_range`: `V1`と`V2`がともに`borrowed_range`なら
- `const-iterable`
    - `set_union`: 〇
    - それ以外: ×
        - `begin()`のキャッシュの必要がある

サンプルコード

```cpp
int main() {
  const auto v1 = std::views::iota(1, 6);
  const std::vector v2 = {1, 3, 5, 7};

  auto uni = v1 | views::set_union(v2);
  // [1, 2, 3, 4, 5, 7]
  
  auto intersection = v1 | views::set_intersection(v2);
  // [1, 5]
  
  auto difference = v1 | views::set_difference(v2);
  // [2, 4]
  
  auto symmetric_difference = v1 | views::set_symmetric_difference(v2);
  // [2, 4, 7]
}
```

- [P3741 進行状況](https://github.com/cplusplus/papers/issues/2370)

### [P3742R0 C++ Standard Library Ready Issues to be moved in Sofia, Jun. 2025](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3742r0.html)

6月に行われたSofia会議でWDに適用されたライブラリに対するIssue報告の一覧

- [4198. schedule_from isn't starting the schedule sender if decay-copying results throws](https://cplusplus.github.io/LWG/issue4198)
- [4202. enable-sender should be a variable template](https://cplusplus.github.io/LWG/issue4202)
- [4203. Constraints on get-state functions are incorrect](https://cplusplus.github.io/LWG/issue4203)
- [4204. specification of as-sndr2(Sig) in [exec.let] is incomplete](https://cplusplus.github.io/LWG/issue4204)
- [4205. let_[*].transform_env is specified in terms of the let_* sender itself instead of its child](https://cplusplus.github.io/LWG/issue4205)
- [4208. Wording needs to ensure that in connect(sndr, rcvr) that rcvr expression is only evaluated once](https://cplusplus.github.io/LWG/issue4208)
- [4209. default_domain::transform_env should be returning FWD-ENV(env)](https://cplusplus.github.io/LWG/issue4209)
- [4188. ostream::sentry destructor should handle exceptions](https://cplusplus.github.io/LWG/issue4188)
- [4200. The operation_state concept can be simplified](https://cplusplus.github.io/LWG/issue4200)
- [4201. with-await-transform::await_transform should not use a deduced return type](https://cplusplus.github.io/LWG/issue4201)
- [4217. Clarify mdspan layout mapping requirements for rank == 0](https://cplusplus.github.io/LWG/issue4217)
- [4222. expected constructor from a single value missing a constraint](https://cplusplus.github.io/LWG/issue4222)
- [4224. Philox engines should be freestanding](https://cplusplus.github.io/LWG/issue4224)
- [4227. Missing noexcept operator in [exec.when.all]](https://cplusplus.github.io/LWG/issue4227)
- [4231. datapar::chunk<N> should use simd-size-type instead of size_t](https://cplusplus.github.io/LWG/issue4231)
- [4232. datapar::resize does not resize](https://cplusplus.github.io/LWG/issue4232)
- [4233. The helper lambda of std::erase for hive should specify return type as](https://cplusplus.github.io/LWG/issue4233)
- [4234. Including <hive> doesn't provide std::begin/end](https://cplusplus.github.io/LWG/issue4234)
- [4235. cache_latest_view and to_input_view miss reserve_hint](https://cplusplus.github.io/LWG/issue4235)
- [4236. chunk_view::outer-iterator::value_type should provide reserve_hint](https://cplusplus.github.io/LWG/issue4236)
- [4239. flat_map's transparent comparator no longer works for string literals](https://cplusplus.github.io/LWG/issue4239)
- [4242. ranges::distance does not work with volatile iterators](https://cplusplus.github.io/LWG/issue4242)
- [4245. Operators that interact with counted_iterator and default_sentinel_t should be noexcept](https://cplusplus.github.io/LWG/issue4245)
- [4247. Header <stdbit.h> is not yet freestanding](https://cplusplus.github.io/LWG/issue4247)

### [P3745R0 Rebuttal to P1144R13](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3745r0.pdf)

P1144R13に対して反論を行うスライド。

P1144R13については以前の記事を参照

- [P1144R13 `std::is_trivially_relocatable`](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P1144R13-stdis_trivially_relocatable)

P1144R13はP2786R13に対して反対を表明するものですが、これはさらにP1144R13の主張に反論するものです。

スライドでは、関連する提案の提出タイミング等についての説明を行った後、P1144R13の主張（の一部）に対して一つ一つ反論を行っています。

### [P3746R0 LEWG Slides for P3637R0 Inherit `std::meta::exception` from `std::exception`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3746r0.pdf)

P3637R0の紹介スライド。

- [P3637R0 Inherit `std::meta::exception` from `std::exception` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3637R0-Inherit-stdmetaexception-from-stdexception)

`std::meta::exception`が`std::exception`を継承しないことの原因が現在問題ではないことを説明し、そうすることの利点などを簡単に説明しています。

### [P3747R0 Call side return type deduction](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3747r0.pdf)

式の戻り値の型を取得する構文の提案。

`std::numeric_limits`や`std::numbers`などの利用時には、数値型を指定して値を取得する必要があります。

```cpp
double i = std::numeric_limits<double>::max();

float pi = std::numbers::pi_v<float>;
```

このような場合、初期化先の型とテンプレートパラメータの型が一致しており、冗長に指定しなければなりません。この時に、この初期化先の型を初期化している式で取得できると冗長な型の指定を省略することができます。

```cpp
double i = std::numeric_limits<deduce>::max();  // deduceはdoubleが取得される

float pi = std::numbers::pi_v<deduce>;  // deduceはfloatが取得される
```

この提案は、このように初期化式の初期化先の型を取得することのできる言語機能を提案するものです。この提案ではこれを仮に`deduce`としています。

上記のような変数初期化であれば、変数の宣言の方を`auto`にしておけば型を2回指定する必要は無くなりますが、`auto`を使用できない所では2回指定しなければなりません。

```cpp
// メンバ変数定義での利用の例
struct S {
  // これはできない
  auto i = std::numeric_limits<int>::max();

  // この提案
  int i = std::numeric_limits<deduce>::max();
};
```
```cpp
// これは関数テンプレートになってしまう
void func(auto i = std::numeric_limits<int>::max());

// この提案
void func(int i = std::numeric_limits<deduce>::max());
```
```cpp
// Double/Float を double/float の強エイリアスとする
Double func(Double);

Float f = 1;

func(f); // ng、変換できない
func(static_cast<deduce>(f)); // 自動キャスト
```

このような初期化先の型の取得は、テンプレート型変換演算子において現在でも限定的に利用することができます。しかし、`std::numbers`などの既存のものを今からテンプレート型変換演算子を備えた型に変更することは後方互換性を保てない（ABI破壊になる）ために不可能です。このソリューションであれば、他の部分にほとんど影響を与えることなく導入できます。

- [P3747 進行状況](https://github.com/cplusplus/papers/issues/2345)

### [P3748R0 Inspecting exception_ptr works should be constexpr.](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3748r0.html)

`std::exception_ptr_cast()`を`constexpr`指定する提案。

C++26で定数式での例外送出対応を受けて、`<exception>`ヘッダの`exception_ptr`関連のユーティリティは`constexpr`指定されて定数式で利用可能なようになっています。

しかし、同じくC++26で追加された`std::exception_ptr_cast()`はそうなっていません。

この関数の実装にあたって定数式で実行できないような障害はないはずだとして、この提案ではこの関数に`constexpr`を追加することを提案しています。

- [P3748 進行状況](https://github.com/cplusplus/papers/issues/2375)

### [P3749R0 Slides in response to P3655R2 - Concerns regarding `std::zstring_view`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3749r0.html)

P3655R2（`zstring_view`提案）への懸念を説明したスライド。

P3655については以前の記事を参照

- [P3655R1 `zstring_view` - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3655R1-zstring_view)

主に、パフォーマンスの検討が足りない事、`std::string_view`を挟むと変換できなくなること、命名が分かりづらいこと、についての懸念を表明しています。

### [P3752R0 Core Language Working Group "ready" Issues for the June, 2025 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3752r0.html)

2025年06月に行われたSofia会議でWDに適用されたコア言語に対するIssue報告の一覧。

- [2843. Undated reference to Unicode makes C++ a moving target](https://cplusplus.github.io/CWG/issues/2843)
- [2898. Clarify implicit conversion sequence from `cv T` to `T`](https://cplusplus.github.io/CWG/issues/2898)
- [2982. Deduction in type-constraints](https://cplusplus.github.io/CWG/issues/2982)
- [2985. Unclear rules for reference initialization with conversion](https://cplusplus.github.io/CWG/issues/2985)
- [2987. Remove dilapidated wording from `static_cast`](https://cplusplus.github.io/CWG/issues/2987)
- [3013. Disallowing macros for `#embed` parameters](https://cplusplus.github.io/CWG/issues/3013)
- [3014. Comma-delimited vs. comma-separated output for `#embed`](https://cplusplus.github.io/CWG/issues/3014)
- [3015. Handling of header-names for `#include` and `#embed`](https://cplusplus.github.io/CWG/issues/3015)
- [3016. Satisfying the syntactic requirements of `#include` and `#embed`](https://cplusplus.github.io/CWG/issues/3016)
- [3018. Validity of `defined` in `__has_embed`](https://cplusplus.github.io/CWG/issues/3018)
- [3020. Missing specification for `__has_cpp_attribute(indeterminate)`](https://cplusplus.github.io/CWG/issues/3020)

### [P3753R0 Slides for P3740R0 - Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3753r0.html)

↓

### [P3753R1 Slides for P3740R1 - Last chance to fix std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3753r1.html)

P3740R1の紹介スライド。

P3740R1は少し上の方にあります。

P3740R1をはじめとする`std::nontype`の修正関連の提案（今月いくつかある）の背景となる、現時点で結果的に`std::nontype`に起きてしまっていることについて簡単に説明されています。

### [P3754R0 Slides for P3100R2 presentation to EWG](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3754r0.pdf)

P3100R2の紹介スライド。

P3100R2に関しては以前の記事を参照

- [P3100R2 Implicit contract assertions - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3100R2-Implicit-contract-assertions)

P3100R2の成り立ちや現状、コア言語UBホワイトペーパーにおける立ち位置を説明したうえで、P3100R2の内容を解説しています。

### [P3757R0 Remove value-type invocability requirement from indirect unary callable concepts](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3757r0.html)

`indirectly_unary_invocable`コンセプトから、イテレータの値型によって呼び出し可能であることを要求する制約を削除する提案。

`indirectly_unary_invocable<F, I>`コンセプトは、`I`型のイテレータ経由で値を取得してその値によって`F`のオブジェクトが呼び出し可能であることを表現するコンセプトです。このコンセプト定義中では、イテレータの参照型（間接参照結果）だけでなく値型に対しても呼び出し可能であることを要求しています。

```cpp
template<class F, class I>
  concept indirectly_unary_invocable =
    indirectly_readable<I> &&
    copy_constructible<F> &&
    invocable<F&, indirect-value-t<I>> && // 👈
    invocable<F&, iter_reference_t<I>> &&
    common_reference_with<
      invoke_result_t<F&, indirect-value-t<I>>, // 👈
      invoke_result_t<F&, iter_reference_t<I>>>;
```

`indirect-value-t<I>`は射影の結果を反映して値型を取得するコンセプトですが、射影を考慮しない場合は`std::iter_value_t<T>&`が使用されます。イテレータの値型は多くの場合素の*prvalue*な型であるため、この制約によって実際には左辺値参照で呼び出さないような場合にコンパイルエラーになることがあります。

```cpp
vector<string> v;
ranges::for_each(v | views::as_rvalue, [](string&& s) { /* */ }); // ng、右辺値で呼び出しできれば十分だけど・・・
```

また、この値型の呼び出し要求に伴う`common_reference`要件によって、イテレータの参照結果をムーブ不可能な型に射影するユースケースがサポートされなくなっています（`common_reference_with`コンセプト内で変換可能性がチェックされるため）。

歴史を紐解くと、`indirectly_unary_invocable`コンセプトのこのような要件は、その二項版コンセプトである`indirect_binary_predicate`や`indirect_equivalence_relation`における同様の制約から来ているようです。これらの二項版コンセプトでは確かに、それを使用するアルゴリズムにおいてイテレータの値型へのコピーとそれを用いた関数呼び出しが発生するためこれは必要な制約です（`ranges::unique_copy`など）。

単項版のコンセプトは二項版からそれを継承してこのような制約をもっているようです。しかし、単項版コンセプトの使用場所を見てみるとそれはどうやら不要な制約であるようで、この提案ではこの制約を削除しようとしています。

`indirectly_unary_invocable`コンセプトを直接的/間接的に使用しているもの

- `ranges::for_each`系
- `ranges::all_of, any_of, none_of`
- `ranges::find`系
- `ranges::count_if`
- `ranges::copy_if, replace_if, replace_copy_if, remove_if, remove_copy_if`
- `ranges::is_partitioned`
- `ranges::partition, stable_partition, partition_copy, partition_point`
- `ranges::filter_view, take_while_view, drop_while_view`
- `std::projected<I, Proj>`
- `std::projected_value_t<I, Proj>`

このうち、最後の`std::projected_value_t`だけは実際に値型のこのような制約が重要な意味を持っています。そのため、`std::projected_value_t`にはこの提案の変更の影響を受けないように修正しています。

この提案後の`indirectly_unary_invocable`コンセプトの定義

```cpp
template<class F, class I>
  concept indirectly_unary_invocable =
    indirectly_readable<I> &&
    copy_constructible<F> &&
    invocable<F&, iter_reference_t<I>>;
```

また、これと同じ変更を同種の`indirectly_regular_unary_invocable`と`indirect_unary_predicate`にも適用しています。

- [P3757 進行状況](https://github.com/cplusplus/papers/issues/2380)

### [P3760R0 Presentation: constexpr 'Parallel' Algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3760r0.pdf)

P2902の紹介スライド

P2902については以前の記事を参照

- [P2902R2 constexpr 'Parallel' Algorithms - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2902R2-constexpr-Parallel-Algorithms)

P2902では並行アルゴリズムを定数式で使用可能にすることを提案していますが、このスライドではそのモチベーションについて詳細に説明しています。

### [P3763R0 Remove redundant reserve_hint members from view classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3763r0.html)

標準の`view`型が`size()`を提供している場合に`reserve_hint`を削除する提案。

P2846R6の採択によって`reserve_hint`CPOおよび、各標準`view`型（Rangeアダプタ実装クラス）に`reserve_hint`メンバ関数が定義されるようになっています。これは、`size()`が利用できない場合に範囲サイズの見積もりを伝達するもので、`ranges::to`や一部の標準コンテナの`from_range`コンストラクタなどで活用されています。

これについて定義をよく見ると、少しおかしなところがあります。

まず、`sized_range`コンセプトは`approximately_sized_range`コンセプト（`reserve_hint`CPOが使用可能かどうかを表す）によって`reserve_hint`が利用可能かどうかをチェックしています。

```cpp
template<class T>
concept sized_range =
  approximately_sized_range<T> && requires(T& t) { ranges::size(t); };
```

次に、各`view`型では`sized_range`コンセプトと`approximately_sized_range`コンセプトを使用して`.size()`/`.reserve_hint()`を定義しています。

```cpp
template<range R>
struct some_view : public view_interface<some_view<R>> {
  […]
  constexpr auto size()               requires sized_range<R>
  constexpr auto size() const         requires sized_range<const R>
  constexpr auto reserve_hint()       requires approximately_sized_range<R>
  constexpr auto reserve_hint() const requires approximately_sized_range<const R>
  […]
};
```

そして、`ranges::reserve_hint`CPOは`.size()`が利用可能であれば`.reserve_hint()`よりもそちらを優先して使用します。

すなわち、各`view`型は`.size()`を持つ場合は必ず`.reserve_hint()`も持ちますが、範囲の正確なサイズ（`.size()`）が利用可能な場合にサイズの見積もり（`.reserve_hint()`）を提供しても実用的ではありません。標準ライブラリ内では`ranges::reserve_hint`CPOを介してサイズ見積もりを取得するため、これをサポートするユースケースはありません。

この提案では、`reserve_hint`は正確なサイズが得られない場合にのみ提供されるべきであり、`.size()`が利用可能な場合は不要であるため削除することを提案しています。

これを残しておくと、不要なインスタンス化のオーバーヘッド（コンパイル時間増大）にもつながります。

提案では、`view`型の`.reserve_hint()`メンバ関数の制約を修正して、`approximate_sized_range`が満たされて`sized_range`が満たされていない場合にのみ定義されるようにしています。

- [P2846R6 reserve_hint: Eagerly reserving memory for not-quite-sized lazy ranges - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2846R6-reserve_hint-Eagerly-reserving-memory-for-not-quite-sized-lazy-ranges)
- [P3763 進行状況](https://github.com/cplusplus/papers/issues/2382)

### [P3764R0 A utility function for propagating the most significant bit](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3764r0.html)

整数の最上位ビットだけを残したビットマスク値を生成する関数`std::msb_to_mask`の提案。

ビット操作においては、符号付整数値の最上位ビット（すなわち符号ビット）をその他すべてのビットに伝播させたビットマスクを作成して使用することが多々あり、これを用いると整数が正か負かで分岐する必要のある処理において分岐無しの実装が可能になる場合があります。

```cpp
// ナイーブなmod実装
int mod_naive(int x, int y) {
  int rem = x % y;
  if (rem < 0) rem += y;
  return rem;
}

// 分岐無しの実装
int mod_branchless(int x, int y) {
  int rem = x % y;
  rem += y & (rem >> (INT_WIDTH - 1)); // 👈
  return rem;
}
```

このような最適化はコンパイラが優秀であれば自動で適用してくれる場合もあるようですが、コードが複雑化したりするとその信頼性は低下します。また、このような形のビットマスクの生成は少し面倒であり、符号付/符号なし整数型の両方をサポートするような汎用実装では正しい記述が少し難しくなります。そして、このような関数の使用例はgithubにおいて多数見つけることができます。

この提案は、このような符号ビットからのビットマスク生成を行うビット演算関数`std::msb_to_mask()`を`<bit>`に追加する提案です。

`std::msb_to_mask()`は次のような関数です

```cpp
namespace std {
  template<class T>
  constexpr T msb_to_mask(T x) noexcept;
}
```

`T`としては符号付整数型と符号なし整数型の両方をサポートします。また、`std::simd`オーバーロードも追加することを提案しています。

呼び出すと、引数`x`の符号ビットをそれ以下の全てのビットに伝播させたビットマスクに対応する整数値を返します。

サンプルコード

```cpp
int main() {
  std::println("{:032b}", std::bit_cast<std::uint32_t>(10));
  std::println("{:032b}", std::bit_cast<std::uint32_t>(msb_to_mask(10)));
  std::println("{:032b}", std::bit_cast<std::uint32_t>(-10));
  std::println("{:032b}", std::bit_cast<std::uint32_t>(msb_to_mask(-10)));
  std::println("{:032b}", 10u);
  std::println("{:032b}", msb_to_mask(10u));
}
```

出力例

```
00000000000000000000000000001010
00000000000000000000000000000000
11111111111111111111111111110110
11111111111111111111111111111111
00000000000000000000000000001010
00000000000000000000000000000000
```

処理の特性上、符号なし整数型に対しては常に0を返します（はずです）。

提案文書より、実装例。

```cpp
namespace std {
  template<signed-or-unsigned-integer T>
    constexpr T msb_to_mask(T x) noexcept {
      using S = make_signed_t<T>;
      return static_cast<T>(static_cast<S>(x) >> numeric_limits<S>::digits);
    }
}
```

CPUによってはこれを行う命令を備えている場合があるようです。

- [P3764 進行状況](https://github.com/cplusplus/papers/issues/2383)

### [P3765R0 Deprecate implicit conversion from bool to character types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3765r0.html)

`bool`から文字型への暗黙変換を非推奨にする提案。

例えば次のようなコードにおいて、`bool`から`char`型への暗黙変換が発生していますが、これは警告などが発っせられることもなくコンパイルされ、実行できてしまいます。

```cpp
std::string_view str = /* ... */;
if (str.ends_with('\n' || str.ends_with('\r'))) {
//                   ^^
  ...
}
```

このコードでは`'\n'`の後にかっこを入れ忘れたうえで別の場所にかっこを挿入してしまっている例です。このコードにおける`'\n' || str.ends_with('\r')`は全体として常に`true`になります。

まず、組み込み`||`のオペランドは`bool`でなければならないため、`'\n'`は`bool`に変換されます。これは`char(0)`ではないため`bool`値としては常に`true`になるため、`str.ends_with('\r')`の結果がなんであれ`true || str.ends_with('\r')`は`true`になります。そして、その結果を用いた`str.ends_with(true)`の呼び出しは`bool`型から`char`への暗黙変換によって`str.ends_with(char)`のオーバーロードを呼び出します。

しかし当然、このコードはほとんどの場合に意図通りに動作しないでしょう。

このような変換は意味のあるものとは思えず、上記例のようにバグの元にしかならないため、この提案ではこの変換を非推奨にしようとしています。

提案しているのは、`bool`型から文字型、すなわち`char, wchar_t, char8_t, char16_t, char32_t`型への暗黙変換を非推奨とすることです。削除することは提案しておらず、`bool`型から`signed char`/`unsigned char`型への暗黙変換は対象ではありません。

```cpp
int x = /* ... */, z;
unsigned char y = x % 2 != 0; // ok、提案後も非推奨ではない
z += y;
```

また、明示的変換も非推奨ではありません。

```cpp
bool b = /* ... */;

char d1 = b;                    // deprecated
char d2(b);                     // deprecated
char d3{b};                     // deprecated
char d4 = {b};                  // deprecated
char d5 = char{b};              // deprecated

char k1 = char(b);              // OK
char k2 = (char)b;              // OK
char k3 = static_cast<char>(b); // OK

'a' + b;                        // OK

char d6 = +b;                   // OK
```

この提案はEWGの議論にてより時間をかけることに合意を得られず、リジェクトされています。

- [P3765 進行状況](https://github.com/cplusplus/papers/issues/2384)

### [P3769R0 Clarification of placement new deallocation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3769r0.html)

配置`new`式における`delete`演算子の選択に関する仕様を明確化する提案。

P3492ではユーザー定義配置`new`演算子を呼び出す`new`式において、オブジェクト初期化失敗時に呼び出される`delete`演算子に対して確保したサイズに関する情報を渡せるようにしようとするものです。この仕様の策定・検討時に、配置`new`式においてどの`delete`演算子が選択されるかについての仕様が不十分であったことが発覚し、P3492R2ではその修正も含める形の文言が提案されていました。

しかし、それはP3492の主たる提案とは少し外れたところにあり、変更点を明確にするために別の提案に分離されることになり、これがその提案です。

ここでは、次の提案から関連する文言を分離してきています

- P3492R2
- P2719R5

また、この提案の内容はDRとすることを提案しています。

この提案において、グローバルスコープで`new`式に対応する`delete`演算子が探索される場合、次のように選択されます

1. 候補が関数テンプレートである場合、テンプレート引数推論を用いて候補関数テンプレートの特殊化を生成する。推論に使用される引数は、最初の引数とそれに続く引数。
2. 仮引数宣言が省略記号（`...`）で終了する関数は、（選択されている）`new`演算子の仮引数宣言が同様に省略記号で終了していない場合、以降の検討候補から外す。
3. 仮引数宣言が省略記号（`...`）で終了しないものの、（選択されている）`new`演算子の仮引数宣言が省略記号で終了している場合、以降の検討候補から外す。
4. 引数の数が（選択されている）`new`演算子の引数の数と等しくない場合、以降の検討候補から外す。
5. 引数の変換の後の関数引数の型が、それぞれの最初の引数を除いて、（選択されている）`new`演算子の引数の型と一致しない場合、以降の検討候補から外す。
6. （ここまでの選別の後で）関数が一つだけ残っている場合、それを選択して選択プロセスを終了する。
7. それ以外の場合、関数を選択せずに選択プロセスは終了する。

この選択の過程（特に4~5）において、`delete`関数末尾にデフォルト引数を指定する形で追加されている引数でもそれによって省略されたりせずに、厳密にマッチングされます。

```cpp
struct A {};
struct T {};

void* operator new(std::size_t s, A& al); // #1

template<int = 0>
void operator delete(void* p, A& al); // #2

A al;
new (al) T(); // ok、#1と#2のペアを使用する
```
```cpp
template<int I>
struct A {};
struct T {};

void* operator new(std::size_t s, A& al); // #1

template<int I>
void operator delete(void* p, A<I>& al); // #2
void operator delete(void* p, A<0>& al); // #3

A<0> al;
new (al) T(); // ok、#1を使用（deleteは選択されない
```
```cpp
struct A {};
struct T {};

void* operator new(std::size_t s, A& al);
void operator delete(void* p, A& al) = delete;

A al;
new (al) T(); // ng、削除された関数が選択された
```

- [P3492R2 Sized deallocation for placement new - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3492R2-Sized-deallocation-for-placement-new)
- [P2719R5 Type-aware allocation and deallocation functions - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2719R5-Type-aware-allocation-and-deallocation-functions)
- [P3769 進行状況](https://github.com/cplusplus/papers/issues/2385)

### [P3771R0 constexpr mutex, locks, and condition variable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3771r0.html)

標準ライブラリのミューテックスや条件変数関連のものを定数式で使用可能にする提案。

この提案は以前に`std::atomic`関連のものを定数式対応させた提案（P3309R3）の延長であり、それに続いてミューテックスとロック、そして条件変数を定数式で使用可能にしようとするものです。ただし、その動機は実行時とコンパイル時で同じコードを使用可能にすることにあり、定数式で並行処理を行おうとするものではありません。

`if consteval`によってコンパイル時処理のための分岐は可能になっていますが、これはコードに余分な分岐と重複をもたらし、記述しやすさと可読性を低下させます。標準ライブラリのエンティティについては`constexpr`対応させておくことで、利用側のコードは何もせずに定数式と実行時の両方で動作するようになります。

この提案で`constexpr`指定を追加しようとしているのは

- `std::mutex`
- `std::recursive_mutex`
- `std::timed_mutex`
- `std::recursive_timed_mutex`
- `std::shared_mutex`
- `std::shared_timed_mutex`
- `std::lock_guard`
- `std::scoped_lock`
- `std::unique_lock`
- `std::shared_lock`
- `std::call_once`
- `std::condition_variable`
- `std::condition_variable_any`
- `std::notify_all_at_thread_exit`

一部のミューテックス型が備えている、`.try_lock_until()`などの時間指定でロック取得を試みる関数は、定数式においては即処理を返すようになります。この時、対象のミューテックスがすでにロックされていたら即時に失敗するようにしています。これは、定数式においては時間計測の方法がないことと、実行がシングルスレッドであることによる動作の選択です。

また、いずれにおいても`.native_handle()`は`constexpr`指定されません。

定数式においては未定義動作は禁止（コンパイルエラー）であり、デッドロックの発生は未定義動作となるためコンパイルエラーとなります（シングルスレッド動作時のそれは同じミューテックスに対して2度ロックを取得することであるため、検出は可能・・・？）。

- [P3309R3 constexpr `atomic` and `atomic_ref` - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3309R3-constexpr-atomic-and-atomic_ref)
- [P3771 進行状況](https://github.com/cplusplus/papers/issues/2386)

### [P3772R0 `std::simd` overloads for bit permutations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3772r0.html)

`<bit>`のビット置換系操作APIの`std::simd`オーバーロードを追加する提案。

P3104R3では、C++29向けにビット置換系のビット演算に対応する関数を追加しようとしています。一方、C++26で追加される`std::simd`に対してはP2933R4で`<bit>`にすでにあるビット操作関数について`std::simd`対応がなされています。

この提案は、P3104R3で追加されるビット操作関数についても`std::simd`対応しておこうとするものです。

- [P3104R3 Bit permutations - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3104R3-Bit-permutations)
- [P2933R4 Extend `<bit>` header function with overloads for `std::simd` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2933R4-Extend-header-function-with-overloads-for-stdsimd)
- [P3772 進行状況](https://github.com/cplusplus/papers/issues/2387)

### [P3774R0 Rename `std::nontype`, and make it broadly useful](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3774r0.html)

`std::nontype`を`std::fn`にリネームする提案。

P3740R1（少し上）のLEWGでのレビューにおいては、`std::nontype`を`std::constant_arg`にリネームするオプションが最も支持を集めましたが、LWGの時間不足もありC++26に採択しないという決定がなされたようです。

この提案は、そのオプションの方向性において、`std::nontype`を`std::fn`にリネームすることを提案しています。

`std::constant_arg`ではなく`std::fn`とするのは、同時にC++29以降の拡張として提案しているメンバの追加によって、`std::fn`が関数ポインタを型システムに持ち上げる役割を担うようなユーティリティになることを見越しての事です。

この提案では、C++29以降の拡張として`std::fn`に関数呼び出し演算子と関数ポインタへの変換演算子を追加することを提案しています。これによって、`std::fn`は関数ポインタに対してラムダ式や`std::function_ref`などと同等の関数ラッパとして働くようになります。

`std::fn<f>`（`std::nontype<f>`）は関数`f`の関数ポインタをNTTP値として保持するため、関数ポインタ保持のためにストレージ領域を使用しません。さらに、`std::fn<f>`は異なる`f`に対して異なるインスタンス化をもたらします。これによって、標準アルゴリズムにおいて関数ポインタを使用した時でもインライン展開しやすくなります。

```cpp
void f(int);
std::ranges::for_each(r, f);                           // インライン展開を妨げるため推奨されない
std::ranges::for_each(r, [](int x) { return f(x); });  // 正しいが面倒
std::ranges::for_each(r, std::fn<f>);                  // 正しく、簡潔
```

また、関数ポインタへの変換演算子はある程度の自由度を持たせておくことで、引数型の変換を考慮した関数ポインタの変換機能を提供できます。

```cpp
bool is_prime(long long x);

bool(*p)(int) = std::fn<&is_prime>;
```

このように、`std::fn<f>`は`f`のアドレス値を型名に取り込むことによって関数ポインタを型システムに持ち上げる役割を担うようになるため、より短く適切な命名として`std::constant_arg`よりも`std::fn`を選択しています。

提案文書より、`std::fn`の実装例

```cpp
template<auto f>
struct fn_t
{
  using type = decltype(f);

  static constexpr bool is_function_ptr = std::is_function_v<std::remove_pointer_t<type>>;

  template<bool Noex, typename Ret, typename... Args>
  using func_type = Ret(*)(Args...) noexcept(Noex);

  constexpr operator type() const noexcept
    requires is_function_ptr
  { 
    return f;
  }

  template<bool Noex, typename Ret, typename... Args>
    requires (Noex ? std::is_nothrow_invocable_v<Ret, type const&, Args...> 
                   : std::is_invocable_r_v<Ret, type const&, Args...>)
  constexpr operator func_type<Noex, Ret, Args...>() const
  {
    if constexpr (is_function_ptr && std::is_convertible_v<type, func_type<Noex, Ret, Args...>>)
      return f;
    else
      return [](Args... args) noexcept(Noex) -> Ret {
        return std::invoke(f, std::forward<Args>(args)...);
      };
  }

  template<typename... Args>
    requires (!is_function_ptr)
  static constexpr std::invoke_result_t<type const&, Args...> operator()(Args&&... args)
    noexcept(std::is_nothrow_invocable_v<type const&, Args...>)
  { 
    return std::invoke(f, std::forward<Args>(args)...);
  }
};

template<auto f>
constexpr fn_t<f> fn;
```

この提案のC++26部分（リネームのみ）に関してLEWGの議論の結果、`std::constant_arg`という名前にリネームすることに合意が取れたようです。

- [関数へのポインタによるコールバックをインライン化する - Cry's Blog](https://blog.cryolite.net/entry/01000831/p1)
- [P3774 進行状況](https://github.com/cplusplus/papers/issues/2388)

### [P3778R0 Fixing `type_order` template definition](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3778r0.html)

`std::type_order`による比較結果の表現方法を修正する提案。

P2830R10では2つの型を実装定義の全順序の上で比較するためのメタ関数`std::type_order`が提案され、これはC++26に採択されています。`std::type_order`は`std::type_order_v<T, U>`のように使用して、2つの型`T, U`の実装定義の`<`比較の結果を`std::strong_ordering`の値で得ることができます。

この`std::type_order`の実装は次のようになっています

```cpp
template <class T, class U>
struct type_order : integral_constant<strong_ordering, see below> {};

template <class T, class U>
constexpr strong_ordering type_order_v = type_order<T, U>::value;
```

このように`integral_constant`（特に`std::bool_constant`）を使用してメタ関数の実装をある程度簡略化するのは他のメタ関数でもよくやられていることです。しかし、`std::strong_ordering`がNTTPとして使用できないため、この実装は不可能でした。

NTTPとして使用可能な型は構造的な型（structural type）という型のカテゴリで定義されており、クラス型の場合は集成体型のようにすべてのメンバ変数が`public`である必要があります。しかし、`std::strong_ordering`は通常プライベートメンバを持つ形で実装されるため、NTTPとして使用できません。

この提案は、`std::type_order`を`std::integral_constant`を使わないように修正することでこの問題を解決しようとするものです。

`std::type_order`の実装が先ほどの例のように`std::integral_constant`を使用する必要があるのは、*Cpp17BinaryTypeTrait*という要件に従うように指定されているからです。この要件の意図するところは次のようなものの様です

1. `std::integral_constant<T, v>`への暗黙変換を行うことで、メタ関数の引数型を隠蔽することができる。
    - 意図的に使用すると、テンプレートのインスタンス化数を減少させられる
2. `::type`メンバは1を明示的に実行するのに使用できる
3. メタ関数の結果として`::value`メンバを提供する
4. `value_type`メンバによって`::value`の型を取得できる
5. 利便性向上のための、`constexpr`暗黙変換演算子（`::value`へ変換）
6. `constexpr operator()`は関数呼び出しを期待するコンテキストから値を取得するのに役立つ

これらの性質を実現するのに`std::integral_constant`を使用するのは最も簡単なため、現在の定義はそうしています。この提案では、これらの性質を維持し他のメタ関数とほぼ同じ動作をさせながらも`std::integral_constant`を使用しないようにするために、`std::type_order`の構造体を独自かつ具体的に定義するようにしています。

変更後の定義は次のようになります

```cpp
template<class T, class U>
struct type_order {
  static constexpr strong_ordering value = TYPE-ORDER(T, U);

  using value_type = strong_ordering;

  constexpr operator value_type() const noexcept { return value; }
  constexpr value_type operator()() const noexcept { return value; }
};
```

そして、`std::type_order`の*Cpp17BinaryTypeTrait*への適合の規定を削除しています。これによって、上記性質の1と2以外のものは維持されたままで、`std::strong_ordering`を比較結果に使用しつつ実装可能になります。

この提案は、2025年11月の全体会議を通過し、C++26に採択されています。

- [P2830R10 Standardized Constexpr Type Ordering - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2830R10-Standardized-Constexpr-Type-Ordering)
- [P2830R7 Standardized Constexpr Type Ordering - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P2830R7-Standardized-Constexpr-Type-Ordering)
- [std::type_orderによる型リストの正規化 - zenn](https://zenn.dev/yaito3014/articles/type-order-and-canonicalization)
- [C++20 非型テンプレートパラメータとしてクラス型を許可する [P0732R2]](https://cpprefjp.github.io/lang/cpp20/class_types_in_non-type_template_parameters.html)
- [P3778 進行状況](https://github.com/cplusplus/papers/issues/2389)

### [P3780R0 Detecting bitwise trivially relocatable types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3780r0.html)

トリビアルリロケーション可能な型が、`memcpy`によってトリビアルリロケーション可能であるかを調べる型特性を追加する提案。

P2786では、オブジェクトの再配置（リロケーション）という操作をライブラリ実装で使用可能にするための言語の調整と最低限のライブラリ機能が提供されます。リロケーション操作は通常ムーブ+デストラクタ呼び出しの複合操作となりますが、一部の条件を満たした方はもっと単純に`memcpy`によるビットコピーによってリロケーションを行うことができます。

この`memcpy`によるリロケーションが可能な型の事をトリビアルリロケーション可能（*trivially relocatable*）な型と呼び、P2786は専らこれを正式にC++コード上で利用可能にすることを目的としています。

トリビアルリロケーション可能な型とは、スカラ型やポインタ型などのプリミティブ型は当然含まれますが、普通のクラス型でもトリビアルリロケーション可能となる場合があります。例えば、通常の実装の`std::vector`はトリビアルリロケーション可能になります。

P2786によるトリビアルリロケーション可能の定義では、多態的な型（*polymorphic type*）もトリビアルリロケーション可能であるとされます。これは、多態的な型は隠れた非静的メンバ変数としてポインタ（仮想関数テーブルへのポインタ）を持っているとみなすことができ、ポインタ型はトリビアルリロケーション可能であるため、多態的な型はその継承構造に関わらずトリビアルリロケーション可能となります。

しかし、一部のアーキテクチャやABIにおいてはポインタの署名が行われる場合があり、署名による認証に失敗するとポインタアクセスに失敗するようになります。例えばARM64eではPointer Authentication Code（PAC）と呼ばれる拡張命令を備えています。そして、仮想関数テーブルへのポインタがこの署名の対象になる場合があります。

このポインタの署名にはポインタの参照先アドレスとポインタ自体のアドレスが少なくとも使用されます。これにより、ポインタ署名をサポートする（+仮想関数テーブルへのポインタの認証を行う）ような環境においては、多態的な型を単純な`memcpy`によってリロケーションしてしまうとうまく動作しなくなります（仮想関数テーブルへのポインタのアドレスが変化することでポインタ認証に失敗してしまう）。

P2786ではこれが考慮されており、`std::trivially_relocate()`関数を用いてトリビアルリロケーションを行うことで、この関数内でポインタ署名の再署名を行えるようにしています。

結局、P2786のトリビアルリロケーション可能な型の定義においては、多態的な型もトリビアルリロケーション可能となっています。しかし、それは必ずしもビットコピーによってトリビアルリロケーション可能であることを意味していません。このことは、多態的な型をバイト列として内部的に保持しうるようなラッパ型の実装時に問題となります。

例えば次のようなラッパ型を考えます

```cpp
class Wrapper {
  // オブジェクトか、ヒープへのポインタを格納するバイト配列
  alignas(A) std::byte storage[N];
  /* ... other data ... */

public:
  Wrapper();

  // デストラクタとムーブコンストラクタがユーザー定義される
  ~Wrapper();
  Wrapper(Wrapper &&);
  /* other special member functions, rest of the API, etc. */
};
```

これをP2786のトリビアルリロケーションの枠組みにアダプトさせると次のようになります

```cpp
class Wrapper trivially_relocatable_if_eligible {
  // オブジェクトか、ヒープへのポインタを格納するバイト配列
  alignas(A) std::byte storage[N];
  /* ... other data ... */

public:
  Wrapper();
  
  // デストラクタとムーブコンストラクタがユーザー定義される
  ~Wrapper();
  Wrapper(Wrapper &&);
  /* other special member functions, rest of the API, etc. */
};
```

このような型の具体例としては`std::any`があり、`optional`や`inplace_vector`の実装の一つとして一般的なものです。

`storage`以外のメンバは通常整数やポインタ等のプリミティブ型しか必要ないため、この型はトリビアルリロケーション可能となります。ただしそのためには、`storage`に保存する型もまたトリビアルリロケーション可能でなければならず、そうではない場合は構築を禁止するかヒープに配置してそのポインタを（`storage`に）保存するようにする必要があります。

そのように実装されているとして、この`Wrapper`クラスオブジェクトをリロケーション（`std::trivially_relocate()`）する際に単純な`memcpy`によって実行しても大丈夫でしょうか？特に多態的な型（前述のようにこれはトリビアルリロケーション可能）を保持している（`storage`に格納されている）場合に`memcpy`によるリロケーションは安全でしょうか？

前述のように、ポインタ認証を行う環境においては、多態的な型を保持する`Wrapper`クラスオブジェクトを`memcpy`によってリロケーションするとポインタ認証に失敗するポインタが生成されてしまうため安全ではありません。`std::trivially_relocate()`によってリロケーションを行うときでも、`std::trivially_relocate()`は`Wrapper`クラスの実装についての知識を持たないため、単純な`memcpy`でリロケーションしていいのかポインタ再認証が必要なのか（そしてそのポインタはどこにあるのか）は分かりません。

そのため、このトリビアルリロケーション可能な`Wrapper`型に直接格納できる型の要件はトリビアルリロケーション可能というだけではなく、`memcpy`によってリロケーション可能であるという要件も必要になります。これはP2786でも提供されていません。この提案は、これを検出する型特性を提案するものです。

ポインタ認証をサポートするかはプラットフォームによって異なり、また型が多態的であるかどうかということはこの問題の本質ではないため、`std::is_polymorphic`ではこの問題の解決には適さないため、専用の型特性が必要となります。

この提案では、この型特性を`std::is_bitwise_trivially_relocatable`として提案しています。

`Wrapper`クラスでは、コンストラクタや代入演算子などでこの型特性を使って格納しようとしている型を内部バッファ（`storage`）に配置すべきかヒープに配置してポインタを保持すべきかを決定するようにすることで、プラットフォームによらず安全なトリビアルリロケーション対応を達成することができます。

また、この`memcpy`によってリロケーション可能であるという要件は、動作するUBの上ですでにリロケーションを活用している既存のライブラリ実装が想定している定義でもあります。既存のライブラリの要件と合致する型特性を追加しておくことでC++26リロケーションへの移行を促しやすくなる効果もあります。

- [P3780 進行状況](https://github.com/cplusplus/papers/issues/2390)

### [P3781R0 `is_*_type` should imply `is_type`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3781r0.html)

リフレクション（`std::meta::info`）が何らかのカテゴリの型を反映しているかを取得する関数群について、型ではないリフレクションの入力がエラーにならないようにする提案。

リフレクションのユースケースとしてかなり一般的になると予想されることの一つは何らかのバインディングを作成することだと予想されます。その際、対象が関数なのかクラスなのかによって処理が変わることがあると予想され、その場合はそれを判定して分岐することになります。例えば次のような単純な例が考えられます

```cpp
// 名前空間fooのリフレクションを取得
constexpr auto namespace_info = ^^foo;

// foo名前空間以下のもののリフレクションを取得しイテレーションする
for (int i = 0; auto element : std::meta::members_of(namespace_info, std::meta::access_context::current()))
{
  // elementがクラスかを判定
  if (std::meta::is_class_type(element))
  {
    // クラスに対する処理をここで行う
    classes[i++] = std::meta::identifier_of(element);
  }
}
```

どのようなバインディングを作成するかは置いておいて、何かしらの対象（ここでは名前空間）のエンティティの処理は例えばこのようになるでしょう。しかしこのコードは実際には期待通りに動作しません。なぜなら、`std::meta::is_class_type(element)`は`element`が型のリフレクションではない場合に`false`を返すのではなくコンパイルエラーになるためです。この例では名前空間のメンバについてイテレーションしているので、関数や名前空間が出てきたところでエラーになります。

正しくは、`std::meta::is_type`で`element`が型のリフレクションであるかどうかを先に判定する必要があります。

```cpp
  // elementがクラスかを判定
  if (std::meta::is_type(element) && std::meta::is_class_type(element))
```

とはいえこれは直感的ではなく冗長です。

`std::meta::is_*_type`という関数は多数ありいずれも同様の問題があります。`is_*_type`という命名からは、それが型かどうかを`bool`値で返すものであるという妥当な推測が立ち、型ではないものについてクエリしたときに`false`ではなくエラーを返すのは直感的ではありません。

このため、この提案では`std::meta::is_*_type`系の関数において`std::meta::is_type`による判定をまず行うようにすることを提案しています。これにより、上記の例では`std::meta::is_class_type(element)`だけで意図通りに動作するようになります。

ただし、`std::meta::is_*_type`系の関数のうち、2項で型以外の入力が意味を持たないものについては除外しています。除外する関数は次のものです

```cpp
// associated with [meta.unary.prop], type properties
consteval bool is_assignable_type(info type_dst, info type_src);
consteval bool is_trivially_assignable_type(info type_dst, info type_src);
consteval bool is_nothrow_assignable_type(info type_dst, info type_src);

consteval bool is_swappable_with_type(info type_dst, info type_src);
consteval bool is_nothrow_swappable_with_type(info type_dst, info type_src);

// associated with [meta.rel], type relations
consteval bool is_same_type(info type1, info type2);
consteval bool is_base_of_type(info type_base, info type_derived);
consteval bool is_virtual_base_of_type(info type_base, info type_derived);
consteval bool is_convertible_type(info type_src, info type_dst);
consteval bool is_nothrow_convertible_type(info type_src, info type_dst);
consteval bool is_layout_compatible_type(info type1, info type2);
consteval bool is_pointer_interconvertible_base_of_type(info type_base, info type_derived);

template <reflection_range R = initializer_list<info>>
consteval bool is_invocable_r_type(info type_result, info type, R&& type_args);

template <reflection_range R = initializer_list<info>>
consteval bool is_nothrow_invocable_r_type(info type_result, info type, R&& type_args);
```

これらの関数ではどちらかの引数に型以外のものを入れた時に`false`を返すと誤解を招く可能性があります。例えば、`is_same_type(r1, r2)`は一方もしくは両方の引数が型を反映したものでない場合に`false`を返すと型として一致していなかったのか引数が型ではなかったのかわからなくなります。

- [P3781 進行状況](https://github.com/cplusplus/papers/issues/2391)

### [P3784R0 range-if](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3784r0.pdf)

範囲`if`文の提案。

範囲が空であるかによって処理を分岐したい場合ということは良くあります。単純には`ranges::empty`を使用して分岐すればよいのですが、真にジェネリックに記述しようとすると、`empty`が使用できない場合があり得るためイテレータを使用しなければなりません。

```cpp
// パイプラインを使用するなどして生成されている何か範囲
auto && r = a-view-pipeline; 

if(!r.empty()) { // ❌ すべてのビュー型がempty()を提供するわけではない
  for(auto & x : r) { 
    … 
  } 
} else { 
  // 範囲が空の場合の処理
}
```
```cpp
auto && r = a-view-pipeline;

// 😬 明示的にイテレータを使用する
if(auto it{r.begin()}; it != r.end()) { 
  for(; it != r.end(); ++it) { // 冗長なチェック
    auto & x{*it}; 
    … 
  } 
} else { 
  // 範囲が空の場合の処理
}
```

この用途に範囲`for`を使用できないのは、`else`節に相当するものが無いためです。

範囲`for` + フラグという方法もありますが、フラグの扱いそのものやそのスコープについてなどの問題がありベストな解決策とは言えません。

```cpp
// 😬 空かどうかのフラグ
auto empty{true}; 
for(auto & x : a-view-pipeline) { 
  empty = false; 
  … 
} 

if(empty) { 
  // 範囲が空の場合の処理
}
```

この提案は、範囲`for`に対応する範囲`if`文によってこのような場合の記述の問題を言語機能で解決しようとするものです。

提案している構文は通常の`if`文に対して、条件を記述するところに範囲`for`のように記述する構文です

```cpp
if (auto & x : a-view-pipeline) { 
  // 範囲のイテレーション処理
  // ここはループする
} else { 
  // 範囲が空の場合の処理
  // ここは一回で抜ける
}
```

これは範囲`for`にかなり近いもので、それと同じように展開されます

```
if constexpr(opt)(init-statementopt for-range-declaration : for-range-initializer) 
statement1 else statement2
```

の様な文は

```cpp
{
  init-statement(opt); 
  auto && range = for-range-initializer; 
  auto begin = begin-expr; 
  auto end = end-expr; 
  if constexpr(begin != end) 
    do { 
      for-range-declaration = *begin; 
      statement1 
    } while(((void)++begin), begin != end); 
  else 
    do { statement2 } while(false); 
}
```

のように展開されます。

この範囲`if`ではループ部と`else`節の両方で`break`や`continue`を使用可能にすることを意図しており、そのために`else`側（`statement2`）もダミーループで囲われます。

- [P3784 進行状況](https://github.com/cplusplus/papers/issues/2392)

### [P3785R0 Library Wording Changes for Defaulted Postfix Increment and Decrement Operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3785r0.html)

P3668の後置インクリメント/デクリメント演算子の`default`定義を利用して標準ライブラリの規定を変更をする提案。

P3668では後置インクリメント/デクリメント演算子が対応する前置演算子を用いて典型的に記述できることを利用して、そのような実装をデフォルトとする`default`定義できるようにしようとしています。

P3668については以前の記事を参照

- [P3668R1 Defaulting Postfix Increment and Decrement Operations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3668R1-Defaulting-Postfix-Increment-and-Decrement-Operations)

この提案は、標準ライブラリ中で後置インクリメント/デクリメント演算子を定義している部分でこの`default`指定を使用するようにすることで、標準の規定を圧縮しようとするものです。

この提案による変更は既存の動作を変更したりするものではなく、標準の文言を簡素化することにあります。そのため、この変更は編集上のものとしてLWGのレビューにかけることを提案しています。

変更の候補は全部で53個あり、表記の揺れはあるもののデフォルト実装と一致する規定を持つものと、デフォルト実装と一致しているもののコンパイル時の分岐を伴う物や事前条件や制約を持つものの大きく2種類に分けて、その文言とともにリストアップしています。

- [P3785 進行状況](https://github.com/cplusplus/papers/issues/2393)

### [P3787R0 Adjoints to "Enabling list-initialization for algorithms": uninitialized_fill](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3787r0.html)

P2248R8での変更を`uninitialized_fill`にも適用する提案。

P2248については以前の記事を参照

- [P2248R8 Enabling list-initialization for algorithms - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2248R8-Enabling-list-initialization-for-algorithms)

P2248R8では値を取るタイプのアルゴリズムにおいて、イテレータから取得した値型を利用することで`{}`の指定ができるようになっています。しかし、`uninitialized_fill`はそこから漏れていたようでその変更が適用可能であるのに適用されていないため、特に`fill`アルゴリズムの仕様と一致するように`uninitialized_fill`も変更しようとする提案です。

```cpp
int main() {
  std::array<int, 10> arr;  // 未初期化配列

  std::ranges::uninitialized_fill(arr, {}); // この提案後ok
}
```

- [P3787 進行状況](https://github.com/cplusplus/papers/issues/2394)

### [P3788R0 Fixing `std::complex` binary operators](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3788r0.html)

`std::complex`の二項演算において暗黙変換が考慮されないことを修正する提案。

`std::complex<T>`は`T`に暗黙変換可能な数値型から構築することができます。一方で、`std::complex<T>`を用いた二項演算においては数値として使用可能なのは`T`型そのもののみで、`T`に暗黙変換可能な型を使用できません。

```cpp
long double ld = 2.5;
std::complex<float> c = 3.14;           // OK!!!

auto res1 = c * 3.14f;                  // OK
auto res2 = c * 3.14;                   // DOES NOT COMPILE!!!
auto res3 = c * ld;                     // DOES NOT COMPILE!!!
auto res4 = c * static_cast<float>(ld); // OK but verbose

if (c == 3.14f) {                       // OK
  // ...
}
if (c == 3.14) {                        // DOES NOT COMPILE!!!
  // ...
}
```

これは`std::complex<T>`の二項演算の演算子オーバーロードの定義のされ方に問題があります。例えば、二項`*`演算子オーバーロードは次のように定義されています。

```cpp
template<class T>
constexpr complex<T> operator*(const complex<T>&, const complex<T>&);

template<class T>
constexpr complex<T> operator*(const complex<T>&, const T&);

template<class T>
constexpr complex<T> operator*(const T&, const complex<T>&);
```

この演算子（およびほかの二項演算子）は非メンバの非`friend`関数として定義されています。下二つの演算子定義において、`std::complex`ではない値を受け取る引数の引数型が`std::complex<T>`の`T`を直接使用してしまっていることに問題があります。この`T`はテンプレート引数推論の対象であり、両方のオペランドから推論した型が一致しなければなりません。その結果、`T`に対してはほとんどすべての変換は行われず、`std::complex<T>`に対して丁度`T`型の値しか渡すことができません。例えば、`std::complex<float>`と`double`を受け取れる`*`は存在しません。

また、両方のオペランドが`std::complex`である場合でも、その数値型が異なるとやはり利用できる演算子がなくなります（`std::complex<double>`と`std::complex<float>`など）。

これと同じことが他の二項演算子においても起きているため、`std::complex`を使用する場合の使用感を損ねています。特に、`std::complex`は数式をコードに起こす場合に使用されることが多く、そのようなコードを動作させるためにキャストが多く必要になると元の数式と乖離することで可読性が低下します。

この提案は、これを修正して`std::complex<T>`の二項演算で`T`に暗黙変換可能な型の値を使用できるようにしようとするものです。

後方互換性を重視して、この提案では`T`を直接取っていたところを`std::complex<T>::value_type`を使用するように変更することを提案しています。

```cpp
template<class T>
constexpr complex<T> operator*(const complex<T>&, const complex<T>&);

template<class T>
constexpr complex<T> operator*(const complex<T>&, const typename complex<T>::value_type&);

template<class T>
constexpr complex<T> operator*(const typename complex<T>::value_type&, const complex<T>&);
```

このようにすることで、下二つのオーバーロードの非`std::complex`引数はテンプレートパラメータの推論に寄与しなくなり、`std::complex<T>`引数から`T`が決定された後で`T`に対する変換が効くようになります。

これと同じことを、他の二項演算（`+ - * / ==`）に対しても適用します。

この変更は既存の動作しているコードに対しては影響がなく、オーバーロード解決結果も変更されません。動作していなかったコードが動作するようになります。

- [P3788 進行状況](https://github.com/cplusplus/papers/issues/2395)

### [P3790R0 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r0.pdf)

ポインタの参照先の寿命が尽きた後でも使用可能なライブラリユーティリティを提供する提案。

現在のC++のポインタの意味論においては、参照先のオブジェクトの寿命が尽きた後のポインタ値は不定となり、その使用（ポインタ値の読み出し、保存、キャスト、比較）は実質的に許可されていません。一方で、既に広く使用されている並行アルゴリズムの中にはそのような不定なポインタ値が使用できることに依存している場合があります。

この問題はPointer lifetime-end zapと呼ばれており、先行する提案によって否定的に（不定なポインタの使用を禁止する形で）解決されようとしています。その場合、現在存在しているそのような操作に依存しているアルゴリズムは未定義動作になってしまいます。

それを防止するために、この提案では　これは、整数値アドレスを格納する変数の様な単純なポインタの意味論（Bag of bits）をエミュレートするライブラリ機能です。

ここで提案しているのは、`launder_bag_of_bits_ptr()`という関数と`bag_of_bits_ptr<T>`というクラステンプレートです。

`launder_bag_of_bits_ptr()`はポインタを受け取り、そのポインタに対応する将来のポインタ値を返す関数です。参照先の寿命が尽きているポインタはそのままだと不定値を取りますが、この関数を通すことで同じアドレスに再度配置される別の（将来の）オブジェクトのアドレスを指す有効なポインタが得られます。名前の通り、この関数はポインタのロンダリングを行います。

`bag_of_bits_ptr<T>`は参照先の寿命が尽きた後にも無効化しないポインタ型をエミュレートする型です。このクラステンプレートは`T`のポインタとして使用することができ、このクラスオブジェクトとして使用する限りポインタの参照先の寿命が尽きた後でもポインタ値が有効であり続けます。また、このクラスによるポインタはポインタのprovenanceを切ることもできます。

これらのユーティリティは、zapおよびprovenanceによって問題を受けるコードを保護するためのテクニックである、ポインタ値を`reinterpret_cast`によって整数値に落としてから戻す（戻す際にprovenance再計算とその時点で有効なポインタの取得が行われる）という操作をラップするユーティリティです。現在不定なポインタの使用に依存しているコードでは、生ポインタを使用する代わりにこれらのユーティリティを介してポインタを使用するようにすることで、将来的にPointer lifetime-end zapが否定的に解決されprovenanceが導入された場合でも、従来の動作を維持することができます。

この提案はP2414で提案されていたライブラリ機能を単離したもので、`bag_of_bits_ptr`は以前は`usable_ptr`と呼ばれていました。

- [P1726R5 Pointer lifetime-end zap (informational/historical) - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P1726R5-Pointer-lifetime-end-zap-informationalhistorical)
- [P2188R1 : Zap the Zap: Pointers are sometimes just bags of bits - WG21月次提案文書を眺める（2020年07月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P2188R1--Zap-the-Zap-Pointers-are-sometimes-just-bags-of-bits)
- [P2434R4 Nondeterministic pointer provenance - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2434R4-Nondeterministic-pointer-provenance)

### [P3791R0 constexpr deterministic random](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3791r0.html)

決定論的なアルゴリズムによる乱数生成器と、乱数生成器を使用するアルゴリズムを`constexpr`指定する提案。

この提案では決定論的なアルゴリズムによる乱数生成器、すなわち疑似乱数生成器の全てに対して`constexpr`指定しようとしています。それに加えて、`shuffle`と`sample`アルゴリズムも`constexpr`指定しようとしています。

```cpp
constexpr sample_to_sketch(std::span<const T> items, sketch<T> & sk) noexcept {
	auto engine = std::mt19937_64{/* default seed is fine*/}; // この提案後ok
	std::ranges::sample(items, std::insert_iterator(sk), sk.capacity(), engine);  // この提案後ok
}
```

ただし、`std::random_device`など非決定論的な乱数生成を伴うものについては対象にしていません。

この動機については他の`constexpr`対応と同様に、実行時とのコード共通化や定数式でのテストを可能にすることでUB検出機能付きでテストできるようにすることなどを挙げています。

- [P3791 進行状況](https://github.com/cplusplus/papers/issues/2397)

### [P3792R0 Why `constant_wrapper` is not a usable replacement for `nontype`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3792r0.html)

`std::nontype`を`std::constant_wrapper`で置き換えられない理由を説明する文書。

P3740R1（上の方に詳細あり）では`std::nontype`をリネームするか`std::constant_wrapper`で置き換えるかの2つのオプションを提示しており、LEWGの投票ではリネームすることに合意がありました。`std::constant_wrapper`はNTTPをより汎用的に取り扱うものであるため、`std::nontype`を完全に置き換えられると考えるのは自然なことです。この投票結果においてはそのことがメンバーに共有された上でのものであり、この文書はそれを説明するものです。

`std::constant_wrapper<V>`はNTTP値`V`をラップして通常のオブジェクトとして扱えるようにしたもので、`std::integral_constant`を汎用化したものです。`std::constant_wrapper`の特徴はほぼすべての演算子オーバーロードを提供することで`V`で可能な演算を`std::constant_wrapper`上で実行できるようにしていることで、`std::constant_wrapper`という型を通してコンパイル時定数の計算を型システム上で簡単に行うことができます。

この演算子オーバーロードの中には関数呼び出し演算子も含まれており、次のように定義されています。

```cpp
template<constexpr-param T, constexpr-param... Args>
constexpr auto operator()(this T, Args...) noexcept
  requires requires(Args...) { constant_wrapper<T::value(Args::value...)>(); }
{
  return constant_wrapper<T::value(Args::value...)>{};
}
```

`std::cw<V>(args...)`（`std::cw<V>`は`std::constant_wrapper<V>`の略記）の様な呼び出しは、`V(args.value...)`の結果を再び`std::constant_wrapper`にラップした`std::cw<V(args.value...)>`を返します（`std::constant_wrapper<V>::value`で`V`にアクセスできる）。

`std::cw<V>(args...)`において、この関数呼び出し演算子が使用可能であるためには、`V(args.value...)`の呼び出しが定数式で実行可能であり、`args`はすべて`std::constant_wrapper`型の値（もしくは互換のある型の値）である必要があり、戻り値型がNTTPとして利用可能（戻り値型が構造的な型）である必要があります。そうでない場合、この関数呼び出し演算子は使用できません。

これによって、`std::constant_wrapper`自体が呼び出し可能になる場合があり得ます。それでも、`std::nontype`の代わりに`std::constant_wrapper`を使用することは可能であり、単に`std::constant_wrapper`を受け取るコンストラクタにおいて`std::constant_wrapper<V>::value`を使用するようにするだけです。

では何が問題なのかというと、現在`std::nontype`を使用しているところが`std::function_ref`のみであるため、`std::function_ref`とそれ以外の関数ラッパ（`std::move_only_function`など）との間で`std::cw<f>`を渡した場合の挙動が異なってしまうことです。`std::function_ref`では`::value`から`f`（関数ポインタ）を取り出してそれを保持するのに対して、他の関数ラッパでは`std::cw<f>`そのものを呼び出し可能オブジェクトとして保持します。前述のように、`std::cw<f>(args...)`の`args...`の値は静的メンバ変数`value`を取り出せなければならないためいつも起こるわけではありませんが、意図しないでこの不一致が発生する可能性が生まれてしまいます。

例えば次のような呼び出し可能な型があり

```cpp
static constexpr struct foo_t
{
  constexpr auto operator()(auto &&...args) const -> int
    requires(std::integral<std::remove_cvref_t<decltype(args)>> && ...)
  {
    return (0 + ... + args);
  }

  constexpr auto operator()(auto &&...args) const -> int
    requires(std::integral<
                 decltype(std::remove_cvref_t<decltype(args)>::value)> &&
             ...)
  {
    return sizeof...(args);
  }

} foo = {};
```

次のような型の値があったとして

```cpp
static constexpr struct baz_t final
{
    static constexpr int value = 42;
} baz = {};
```

次のコードは動作します

```cpp
auto main() -> int {
  move_only_function<int(baz_t)> fn(cw<foo>);
  assert(fn(baz) == 42);  // ✅
}
```

`cw<foo>`は構築可能であり、`cw<foo>(baz_t)`の呼び出しは有効で`cw<foo(baz_t::value)>`を返します。このため、`move_only_function<int(baz_t)>`への格納も行うことができ、`fn(baz)`の呼び出しも行うことができて、アサートはパスします。

しかし、この`move_only_function`を`function_ref`に変えると動作が変化します（`std::nontype`を`std::constant_wrapper`で置き換えた場合）

```cpp
auto main() -> int
{
  function_ref<int(baz_t)> fn(cw<foo>);
  assert(fn(baz) == 42); // ❌ fn(baz) == 1
}
```

`function_ref`においては`cw<foo>`からの構築は`foo`を取り出しこれをそのまま関数呼び出し対象として利用する形になります。それによって、`foo_t`で定義された関数呼び出し演算子の2つ目の方が選択され（`baz_t`は`::value`がアンラップされずにそのまま渡される）るようになります。

これを防止するには`std::nontype`を維持するか、`std::constant_wrapper`を取り`std::function_ref`と同等に動作するコンストラクタを他の関数ラッパにも追加するかのどちらかをする必要があり、前者が選ばれたのがP3740R1のLEWGでの投票の結果です。後者はP2511で提案されていたものの否決されていたこともあり、C++26ギリギリの状況では選択しづらかったものと思われます。

- [P3792 進行状況](https://github.com/cplusplus/papers/issues/2398)

### [P3793R0 Better shifting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3793r0.html)

整数のビットシフトを行うライブラリ関数の提案。

C++のシフト演算子（`<< >>`）は基本的にCから受け継いだものそのままで、いくつかの落とし穴が知られています

1. 演算子の優先順位が`+ -`（二項演算子）よりも低い
    - シフト演算が実質乗除算として機能することを考えると直感的ではない
2. シフト量がシフト対象のビット幅以上、あるいは負の値の場合、未定義動作となる

1の問題はGCCの最適化がこのことに依存しているため変更することが難しく、2の問題は動作を定義するよりもEBにすることを好む向きがあるため議論の余地があります。この提案では特に2の問題の解決に焦点が置かれており、シフト対象の幅と同じ値を指定した場合の未定義動作を回避するために気を使わなければならない不便さなどを動機として挙げています。

この提案では、これらの問題を解決したシフト演算を提供するために、シフト演算を行うライブラリ関数を追加しようとしています。提案しているのは`std::shl()`と`std::shr()`という2つの関数です。

```cpp
// <bit>に追加
namespace std {
  template<class T>
  constexpr T shl(T x, int s) noexcept;
  
  template<class T>
  constexpr T shr(T x, int s) noexcept;
}
```

`shl(x, s)`は`x`を`s`ビット左シフトし、`shr(x, s)`は`x`を`s`ビット右シフトします。ここでのシフトは算術シフトを行うため、論理シフトを行う場合は`x`引数を符号なし整数型にキャストする必要があります。

そして、シフト量が大きい場合のシフトについては未定義動作とせず、シフト対象のビット全てが外に押し出されることになり、論理シフト（符号なし整数型）の場合は`0`になり、算術シフト（符号付整数型）の場合は負の値であれば`-1`、そうでなければ`0`になります。

一方、シフト量が負の場合のシフトについては実装定義の結果を伴うEBとしています。

また、他のビット操作関数と同様に`std::simd`（`std::simd::vec`）に対するオーバロードも用意しています。

- [P3793 進行状況](https://github.com/cplusplus/papers/issues/2399)

### [P3794R0 An idea or two on renaming the nontype tag](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3794r0.html)

`std::nontype`のリネーム名の別案の提案。

C++26でNTTPという言葉が標準で使用されなくなったのを受けて、`std::nontype`の名前を変更する必要があることが認識されています。そのリネーム候補としてここでは、swiftのWitness Tableと呼ばれる概念からとった`std::witness`を代わりの名前として提案しています。

LEWGにおける検討では少なくとも`std::witness`は支持を得られなかったようです。

- [P3794 進行状況](https://github.com/cplusplus/papers/issues/2400)

### [P3795R0 Miscellaneous Reflection Cleanup](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3795r0.html)

リフレクション関連提案の間での文言の整合性を調整する提案。

2025年6月に行われた全体会議では、リフレクション関連の提案がほぼ同時にいくつもWDに採択されました。これらの提案はリフレクション機能に関するものではあるものの、それぞれスコープが異なるものが同時並行的に進行していたことによって、それぞれの仕様の間で不整合が生じている部分があります。この提案は、その様な問題点を修正しようとするものです。

この提案の修正は次のものです

1. 不足している述語の追加
    - `inline`や`constexpr`などの指定を取得するクエリ関数を追加する
        - `is_inline(info) -> bool`
        - `is_constexpr(info) -> bool`
        - `is_consteval(info) -> bool`
2. スコープ識別機能の追加
    - `std::meta::access_context`が追加されたことで、これを利用してある場所がどのスコープ（名前空間・クラス・関数など）なのかを判定することができるようになった
    - このような有用な情報のクエリは正式にサポートすべきなので、対応するメタ関数を追加する
3. `data_member_spec()`において、型とアノテーションの指定を`data_member_options`で指定するようにする
    - `define_aggregate()`において集成体型のメンバ変数を作成するための`data_member_spec()`関数では、メンバ型のリフレクションとその他プロパティを指定するオプション（`data_member_options`構造体）を受け取る
        - `data_member_spec(info type, data_member_options options) -> info`
    - 型だけを特別扱いして他のオプションと別に指定するのは奇妙なので、型の指定も`data_member_options`構造体で指定する
    - また、生成したメンバに対してアノテーションを付加しておくためのオプションを`data_member_options`構造体に追加する
4. 関数引数へのアノテーションのサポート
    - P3394R4（リフレクションのためのアノテーションサポート）と、P3096R12（関数引数のリフレクション）は独立して作業されほぼ同時に採択された提案
    - そのため、関数引数へのアノテーションは検討されていなかった
    - 関数引数へのアノテーションサポートを追加する
5. P1317R2で追加された型特性に対応する`consteval`メタ関数の追加
    - P1317R2も6月の会議で採択されたが、そこで追加された3つの型特性に対応するリフレクションメタ関数は提供されていなかったため、これを追加する
      - `is_applicable_type(info fn, info tuple) -> bool`
      - `is_nothrow_applicable_type(info fn, info tuple) -> bool`
      - `apply_result(info fn, info tuple) -> info`
6. エラー処理APIを一貫させる
    - P3650R2によってリフレクションのエラー報告は例外によるものになったが、P2996R13の型特性関数には適用されておらず、他の関連提案の関数にも適用されていない
    - 未適用のリフレクション関連関数のエラー報告は例外送出で一貫させる
7. エラーの内容をより詳細に指定する
    - リフレクション関数の失敗時に例外を送出する際に、`std::meta::exception`の`from()`から例外送出元関数のリフレクションを取得できることを明記する
    - リフレクション関数`F()`が例外を送出した場合、その`from()`からは`^^F`が取得できるようにする

この提案はNBコメント解決の一環としてC++26に向けて作業されています。

- [P3795 進行状況](https://github.com/cplusplus/papers/issues/2401)

### [P3796R0 Coroutine Task Issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3796r0.html)

`std::task`の設計上の問題点を修正する提案。

`std::task`は2025年6月の全体会議でC++26に向けて採択済みですが、その投票の前後でいくつかの問題点が指摘されていたようです。全体会議ではそれらの指摘が遅かったことや`std::task`をC++26に間に合わせるためなどの理由によりそのまま投票にかけられてC++26に採択されました。

この提案はそのような`std::task`に対する問題点とその解決案についてまとめたものです。ここで報告されているのは次のおおきく5つです

1. `affine_on`について
2. `std::task`の開始と終了の方法についての懸念
3. アロケータの取り扱い
4. `std::stop_token`の管理方法
5. その他の設計上の修正

これらの項目それぞれについていくつか個別の問題があり、問題を説明するとともに一部はその解決策も提案しています。

1. `affine_on`について
    1. `affine_on`のデフォルト実装の仕様不足
        - -> デフォルト実装を指定する
    2. `affine_on`の動作が明確ではない
        - -> 明確になるようなセマンティクスを提示
            - `affine_on`の`sender`の完了は、開始された実行エージェント上でインラインで完了するか、指定されたスケジューラに関連付けられた実行エージェント上で非同期的に完了するかのいずれかとする
    3. `affine_on`シグネチャが改善できうる
        - -> スケジューラを`receiver`の環境から取得できる可能性がある
    4. `affine_on`の暗黙的スケジュール操作には停止要求を伝播させない
        - コルーチンが中断したコンテキストで再開するために、`affine_on`の動作をキャンセルすべきではない
        - -> そのための設計選択肢を提示
    5. `affine_on`の暗黙的スケジュール操作には停止要求を伝播させない
        - 提案の議論時間の都合からカスタマイズについて曖昧にされているが、このアルゴリズムは他の`sender`においてもカスタマイズが有効である可能性がある
        - -> カスタマイズをサポートする方法を規定することを推奨
2. `std::task`の開始と終了の方法についての懸念
    1. `std::task`は`start()`時に再スケジュールすべきではない
        - `std::task`の実行が関連付けられたスケジューラ出確実に行われるようにするために、サスペンドしてスケジューリングしてから再開、という手順を取る
        - 中断再開等の度にスケジューラを往復することになり効率的ではない
        - -> 再スケジュールしないような設計選択肢を提示
    2. `std::task`を待機している`std::task`は再スケジュールすべきではない
        - `std::task`はその特性上開始時と同じスケジューラで完了する可能性が高いため、再スケジュールを回避できうる
        - -> その情報をクエリする方法など、そのための仕組みを整備する
    3. `std::task`は対称転送をサポートしていない
        - 仕様では対称転送について一切言及がない
        - -> ここでの3つの問題合わせて、`affine_on`と`as_awaitable`のカスタマイズによって解決することが望ましい
3. アロケータの取り扱い
    1. `std::generator`とアロケータカスタマイズの方法が異なる
        - `std::task`の場合、環境からアロケータ型を取得してその型に合致するアロケータをコルーチン引数で受け取る
        - 環境から取得できない場合にデフォルト（`std::allocator<std::byte>`）以外を受け取れない（ill-formedになる）
        - これは、`receiver`の環境を介した`get_allocator`クエリを処理するためだが、ここでのアロケータはコルーチンフレームの確保に使用されるもの
        - -> コルーチンフレームの確保に使用するアロケータについては、`std::generator`同様に`std::allocator_arg`引数によって任意のものを指定できるようにする
    2. `std::generator`と`std::allocator_arg`引数の位置が異なる
        - `std::generator`が引数の先頭なのに対して、`std::task`では任意の位置でよい
        - -> `std::task`も引数の先頭にする（任意の位置を許可するのは`std::generator`と同時に別に行う）
    3. 環境のアロケータを隠蔽しない
        - `std::task`の下流からの`get_allocator`クエリは`std::task`においてコルーチンフレームの確保に使用されたアロケータを返し、あとから接続された`receiver`の環境のアロケータを隠蔽してしまう
        - `std::task`でも`receiver`の環境のアロケータを使用する方が良い可能性が高いが、`std::task`は接続前に環境型を確定してしまう（下流の操作は同じアロケータを使用すべきというコルーチンの原則による）ため、困難がある
        - -> アロケータの型消去や互換性のあるアロケータのみ転送するなど、環境のものを優先することを検討する 
4. `stop_token`の管理方法
    1. `stop_source`を常に新規作成し格納してしまう
        - `std::task::promise_type`はストップトークン/ソースがデフォルトであるかに関わらずそれらを保持し、リレー的に上流の停止要求を伝播させる
        - これにはスペースと同期のコストがかかる
        - -> 接続後の`operation_state`においてストップトークン/ソースの型がデフォルトである場合は何も保持せず、`receiver`を介して上流のものを伝播させる
            - 型がデフォルトではない場合にのみ現在と同様に保持してリレーする
    2. `stop_token`型がデフォルト構築可能であるように扱っている
        - `stop_token`は通常`stop_source`から取得する必要があるためデフォルト構築可能ではないが、1の様に保存のためにメンバ変数を指定していることによってデフォルト構築可能性を要求（あるいは仮定）しているように見える
        - -> 1のように、`stop_token`を保存しないようにする
            - 環境から取得するか、`stop_source`から取得する
5. その他の設計上の修正
    1. `std::task`が積極的に開始される場合があるように見える（遅延実行されない場合があるように見える）
        - -> 紛らわしい文言を改善しかつより明確化することで、常に遅延実行することを明確にする
    2. コルーチンフレームの破棄が遅い
        - `std::task`が中断されたコルーチンから`final_suspend`に到達することなく完了した場合、コルーチンフレームは`operation_state`オブジェクトの破棄まで保持され続ける
        - コルーチンフレームは完了関数が呼び出されてからかなり後に破棄される可能性がある
        - -> 完了関数が呼び出される前に破棄されることを指定する
    3. `task<T, E>`にはデフォルト引数がない
        - -> `T = void`、`E = env<>`に設定する
    4. `unhandled_stopped()`に`noexcept`がない
        - -> この関数は`noexcept`関数から呼び出されるため、`noexcept`指定する
    5. 環境の保存が非効率な場合がある
        - `co_await`で待機した`sender`に接続するために使用された`receiver`の`get_env`から返される環境は、プロミス型の`state`メンバを参照して指定されているが、この中に場合によって無駄なコピーを発生させるものが入っている
        - -> 本当に必要になるまで環境を保存しないようにする
    6. 完了スケジューラがない
        - `std::task`は、`std::get_completion_scheduler<Tag>`クエリに応答する`get_env`を定義していない
        - これにより、正しいスケジューラで完了している場合でも再スケジュールが必要になる場合がある
        - -> `std::task`は完了スケジューラを知れるのは`std::task`の処理が完了した後であり、`get_completion_scheduler`が有用な場面はなさそう。将来必要になったら再検討する
    7.　待機可能な非`sender`型がサポートされない
        - `await_transform()`オーバーロードは`sender`を満たす引数を必要とするように制約されており、`sender`ではない待機可能な型は`std::task`のコルーチンに内で待機できない
        - -> `await_transform()`の制約を緩和して、サポートを拡大する
    7. `std::task::promise_type`が`with_awaitable_senders`を使用していないこと
        - `with_awaitable_senders`はコルーチンの`promise_type`の基底クラスとして使用して、`sender`を`co_await`可能にするためのものです
        - しかし、その対象の第一号のはずの`std::task`はいくつかの理由からこれを使用しておらず、`with_awaitable_senders`の設計の再検討が必要かもしれない
        - -> 少なくとも、`std::task`のプロミス型の仕様の`unhandled_stopped`の文言において、`set_stopped`完了が正しいスケジューラで呼び出されることを指定していない問題は修正すべき
    8. エラー発生時の`co_yield`を回避できる実装を取れる可能性
        - `std::task`では、例外を送出せずにエラー発生時に完了させるには`co_yield with_error(x)`を使用するが、`co_yield`は通常コルーチンの途中の処理であるため、利用者にとって驚きがある可能性がある
        - -> 現在提案中の機能を活用することでより優れたエラーハンドリングを行える可能性があるので、それを考慮しておく
    9. TLSを退避・復帰する機能がない
        - TLSへアクセスしている既存のコードの移行時に、コルーチンの中断とそのスレッドで別のコルーチンの再開が起きたり、`std::task`がスレッドプール上で実行していた場合に必ずしも同じスレッドに戻れないなど、移行の問題が起こりうる
        - `sender/receiver`では`receiver`の環境をこの目的で使用することが推奨されているが、既存のTLSを使用しているプログラムからの移行時にはTLSを中断時に退避し再開時に復帰する機能が必要
        - -> `affine_on`のカスタマイズによって対応できる

`affine_on(sndr, sch)`は`continues_on(sndr, sch)`とほぼ同じ動作をしますが、`sndr`の処理が`sch`上で完了することが分かっている場合に追加のスケジューリングを回避するように動作することを意図するものです。これは`std::task`と一緒に導入されている`sender`アルゴリズムです。コルーチンの中断と再開を正しく取り扱うためには、コルーチンが中断したのと同じ実行コンテキストで再開をする必要があり、そのために`continues_on`が使用できますが、`affine_on`を使用することでその操作の最適化を図ることができます。

`affine_on`は`std::task`に必須のアルゴリズムとして`std::task`と同時に導入されているものの、その動作の詳細や最適化・カスタマイズの方法などの仕様がかなりぼかして記述されており明確ではありません。これは`std::task`をC++26に間に合わせるための時間制約によるものとみられており、それによって`affine_on`に関連して問題が多く指摘されています（それだけではないですが）。

- [P3796 進行状況](https://github.com/cplusplus/papers/issues/2402)

### [P3798R0 The unexpected in `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3798r0.html)

`std::expected`に`.has_error()`を追加する提案。

`std::expected`は`std::optional`と共通するインターフェースを基本としており、オブジェクトが正常値を保持しているかどうかを調べるために`.has_value()`もしくは`bool`への変換演算子を使用できます。

一方で、`std::expected`は`std::optional`とは異なり値もしくはエラー値を保持するものであるため、そのエラー状態の側に特化した独自のインターフェースを持つことで、エラー処理に重点を置く場合により自然に記述することができるようになります。

この提案は、そのために`.has_error()`メンバ関数を追加しようとするものです。

`.has_error()`はその名の通り`.has_value()`の逆の動作をするもので、エラー状態の場合に`true`を返します。

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
if (!result.has_value()) {
  log_and_exit(result.error());
}
```

</td>
<td valign="top">

```cpp
if (result.has_error()) {
  log_and_exit(result.error());
}
```

</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
// somewhere in unit tests
ASSERT_TRUE(!result.has_value());
EXPECT_EQ(result.error(), "myError");
```

</td>
<td valign="top">

```cpp
// somewhere in unit tests
ASSERT_TRUE(result.has_error());
EXPECT_EQ(result.error(), "myError");
```

</td>
</tr>
</table>

- [P3798 進行状況](https://github.com/cplusplus/papers/issues/2403)

### [P3799R0 2025-07 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3799r0.html)

2025年5月に行われる予定の、LEWGにおける投票の予定。

次の提案が投票にかけられる予定です

- [P3125R5 constexpr pointer tagging](https://wg21.link/P3125R5)
- [P3778R0 Fix for type_order template definition](https://wg21.link/P3778R0)

P3125R5はC++29導入を目指して、P3778R0はC++26DRとするために、LWGに転送するための投票です。

### [P3801R0 Concerns about the design of `std::execution::task`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3801r0.html)

`std::execution::task`のC++26での採用を再考することを促す提案。

P3796R0とも共通するものですが、こちらには`std::execution::task`（P3552R3）が採択されるまでの過程が詳しく書かれています。

それによれば、P3552R3はC++26 feature freeze期限（おそらくLWGの期限、2月頃）に間に合わなかったものの、期限後にLEWGとLWG共同のスピードレビューによって2025年6月の全体会議にかけられ、異議申し立てはあったもののC++26に採択されました。

しかし、このような例外的な経路を辿っているにもかかわらず必要な手続きが取られておらず、P3552R0の提出も2025年に入ってからと遅かったため議論が尽くされていない可能性があります。実際著者の方も、2025年6月の会議直前までP3552R3がC++26向けに検討されていることに気づいていなかったため問題点の指摘が遅れたとしています。

この提案はそのような拙速なプロセスへの非難と、`std::execution::task`設計の問題点について指摘し、C++26から取り下げることを提案するものです。

- 重大な懸念事項
    1. 対称転送をサポートしていないこと
    2. `task`のコルーチンフレームの破棄が遅い
        - コルーチン引数とローカル変数の破棄が、`task`の`operation_state`の破棄まで延期される
        - `|`でつないだパイプライン全体が終了するまで、コルーチン状態が破棄されない
    3. ダングリング参照への対策の欠如
        - コルーチン引数に参照を渡すと、それが浅くコピーされ（参照のままコピーされ）コルーチンフレームに格納されることで、参照の生存期間に注意を払う必要がある
        - 言語の改善には時間がかかるが、ライブラリソリューションがすでに存在しているため、対応すべき
- その他の懸念事項
    1. `co_yield with_error(x)`というエラー処理の方法
        - 直観的ではないため、言語を修正して`co_return`を使用できるようにすべき
    2. `co_await ex::schedule(sch)`という高コストなno-op
        - これは通常の`sender`チェーンであればスケジューラを変更することを意味するが、`task`においては異なる
            - 正確には、`change_coroutine_scheduler`を使用する
        - 1の変更によって`co_yield`を解放し、`co_yield sch`のようにして簡易にスケジューラ変更をできるようにする
    3. コルーチンのキャンセルがアドホック
        - C++20コルーチンはそのキャンセルをサポートしていないため、`std::execution`ではコルーチンのプロミス型を拡張して`unhandled_stopped`というカスタマイズポイントを設けた
        - 言語そのものを拡張して、コルーチンのキャンセルをネイティブにサポートすべき
          - これにより、対称転送をサポート可能にもなる

おおくはP3796R0での指摘と共通しています。

その他の懸念事項についてはC++26に間に合わせる必要はないものの、時間的余裕があれば解決が可能だった可能性があるとしています。

P3552R3については設計の検討不足をその著者の方も認めているようで、問題はNBコメントを通して解決することを意図していたようです。この提案はそれに反対しており、問題があることが分かっていたのならば無理に間に合わせるべきではなかったとして、C++26へのP3552R3採択を再検討することを要求しています。

- [P3801 進行状況](https://github.com/cplusplus/papers/issues/2405)

### [P3802R0 Poor Functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3802r0.pdf)

呼び出されている場所のコンテキストに依存する関数から、そのコンテキスト依存性を分離する提案。

このような関数の代表は、`std::source_location::current()`です。

```cpp
namespace std { 

  struct source_location { 
    static consteval source_location current() noexcept; 
    ... 
  }; 
} 
```

宣言だけを見ればこれは普通の静的関数であり、その他の関数にラップしても動作するように見えます。

```cpp
consteval auto curr_loc() { 
  return std::source_location::current(); 
}
```

しかし実際にはこれは意図通りに機能しません。`std::source_location::current()`はコンパイル時のグローバル状態や呼び出しが行われるローカルコンテキストに依存した結果を取得するため、関数にラップしたものを呼び出すとラップしない場合と結果が異なります。

```cpp
using srcloc = std::source_location; 

consteval auto number(srcloc loc = srcloc::current()) { 
  return loc.line(); 
}

auto r = number(); 
```

したがって、このコードにおいて`srcloc::current()`の呼び出しを`curr_loc()`の呼び出しに置き換えることはできません。これは、`srcloc::current()`の呼び出しはそれが出現するソースロケーションコンテキストを取得するものの、デフォルト引数として使用されている場合はそのデフォルト引数が使用されるコンテキストを取得するためです。

上記`curr_loc()`の様な関数においてこのような振る舞いを再現する方法はありません。

`std::source_location::current()`はこのような振る舞いを持つ標準内で最初の関数でしたが、C++26では`std::meta::access_context::current()`という関数が同様の振る舞いを持つものとして新しく追加されています。また、同種の関数の提案が潜在的に存在しているようです。

この提案では、これらの関数について暗黙的なローカルコンテキストに依存するのではなく、ローカルコンテキストを明示的にし、それに依存する通常の関数として定義するようにすることを提案しています。

```cpp
namespace std { 
  struct source_location { 
    static consteval source_location current(std::meta::info = __local_ctx) noexcept; 
    ... 
  };
}
```

この`__local_ctx`というのはキーワードによって指定される言語組み込みのもので、現在`std::source_location::current()`が特別に持っているローカルコンテキスト情報を表す値です。

これを用いると、`curr_loc()`は次のように書き直すことができます

```cpp
consteval auto curr_loc(std::meta::info c = __local_ctx) { 
  return std::source_location::current(c); 
}
```

これにより、`curr_loc()`は`std::source_location::current()`のような関数をラップしながらもその望ましい動作を達成することができます。そして、元来`std::source_location::current()`が持っていたような魔法的な性質は`__local_ctx`に分離されることで、同種の関数を普通の関数として定義することができるようになります（`std::source_location::current()`の性質はユーザー定義関数では完全に再現できない部分があり、特別な規定を必要としている）。

`__local_ctx`は当初は実装依存のものとして導入しておき、将来必要になった際に標準構文へ昇格させることを提案しています。また、型としては`std::meta::info`が完全に適切としています。

- [P3802 進行状況](https://github.com/cplusplus/papers/issues/2406)
