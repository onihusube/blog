# ［C++］WG21月次提案文書を眺める（2025年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-08)

全部で26本あります。

もくじ

[:contents]

### [N5013 Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n5013.pdf)
### [N5014 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf)
### [N5015 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5015.html)
### [N5019 Business Plan and Convener's Report: ISO/IEC JTC1/SC22/WG21 (C++)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5019.pdf)
### [P2414R10 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r10.pdf)
### [P2843R3 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r3.pdf)
### [P3100R4 A framework for systematically addressing undefined behaviour in the C++ Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r4.pdf)
### [P3337R0 Graph Library: Library Comparisons](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3337r0.pdf)

提案中のグラフライブラリと既存のグラブライブラリの比較を行った文書。

この文書は一連のグラフライブラリ提案の一部として、提案中のグラフライブラリ（の参照実装graph-v2）と既存のグラフライブラリ（主にBoost Graph: BGL）との書き味とパフォーマンスについての比較を行った結果を報告するものです。

文書では、まずP3128 でTier1として提示されているアルゴリズムの一部について比較を行っています。扱われているアルゴリズムは次のものです

- 幅優先探索
- 連結成分
- 単一始点最短路
- 三角形カウント

両ライブラリでこれらのアルゴリズムがどのように記述できるかを比較し、大きなデータセットにおけるその実行パフォーマンスを比較しています。

提案文書より、幅優先探索コードの比較。

BGL

```cpp
using namespace std;
using namespace boost;

using G = compressed_sparse_row_graph<directedS, no_property, no_property>;
using Vertex = graph_traits<G>::vertex_descriptor;

G g;
// populate g

vector<Vertex> parents(num_vertices(g));

auto vis = make_bfs_visitor(
  make_pair(
    record_predecessors(parents.begin(), on_tree_edge())
  )
);

breadth_first_search(g, vertex(0, g), visitor(vis));
```

graph-v2
```cpp
using namespace std;
using namespace graph;

using G = container::compressed_graph<void, void, void, uint32_t, uint32_t>;
using VId = vertex_id_t<G>;

G g;
//  populate g

vector<VId> parents(size(vertices(g)));

auto bfs = edges_breadth_first_search_view<G, void, true>(g, 0);

for (auto&& [uid, vid, uv] : bfs) {
  parents[vid] = uid;
}
```

詳細な比較結果については提案を参照してください。

全体として、最新のC++機能を使用することでよりシンプルに記述できつつ、多くの場面でBGLを大きく上回るパフォーマンスを発揮しています。

- [stdgraph/graph-v2: General-purpose C++ graph library](https://github.com/stdgraph/graph-v2)
- [P3337 進行状況](https://github.com/cplusplus/papers/issues/2410)

### [P3347R4 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r4.pdf)
### [P3427R2 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3427r2.pdf)
### [P3428R2 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3428r2.pdf)
### [P3643R1 std::to_signed and std::to_unsigned](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r1.html)
### [P3688R2 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r2.html)
### [P3692R2 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r2.pdf)
### [P3702R1 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r1.html)
### [P3719R1 std::is_vector_bool_reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3719r1.html)
### [P3739R2 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r2.html)
### [P3774R1 Rename std::nontype, and make it broadly useful](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3774r1.html)
### [P3775R0 Slides for P3774R0 - Rename std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3775r0.html)
### [P3779R0 `reserve()` and `capacity()` for flat containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3779r0.pdf)

`std::flat_map`等のflatなコンテナに、`reserve()`と`capacity()`メンバ関数を追加する提案。

`std::flat_set`、`std::flat_map`、`std::flat_multiset`、`std::flat_multimap`はメモリ上で連続した領域にソート済み配列を構築することでメモリの局所性を高め、イテレーションのパフォーマンスを向上させた連想コンテナです。

これらのコンテナはいずれも内部で別のシーケンスコンテナを使用しており、デフォルトでは`std::vector`が使用されています（最後の方のテンプレート引数で変えられる）。

```cpp
namespace std {
  // flat_mapの宣言例
  template <class Key,
            class T,
            class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_map;
}
```

`flat`コンテナはこれらの内部コンテナに関する操作をほとんど公開しておらず、特に`reserve()`の様なパフォーマンス上重要なインターフェースも公開していません。

そのため、`flat`コンテナで`reserve()`を行おうとすると、`.key()/.value()`を使って得た`const`参照を`const_cast`するか、`.extract()`を使って取り出したコンテナを`.replace()`で戻す、という方法を取らざるを得ません。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// 1. 内部コンテナ参照をconst_cast
const_cast<std::vector<std::string>&>(fmap.keys()).reserve(100);     
const_cast<std::vector<std::string>&>(fmap.values()).reserve(100); 

// 2. 取り出した内部コンテナを戻す
auto tmp = std::move(fmap).extract(); 
tmp.keys.reserve(100); 
tmp.values.reserve(100); 
fmap.replace(std::move(tmp.keys), std::move(tmp.values)); 
```

1つ目の方法は、`set`系のコンテナが`.key()/.value()`を提供していないため`flat_set`などでは使えません。2つ目の方法は、これらのインターフェース特有の事情による注意事項がいくつかあるためリスクがあります。

この提案はこの問題の解決のために、`.reserve()`と`.capacity()`を`flat`コンテナに追加することを提案しています。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// proposed: 
fmap.reserve(100); 

// proposed: 
if (fmap.capacity() == fmap.size()) { 
  fmap.reserve(100); 
} 
```

- `.reserve()`
    - 内部コンテナのどちらか片方がサポートしている場合に提供
    - サポートしている内部コンテナに対して対応する`.reserve()`を呼び出す
- `.capacity()`
    - 内部コンテナの両方がサポートしている場合に提供
    - 内部コンテナの返す`.capacity()`の値の最小値を返す

そして、`set`系のコンテナに対して`.key()/.value()`メンバ関数を追加することも提案しています。

```cpp
std::flat_map<std::string> fset = ...;

// どちらの関数からも同じコンテナが取得できる
const auto& data1 = fset.keys();     
const auto& data2 = fset.values(); 
```

`set`系のコンテナの場合、key=valueであるので`.key()/.value()`メンバ関数はどちらも同じ内部コンテナへの`const`参照を返します。

- [`<flat_map>` - cpprefjp](https://cpprefjp.github.io/reference/flat_map.html)
- [`<flat_set>` - cpprefjp](https://cpprefjp.github.io/reference/flat_set.html)
- [P3779 進行状況](https://github.com/cplusplus/papers/issues/2412)

### [P3790R1 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r1.pdf)
### [P3796R1 Coroutine Task Issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3796r1.html)
### [P3798R1 The unexpected in std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3798r1.html)
### [P3806R0 views::cycle](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3806r0.html)

- [ 進行状況](https://github.com/cplusplus/papers/issues/)

### [P3809R0 Should we make `std::linalg` reductions deduce return types like fold algorithms?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3809r0.html)

`std::linalg`にあるリダクション系の関数の戻り値型の決定方法を変更しないようにすることを促す提案。

`std::linalg`にある`dot()`や`vector_two_norm()`などのリダクション（`std::accumulate`や`ranges::fold_left`などのように、範囲の各要素に何か処理をしてその結果を集計していくような計算）を行うような関数の戻り値型の決定方法は、`std::recude`などの設計を踏襲して初期値の型を戻り値型として使用します。しかし、C++23の`ranges::fold_left`など`fold`操作においては、初期値と範囲の参照型を使用した二項演算の結果の型を推論して戻り値型として使用します。

```cpp
// linalgのリダクション操作
std::mdspan<double, std::dims> vec1 = ...;
std::mdspan<double, std::dims> vec2 = ...;

std::same_as<int> auto dot = std::linalg::dot(vec1, vec2, 0); // ✅

// ranges::fold系リダクション操作
std::vector<double> vec3 = ...;

std::same_as<double> auto foldl = std::ranges::fold_left(vec3, 0, std::plus<>{}); // ✅

// std::reduce
std::same_as<int> auto reduce = std::reduce(vec3.begin(), vec3.end(), 0, std::plus<>{}); // ✅
```

このように、C++23以降のよく似た操作であってもその戻り値型の決定過程が異なります。また、`ranges::fold_left`の戻り値型決定方法は、オリジナルの`std::accumulate`（`std::reduce`も同様）において初期値の型で戻り値型が決まってしまうことが問題点として認識されていたことからそれを改善したものです。

また、数値アルゴリズムのRange版の提案（P3732R0）でも`ranges::fold_left`の設計を踏襲して同じ戻り値型の決定方法を採用していることもあり、`std::linalg`リダクション系の関数でも`ranges::fold_left`と同様の戻り値型の決定方法を取るべきではないかという声が上がったようです。

この提案は、それらの設計選択は合理的なものとしつつも、`std::linalg`は現在の動作が理になかったものであるとして変更しない様にすることを提案するものです。

この理由としては次の事を挙げています

1. 式テンプレートとの相性の良さ
    - `std::reduce`は式テンプレートによって計算が行われるような要素型をうまく扱えるが、`ranges::fold_left`はそうではない
    - 数値計算分野においては式テンプレートが比較的良く使用されるため、考慮する必要がある
2. BLAS規格との一貫性
    - BLASのFortran 95インターフェースは、初期値の型によって戻り値型が決定される
3. 戻り値型の簡単な制御
    - 線形代数領域と混合制度数値演算に精通しているユーザーは、戻り値型を推測するのではなく明示的に指定することを好む傾向にある

これらの理由から、`std::linalg`の現在の動作は線形代数計算の領域においては理に適ったものであるため、現状のまま変更しないことを推奨しています。

- [P3809 進行状況](https://github.com/cplusplus/papers/issues/2414)

### [P3810R0 hardened memory safety guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3810r0.html)

標準ライブラリ内の基本的な操作について、未定義動作の余地がないことを規定しておく提案。

C++26では標準ライブラリに堅牢化モードを導入し、一部の事前条件が堅牢化された事前条件としてC++26 Contractsの枠組みによって実行時にチェックされるようになります（P3471R4/P3607R0）。

コンテナ型はそこには当然含まれていますが、そのチェックにおいては`.size()`や`.empty()`といったメンバ関数が使用されます。これは実装を考慮すると未定義動作の余地なく実装可能と考えられますが、標準ではそのようなことを一切指定していません。

C++26 Contractsそのものが未定義動作が無いこと（契約チェック時のUBフリー）を保証してはいませんが、契約チェックに使用されるこれらの関数がUBフリーであることを保証できれば、少なくとも標準ライブラリの堅牢化モードの範囲においてはそのチェックがUBを伴わないことを保証することができます。

これらの理由からこの提案では、堅牢化モードのチェックに使用される標準ライブラリ中の基本的とみなされる操作について、未定義動作無しの実装を要求することを提案しています。

提案での対象は次の関数です

- `.size()`
- `.empty()`
- イテレータの差分計算（`-`）
- `static_extent()`
- `.extent()`
- `.has_value()`
- `.valueless_by_exception()`
- `.holds_alternative<I>()`

これらの関数はメンバ変数の値を返すだけの単純な実装になるはずであり、UBの余地なく実装できるはずです。そしてそれはすでに行われているはずでもあるため、この提案による実装の変更は必要なく、実装者にUBフリーであることを要求することは不合理ではないとしています。

- [P3810 進行状況](https://github.com/cplusplus/papers/issues/2415)
