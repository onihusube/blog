# ［C++］WG21月次提案文書を眺める（2025年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-08)

全部で26本あります。

もくじ

[:contents]

### [N5013 Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n5013.pdf)
### [N5014 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf)
### [N5015 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5015.html)
### [N5019 Business Plan and Convener's Report: ISO/IEC JTC1/SC22/WG21 (C++)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5019.pdf)
### [P2414R10 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r10.pdf)
### [P2843R3 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r3.pdf)
### [P3100R4 A framework for systematically addressing undefined behaviour in the C++ Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r4.pdf)
### [P3337R0 Graph Library: Library Comparisons](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3337r0.pdf)

提案中のグラフライブラリと既存のグラブライブラリの比較を行った文書。

この文書は一連のグラフライブラリ提案の一部として、提案中のグラフライブラリ（の参照実装graph-v2）と既存のグラフライブラリ（主にBoost Graph: BGL）との書き味とパフォーマンスについての比較を行った結果を報告するものです。

文書では、まずP3128 でTier1として提示されているアルゴリズムの一部について比較を行っています。扱われているアルゴリズムは次のものです

- 幅優先探索
- 連結成分
- 単一始点最短路
- 三角形カウント

両ライブラリでこれらのアルゴリズムがどのように記述できるかを比較し、大きなデータセットにおけるその実行パフォーマンスを比較しています。

提案文書より、幅優先探索コードの比較。

BGL

```cpp
using namespace std;
using namespace boost;

using G = compressed_sparse_row_graph<directedS, no_property, no_property>;
using Vertex = graph_traits<G>::vertex_descriptor;

G g;
// populate g

vector<Vertex> parents(num_vertices(g));

auto vis = make_bfs_visitor(
  make_pair(
    record_predecessors(parents.begin(), on_tree_edge())
  )
);

breadth_first_search(g, vertex(0, g), visitor(vis));
```

graph-v2
```cpp
using namespace std;
using namespace graph;

using G = container::compressed_graph<void, void, void, uint32_t, uint32_t>;
using VId = vertex_id_t<G>;

G g;
//  populate g

vector<VId> parents(size(vertices(g)));

auto bfs = edges_breadth_first_search_view<G, void, true>(g, 0);

for (auto&& [uid, vid, uv] : bfs) {
  parents[vid] = uid;
}
```

詳細な比較結果については提案を参照してください。

全体として、最新のC++機能を使用することでよりシンプルに記述できつつ、多くの場面でBGLを大きく上回るパフォーマンスを発揮しています。

- [stdgraph/graph-v2: General-purpose C++ graph library](https://github.com/stdgraph/graph-v2)
- [P3337 進行状況](https://github.com/cplusplus/papers/issues/2410)

### [P3347R4 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r4.pdf)
### [P3427R2 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3427r2.pdf)
### [P3428R2 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3428r2.pdf)
### [P3643R1 std::to_signed and std::to_unsigned](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r1.html)
### [P3688R2 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r2.html)
### [P3692R2 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r2.pdf)
### [P3702R1 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r1.html)
### [P3719R1 std::is_vector_bool_reference](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3719r1.html)
### [P3739R2 Standard Library Hardening - using std::optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r2.html)
### [P3774R1 Rename std::nontype, and make it broadly useful](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3774r1.html)
### [P3775R0 Slides for P3774R0 - Rename std::nontype](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3775r0.html)
### [P3779R0 `reserve()` and `capacity()` for flat containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3779r0.pdf)

`std::flat_map`等のflatなコンテナに、`reserve()`と`capacity()`メンバ関数を追加する提案。

`std::flat_set`、`std::flat_map`、`std::flat_multiset`、`std::flat_multimap`はメモリ上で連続した領域にソート済み配列を構築することでメモリの局所性を高め、イテレーションのパフォーマンスを向上させた連想コンテナです。

これらのコンテナはいずれも内部で別のシーケンスコンテナを使用しており、デフォルトでは`std::vector`が使用されています（最後の方のテンプレート引数で変えられる）。

```cpp
namespace std {
  // flat_mapの宣言例
  template <class Key,
            class T,
            class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_map;
}
```

`flat`コンテナはこれらの内部コンテナに関する操作をほとんど公開しておらず、特に`reserve()`の様なパフォーマンス上重要なインターフェースも公開していません。

そのため、`flat`コンテナで`reserve()`を行おうとすると、`.key()/.value()`を使って得た`const`参照を`const_cast`するか、`.extract()`を使って取り出したコンテナを`.replace()`で戻す、という方法を取らざるを得ません。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// 1. 内部コンテナ参照をconst_cast
const_cast<std::vector<std::string>&>(fmap.keys()).reserve(100);     
const_cast<std::vector<std::string>&>(fmap.values()).reserve(100); 

// 2. 取り出した内部コンテナを戻す
auto tmp = std::move(fmap).extract(); 
tmp.keys.reserve(100); 
tmp.values.reserve(100); 
fmap.replace(std::move(tmp.keys), std::move(tmp.values)); 
```

1つ目の方法は、`set`系のコンテナが`.key()/.value()`を提供していないため`flat_set`などでは使えません。2つ目の方法は、これらのインターフェース特有の事情による注意事項がいくつかあるためリスクがあります。

この提案はこの問題の解決のために、`.reserve()`と`.capacity()`を`flat`コンテナに追加することを提案しています。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// proposed: 
fmap.reserve(100); 

// proposed: 
if (fmap.capacity() == fmap.size()) { 
  fmap.reserve(100); 
} 
```

- `.reserve()`
    - 内部コンテナのどちらか片方がサポートしている場合に提供
    - サポートしている内部コンテナに対して対応する`.reserve()`を呼び出す
- `.capacity()`
    - 内部コンテナの両方がサポートしている場合に提供
    - 内部コンテナの返す`.capacity()`の値の最小値を返す

そして、`set`系のコンテナに対して`.key()/.value()`メンバ関数を追加することも提案しています。

```cpp
std::flat_map<std::string> fset = ...;

// どちらの関数からも同じコンテナが取得できる
const auto& data1 = fset.keys();     
const auto& data2 = fset.values(); 
```

`set`系のコンテナの場合、key=valueであるので`.key()/.value()`メンバ関数はどちらも同じ内部コンテナへの`const`参照を返します。

- [`<flat_map>` - cpprefjp](https://cpprefjp.github.io/reference/flat_map.html)
- [`<flat_set>` - cpprefjp](https://cpprefjp.github.io/reference/flat_set.html)
- [P3779 進行状況](https://github.com/cplusplus/papers/issues/2412)

### [P3790R1 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r1.pdf)
### [P3796R1 Coroutine Task Issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3796r1.html)
### [P3798R1 The unexpected in std::expected](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3798r1.html)
### [P3806R0 views::cycle](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3806r0.html)
### [P3809R0 Should we make std::linalg reductions deduce return types like fold algorithms?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3809r0.html)
### [P3810R0 hardened memory safety guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3810r0.html)

- [ 進行状況](https://github.com/cplusplus/papers/issues/)