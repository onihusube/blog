# ［C++］WG21月次提案文書を眺める（2025年08月）

文書の一覧

- [JTC1/SC22/WG21 - Papers mailing2025-08](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/#mailing2025-08)

全部で26本あります。

もくじ

[:contents]

### [N5013 Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/prot/14882fdis/n5013.pdf)

C++26規格書のCommittee Draft。委員会に所属していないと見られないようです。

### [N5014 Working Draft, Standard for Programming Language C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5014.pdf)

C++26のワーキングドラフト第8弾。

### [N5015 Editors' Report - Programming Languages - C++](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5015.html)

↑の変更点をまとめた文書。

### [N5019 Business Plan and Convener's Report: ISO/IEC JTC1/SC22/WG21 (C++)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5019.pdf)

ビジネスユーザ向けのC++およびWG21の現状報告書。

### [P2414R10 Pointer lifetime-end zap proposed solutions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r10.pdf)

Pointer lifetime-end zapと呼ばれる問題の解決策の提案。

以前の記事を参照

- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R1 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年08月）](https://onihusube.hatenablog.com/entry/2021/09/03/230045#P2414R1-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R2 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2023年12月）](https://onihusube.hatenablog.com/entry/2024/02/29/191439#P2414R2-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R3 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年04月）](https://onihusube.hatenablog.com/entry/2024/08/31/233056#P2414R3-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R4 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P2414R4-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R5 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2414R5-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R6 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2414R6-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R7 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P2414R7-Pointer-lifetime-end-zap-proposed-solutions)
- [P2414R9 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P2414R9-Pointer-lifetime-end-zap-proposed-solutions)

このリビジョンでの変更は

- LIFO Pushアルゴリズムに関する歴史を纏めたセクション『The Ancient History of LIFO Push』を追加

などです。

- [P2414 進行状況](https://github.com/cplusplus/papers/issues/1084)

### [P2843R3 Preprocessing is never undefined](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2843r3.pdf)

プリプロセッサに存在する未定義動作を取り除く提案。

以前の記事を参照

- [P2843R0 Preprocessing is never undefined - WG21月次提案文書を眺める（2023年05月）](https://onihusube.hatenablog.com/entry/2023/07/08/205803#P2843R0-Preprocessing-is-never-undefined)
- [P2843R1 Preprocessing is never undefined - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P2843R1-Preprocessing-is-never-undefined)
- [P2843R2 Preprocessing is never undefined - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P2843R2-Preprocessing-is-never-undefined)

このリビジョンでの変更は

- EWGにおいて設計上の選択を確認
    - キーワードに一致するマクロはill-formedとなるべき
    - `//`コメント内で垂直方向のホワイトスペースをサポートする
- フィードバックにより、一部のケースで現在のIFNDRを維持する
    - `#include`ディレクティブにおいて、マクロ展開後の標準形式のいずれとも一致しない場合
    - マクロが定義済みのpreprocessor operatorに展開される場合

などです。

この提案は2025年6月の全体会議で承認され、C++26に採択されています。

- [P2843 進行状況](https://github.com/cplusplus/papers/issues/1548)

### [P3100R4 A framework for systematically addressing undefined behaviour in the C++ Standard](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3100r4.pdf)

UB（及びEB）を契約違反として扱うようにする提案。

以前の記事を参照

- [P3100R0 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年05月）](https://onihusube.hatenablog.com/entry/2024/11/24/155428#P3100R0-Undefined-and-erroneous-behaviour-are-contract-violations)
- [P3100R1 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3100R1-Undefined-and-erroneous-behaviour-are-contract-violations)
- [P3100R2 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3100R2-Implicit-contract-assertions)
- [P3100R3 Undefined and erroneous behaviour are contract violations - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3100R3-Implicit-contract-assertions)

このリビジョンでの変更は

- P3754R0に合わせて提案を更新
- Sofia会議でのフィードバックを適用
- UBリストからUBとして指定されるべきではなく、CWG Issueがあるものを削除
- `noexcept`との相互作用に関する議論を追加
- 提案の構成を改善
- 提案のスコープを反映してタイトルを更新

などです。

- [P3100 進行状況](https://github.com/cplusplus/papers/issues/1901)

### [P3337R0 Graph Library: Library Comparisons](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3337r0.pdf)

提案中のグラフライブラリと既存のグラフライブラリの比較を行った文書。

この文書は一連のグラフライブラリ提案の一部として、提案中のグラフライブラリ（の参照実装graph-v2）と既存のグラフライブラリ（主にBoost Graph: BGL）との書き味とパフォーマンスについての比較を行った結果を報告するものです。

文書では、まずP3128 でTier1として提示されているアルゴリズムの一部について比較を行っています。扱われているアルゴリズムは次のものです

- 幅優先探索
- 連結成分
- 単一始点最短路
- 三角形カウント

両ライブラリでこれらのアルゴリズムがどのように記述できるかを比較し、大きなデータセットにおけるその実行パフォーマンスを比較しています。

提案文書より、幅優先探索コードの比較。

BGL

```cpp
using namespace std;
using namespace boost;

using G = compressed_sparse_row_graph<directedS, no_property, no_property>;
using Vertex = graph_traits<G>::vertex_descriptor;

G g;
// populate g

vector<Vertex> parents(num_vertices(g));

auto vis = make_bfs_visitor(
  make_pair(
    record_predecessors(parents.begin(), on_tree_edge())
  )
);

breadth_first_search(g, vertex(0, g), visitor(vis));
```

graph-v2
```cpp
using namespace std;
using namespace graph;

using G = container::compressed_graph<void, void, void, uint32_t, uint32_t>;
using VId = vertex_id_t<G>;

G g;
//  populate g

vector<VId> parents(size(vertices(g)));

auto bfs = edges_breadth_first_search_view<G, void, true>(g, 0);

for (auto&& [uid, vid, uv] : bfs) {
  parents[vid] = uid;
}
```

詳細な比較結果については提案を参照してください。

全体として、最新のC++機能を使用することでよりシンプルに記述できつつ、多くの場面でBGLを大きく上回るパフォーマンスを発揮しています。

- [stdgraph/graph-v2: General-purpose C++ graph library](https://github.com/stdgraph/graph-v2)
- [P3337 進行状況](https://github.com/cplusplus/papers/issues/2410)

### [P3347R4 Invalid/Prospective Pointer Operations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r4.pdf)

無効化されたポインタに対する一部の演算を明示的に許可する提案。

以前の記事を参照

- [P3347R0 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2024年08月）](https://onihusube.hatenablog.com/entry/2025/01/26/185126#P3347R0-InvalidProspective-Pointer-Operations)
- [P3347R1 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2025年01月）](https://onihusube.hatenablog.com/entry/2025/08/30/234243#P3347R1-InvalidProspective-Pointer-Operations)
- [P3347R2 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3347R2-InvalidProspective-Pointer-Operations)
- [P3347R3 Invalid/Prospective Pointer Operations - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3347R3-InvalidProspective-Pointer-Operations)

このリビジョンでの変更は良くわかりませんが、編集者を追加したり、文書と文言の修正などのようです。

- [P3347 進行状況](https://github.com/cplusplus/papers/issues/2019)

### [P3427R2 Hazard Pointer Synchronous Reclamation](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3427r2.pdf)

ハザードポインタライブラリにSynchronous Reclamation機能拡張を追加する提案。

以前の記事を参照

- [P3427R0 Hazard Pointer Synchronous Reclamation - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3427R0-Hazard-Pointer-Synchronous-Reclamation)
- [P3427R1 Hazard Pointer Synchronous Reclamation - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3427R1-Hazard-Pointer-Synchronous-Reclamation)

このリビジョンでの変更は

- `hazard_pointer_asynchronous_reclamation`を`hazard_pointer_try_reclamation`にリネーム
- `retire_to_cohort`の文言に、"May reclaim possibly-reclaimable members of c."を追加

などです。

- [P3427 進行状況](https://github.com/cplusplus/papers/issues/2094)

### [P3428R2 Hazard Pointer Batches](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3428r2.pdf)

ハザードポインタライブラリに複数のハザードポインタをまとめて構築・破棄する機能拡張を追加する提案。

以前の記事を参照

- [P3428R0 Hazard Pointer Batches - WG21月次提案文書を眺める（2024年10月）](https://onihusube.hatenablog.com/entry/2025/04/20/205527#P3428R0-Hazard-Pointer-Batches)
- [P3428R1 Hazard Pointer Batches - WG21月次提案文書を眺める（2024年12月）](https://onihusube.hatenablog.com/entry/2025/05/18/195724#P3428R1-Hazard-Pointer-Batches)

このリビジョンでの変更は

- 事前条件を緩和し、それを文言に反映
- `reset_hazard_pointer_batch`を`clear_hazard_pointer_batch`にリネーム
- `span1, span2`を`span_from, span_to`に変更
- なるべく`N`の代わりに`span.size()`を使用する

などです。

- [P3428 進行状況](https://github.com/cplusplus/papers/issues/2095)

### [P3643R1 `std::to_signed` and `std::to_unsigned`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3643r1.html)

整数型を対応する符号付/符号なしの整数型に簡易に変換する関数の提案。

以前の記事を参照

- [P3643R0 `std::to_signed` and `std::to_unsigned` - WG21月次提案文書を眺める（2025年03月）](https://onihusube.hatenablog.com/entry/2025/09/30/224815#P3643R0-stdto_signed-and-stdto_unsigned)

このリビジョンでの変更は

- 制約を厳格化し、`cv bool`だけでなくCV修飾型全般を除外
- 機能テストマクロに`freestanding`を追加

などです。

- [P3643 進行状況](https://github.com/cplusplus/papers/issues/2280)

### [P3688R2 ASCII character utilities](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3688r2.html)

ASCIIに関連する文字の判定・処理関数群を提供する提案。

以前の記事を参照

- [P3688R0 ASCII character utilities - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3688R0-ASCII-character-utilities)
- [P3688R1 ASCII character utilities - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3688R1-ASCII-character-utilities)

このリビジョンでの変更は

- `ascii_case_insensitive_compare()`の戻り値型の誤りを修正
- `ascii_case_insensitive_compare()`の定義における`strong_ordering`の`std::`プリフィックスを削除

などです。

- [P3688 進行状況](https://github.com/cplusplus/papers/issues/2318)

### [P3692R2 How to Avoid OOTA Without Really Trying](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3692r2.pdf)

P3064R2を要約した文書、および現在の実装ではOOTAが起こらないことを明確化する提案。

以前の記事を参照

- [P3692R0 How to Avoid OOTA Without Really Trying - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3692R0-How-to-Avoid-OOTA-Without-Really-Trying)
- [P3692R1 How to Avoid OOTA Without Really Trying - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3692R1-How-to-Avoid-OOTA-Without-Really-Trying)

このリビジョンでの変更は

- `volatile`セマンティクスに関する変更について再検討
- この提案が他のOOTA研究者にもたらす利点について言及
- 著者リストの更新

などです。

- [P3692 進行状況](https://github.com/cplusplus/papers/issues/2322)

### [P3702R1 Stricter requirements for document submissions (SD-7)](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3702r1.html)

HTML形式の提案文書について一定のルールを設ける提案。

以前の記事を参照

- [P3702R0 Stricter requirements for document submissions (SD-7) - WG21月次提案文書を眺める（2025年05月）](https://onihusube.hatenablog.com/entry/2025/12/16/230316#P3702R0-Stricter-requirements-for-document-submissions-SD-7)

このリビジョンでの変更は

- 変更点の協調スタイルの変更
- アクセシビリティガイダンスとしてN3325への言及

などです。

- [P3702 進行状況](https://github.com/cplusplus/papers/issues/2331)

### [P3719R1 `std::is_vector_bool_reference`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3719r1.html)

`std::vector<bool>`を検出する型特性を追加する提案。

以前の記事を参照

- [P3719R0 `std::is_vector_bool_reference` - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3719R0-stdis_vector_bool_reference)

このリビジョンでの変更は

- 概念・提案する文言・実装経験、について追加

などです。

- [P3719 進行状況](https://github.com/cplusplus/papers/issues/2351)

### [P3739R2 Standard Library Hardening - using `std::optional<T&>`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3739r2.html)

`std::inplace_vector`において、`std::optional<T&>`を利用して堅牢化モードを導入する提案。

以前の記事を参照

- [P3739R1 Standard Library Hardening - using `std::optional` - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3739R1-Standard-Library-Hardening---using-stdoptional)

このリビジョンでの変更は

- `exception_ptr`の検査を追加
- `define_static_{string,object,array}`を追加
- `const`を追加

などです。

- [P3739 進行状況](https://github.com/cplusplus/papers/issues/2368)

### [P3774R1 Rename `std::nontype`, and make it broadly useful](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3774r1.html)

`std::nontype`を`std::constant_arg`にリネームする提案。

以前の記事を参照

- [P3774R0 Rename `std::nontype`, and make it broadly useful - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3774R0-Rename-stdnontype-and-make-it-broadly-useful)

このリビジョンでの変更は

- LEWGレビューを反映
    - `std::nontype`の`std::constant_arg`へのリネーム
- この提案は`std::nontype`のリネームのみを行うものであることを明確化
    - 以前の提案内容も残しておく
- §2.2. Post-Sofia decisions にLEWGレビューの決定事項を要約
- abstractの更新

などです。

この提案は、2025年11月の全体会議を通過し、C++26に採択されています。前述のように、リネームのみを行っています。

- [P3774 進行状況](https://github.com/cplusplus/papers/issues/2388)

### [P3775R0 Slides for P3774R0 - Rename `std::nontype`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3775r0.html)

P3774R0の紹介スライド。

P3774R0については以前の記事を参照

- [P3774R0 Rename `std::nontype`, and make it broadly useful - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3774R0-Rename-stdnontype-and-make-it-broadly-useful)

このスライドではC++26タイムフレーム内での`std::nontype`の経緯を説明し、P3774R0での変更を簡単に紹介しています。

### [P3779R0 `reserve()` and `capacity()` for flat containers](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3779r0.pdf)

`std::flat_map`等のflatなコンテナに、`reserve()`と`capacity()`メンバ関数を追加する提案。

`std::flat_set`、`std::flat_map`、`std::flat_multiset`、`std::flat_multimap`はメモリ上で連続した領域にソート済み配列を構築することでメモリの局所性を高め、イテレーションのパフォーマンスを向上させた連想コンテナです。

これらのコンテナはいずれも内部で別のシーケンスコンテナを使用しており、デフォルトでは`std::vector`が使用されています（最後の方のテンプレート引数で変えられる）。

```cpp
namespace std {
  // flat_mapの宣言例
  template <class Key,
            class T,
            class Compare = less<Key>,
            class KeyContainer = vector<Key>,
            class MappedContainer = vector<T>>
  class flat_map;
}
```

`flat`コンテナはこれらの内部コンテナに関する操作をほとんど公開しておらず、特に`reserve()`の様なパフォーマンス上重要なインターフェースも公開していません。

そのため、`flat`コンテナで`reserve()`を行おうとすると、`.key()/.value()`を使って得た`const`参照を`const_cast`するか、`.extract()`を使って取り出したコンテナを`.replace()`で戻す、という方法を取らざるを得ません。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// 1. 内部コンテナ参照をconst_cast
const_cast<std::vector<std::string>&>(fmap.keys()).reserve(100);     
const_cast<std::vector<std::string>&>(fmap.values()).reserve(100); 

// 2. 取り出した内部コンテナを戻す
auto tmp = std::move(fmap).extract(); 
tmp.keys.reserve(100); 
tmp.values.reserve(100); 
fmap.replace(std::move(tmp.keys), std::move(tmp.values)); 
```

1つ目の方法は、`set`系のコンテナが`.key()/.value()`を提供していないため`flat_set`などでは使えません。2つ目の方法は、これらのインターフェース特有の事情による注意事項がいくつかあるためリスクがあります。

この提案はこの問題の解決のために、`.reserve()`と`.capacity()`を`flat`コンテナに追加することを提案しています。

```cpp
std::flat_map<std::string, std::string> fmap = ...;

// proposed: 
fmap.reserve(100); 

// proposed: 
if (fmap.capacity() == fmap.size()) { 
  fmap.reserve(100); 
} 
```

- `.reserve()`
    - 内部コンテナのどちらか片方がサポートしている場合に提供
    - サポートしている内部コンテナに対して対応する`.reserve()`を呼び出す
- `.capacity()`
    - 内部コンテナの両方がサポートしている場合に提供
    - 内部コンテナの返す`.capacity()`の値の最小値を返す

そして、`set`系のコンテナに対して`.key()/.value()`メンバ関数を追加することも提案しています。

```cpp
std::flat_set<std::string> fset = ...;

// どちらの関数からも同じコンテナが取得できる
const auto& data1 = fset.keys();     
const auto& data2 = fset.values(); 
```

`set`系のコンテナの場合、key=valueであるので`.key()/.value()`メンバ関数はどちらも同じ内部コンテナへの`const`参照を返します。

- [`<flat_map>` - cpprefjp](https://cpprefjp.github.io/reference/flat_map.html)
- [`<flat_set>` - cpprefjp](https://cpprefjp.github.io/reference/flat_set.html)
- [P3779 進行状況](https://github.com/cplusplus/papers/issues/2412)

### [P3790R1 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r1.pdf)

ポインタの参照先の寿命が尽きた後でも使用可能なライブラリユーティリティを提供する提案。

以前の記事を参照

- [P3790R0 Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3790R0-Pointer-lifetime-end-zap-proposed-solutions-Bag-of-bits-pointer-class)

このリビジョンでの変更は

- `launder_bag_of_bits_ptr()`と`bag_of_bits_ptr<T>`を`launder_ptr_bits()`と`ptr_bits<T>`にリネーム
- 以前の`usable_ptr<T>`に対する別名候補の追加

などです。

- [P3790 進行状況](https://github.com/cplusplus/papers/issues/2396)

### [P3796R1 Coroutine Task Issues](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3796r1.html)

`std::task`の設計上の問題点を修正する提案。

以前の記事を参照

- [P3796R0 Coroutine Task Issues - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3796R0-Coroutine-Task-Issues)

このリビジョンでの変更は

- `co_return { ... };`をサポートする提案を追加
- P3801R0への回答を追加
- `co_yield with_error(e)`が使いにくい理由を追記
- `change_coroutine_scheduler`で`scheduler`が代入可能であることを要求するという議論を追加
- `operator co_await`の追加に関する議論を追加
- `bulk`と`task_scheduler`に関する議論を追加
- 右辺値修飾子の欠落に関する議論を追加
- `return_value`と`return_void`に関する仕様が欠落しているという問題を追加
- その他小さな修正

などです。

この提案では、以前の記事の分類における"その他の設計上の修正"のカテゴリに次の問題を追加しています

- `co_return { ... };`のサポート追加
    - プロミス型の`return_value()`はテンプレートパラメータにデフォルト値が無いことで`{}`を使用できない
    - テンプレート引数のデフォルトを設定することで`{}`による初期化をサポートする
- `co_await change_coroutine_scheduler(sched)`では代入可能な`scheduler`が必要になっている
    - 効果の規定で`std::exchange`を使用していることで`sched`に代入可能であることを要求しているが、`scheduler`は通常それが必須ではない
    - -> `std::exchange`を使用しない定義で置き換えるか、代入可能性を`scheduler`の置換可能性の判定に使用する
- `sender`非対応コルーチンは`task`を`co_await`できるべき
    - いくつかの制約（提案文書 3.5.15 Sender Unaware Coroutines Should Be Able To co_await A task を参照）を考慮すると、現時点では`task`に`operator co_await`を追加しないことが妥当と思われる
- `task_scheduler`での`bulk`の使用に関する問題
    - 通常の`sender`と異なり、コルーチンで使用される`scheduler`の型は`task`の作成時に認識されている必要があり、接続時にカスタム`scheduler`を使用するためには、型消去スケジューラである`task_scheduler`を使用する
    - `sender`アルゴリズムを特定のスケジューラ向けにカスタマイズする場合、`task_scheduler`が（型消去されていることによって）そのカスタマイズを伝達できないことで、意図通りに動作しない場合がある
    - `bulk`アルゴリズムと`parallel_scheduler`がその典型例
    - -> いくつかの選択肢を提示
- 右辺値修飾子の欠落
    - `task_scheduler`にネストされた`sender`は必ずしもコピー可能ではなく、操作は型消去されるため、`task_scheduler::ts-sender::connect`は右辺値修飾する必要がある
    - コルーチンはコピーできず、コルーチンハンドルを別のオブジェクトに転送する場合その操作は右辺値修飾する必要があるため、`task<T, E>::connect`も右辺値修飾する必要がある
- `return_value`と`return_void`の仕様の欠落
    - プロミス型の`return_value`と`return_void`は宣言されてはいるもののその仕様が欠落している
    - -> 対応する文言を提案

また、P3801R0への回答では提示されている問題点はこの提案でもある程度カバーされており理解できるものの、`std::execution::task`を削除する理由にはならないとしています。

こことP3801で挙げられている問題のうち緊急性のあるものについてはNBコメント対応やLWG Issue対応としてC++26に向けて修正するつもりのようです。

- [P3796 進行状況](https://github.com/cplusplus/papers/issues/2402)

### [P3798R1 The unexpected in `std::expected`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3798r1.html)

`std::expected`に`.has_error()`を追加する提案。

以前の記事を参照

- [P3798R0 The unexpected in `std::expected` - WG21月次提案文書を眺める（2025年07月）](https://onihusube.hatenablog.com/entry/2026/01/16/235211#P3798R0-The-unexpected-in-stdexpected)

このリビジョンでの変更は

- 例では`std::expected<void, std::string>`を使用するようにした
- フィードバックによる文言の改善
- `__cpp_lib_expected`の値を更新
- 謝辞の追加

などです。

- [P3798 進行状況](https://github.com/cplusplus/papers/issues/2403)

### [P3806R0 `views::cycle`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3806r0.html)

入力範囲を無限に循環する範囲を生成するRangeアダプタ、`views::cycle`の提案。

`views::repeat(v)`は`v`の繰り返しによる範囲を生成するのに対して、`views::cycle(r)`は範囲`r`を循環イテレーションすることによる繰り返し範囲を生成するものです。現在これは、`views::repeat(r) | views::join`を用いて近似できます。

```cpp
std::vector<int> r = {1, 2, 3};

for (auto&& v : views::repeat(r) | views::join) {
  // 1, 2, 3, 1, 2, 3, 1, 2... という要素列をイテレーションし続ける
  ...
}
```

これには`views::join`を通すことによってもっとも強くても`bidirectional_range`にしかならないなどの問題があり、専用のアダプタを用意することで直観的に使用できるようになるとして、`views::cycle`を追加することを提案しています。

提案文書より、サンプルコード

```cpp
for (auto&& song : playlist | views::cycle | views::take(100)) {
  play(song);
}
```

元の範囲を繰り返す性質上マルチパス保証が必要となるため、`views::cycle(r)`の`r`は`forward_range`である必要があります。

元の範囲を`R`として、その他の性質は次のようになっています

- `range`カテゴリ
    - `R`が`random_access_range`かつ`sized_range`: `random_access_range`
    - `R`が`bidirectional_range`かつ`common_range`: `bidirectional_range`
    - それ以外: `forward_range`
- `common_range`: ×
- `borrowed_range`: ×
- `sized_range`: ×
- `const-iterable`: `const R`が`forward_range`であれば

Range-v3にある同等のアダプタ`views::cycled`では元の範囲の終端イテレータを積極的にキャッシュすることで、元の範囲のカテゴリを可能な限り維持しようとしますが、`views::cycle`ではそれを行っていません（カテゴリが`bidirectional_range`/`random_access_range`になる場合の条件）。

また、`views::cycle`は同じ範囲を循環していることから`iter_swap`を提供しません。これは、イテレータとして異なる位置にある要素でも元の範囲上では同じ要素を指している可能性があり、その状況で`iter_swap`すると自己代入のようなことが起こってしまうためです。

- [P3806 進行状況](https://github.com/cplusplus/papers/issues/2413)

### [P3809R0 Should we make `std::linalg` reductions deduce return types like fold algorithms?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3809r0.html)

`std::linalg`にあるリダクション系の関数の戻り値型の決定方法を変更しないようにすることを促す提案。

`std::linalg`にある`dot()`や`vector_two_norm()`などのリダクション（`std::accumulate`や`ranges::fold_left`などのように、範囲の各要素に何か処理をしてその結果を集計していくような計算）を行うような関数の戻り値型の決定方法は、`std::reduce`などの設計を踏襲して初期値の型を戻り値型として使用します。しかし、C++23の`ranges::fold_left`など`fold`操作においては、初期値と範囲の参照型を使用した二項演算の結果の型を推論して戻り値型として使用します。

```cpp
// linalgのリダクション操作
std::mdspan<double, std::dims<1>> vec1 = ...;
std::mdspan<double, std::dims<1>> vec2 = ...;

std::same_as<int> auto dot = std::linalg::dot(vec1, vec2, 0); // ✅

// ranges::fold系リダクション操作
std::vector<double> vec3 = ...;

std::same_as<double> auto foldl = std::ranges::fold_left(vec3, 0, std::plus<>{}); // ✅

// std::reduce
std::same_as<int> auto reduce = std::reduce(vec3.begin(), vec3.end(), 0, std::plus<>{}); // ✅
```

このように、C++23以降のよく似た操作であってもその戻り値型の決定過程が異なります。また、`ranges::fold_left`の戻り値型決定方法は、オリジナルの`std::accumulate`（`std::reduce`も同様）において初期値の型で戻り値型が決まってしまうことが問題点として認識されていたことからそれを改善したものです。

また、数値アルゴリズムのRange版の提案（P3732R0）でも`ranges::fold_left`の設計を踏襲して同じ戻り値型の決定方法を採用していることもあり、`std::linalg`リダクション系の関数でも`ranges::fold_left`と同様の戻り値型の決定方法を取るべきではないかという声が上がったようです。

この提案は、それらの設計選択は合理的なものとしつつも、`std::linalg`は現在の動作が理に適ったものであるとして変更しない様にすることを提案するものです。

この理由としては次の事を挙げています

1. 式テンプレートとの相性の良さ
    - `std::reduce`は式テンプレートによって計算が行われるような要素型をうまく扱えるが、`ranges::fold_left`はそうではない
    - 数値計算分野においては式テンプレートが比較的良く使用されるため、考慮する必要がある
2. BLAS規格との一貫性
    - BLASのFortran 95インターフェースは、初期値の型によって戻り値型が決定される
3. 戻り値型の簡単な制御
    - 線形代数領域と混合精度数値演算に精通しているユーザーは、戻り値型を推測するのではなく明示的に指定することを好む傾向にある

これらの理由から、`std::linalg`の現在の動作は線形代数計算の領域においては理に適ったものであるため、現状のまま変更しないことを推奨しています。

- [P3809 進行状況](https://github.com/cplusplus/papers/issues/2414)

### [P3810R0 hardened memory safety guarantees](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3810r0.html)

標準ライブラリ内の基本的な操作について、未定義動作の余地がないことを規定しておく提案。

C++26では標準ライブラリに堅牢化モードを導入し、一部の事前条件が堅牢化された事前条件としてC++26 Contractsの枠組みによって実行時にチェックされるようになります（P3471R4/P3607R0）。

コンテナ型はそこには当然含まれていますが、そのチェックにおいては`.size()`や`.empty()`といったメンバ関数が使用されます。これは実装を考慮すると未定義動作の余地なく実装可能と考えられますが、標準ではそのようなことを一切指定していません。

C++26 Contractsそのものが未定義動作が無いこと（契約チェック時のUBフリー）を保証してはいませんが、契約チェックに使用されるこれらの関数がUBフリーであることを保証できれば、少なくとも標準ライブラリの堅牢化モードの範囲においてはそのチェックがUBを伴わないことを保証することができます。

これらの理由からこの提案では、堅牢化モードのチェックに使用される標準ライブラリ中の基本的とみなされる操作について、未定義動作無しの実装を要求することを提案しています。

提案での対象は次の関数です

- `.size()`
- `.empty()`
- イテレータの差分計算（`-`）
- `static_extent()`
- `.extent()`
- `.has_value()`
- `.valueless_by_exception()`
- `.holds_alternative<I>()`

これらの関数はメンバ変数の値を返すだけの単純な実装になるはずであり、UBの余地なく実装できるはずです。そしてそれはすでに行われているはずでもあるため、この提案による実装の変更は必要なく、実装者にUBフリーであることを要求することは不合理ではないとしています。

- [P3810 進行状況](https://github.com/cplusplus/papers/issues/2415)
