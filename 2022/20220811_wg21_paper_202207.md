# ［C++］WG21月次提案文書を眺める（2022年07月）

文書の一覧

- [JTC1/SC22/WG21 - Papers 2022 mailing2022-07](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/#mailing2022-07)

全部で47本あります。

[:contents]

### [P0009R18 MDSPAN](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0009r18.html)

多次元配列に対する`std::span`である、`mdspan`の提案。

以前の記事を参照

- [P0009R12 MDSPAN - WG21月次提案文書を眺める（2021年05月）](https://onihusube.hatenablog.com/entry/2021/06/13/165215#P0009R12-MDSPAN)
- [P0009R13 MDSPAN - WG21月次提案文書を眺める（2021年10月）](https://onihusube.hatenablog.com/entry/2021/11/13/193322#P0009R13-MDSPAN)
- [P0009R14 MDSPAN - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P0009R14-MDSPAN)
- [P0009R15 MDSPAN - WG21月次提案文書を眺める（2022年02月）](https://onihusube.hatenablog.com/entry/2022/03/19/224729#P0009R15-MDSPAN)
- [P0009R16 MDSPAN - WG21月次提案文書を眺める（2022年03月）](https://onihusube.hatenablog.com/entry/2022/04/02/175835#P0009R16-MDSPAN)
- [P0009R17 MDSPAN - WG21月次提案文書を眺める（2022年07月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P0009R17-MDSPAN)

このリビジョンでの変更は、LWGのフィードバックを受けての文言調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P0009 進行状況](https://github.com/cplusplus/papers/issues/96)

### [P1018R17 C++ Language Evolution status - pandemic edition - 2022/06-2022/07](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1018r17.html)
### [P1083R6 Move resource_adaptor from Library TS to the C++ WP](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1083r6.pdf)
### [P1255R8 A view of 0 or 1 elements: views::maybe](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1255r8.pdf)
### [P1642R11 Freestanding Library: Easy [utilities], [ranges], and [iterators]](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1642r11.html)
### [P1684R3 mdarray: An Owning Multidimensional Array Analog of mdspan](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1684r3.html)
### [P1899R3 stride_view](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1899r3.html)
### [P1967R8 #embed - a simple, scannable preprocessor-based resource acquisition method](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1967r8.html)
### [P2047R3 An allocator-aware optional type](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2047r3.html)
### [P2079R3 System execution context](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2079r3.html)
### [P2165R4 Compatibility between tuple, pair and tuple-like objects](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2165r4.pdf)
### [P2248R5 Enabling list-initialization for algorithms](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2248r5.html)
### [P2295R6 Support for UTF-8 as a portable source file encoding](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf)
### [P2361R5 Unevaluated strings](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2361r5.pdf)
### [P2374R4 views::cartesian_product](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2374r4.html)
### [P2404R3 Move-only types for equality_comparable_with, totally_ordered_with, and three_way_comparable_with](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r3.pdf)
### [P2417R2 A more constexpr bitset](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2417r2.pdf)
### [P2419R2 Clarify handling of encodings in localized formatting of chrono types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html)
### [P2460R2 Relax requirements on wchar_t to match existing practices](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2460r2.pdf)
### [P2474R2 views::repeat](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2474r2.html)
### [P2481R1 Forwarding reference to specific type/template](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2481r1.html)
### [P2494R2 Relaxing range adaptors to allow for move only types](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2494r2.html)
### [P2513R4 char8_t Compatibility and Portability Fix](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2513r4.html)
### [P2547R1 Language support for customisable functions](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2547r1.html)
### [P2548R0 `copyable_function`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2548r0.pdf)

`std::move_only_function`に対して、コピー可能な*Callable*ラッパである`copyable_function`の提案。

C++23で導入された`std::move_only_function`は、その関数シグネチャに`const`/参照修飾と`noexcept`を指定することができ、呼び出し時に自信の`const`性と値カテゴリを保持する*Callable*オブジェクトまで伝播させたうえで呼び出しを行うことができます。これによって、`std::move_only_function`オブジェクトの`const`有無と右辺値であるかの状態と、保持する*Callbale*オブジェクトの呼び出し環境を一致させることができます。

一方`std::function`にはそのようなサポートはなく、そのために`const`修飾のミスマッチバグ等の設計上の問題がいくつか指摘されていました。

- `const`修飾を正しく扱えない
- ムーブのみ可能な（コピーできない）*Callable*オブジェクトを保持できない
- 左辺値から呼び出す*Callable*オブジェクトしか保持できない（参照修飾を正しく扱えない）

`std::move_only_function`は`std::fucntion`の持つこれらの問題と軽微ないくつかの問題（RTTIへの依存、呼び出し時の空チェック）を解決するために導入されましたが、名前が示すとおりに`std::move_only_function`のオブジェクトはムーブしかできません（ムーブしかできない*Callable*だけを保持可能なわけではありません）。

コピー可能な`std::move_only_function`が欲しい場合は`std::function`を使用するしかないのですが、`std::function`には上記のような問題があります。また、後方互換のためには、`std::function`を`std::move_only_function`のような設計に変更することもできません。

この提案は、コピー可能かつ現在の`std::function`の問題を解決した、`std::move_only_function`のコピー可能なバージョンである`std::copyable_function`を標準ライブラリに追加する提案です。

`std::move_only_function`が保持する*Callable*は`copyable`であっても単に`movable`でしかなくても大丈夫ですが、`std::copyable_function`は`copyable`な*Callable*しか保持できません。それ以外のところでは、`std::move_only_function`にコピーコンストラクタとコピー代入演算子を追加しただけです。

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ✔
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() /*const*/ { … }};

copyable_function<void(void)> func0{lambda};    // ✔
const auto & ref0{func0};

func0();  // ✔
ref0();   // ❌ operator() is NOT const! 

copyable_function<void(void) const> func1{lambda};  // ✔
const auto & ref1{func1};

func1();  // ✔
ref1();   // ✔ operator() is const! 
```

</pre>
</td>
</tr>
</table>

<table>
<tr>
<th>現在</th>
<th>この提案</th>
</tr>
<tr>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

function<void(void)> func{lambda};  // ✔
const auto & ref{func};

func(); // ✔
ref();  // ⁉✔ operator() is const! 
        //     this is the infamous constness-bug
```

</td>
<td valign="top">

```cpp
auto lambda{[&]() mutable { … }};

copyable_function<void(void)> func{lambda}; // ✔
const auto & ref{func};

func(); // ✔
ref();  // ❌ operator() is NOT const! 

copyable_function<void(void) const> tmp{lambda};  // ❌
```

</pre>
</td>
</tr>
</table>

- [N4159 `std::functionand` Beyond](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4159.pdf)
- [MFHava/P2548 - Github](https://github.com/MFHava/P2548)
- [P2548 進行状況](https://github.com/cplusplus/papers/issues/1275)

### [P2549R1 std::unexpected should have error() as member accessor](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2549r1.html)
### [P2561R0 `operator??`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2561r0.html)

`std::expected`などを返す関数において、エラーの伝播を自動化させる演算子`??`の提案。

例外を投げうる関数を扱う関数が自身も例外を投げうる場合、例外を伝播させるための構文的なコストはゼロです。

```cpp
auto foo(int i) noexcept(false) -> int; // might throw an E
auto bar(int i) noexcept(false) -> int; // might throw an E

auto strcat(int i) noexcept(false) -> std::string {
  int f = foo(i);
  int b = bar(i);

  return std::format("{}{}", f, b);
}

// あるいはインライン化してこう書ける
auto strcat(int i) noexcept(false) -> std::string {
  return std::format("{}{}", foo(i), bar(i));
}
```

例外をハンドルせずに伝播させるためには、追加で何かを書く必要はありません。

ただし、例外にはその他多くの問題があるためあまり好まれず、その代替手段の一つとしてC++23からは`std::expected<T, E>`が使用できます。

```cpp
auto foo(int i) -> std::expected<int, E>;
auto bar(int i) -> std::expected<int, E>;

auto strcat(int i) -> std::expected<std::string, E> {
  auto f = foo(i);
  if (not f) {
    return std::unexpected(f.error());
  }

  auto b = bar(i);
  if (not b) {
    return std::unexpected(b.error());
  }

  return std::format("{}{}", *f, *b);
}
```

こちらの場合、エラーをハンドルせず伝播させる場合でも、そのためのかなり冗長なコードを追加しなければならず、値の取り出しにおいても`*`を使用しなければなりません。また、その際に考慮すべきことがいくつも潜んでいます（適切なムーブなど）。

そのため、`std::expected`に似た機能を提供するライブラリでは、このような処理をマクロによってラップする機能を提供しています。

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  SOMETHING_TRY(int f, foo(i));
  SOMETHING_TRY(int b, bar(i));
  return std::format("{}{}", f, b);
}
```

この場合は例外を使用するコードにかなり近くなりますが、マクロを使用していることから`f, b`の宣言を省いてインライン化することができません。これもまたマクロを工夫することで解決できますが、それは特定のコンパイラ拡張に頼っていたり適切にムーブされないなど効率的とは言えないものです。

コルーチンを用いて近しいシンタックスシュガーを再現することもできます。

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  int f = co_await foo(i);
  int b = co_await bar(i);
  co_return std::format("{}{}", f, b);

  // ... or
  co_return std::format("{}{}", co_await foo(i), co_await bar(i));
}
```

しかし、現在のところコルーチンは動的なメモリ確保を必ずしも回避できないため、これもまた効率的なコードではありません。

結局のところ、現在のC++における`std::expected`のエラー伝播手法としては、マクロによるものがベストとなります。

別の言語、例えばRustでは、`std::expected`に対応する`result`型がエラー伝播によく使用されています。Rustでは、先程のサンプルコードは例えば次のように書けます。

<table>
<tr>
<th>Rust</th>
<th>C++</th>
</tr>
<tr>
<td valign="top">

```cpp
fn strcat(i: i32) -> Result<String, E> {
  let f = match foo(i) {
      Ok(i) => i,
      Err(e) => return Err(e),
  };

  let b = match bar(i) {
      Ok(i) => i,
      Err(e) => return Err(e),
  }

  Ok(format!("{}{}", f, b))
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  auto f = foo(i);
  if (not f) {
      return std::unexpected(f.error());
  }

  auto b = bar(i);
  if (not b) {
      return std::unexpected(b.error());
  }

  return std::format("{}{}", *f, *b);
}
```

</pre>
</td>
</tr>
</table>

パターンマッチングの利用によって中間変数が必要ないなど、これだけでもRustの方が良い書き方ができますが、Rustにおいてのベストな書き方はこれではありません。

<table>
<tr>
<th>Rust</th>
<th>C++(例外)</th>
</tr>
<tr>
<td valign="top">

```cpp
fn strcat(i: i32) -> Result<String, E> {
  let f = foo(i)?;
  let b = bar(i)?;
  Ok(format!("{}{}", f, b))

  // ... or simply ...
  Ok(format!("{}{}", foo(i)?, bar(i)?))
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::string {
  int f = foo(i);
  int b = bar(i);
  return std::format("{}{}", f, b);

  // ... or simply ...
  return std::format("{}{}", foo(i), bar(i));
}
```

</pre>
</td>
</tr>
</table>

この場合、1文字（`?`）の構文上のオーバーヘッドによって、C++の例外を用いたコードとほぼ同等の半自動エラー伝播処理を記述できています。1文字とはいえオーバーヘッドではありますが、`std::expected`を使用するコードにおけるマクロに比べたらこのオーバーヘッドは無視できるでしょう。

理想的にはこれをC++に導入したいのですが、条件演算子`?:`と曖昧になる可能性があるためこの`?`を単項後置演算子として単純に導入できません。

```cpp
// ?:と?がある場合、次のコードは
auto res = a ? * b ? * c : d;

// 以下の2つのパース先がある
auto res1 = a ? (*(b?) * c) : d;
auto res2 = ((a?) * b) ? (*c) : d;
```

そのため、この提案では1文字増やした`??`演算子を`std::expected`等のためのエラー伝播半自動化構文として導入することを提案しています。

この演算子は上で示したRustの`?`に対応するもので、コンパイル時には範囲`for`のように展開されます。

<table>
<tr>
<th>展開前</th>
<th>展開後</th>
</tr>
<tr>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E>{


  int f = foo(i)??;









  int b = bar(i)??;








  return std::format("{}{}", f, b);
}
```

</td>
<td valign="top">

```cpp
auto strcat(int i) -> std::expected<std::string, E> {
  using _Return = std::try_traits<
      std::expected<std::string, E>>;

  auto&& __f = foo(i);
  using _TraitsF = std::try_traits<
      std::remove_cvref_t<decltype(__f)>>;
  if (not _TraitsF::is_ok(__f)) {
      return _Return::from_error(
          _TraitsF::extract_error(FWD(__f)));
  }
  int f = _TraitsF::extract_value(FWD(__f));

  auto&& __b = bar(i);
  using _TraitsB = std::try_traits<
      std::remove_cvref_t<decltype(__b)>>;
  if (not _TraitsB::is_ok(__b)) {
      return _Return::from_error(
          _TraitsB::extract_error(FWD(__b)));
  }
  int b = _TraitsB::extract_value(FWD(__b));

  return std::format("{}{}", f, b);
}
```

</pre>
</td>
</tr>
</table>

展開に当たっては、対象のオブジェクトからエラー状態と中身の値を取り出す必要があり、また、それらの値から戻り値をどう構築するかを指定する必要があります。それを担っているのが`std::try_traits`という型特性で、次の静的メンバ関数を持っています

- `is_ok` : オブジェクトのエラー状態を取得する
- `extract_value/extract_error` : 正常値/エラー値を取得する
- `from_value/from_error` : 正常値/エラー値からその型のオブジェクトを構築する

これは、`std::expected`のような型に対して簡単にアダプトできます。

```cpp
// std::optionalでの例
template <class T>
struct try_traits<optional<T>> {
  using value_type = T;
  using error_type = nullopt_t;

  auto is_ok(optional<T> const& o) -> bool {
    return o.has_value();
  }

  // extractors
  auto extract_value(auto&& o) -> auto&& {
    return *FWD(o);
  }
  auto extract_error(auto&&) -> error_type {
    return nullopt;
  }

  // factories
  auto from_value(auto&& v) -> optional<T> {
    return optional<T>(in_place, FWD(v));
  }
  auto from_error(nullopt_t) -> optional<T> {
    return {};
  }
};

// std::expectedでの例
template <class T, class E>
struct try_traits<expected<T, E>> {
  using value_type = T;
  using error_type = E;

  auto is_ok(expected<T, E> const& e) -> bool {
    return e.has_value();
  }

  // extractors
  auto extract_value(auto&& e) -> auto&& {
    return *FWD(e);
  }
  auto extract_error(auto&& e) -> auto&& {
    return FWD(e).error();
  }

  // factories
  auto from_value(auto&& v) -> expected<T, E> {
    return expected<T, E>(in_place, FWD(v));
  }
  auto from_error(auto&& e) -> expected<T, E> {
    return expected<T, E>(unexpect, FWD(e));
  }
};
```

また、この提案の`try_traits`はC#等のnull条件演算子`?.`のような演算子のために必要なものをすべて提供します。

```cpp
auto f(int) -> std::expected<std::string, E>;

// 将来の可能性？
auto x = f(42)?.size();
```

- [P2561 進行状況](https://github.com/cplusplus/papers/issues/1276)

### [P2579R0 Mitigation strategies for P2036 “Changing scope for lambda trailing-return-type”](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2579r0.pdf)

P2036R3による後方非互換性を緩和する提案。

P2036R3（ラムダ式の後置戻り値型がキャプチャする変数のスコープの変更）はC++23のWDに導入されており、以前のバージョンに対するDRとして採択されています。P2036については以前の記事を参照。

- [P2036R1 Changing scope for lambda trailing-return-type - WG21月次提案文書を眺める（2021年01月）](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P2036R1-Changing-scope-for-lambda-trailing-return-type)

この提案の検討段階では、この変更によって影響を受けるコードはほぼ無いだろうと思われていました。しかし、clangで実装されたところclangそのもの（llvm/libstdc++）のコードを壊している事が判明しました。それは次のようなコードです

```cpp
// なんかイテレータ範囲のendの値
auto local_end = ...;

[local_end](decltype(local_end) it) { return it != local_end; };
//          ^^^^^^^^^^^^^^^^^^^
```

後置戻り値型指定ではなく引数型でキャプチャした変数を参照しているコードが存在しており、P2036R3ではこれはill-formedとしています。なぜなら、ここではまだ`mutable`が見えていないため、`decltype((x))`の型を正しく求める事ができないためです。しかし、以前はこの`x`は外の変数をキャプチャしていたため問題にならず、少なくともコードを書いた人間の意図通りには動いていました。

このようなコードは[CWG2569](https://cplusplus.github.io/CWG/issues/2569.html)として報告され、これを先行実装することで解決されました。ここでは、`mutable`が現れる（場所に到達する）前にキャプチャ変数が`decltype`などで使用される場合、`decltype(x)`は許可するものの`decltype((x))`は許可しないようにすることで`mutable`の影響を受けないようにしつつ既存のコードが壊れないようにしています。

しかしその後、次のような別のコードが壊れている事が報告されました

```cpp
template <typename It, typename MapFn>
auto MapJoin(It first, It last, MapFn map_fn) {
  return std::accumulate(first, last, map_fn(*first),
                         // a new diagnostic: error: captured variable 'first' cannot appear here
                         [=](typename std::result_of<MapFn(decltype(*first))>::type result) { });
}

void foo() {
  int x = [x](int y[sizeof x]) { return sizeof x; }(0);
}
```

これらのコード破壊が報告された結果clangではP2036の実装を一旦停止したためこれ以上の破損例を収集できませんでしたが、実装された場合より多くのコードを壊すことになる事が予想されます。結果として、clangの実装者（筆者の方）はP2036R3は実装不可能であると考えているようです。

これらのコードに共通することは、C++11時点でジェネリックラムダが導入されていなかったことによる代替手段であるように思われます。従って、現在ジェネリックラムダを使用するコードをC++11で書こうとした場合にP2036に違反するコードになる可能があり、コーナーケースであると切って捨てられるほどおかしなコードであるわけではありません。

この提案は、P2036R3の変更を修正してその悪影響を緩和しようとするものです。ここでは、5つのソリューションが提示されています。

1. CWG2569の修正
2. `mutable`が現れた場合、ラムダ式の引数宣言内でキャプチャを参照するコードをill-formedにする
3. パース時に`mutable`キーワードを先読みする
4. キャプチャされた変数を参照するものの、常に`mutable`有無を考慮しない

EWGでは5番目の解決策が選択され、この提案はそのための文言を含んでいます。

それぞれのデメリットの概要は次のようになっています

1. CWG2569の修正
      - ラムダの変数宣言部で一部の用法（`decltype(x)`など）だけを許可するようにする 
      - 許可されるかが式に左右されるため理解しづらい（`decltype(*x)`はngなど）
      - 前述の通り、これだけでは破損するコードがまだある
2. `mutable`が現れる前は、ラムダの外側の変数をキャプチャする
      - つまりC++20以前（現在）の挙動
      - `decltype(expr)`の結果が`mutable`の前後で異なることはラムダ式本体開始（`{`）の前後で異なることよりも良いとは言えない
3. `mutable`が現れた場合、ラムダ式の引数宣言内でキャプチャを参照するコードをill-formedにする
      - 破損は減少するが完全ではない
      - 後から見つかる`mutable`によってエラー有無が変わるのは奇妙
4. パース時に`mutable`キーワードを先読みする
      - 完璧では無いものの、最善の解決策
      - 実装の負担が大きい
      - 後から見つかる`mutable`によって構文の意味が変わるのは奇妙
5. キャプチャされた変数を参照するものの、常に`mutable`有無を考慮しない
      - `decltype((x))`の振る舞いが関数引数部分の終端の前後で変化する可能性がある

なお、この場合、キャプチャされた変数`x`を参照する`decltype((x))`は`x`が`const`でない限り非`const`となります。すなわち、デフォルトで`mutable`があるかのように扱います。

```cpp
void f() {
  float x, &r = x;

  [=](decltype((x)) y) {
    decltype((x)) z = x;
  };  // ok、yの型はfloat&, zの型はconst float&

  [=] {
    []<decltype(x) P>;      // ok
    [](decltype((x)) y){};  // ok、yの型はfloat const&（囲むラムダがコピーキャプチャしたxを参照している）
    [x=1](decltype((x)) y){
      decltype((x)) z = x;
    };  // ok, yの型はint&, zの型はconst int&
  };
}
```

この提案は、CWG Issueと関連する提案でもあることからすでにCWGのレビューをパスしており、次の全体会議で投票にかけられる事が決まっています。

- [P2598R0 “Changing scope for lambda trailing-return-type” (P2036) should not be a DR - WG21月次提案文書を眺める（2022年06月）](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2598R0-Changing-scope-for-lambda-trailing-return-type-P2036-should-not-be-a-DR)
- [CWG Issue 2569. Use of `decltype(capture)` in a lambda's parameter-declaration-clause](https://cplusplus.github.io/CWG/issues/2569.html)
- [P2579 進行状況](https://github.com/cplusplus/papers/issues/1274)

### [P2585R1 Improving default container formatting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2585r1.html)
### [P2587R1 to_string or not to_string](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r1.html)
### [P2590R2 Explicit lifetime management](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2590r2.pdf)
### [P2592R1 Hashing support for std::chrono value classes](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2592r1.html)
### [P2601R1 Make redundant empty angle brackets optional](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2601r1.html)
### [P2602R1 Poison Pills are Too Toxic](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2602r1.html)
### [P2609R1 Relaxing Ranges Just A Smidge](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2609r1.html)
### [P2610R0 2022-07 Library Evolution Polls](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2610r0.html)

2022年の5月に予定されている、LEWGでの全体投票の予定表。

次の提案が、LWGに進むための投票にかけられます。

- C++23
    - [P0429R9 flat_map](https://wg21.link/P0429R9)
    - [P1222R4 flat_set](https://wg21.link/P1222R4)
    - [P0792R10 function_ref](https://wg21.link/P0792R10)
    - [P2505R4 Monadic Functions For expected](https://wg21.link/P2505R4)
    - [P2585R0 Improving Default Container Formatting](https://wg21.link/P2585R0)
    - [P2446R2 views::as_rvalue](https://wg21.link/P2446R2)
    - [P2278R4 cbegin Should Always Return A Constant Iterator](https://wg21.link/P2278R4)
    - [P2248R5 Enabling List-Initialization For Algorithms](https://wg21.link/P2248R5)
    - [P2539R1 Should The Output Of print To A Terminal Be Synchronized With The Underlying Stream?](https://wg21.link/P2539R1)
    - [P2510R3 Formatting Pointers](https://wg21.link/P2510R3)
    - [P2551R2 Clarify Intent Of Individually Specializable Numeric Traits](https://wg21.link/P2551R2)
    - [P2599R2 index_type & size_type In mdspan](https://wg21.link/P2599R2)
    - [P2604R0 mdspan: Rename pointer, data, And contiguous](https://wg21.link/P2604R0)
    - [P2613R1 Add The Missing empty To mdspan](https://wg21.link/P2613R1)
- C++26
    - [P2338R2 Freestanding Library: Character Primitives And The C Library](https://wg21.link/P2338R2)
    - [P2407R1 Freestanding Library: Partial Classes](https://wg21.link/P2407R1)
    - [P2562R1 constexpr Stable Sorting](https://wg21.link/P2562R1)
    - [P2283R2 constexpr Specialized Memory Algorithms](https://wg21.link/P2283R2)
    - [P2542R2 views::concat](https://wg21.link/P2542R2)
    - [P2609R1 Relaxing Ranges Just A Smidge](https://wg21.link/P2609R1)

### [P2613R1 Add the missing `empty` to `mdspan`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2613r1.html)

`std::mdspan`に`empty()`メンバ関数を追加する提案。

以前の記事を参照

- [P2613R0 Add the missing `empty` to `mdspan`](https://onihusube.hatenablog.com/entry/2022/07/09/160343#P2613R0-Add-the-missing-empty-to-mdspan)


このリビジョンでの変更は、LWGのフィードバックを受けての文言調整のみです。

この提案は今回（2022/07）の全体会議で承認され、C++23入りしています。

- [P2613 進行状況](https://github.com/cplusplus/papers/issues/1272)

### [P2614R0 Deprecate `numeric_limits::has_denorm`](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2614r0.pdf)

`std::numeric_limits::has_denorm`関連の定数を非推奨化する提案。

[`std::numeric_limits::has_denorm`](https://cpprefjp.github.io/reference/limits/numeric_limits/has_denorm.html)はその環境で、浮動小数点数型`T`が非正規化数をサポートしているかを調べるものです。これはコンパイル時定数であり、浮動小数点数型`T`非正規化数をサポートしている/いない/わからない、をコンパイル時に取得するものです。

IEE754準拠の浮動小数点数型であっても、ハードウェアによっては非正規化数をサポートしていない場合がありその場合はソフトウェアエミュレーションによってサポートされている場合があります。この場合、同じ系統のハードウェアであっても将来のバージョンでサポートされる可能性があり、この時にABI破壊を回避しようと思うと`std::denorm_indeterminate`を常に使用せざるを得なくなります。また、ハードウェアサポートがある場合でも、実行時のフラグ切り替えによって非正規化数をゼロにフラッシュするように設定する事が可能であり、`std::numeric_limits::has_denorm`は必ずしもコンパイル時に確定するプロパティでは無い面があります。

`std::numeric_limits::has_denorm_loss`は非正規化数が作成され（計算に使用され）る場合に起こる精度の低下をどのように検出できるかを取得するものです。非正規化数が使用されたことによって精度が低下した時にそれを検出する次の2つの方法がIEEE754標準で指定されていました

1. 非正規化損失（Denormalization loss）
2. 不正確な結果（Inexact result）

実際には1つ目の実装は存在しなかったため、現在のIEE754からは削除されており、2つ目の実装だけが存在しています。`std::numeric_limits::has_denorm_loss`はこの2つのどちらがその環境の浮動小数点数型で実装されているかを示すものでしたが、このような理由によりもはや意味がありません。また、この値は実装によってなぜか異なっています（MSVCだけが浮動小数点数型に対して`true`を返す）。

これらの理由から、`std::numeric_limits::has_denorm`と`std::numeric_limits::has_denorm_loss`は有用なものではなく、最悪勘違いして使用される危険性があるため、非推奨化しようとする提案です。ただし、削除してしまうと互換性の問題を引き起こすため、非推奨に止めようとしています。

- [`std::numeric_limits<T>::has_denorm_loss` - cppreference](https://en.cppreference.com/w/cpp/types/numeric_limits/has_denorm_loss)
- [P2614 進行状況](https://github.com/cplusplus/papers/issues/1278)

### [P2615R0 Meaningful exports](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2615r0.html)

無意味な`export`を行えないようにする提案。

現在の`export`宣言にまつわる規定の解釈の一つとして、次のような宣言が許可されているように見えます。

```cpp
// これは何？
template export void f();
export template void f();

// 本体の関数テンプレートがexportされているならこちらには不要
export template<> void g(int);
template<> export void g(int);

// プライマリテンプレートがexportされていれば不要
export template<class T> struct trait<T*>;
```

この問題はコア言語のissueとして提起され、この提案はその解決のための文言変更を含んだものです。

ただし、この後でも`export {...}`の中でこれらの宣言が現れたとしてもエラーにならないようにされています。`export`ブロック内では利便性向上のために、本来`export`できない宣言が含まれていても単に無視されるようにされる（ようにする傾向にある）ためです。

- [CWG Issue 2443. Meaningless template exports](https://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2443)
- [P2615 進行状況](https://github.com/cplusplus/papers/issues/1236)

### [P2616R0 Making `std::atomic` notification/wait operations usable in more situations](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2616r0.html)

`std::atomic`の[`notify_one()`](https://cpprefjp.github.io/reference/atomic/atomic/notify_one.html)と[`wait()`](https://cpprefjp.github.io/reference/atomic/atomic/wait.html)操作を使いづらくしている問題を解消する提案。

`std::atomic`の`notify_one()/wait()`操作はC++23で追加され、`std::atomic`オブジェクトを介したスレッド間の同期プリミティブとして利用できます。

ただ、待機しているスレッドを起床させる`notify_one()`操作と`std::atomic`オブジェクトの出力（`.store()`）が分かれていることによって、 これを利用した同期プリミティブの移植可能な実装を妨げています。

例えば、`std::atomic`の`notify_one()/wait()`のよくある使用法では、`std::atomic`オブジェクトへ値を出力してから`notify_one()`を呼ぶという手順がとられます。この場合に、待機するスレッドが`wait()`からの復帰時に同期に使用していた`std::atomic`オブジェクトをすぐに破棄する場合に問題が起こります。

待機するスレッドで`wait()`が呼ばれる前に（正確には、その呼び出しで値のチェックが行われる前に）、通知スレッド（`notify_one()`を呼ぶスレッド）で`std::atomic`オブジェクトへの値の出力が行われていた場合、待機スレッドの`wait()`はすぐにリターンし使用していた`std::atomic`オブジェクトの破棄が行われます。すると、通知スレッドではそのように破棄されてしまった`std::atomic`オブジェクトに対して`notify_one()`を呼ぶ可能性があり、これはいうまでもなく未定義動作です。

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 値をtrueに更新してから
      sync.store(true);   // #1
      // 待機スレッドを起床させる
      sync.notify_one();  // #2
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false); // #3
    // 終わったら即リターン、syncは破棄される
  } // #4
}
```

`.wait()`では引数に渡された値と現在の値を比較して、等しい場合にブロッキングし、等しく無い場合はすぐリターンします。この例では処理が`#1 -> #3 -> #4 -> #2`の順番で起こる可能性があり、起こった場合に未定義動作となります。

この例は恣意的に見えますが、例えば`std::atomic`を用いて`std::binary_semaphore`が実装されていた場合、このことは表面化しませんが同様の問題を潜在的に引き起こします。

```cpp
#include <semaphore>
#include <thread>

int main() {
  {
    // binary_semaphoreがstd::atomicを用いて実装されていたとすると・・・
    std::binary_semaphore sync;

    std::thread{[&sync]{
      sync.release();
    }}.detach();

    sync.acquire();
  }
}
```

このコードだと先ほどよりも問題が見えにくくなっています。`std::atomic`と`notify_one()/wait()`を用いて他の同期プリミティブを実装する場合はこの問題を避けるための工夫が必要になり、それらのワークアラウンドはパフォーマンスを損ねたり移植性が無かったりと問題があります。

実は標準ライブラリの主要3実装（GCC/clang/MSVC）における`std::binary_semaphore`（`std::counting_semaphore`）はまさに`std::atomic`を利用して実装されています。ただし、そこでは`std::atomic`オブジェクトのアドレスのみを使用して値にアクセスしないため、上記のようなライフタイムにまつわる問題は起こりません。ただしこれは、この3つの実装がプラットフォームの対応する操作に関する追加の知識を仮定できるために可能になっているだけで、その他の標準ライブラリ実装がこの方法を取るかどうかはわからず、ユーザーは同様の仮定のもとで`std::atomic`を使用して`std::binary_semaphore`のようなものを安全かつ移植可能に実装することはできません。

この提案はこの問題の解決を図るもので、次の2つの解決策を提示しています。

1. 名前空間スコープの[`std::atomic_notify_one()`](https://cpprefjp.github.io/reference/atomic/atomic_notify_one.html)/[`std::atomic_notify_all()`](https://cpprefjp.github.io/reference/atomic/atomic_notify_all.html)の規定を変更して、生存期間が終了している`std::atomic`オブジェクトへのポインタを渡されるようにする。
    - 渡されたポインタにはアクセスしないことを保証する
2. `std::atomic`オブジェクトの`.store()`を呼び出す可能性がある関数ごとに、通知操作を融合したオーバーロードを追加する。
    - `std::memory_notification`列挙体を追加して、それを引数に取るようにする

1つ目の方法では、最初のサンプルコードは次のように書き換えられます

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 破棄される前にアドレスを取得
      auto* pa = &sync;
      // 値をtrueに更新
      sync.store(true);
      // 通知
      std::atomic_notify_one(pa);
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false);
  }
```

この時、ポインタ`pa`を`pa`の参照先オブジェクトが破棄された後で使用することが有効であるかには議論があり、Pointer lifetime-end zapという問題として知られています（詳細は以前の記事参照）

- [P1726R4 : Pointer lifetime-end zap - WG21月次提案文書を眺める（2020年07月）](https://onihusube.hatenablog.com/entry/2020/08/12/014639#P1726R4--Pointer-lifetime-end-zap)
- [P2414R0 Pointer lifetime-end zap proposed solutions - WG21月次提案文書を眺める（2021年07月）](https://onihusube.hatenablog.com/entry/2021/08/14/213339#P2414R0-Pointer-lifetime-end-zap-proposed-solutions)

したがって、この解決策を適用するためにはコア言語にこれらの提案による解決が導入される必要があります。

2つ目の方法では、次のような列挙体とその定数を標準ライブラリに追加し、`.store()`などの値を変更する関数にこれを受け取るオーバーロードを追加します。

```cpp
namespace std {
  enum class memory_notification : unspecified {
    notify_none = unspecified,
    notify_one = unspecified,
    notify_all = unspecified
  };
  inline constexpr auto memory_notify_none = memory_notification::notify_none;
  inline constexpr auto memory_notify_one = memory_notification::notify_one;
  inline constexpr auto memory_notify_all = memory_notification::notify_all;
}
```

この方法では、最初のコードは次のようになります

```cpp
#include <atomic>
#include <thread>

int main() {
  {
    // 同期用アトミックオブジェクト
    std::atomic<bool> sync = false;

    std::thread{[&sync]{
      // 値をtrueに更新して通知
      sync.store(true, std::memory_notify_one);
    }}.detach();

    // 値が更新（trueになる）されるまで待機
    sync.wait(false);
  }
}
```

実際の実装では`std::atomic`オブジェクトのアドレスを取ってからストア操作と通知操作を行う（1のような方法）が取られる可能性がありますが、それは実装定義の振る舞いとして（現在の`std::counting_semaphore`の実装のように）動作が保証されるため、ユーザーコードで同じことをした場合の未定義動作を回避することができます。

- [P2616 進行状況](https://github.com/cplusplus/papers/issues/1279)

### [P2617R0 Responses to NB comments on DTS 12907 "Extensions to C++ for Transactional Memory Version 2"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2617r0.html)

[Transactional Memory TS2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4906.pdf)に寄せられたNBコメントを受けての修正を反映する提案。

6つのNB（*national body*）コメント（WG21の各国毎のサブグループからのレビュー結果みたいなもの）が寄せられ、その指摘に対処するための文言変更が含まれています。どうやら全てカナダの委員会メンバからのものです。

この提案は既に2022年7月の全体会議で承認されたようです。

- [N4906 Transactional Memory TS2](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/n4906.pdf)
- [P2617 進行状況](https://github.com/cplusplus/papers/issues/1280)

### [P2618R0 C++ Standard Library Issues to be moved in Virtual Plenary, Jul. 2022](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2618r0.html)

今回（2022/07）の会議で採択された標準ライブラリについてのIssue報告とその解決。

1. [3564. `transform_view::iterator<true>::value_type` and `iterator_category` should use `const F&`](https://wg21.cmeerw.net/lwg/issue3564)
2. [3617. `function/packaged_task` deduction guides and deducing this](https://wg21.cmeerw.net/lwg/issue3617)
3. [3656. Inconsistent bit operations returning a count](https://wg21.cmeerw.net/lwg/issue3656)
4. [3659. Consider ATOMIC_FLAG_INIT undeprecation](https://wg21.cmeerw.net/lwg/issue3659)
5. [3670. Cpp17InputIterators don't have integer-class difference types](https://wg21.cmeerw.net/lwg/issue3670)
6. [3671. `atomic_fetch_xor` missing from stdatomic.h](https://wg21.cmeerw.net/lwg/issue3671)
7. [3672. `common_iterator::operator->()` should return by value](https://wg21.cmeerw.net/lwg/issue3672)
8. [3683. `operator==` for `polymorphic_allocator` cannot deduce template argument in common cases](https://wg21.cmeerw.net/lwg/issue3683)
9. [3687. `expected<cv void, E>` move constructor should move](https://wg21.cmeerw.net/lwg/issue3687)
10. [3692. `zip_view::iterator`'s `operator<=>` is overconstrained](https://wg21.cmeerw.net/lwg/issue3692)
11. [3701. Make `formatter<remove_cvref_t<const charT[N]>, charT>` requirement explicit](https://wg21.cmeerw.net/lwg/issue3701)
12. [3702. Should `zip_transform_view::iterator` remove `operator<`?](https://wg21.cmeerw.net/lwg/issue3702)
13. [3703. Missing requirements for `expected<T, E>` requires `is_void<T>`](https://wg21.cmeerw.net/lwg/issue3703)
14. [3704. LWG 2059 added overloads that might be ill-formed for sets](https://wg21.cmeerw.net/lwg/issue3704)
15. [3705. Hashability shouldn't depend on `basic_string`'s allocator](https://wg21.cmeerw.net/lwg/issue3705)
16. [3707. `chunk_view::outer-iterator::value_type::size` should return unsigned type](https://wg21.cmeerw.net/lwg/issue3707)
17. [3708. `take_while_view::sentinel`'s conversion constructor should move](https://wg21.cmeerw.net/lwg/issue3708)
18. [3709. LWG-3703 was underly ambitious](https://wg21.cmeerw.net/lwg/issue3709)
19. [3710. The end of `chunk_view` for input ranges can be `const`](https://wg21.cmeerw.net/lwg/issue3710)
20. [3711. Missing preconditions for `slide_view` constructor](https://wg21.cmeerw.net/lwg/issue3711)
21. [3712. `chunk_view` and `slide_view` should not be `default_initializable`](https://wg21.cmeerw.net/lwg/issue3712)
22. [3713. Sorted with respect to comparator (only)](https://wg21.cmeerw.net/lwg/issue3713)
23. [3715. `view_interface::empty` is overconstrained](https://wg21.cmeerw.net/lwg/issue3715)
24. [3719. Directory iterators should be usable with default sentinel](https://wg21.cmeerw.net/lwg/issue3719)
25. [3721. Allow an arg-id with a value of zero for width in std-format-spec](https://wg21.cmeerw.net/lwg/issue3721)
26. [3724. decay-copy should be constrained](https://wg21.cmeerw.net/lwg/issue3724)

### [P2620R0 Lifting artificial restriction on universal character names](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2620r0.pdf)

ユニコード文字名によって指定するユニバーサルキャラクタ名（名前付文字エスケープ）を識別子に使用した時の制限を解除する提案。

名前付文字エスケープ（*Named character escape*）はC++23で導入されたもので、`U'\N{LATIN CAPITAL LETTER A WITH MACRON}'`のようにユニバーサルキャラクタ名を指定するものです。詳細は以前の記事を参照

- [P2071R1 Named universal character escapes - WG21月次提案文書を眺める（2021年11月）](https://onihusube.hatenablog.com/entry/2021/12/11/220126#P2071R1-Named-universal-character-escapes)

この提案の指摘している問題とは次のようなものです

```cpp
int main() {
  auto \N{LATIN CAPITAL LETTER I} = 42; // ng、Iはユニバーサルキャラクタ名で指定できない
  auto \N{LATIN CAPITAL LETTER I WITH DOT ABOVE} = 42 ; // ok
}
```

`LATIN CAPITAL LETTER I`とは`I`（`U+0049`）の文字（アルファベットのI）であり、これは基本文字集合に含まれる文字であるためユニバーサルキャラクタ名によって指定できません。`LATIN CAPITAL LETTER I WITH DOT ABOVE`はIの上にドットがついている文字`İ`（`U+0130`）で、これは基本文字集合に含まれ無いためユニバーサルキャラクタ名によって指定することができます。

これらのことは、文字/文字列リテラル内では区別されないため問題になりませんが、識別子で使用された時だけこのような違いが生じます。この提案は、この制限を取り払おうとするものです。

- [P2620 進行状況](https://github.com/cplusplus/papers/issues/1282)

### [P2621R0 UB? In my Lexer?](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2621r0.pdf)

字句解析するだけで未定義動作を引き起こすものについて、未定義ではなくする提案。

この提案によれば、次のようなコードは規格的には未定義動作となるようです

```cpp
int \\ // UB : 複数行にわたるユニバーサル文字名
u\
0\
3\
9\
1 = 0;

#define CONCAT(x, y) x ## y
int CONCAT(\, u0393) = 0; // UB: マクロ展開によって形成されるユニバーサル文字名

// UB: 閉じていない文字列リテラル
const char * foo = "
```

この提案は、これらの未定義動作を実際の実装に合わせる形で振る舞いを定義しようとするものです。

|UB|GCC|clang|EDG|MSVC|
|---|---|---|---|---|
|複数行UCN|Supported|Supported|Error|Supported|
|`##`によるUCNの形成|Supported|Supported|Supported|Supported|
|閉じていない文字（列）リテラル|ill-formed|ill-formed|ill-formed|ill-formed|

これらのことを踏まえて、この提案は3つのUBを次のようにしようとしています

|UB|提案|
|---|---|
|複数行UCN|Well-formed|
|`##`によるUCNの形成|Well-formed|
|閉じていない文字（列）リテラル|ill-formed|

従って、MSVCの複数行UCN実装だけがこの提案の影響を受けます。しかし、現在はエラーになっているのでその影響は破壊的なものではありません。

- [P2621 進行状況](https://github.com/cplusplus/papers/issues/1283)

### [P2622R0 Core Language Working Group "ready" Issues for the July, 2022 meeting](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2622r0.html)

今回（2022/07）の会議で採択されたコア言語についてのIssue報告とその解決。

1. [2355. Deducing noexcept-specifiers](https://wg21.cmeerw.net/cwg/issue2355)
2. [2405. Additional type-dependent expressions](https://wg21.cmeerw.net/cwg/issue2405)
3. [2507. Default arguments for operator[]](https://wg21.cmeerw.net/cwg/issue2507)
4. [2534. Value category of pseudo-destructor expression](https://wg21.cmeerw.net/cwg/issue2534)
5. [2535. Type punning in class member access](https://wg21.cmeerw.net/cwg/issue2535)
6. [2540. Unspecified interpretation of numeric-escape-sequence](https://wg21.cmeerw.net/cwg/issue2540)
7. [2571. Evaluation order for subscripting](https://wg21.cmeerw.net/cwg/issue2571)
8. [2582. Differing member lookup from nested classes](https://wg21.cmeerw.net/cwg/issue2582)
9. [2585. Name lookup for coroutine allocation](https://wg21.cmeerw.net/cwg/issue2585)
10. [2586. Explicit object parameter for assignment and comparison](https://wg21.cmeerw.net/cwg/issue2586)
11. [2594. Disallowing a global function template main](https://wg21.cmeerw.net/cwg/issue2594)
12. [2597. Replaceable allocation and deallocation functions in the global module](https://wg21.cmeerw.net/cwg/issue2597)
13. [2606. static_cast from "pointer to void" does not handle similar types](https://wg21.cmeerw.net/cwg/issue2606)
14. [2608. Omitting an empty template argument list](https://wg21.cmeerw.net/cwg/issue2608)

### [P2623R0 implicit constant initialization](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2623r0.html)

一時オブジェクトへの参照によるダングリング発生を削減する提案。

一時オブジェクトへの参照によってダングリング参照が発生するのは主に次の2つの場合です

1. 関数から返された参照
2. 関数から返された、値のセマンティクスを持たないオブジェクト（`std::string_view`など）

例えば2つ目の場合だと、次のようなコードで簡単にダングリング参照を生成できます

```cpp
using namespace std::string_literals;

int main () {
  std::string_view sv = "hello world"s; // この行以降svはダングリング参照となる、その使用はUB
}
```

`"hello world"s`はユーザー定義リテラル`s`によって`std::string`の一時オブジェクトを生成します。それを`std::string_view`でバインドすると、すぐにその一時オブジェクトの寿命が尽きてダングリングとなります。

この提案の目的は、このコードがUB（ダングリング参照）にならないようにすることです。この例では、定数式`"hello world"s`が通常の文字列リテラルと同様に静的記憶域期間（*static storage duration*）を持つようにする（暗黙的な定数初期化を行う）ことで、ダングリング参照の生成を防止しようとしています。

また、`std::string_view`によるダングリングは次のように間接的に発生する場合もあります

```cpp
std::string operator+(std::string_view s1, std::string_view s2) {
  return std::string{s1} + std::string{s2};
}

auto f() {
  std::string_view sv = "hi";
  sv = sv + sv; // svはダングリング
  ...
}
```

`sv + sv`の結果は`std::string`の一時オブジェクトであり、その寿命はその式の終わり（`;`）までです。

この提案では、この場合にこの式の結果生成される一時オブジェクトの生存期間をその式ではなく囲むブロックのスコープとバインドさせることで、このようなダングリングを防止しようとしています。

もちろん、この場合でもこの参照（`sv`）をこのブロックの外に持ち出してしまえばダングリング参照となりますがそれは現在でも同じことで、この提案の目的はダングリング参照の発生を抑制することにあり、完全に失くすことを目指してはいません。

1つ目の場合（関数の参照戻り値）では、次のような場合にダングリング参照を生成できます

```cpp
struct X { int a, b; };

const int& f(const X& x) { return x.a; }  // 引数のメンバへの参照を返す

int main() {
  const int& a = f({4, 2}); // 一時オブジェクトを引数で与える
                            // aはダングリング参照、UB
}
```

この時でも、`{4, 2}`の一時オブジェクトの生存期間が囲むブロックのスコープに紐づいていれば、ダングリング参照は生成されません。

`std::string`では、この例とよく似たことを簡単に起こすことができます。

```cpp
char& c = std::string{"hello my pretty long string"}[0];
c = 'x'; // cはダングリング参照、UB
std::cout << "c: " << c << '\n'; // cはダングリング参照、UB
```

この時でも一時オブジェクトの生存期間がその式ではなく囲むブロックに紐づいていればダングリングを回避できます。ここで、このような一時オブジェクトの寿命にまつわる問題を回避するために一時オブジェクトを変数に受けてみると現在の一時オブジェクトの生存期間のルールがプログラマの期待と一致していないことが垣間見えます。

```cpp
auto anonymous = std::string{"hello my pretty long string"};
char& c = anonymous[0];
c = 'x'; // ok、cはダングリングではない
std::cout << "c: " << c << '\n'; // ok、cはダングリングではない
```

これはプログラマから見ればほぼ同じコードですが、このように一時オブジェクトに名前づけをするだけでダングリング参照の生成を回避できます。しかしこれは、一時オブジェクトの生存期間を囲むブロックに紐づけるという操作を手動でやっているだけです。

このようなことが意図せず発生しうるものとして範囲`for`がよく知られています。

```cpp
for (auto x : reversed(make_vector())) { ... }
```

`make_vector()`が`std::vector`の右辺値を返し、`reversed()`が[`std::ranges::owning_view`](https://cpprefjp.github.io/reference/ranges/owning_view.html)のような一時オブジェクトの生存期間延長のためのケアをしない場合、この範囲`for`全体はダングリングした範囲をイテレートします。

例えば、範囲`for`は次のように展開されています

```cpp
{// containing block
  auto&& rg = reversed(make_vector());  // この行でmake_vector()の戻り値の寿命が尽きる
  auto pos = rg.begin();
  auto end = rg.end();
  for ( ; pos != end; ++pos ) {
    auto x = *pos;
    ...
  }
}
```

この時でも、一時オブジェクトの生存期間が囲むブロックに紐づいていれば、このようなUBを回避できます。そのことは、一時オブジェクトに明示的に名前を与えてみるとわかります

```cpp
{// containing block
  auto anonymous1 = make_vector();
  auto anonymous2 = reversed(anonymous1);
  auto pos = anonymous2.begin();
  auto end = anonymous2.end();
  for ( ; pos != end; ++pos ) {
    auto x = *pos;
    ...
  }
}
```

この提案の主張することは、プログラマから見れば一時オブジェクトとは名前のない変数であるということです。その観点から、一時オブジェクトの寿命を通常の変数のようにすればダングリング参照の発生を減らすだけでなく、ダングリングする可能性のある関数戻り値を受けるための余計な変数の名前づけを削減することもできます。これによって、一時オブジェクトに注意して関数戻り値を命名するのではなく、一時オブジェクトのまま使用することを奨励することすらできるようになります。

より詳細には、この提案ではこれらの一時オブジェクトのうち、暗黙的な定数初期化が可能な場合（`constexpr`コンストラクタを持つ型の`const`参照）にはコンパイル時に定数初期化して静的記憶域期間を与えることで一時オブジェクトではなくし、そのような定数初期化ができない一時オブジェクトについてはその寿命を囲むブロックスコープにまで延長（通常の名前付き変数と同様に）することで、ダングリング参照の発生を防止しようとしています。

```cpp
// std::mapからキーに対応する値を取得する、なければ指定したデフォルトを返す
const V& findOrDefault(const std::map<K,V>& m, const K& key, const V& defvalue);

void f() {
  std::map<std::string, std::string> myMap;
  const std::string& s = findOrDefault(myMap, key, "none"); // "none"はstd::stringの一時オブジェクト
  // 現在はsはダングリング参照
  // この提案後は定数初期化されたグローバルな"none"（std::stringオブジェクト）を指す
}

std::string make_str(); // 非constexpr関数

void g() {
  std::map<std::string, std::string> myMap;
  const std::string& s = findOrDefault(myMap, key, make_str());  // 実行時文字列で使用した場合
  // 現在はsはダングリング参照
  // この提案後はmake_str()の戻り値の一時オブジェクトの寿命は囲むスコープに拡張されるため、ダングリングではなくなる
}
```

一時オブジェクトの生存期間を囲むブロックに拡張するのは、現在のC++でも制限的ながら起こっており、このことは全く新しいことではありません。

```cpp
template<typename T> using id = T;

int i = 1;
int&& a = id<int[3]>{1, 2, 3}[i]; // 配列の一時オブジェクトの寿命はaの寿命と同期する
const int& b = static_cast<const int&>(0); // intの一時オブジェクトの寿命はbの寿命と同期する
int&& c = cond ? id<int[3]>{1, 2, 3}[i] : static_cast<int&&>(0);  // 条件演算子の両方のオペランドの一時オブジェクトの寿命はcの寿命と同期する
```

この提案の内容は以前の[P0936R0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf)を引き継ぐものです。そちらでは追加の注釈によって引数や戻り値の生存期間の延長（この提案の一時オブジェクトの自動変数化）を行なっていましたが、この提案ではそれと同じことを暗黙的に行います。この提案はそこに一時オブジェクトの暗黙的定数初期化を追加することでP0936を補強するとともに、P0936の内容だけでは適切な対策とならないものについてより安全にしようとするものです。

- [P0936R0 Bind Returned/Initialized Objects to the Lifetime of Parameters, Rev0](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0936r0.pdf)
- [P2623 進行状況](https://github.com/cplusplus/papers/issues/1285)

### [P2624R0 Make operations on bools more portable](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2624r0.html)

`bool`型に関する標準の矛盾を正す提案。

標準では、`bool`型について次のように指定しています

- 実装定義の符号なし整数型と同じオブジェクト表現、値表現、アライメントを持つ
- `bool`型の値は`true`と`false`

型`T`のオブジェクト表現とは`T`のオブジェクトを`unsigned char[N]`で参照した時のバイト列のことで、`T`の値表現とは`T`の値を保持するビット列のことです。

`bool`の値は2つしか取れないとする場合、少なくとも256の異なる値を取れる符号なし整数型と同じ値表現として実装することはできません。この矛盾によって、`bool`型のどのような実装も標準に適合することはできておらず、さまざまな方法で標準の規定を近似しています。

- clang : 1バイトオブジェクト中の1ビットのビットフィールドであるかのように実装
    - 下位1ビットのみが値に関与し、残りはパディングビット
    - 2つの値のみを取れるという規定を満たすものの、ベースとなる符号なし整数型と同じ値表現を持たない
- GCC/MSVC : `enum bool : unsigned char { false, true };`のような型として実装
    - 符号なし整数型と同じ値表現を持つものの、異なる256の値を持つことができる

この違いによって、微妙な振る舞いの違いを観測することができます。

```cpp
// clangは常に 0 or 1のどちらかを返す
// msvc & gccは 0, 1, -1のどれかを返す
int test1(bool b) { 
  switch(b) {
    case false: return 0;
    case true: return 1;
    default: return -1;
  }
}
 
// clang & msvcは常に 1を返す
// gccは 1か2のどちらかを返す
int test2(bool b) {
  int n = 0;

  if (b) n++;
  if (!b) n++;
  
  return n;
}
 
// clangは常に 0 or 2のどちらかを返す
// msvc & gccは 0~510の間の任意の値を返す
int test3(bool b) { return b + b; }
 
// clang & msvcは常に 0 or 1のどちらかを返す
// gccは 0~255の間の任意の値を返す
int test4(bool b) { return b || b; }
```

この提案の目的は、これらのことを正すことで`bool`を含む式が数学的論理と一致した予測可能で意外性のない結果を返すようにし、`bool`型の変数を安全かつポータブルに使用可能とすることです。

この提案の内容にclangは既に準拠していますがGCC/MSVCはそうではなく、GCC/MSVCの現在の挙動に依存しているコードは動作が変更されることになります。

- [`std::has_unique_object_representations` - cpprefjp](https://cpprefjp.github.io/reference/type_traits/has_unique_object_representations.html)
- [P2624 進行状況](https://github.com/cplusplus/papers/issues/1286)
