# ［C++］モジュール 理論編

### モジュールの構成

### ファイルの分割

### `export`

### `import`

### 非モジュールコードとの相互運用

#### Header Unit

### モジュール史（2004 - 2019）
- Moduleのあけぼの
  - [N1736: Modules in C++ (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf)
  - [N1778: Modules in C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1778.pdf)
  - [N1964: Modules in C++ (Revision 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1964.pdf)
  - [N2073: Modules in C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf)
  - [N2316: Modules in C++ (Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2316.pdf)
  - [N3347: Modules in C++ (Revision 6)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf)
- MSの隆盛
  - [N4047: A Module System for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf)
  - [N4214: A Module System for C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4214.pdf)
  - [N4465: A Module System for C++ (Revision 3)](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4465.pdf)
  - [P0142R0: A Module System for C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0142r0.pdf)
- Moduleの挑戦とつまづき
  - [N4466: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4466.pdf)
  - [P0143R0: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r0.pdf)
  - [P0143R1: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r1.pdf)
- Module TSの時代
  - [N4592: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
  - [N4610: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4610.pdf)
  - [N4637: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4637.pdf)
  - [N4681: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4681.pdf)
  - [N4720: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf)
- googleの台頭（Atom Proposals）
  - [P0947R0: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r0.html)
  - [P0947R1: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html)
  - [P0986R0: Comparison of Modules Proposals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0986r0.html)
- ひらけゆくModule
  - [P1103R0 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf)
  - [P1103R1 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r1.pdf)
  - [P1103R2 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r2.pdf)
  - [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)

### 参考文献

- [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
- [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)
- [C++ ModulesのHeader units - Qita](https://qiita.com/tetsurom/items/e25b2683cb7e7c0fa91c)
- [C++ Modulesの分割 - Qita](https://qiita.com/tetsurom/items/0de4795866b52f5bcf65)
- [C++ ModulesとDLLの関係 (MSVCの場合) - Qita](https://qiita.com/tetsurom/items/0f6aad21e06b043f42bd)
- [Understanding C++ Modules: Part 1: Hello Modules, and Module Units - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/10/modules-1.html)
- [Understanding C++ Modules: Part 2: export, import, visible, and reachable - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/31/modules-2.html)
- [C++20: Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-modules)
- [C++20: More Details to Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-more-details-to-modules)
- [C++ MODULES - HSAE - Wuhan · 张轶](http://purecpp.org/purecpp/static/717887c97bf947d68e67da309cdd0611.pdf)

# メモ

- module unit : モジュール単位
モジュールを構成する翻訳単位
ファイル先頭のモジュール宣言によりモジュール単位は開始される
その後にimport宣言が続く（なくてもよい

モジュール宣言
```cpp
module foo;  //ファイル先頭で行う
```

- module interface unit : モジュールインターフェース単位  
module unitであり、モジュール宣言にexportを伴うもの

モジュールインターフェース宣言
```cpp
export module foo;  //ファイル先頭で行う
```

モジュールのインターフェースを定義する
インターフェース：シグネチャ、宣言みたいな

モジュールは少なくとも一つがモジュールインターフェース単位である必要がある

- primary module interface unit : プライマリモジュールインターフェース単位  
モジュール名と同じモジュールインターフェース宣言を含むモジュール単位  
モジュールfooなら`export module foo;`

- module interface partitions : モジュールインタフェースパーティション  
プライマリではないすべてのモジュールインターフェース単位

## visible と reachable

- visible : 可視  
名前探索によって宣言が見つかれば、そのコンテキストでその宣言は可視である

- reachable : 到達可能  
定義（意味論的効果）が使用可能である場合、そのコンテキストでその宣言は到達可能である  
例えば、あるコンテキストでクラスが完全型であるならば、そのクラスの定義は到達可能である

宣言は可視 -> 到達可能 : true  
到達可能 -> 宣言は可視 : false (trueとなることもある)

importはどの名前空間スコープの名前が可視になるか
および、どの宣言が意味論的に（semantically）到達可能か
だけをコントロールする。

あるエンティティの振る舞いは、そのエンティティの到達可能な宣言の集合によって決まる（エンティティ = 名前・定義？）
例えば、クラス・列挙体のメンバはその定義が到達可能であるとき、名前探索で可視である

## export
宣言は`export`を用いてモジュールインターフェース単位内でエクスポートできる

内部リンケージを持つものを除いて、エクスポートされていない宣言はそのモジュール単位をインポートする同じモジュール内の名前探索で可視である

推移的にインポートされたモジュール単位内のすべての宣言は、エクスポートされているかにかかわらず到達可能（？？

モジュール単位は対応するモジュールインタフェース単位を暗黙にインポートする

名前空間内の宣言（名前空間を伴う宣言）がエクスポートされると、その名前空間も暗黙的にエクスポートされる。
名前空間をエクスポートすると、名前空間内の宣言は（暗黙的に）エクスポートされる。

## module partitions : モジュールパーティション

一つのモジュールは単一のファイルでも複数のファイルでも定義できる。  
例えば、宣言（モジュールインターフェースユニット）と定義（実装）をファイルで分割することができる。

モジュールパーティションは、そのようなインターフェースと実装を分割することを可能にする

- module interface partitions : モジュールインターフェースパーティション

モジュールインターフェースは必要に応じて複数のファイルに分割することができる。
それらのファイルをモジュールインターフェースパーティションと呼ぶ。
以下のようなモジュールインターフェースパーティション宣言を（その他のモジュール宣言の代わりに）含む翻訳単位のこと。

モジュールインターフェースパーティション宣言
```cpp
export module foo::part;
```

モジュールインターフェースパーティションに含まれるエンティティの所有権は属しているモジュールと共有される。  
それ以外は、モジュールインターフェースパーティションは単一のモジュールと同じ振る舞いをする。  

そのため、エンティティの宣言と定義を別々のパーティションで行うことができる
これは、モジュール内部で発生しうる循環参照（依存関係のループ）を解決するために必要
これはまた、ABIを変えることなくモジュール内でコードを移動することができる

プライマリモジュールインターフェース単位は、モジュール内のすべてのインターフェースパーティションの推移的インポートと再エクスポートをしなければならない。

- module implementation partitions : モジュール実装区分

モジュール内で実装が複数のファイルに分割されており、モジュール内で他のモジュールインターフェースパーティションで定義されたものを使用している場合、実装の詳細（定義）に依存することを避けるために、宣言をモジュールインターフェース単位に含めずに実装単位間で共有することが望ましいことがある  
そうすることで、定義が変更されたときにモジュールインターフェースとその依存関係を再構築する必要がなくなる  
それを可能にするのが モジュール実装区分である。

モジュール実装区分宣言
```cpp
module foo:part;
```
これは、モジュールインターフェース単位の一部ではないモジュールパーティションとなる

モジュール実装区分はエクスポートされた宣言を含めることができない
代わりに、モジュール実装区分をインポートすることで、そのモジュール実装区分のすべての宣言は同じモジュール内の他の翻訳単位から可視となる

`export`はモジュール外部への名前と宣言の可視性にのみ影響を与える。

- module partitions : モジュールパーティション  
モジュールインタフェースパーティションとモジュール実装区分はまとめて、モジュールパーティションと呼ぶ

モジュールパーティションはモジュールの実装の詳細であり、その名前をモジュール外部から参照することはできない。
そのため、モジュールパーティションを指名する`import`宣言はモジュール名を指定できず、パーティション名のみを指定することができる


```cpp
module foo;    //モジュール宣言
import :part;  //モジュールパーティションのインポート

//モジュール名の指定はコンパイルエラー
import bar:part;  //ng
import foo:part;  //ng
```

## 非モジュールコードとの相互運用

### グローバルモジュールフラグメント

以下のように、モジュール（インターフェース）単位で旧来のヘッダをインクルードした場合、そのモジュール内のすべての翻訳単位でインクルードしたのと同じことになってしまう（同じモジュール内の他のファイルでもインクルードしたヘッダの中身が見える）。

```cpp
export module mymodule;

#include <iostream>
```

グローバルモジュールフラグメントは、モジュール内部で他のモジュールパーティションから見えないように旧来のヘッダファイルを#includeするための仕組み

```cpp
module;  //グローバルモジュールフラグメントの（開始）宣言

#include <iostream>

//グローバルモジュールフラグメントの終了
export module mymodule;  //モジュールインターフェース宣言
```

グローバルモジュールフラグメント内の宣言はモジュールによって所有されない

グローバルモジュールフラグメントに含まれる宣言によってモジュールが肥大化することを防ぐため、モジュール単位で参照されていないグローバルモジュールフラグメント内の宣言は破棄される  
そのような宣言は、モジュール単位をインポートするほかの翻訳単位からは到達不可能であり 
モジュール単位の外での2段階目のテンプレートのインスタンス化（two phase name lookup）の際に見つからない

すなわち、グローバルモジュールフラグメント内の宣言は
- グローバルモジュールフラグメント終了後のそのモジュール単位内で名前が現れるか
- そのように参照されている宣言で名前が現れる

場合にその宣言が参照されているとみなされる。

```cpp
module;

#include <tuple>

export module mymodule;

export using int_tuple = std::tuple<int, int, int>;

export auto f() -> std::tuple<char, short, double>;

//これ以外のstd::tuple特殊化および、すべての関数の宣言は使用されていないので破棄される
//破棄された宣言はモジュールに含まれず、コンパイルもされない
//そして、このモジュールをimportした先で参照することもできない
```

### ヘッダーユニット

```cpp
export module foo;  //モジュールインターフェース宣言

//ヘッダーユニットのインポート宣言
import "some-header.h";
import <version>; 
```

`import`に指定されたヘッダファイルはソースファイルのように処理され、ヘッダー内のインターフェースが抽出され`import`した翻訳単位で使用可能になる。  
また、ヘッダー内でプリプロセス時に定義されたマクロも保存され、`import`した翻訳単位で使用可能になる。

ヘッダーユニット内の宣言及びコードはどのモジュールにも所有されない。  
同じエンティティを別のヘッダーユニットもしくは非モジュールコードにおいて再宣言できる。

ヘッダーユニットは通常の再エクスポート宣言と同じように再エクスポートできる。

```cpp
export module foo;
export import "some-header.h";  //ヘッダーユニット”some-header.h”の再エクスポート
```

ただし、マクロをインポートできるのはヘッダーユニット構文だけであり、再エクスポートではマクロはエクスポートされない。

### 非モジュールコード内宣言の到達可能性
グローバルモジュールフラグメント及びヘッダーユニット内の宣言は可視であるときに到達可能である。

そのような宣言が可視ではないが、推移的にインポートされている文脈でも到達可能かどうかは未規定。  
理想的にはそのような（推移的にインポートされた）宣言は到達可能であるべきではないが、そのように規定すると実装によっては実装コストが大きくなってしまうため、標準はその扱いについて規定しない。  
このルールが適用される範囲は実装に任せている。

グローバルモジュールフラグメントにおいて破棄された宣言は、モジュールの外側で可視ではなく、到達可能でもない。


### 非モジュールコードでのモジュールの利用
モジュールとヘッダーユニットは非モジュールコードにインポートすることができる。そのような`import`宣言はプリアンブルに限定されず、どこでも行うことができる。  
これによって、ボトムアップなモジュール化が可能になり、ライブラリはモジュールによるインターフェースのみを提供し、かつモジュールによるインターフェースによってヘッダーインターフェースを定義する事を切り替えることができる。

非モジュールコードには、モジュール単位を除いた翻訳単位（インポートされたヘッダーユニットを含む）及び、モジュール単位内のグローバルモジュールフラグメントが含まれる。

非モジュールコードに#includeがあり、そこで指名されているヘッダファイルがヘッダーユニット化可能である場合、実装はその#includeをヘッダーユニットのインポートに置き換える。

このような置き換えが可能な#includeを見つける方法は実装定義である。  
実装方法は様々考えられ、研究が進むことを期待してのこと。
（ヘッダーユニットを明示的にビルドしてその後のコンパイル時に利用する、ヘッダーユニットの構成を記述するファイルを導入する、など）

実装は、マッピングメカニズムを提供せずに各ヘッダーユニットを個別に処理してもいい

## 以前のバージョンからの変更

### R2からの変更

偶然到達可能なエンティティが他の定義をill-formedにしてしまうバグを修正
```cpp
// a.h 
#ifndef A_H 
#define A_H 
class X {}; 
#endif

// b.cc 
#include "a.h" 
export module B; 
X x;

// c.cc 
export module C; 
import B; // not exported

// d.cc 
import C; 
#include "a.h" //"semantic boundaries rule"によって、Xの定義が見えたとしても問題ない
```
グローバルモジュールフラグメント内のクラスXの宣言はモジュール外で可視でも到達可能でもない
しかし、`d.cc`では（`#include "a.h"`によって）Xの宣言が可視であり到達可能である（定義が見える）
これは”semantic boundaries rule”によって許可される

モジュールリンケージを持つエンティティが複数のモジュール単位で定義を持つことを許可

### R1からの変更

#### P1299R2: Module preamble is unnecessarily fragile
この提案以前は、ヘッダーユニットからインポートされたマクロがモジュール内でインポートされている物に影響を与えることは禁止されていた。

この規則によってユーザーと実装の両方で複雑さが増してしまい、依存関係の抽出をしたい実装側にとって期待した利益では正当化されないため  
この規則は削除された

この提案によると、ヘッダーユニットからインポートされたマクロはインポート直後に利用可能になる。そのようなマクロはモジュール単位のプリアンブルの後、ほかのインポート宣言の前に展開される。

#### P1242R1: Single-ﬁle modules
この提案は モジュールTSにあった”attendant entities”ルールを削除する。

このルールはモジュールの機能に空白を残していた。
モジュールの実装詳細をモジュール外部で利用できないままで、モジュールを単一ファイルで定義する方法はもはやなかった。

この提案では`module :private;`というマーカーを利用してインターフェースから実装を分離し、インターフェースと実装を備えた完全なモジュールを単一ファイルで定義できる。

### R0からの変更

#### 名前空間のエクスポート

R0およびモジュールTSでは、モジュールインターフェース単位で宣言されている全ての名前空間（無名名前空間とその中身を除く）は外部リンケージを持ち、暗黙的にエクスポートされる。

しかし、明示的に`export`した名前空間か、エクスポートされた宣言に含まれている名前空間のみがエクスポートされるように変更された。

これによって、モジュール実装詳細で使用されてる名前空間をモジュールインターフェース単位で宣言しても、モジュールインターフェースから隠す（分離する）ことができる。

#### テンプレートのインスタンス化における到達可能性

P0947R1のルールに基づいて、テンプレートインスタンス化内の宣言の可視性と到達可能性を解決するために、インスタンス化経路（path of instantiation）ルールを使用する。

テンプレートインスタンス化時に利用される宣言が、たとえテンプレートの定義されたところでもインスタンス化されるところでも可視でも到達可能でもなかったとしても  
このルールの下では、テンプレートのインスタンス化の経路の各点で可視または到達可能であれば、それら全ての宣言を利用することが許可される。

```cpp
//moduleA.cpp
export module A;

export template<typename T, typename U> void f(T t, U u) { t.f(); }


//moduleB.cpp
module;

//グローバルモジュールフラグメント内宣言、モジュールBからのみ可視
struct S { 
  void f();
};

export module B;

import A;  //モジュールAのインポート（not エクスポート）

export template<typename U> void g(U u) { S s; f(s, u); }


//moduleC.cpp
export module C;

import B;  //モジュールBのインポート（not エクスポート）

export template<typename U> void h(const U &u) { g(u); }


//main.cpp
import C;

int main() { 
  h(0);
}
```
構造体`S`の定義およびそのメンバ関数`S::f()`の宣言は、インスタンス化地点（`f<S, int>()`）からもそのテンプレート定義からも到達可能ではない。  
しかし、`S`はインスタンス化経路上のモジュールBにおいて到達可能であるので、このコードは有効である。

宣言がインスタンス化経路上でさえも到達可能でなかったとしても、インスタンス化したところにおいてそれら宣言が推移的にインポートされているのならば、実装はそれらを到達可能な追加宣言として扱うことが許されている。

```cpp
module M;

struct S;

import C; // unspeciﬁed whether a deﬁnition of S is reachable here or in the instantiation of h<S>

void q(const S &s) { h(s); } 
```
この例ではモジュールMにおいて`S`の定義は到達可能ではないが、インポートしているモジュールCを通して推移的にインポートされているモジュールBに定義がある。  
この時、`import C;`の点およびそのあとの`h<S>`のインスタンス化地点で`S`の定義が到達可能であるかは未規定（実装は到達可能であるとしてもよい）。

この、インスタンス化経路（path of instantiation）というルールはADLにも適用される。
インスタンス化経路で可視である名前はADLでも可視になる。

さらに、そのように見つかった名前に付属する型を所有しているモジュールでエクスポートされた宣言もADLで可視となる。

ただし、グローバルモジュール内の内部リンケージ宣言は無視される。

#### プリアンブルの終端の検出

R0ではプリプロセッサはプリアンブルの終端を見つけたうえで、その場所でヘッダーユニットからインポートされたマクロを可視にするという負担を負っていた。  
実装者にとっては実装が難しく、ユーザーにとっては書いたコードの想定異なる振舞を行い、プリアンブルのインポートと非モジュールコードでのインポートとで意味が異なることになる
など、問題があった。

そのため、この提案ではよりシンプルなルールを導入する。
ヘッダーユニットからインポートされたマクロは、そのヘッダーユニットのインポート宣言の直後に可視になる。

### モジュール TSからの変更

グローバルモジュールフラグメントの前に、`module;`という導入宣言が必要になった。

モジュールによって所有されているがエクスポートされていないエンティティが、モジュールインターフェースのエクスポート宣言によって参照されている場合  
モジュール TSはそのエクスポートの時点で、エクスポートしているエンティティに関連する意味論的プロパティ（semantic properties）をエクスポートする。
もし、そのような複数のエクスポートがエンティティに異なる意味を与える場合はill-formed

```cpp
export module M;

struct S;
export S f(); // S incomplete here

struct S {};
export S g(); // S complete here, error 
```

Atom提案では、そのようなエンティティの意味は、モジュールインターフェース単位の最後にその特性から決定される。

この提案では、モジュールによって所有される全てのエンティティの意味は、モジュールインターフェース単位の終わりにその特性から決定される（エクスポートされているかに関わらず）。

モジュールインターフェースに宣言どの順番で表れるかは、どの特性による意味がエクスポートされるかとは無関係。  
（あるエンティティのどの特性が意味としてエクスポートされるかは、宣言順に依存しない）

モジュール TSにあった、付随するエンティティ（attendant entities）ルールは、適用できるケースが無くなったため削除された。

モジュール内で`extern "C"`、`extern "C++"`で宣言されたエンティティはモジュールによって所有されなくなった。  
（モジュールTSの意図からの変更であるかは不明）

この提案では、名前空間名はあまり頻繁にエクスポートされなくなった。

### P0947R0 (“Another Take On Modules”)からの変更

この提案では、グローバルモジュールフラグメントをサポートするが、Atom提案のプリアンブルをコンパイラ以外に識別させるという目標を妨げている。
しかし、その目標から得られる利点はグローバルモジュールフラグメントを利用しない場合には有効である。

Atom提案では`export`と`module`は文脈依存キーワードとされていたが、この提案ではそれぞれキーワードとして扱われる。  
これは、[P0924R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0924r0.pdf)における議論からのEWGの指示に従っている。


## Wording Change

### 5.4 Preprocessing tokens [lex.pptoken]
これまでに処理された一連のプリプロセッシングトークンが翻訳フェーズ4までコンパイル可能であり、結果として`import`宣言になる場合  
プリプロセッシングディレクティブの外側では翻訳フェーズ4を適用する。


### 6.2 One-deﬁnition rule [basic.def.odr]
1  
変数、関数、クラス型、列挙型、テンプレートは、以前の定義が到達可能であるところで再定義されてはならない。
ただし、そのような以前の宣言が別の翻訳単位にある場合の診断は不要である。

10  
inline関数/変数の定義は、discarded statementの外側でodr-usedされているすべての翻訳単位で到達可能でなければならない。

11  
クラスの定義は、そのクラスが完全型であることを要求して使用されるすべての文脈で到達可能でなければならない

12  
定義が現れる時点で、事前定義が必ずしも到達可能ではなく、定義が以下の要件を満たす場合、次のものはプログラム内に複数の定義を持つことがある。

- クラス・列挙型
- 外部リンケージを持つinline関数・変数
- クラステンプレート
  - 静的メンバ変数
  - メンバ関数
- 非static関数テンプレート
- コンセプト
- 一部のパラメータが指定されていないテンプレートの特殊化

（以下の要件、は省略・・・）

ただし、名前付きの（もしくは、指名された？）モジュールに付属するエンティティは複数の定義を持ってはならない。  
その場合、後の定義が現れるときに前の定義が到達可能でなければ、診断は不要である。

### 6.3.6 Namespace scope [basic.scope.namespace] 