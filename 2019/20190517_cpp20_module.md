# ［C++］モジュール 理論編

### モジュールの構成

### ファイルの分割

### `export`

### `import`

### ADLとモジュール

### 非モジュールコードとの相互運用

#### Header Unit

### モジュール史（2004 - 2019）
- Moduleのあけぼの
  - [N1736: Modules in C++ (Revision 1)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1736.pdf)
  - [N1778: Modules in C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1778.pdf)
  - [N1964: Modules in C++ (Revision 3)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1964.pdf)
  - [N2073: Modules in C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf)
  - [N2316: Modules in C++ (Revision 5)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2316.pdf)
  - [N3347: Modules in C++ (Revision 6)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3347.pdf)
- MSの隆盛
  - [N4047: A Module System for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4047.pdf)
  - [N4214: A Module System for C++ (Revision 2)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4214.pdf)
  - [N4465: A Module System for C++ (Revision 3)](http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4465.pdf)
  - [P0142R0: A Module System for C++ (Revision 4)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0142r0.pdf)
- Moduleの挑戦とつまづき
  - [N4466: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4466.pdf)
  - [P0143R0: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r0.pdf)
  - [P0143R1: Wording for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0143r1.pdf)
- Module TSの時代
  - [N4592: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4592.pdf)
  - [N4610: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4610.pdf)
  - [N4637: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4637.pdf)
  - [N4681: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4681.pdf)
  - [N4720: Working Draft, Extensions to C++ for Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4720.pdf)
- googleの台頭（Atom Proposals）
  - [P0947R0: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r0.html)
  - [P0947R1: Another take on Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0947r1.html)
  - [P0986R0: Comparison of Modules Proposals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0986r0.html)
- ひらけゆくModule
  - [P1103R0 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r0.pdf)
  - [P1103R1 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r1.pdf)
  - [P1103R2 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1103r2.pdf)
  - [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)

### 参考文献

- [P1103R3 : Merging Modules](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf)
- [モジュール - cpprefjp](https://cpprefjp.github.io/lang/cpp20/modules.html)
- [C++ ModulesのHeader units - Qita](https://qiita.com/tetsurom/items/e25b2683cb7e7c0fa91c)
- [C++ Modulesの分割 - Qita](https://qiita.com/tetsurom/items/0de4795866b52f5bcf65)
- [C++ ModulesとDLLの関係 (MSVCの場合) - Qita](https://qiita.com/tetsurom/items/0f6aad21e06b043f42bd)
- [Understanding C++ Modules: Part 1: Hello Modules, and Module Units - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/10/modules-1.html)
- [Understanding C++ Modules: Part 2: export, import, visible, and reachable - vector<bool>{ true, true, false };](https://vector-of-bool.github.io/2019/03/31/modules-2.html)
- [C++20: Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-modules)
- [C++20: More Details to Modules - MODERNES C++](https://www.modernescpp.com/index.php/c-20-more-details-to-modules)
- [C++ MODULES - HSAE - Wuhan · 张轶](http://purecpp.org/purecpp/static/717887c97bf947d68e67da309cdd0611.pdf)

# メモ

- module unit : モジュール単位  
モジュールを構成する翻訳単位  
ファイル先頭のモジュール宣言によりモジュール単位は開始される  
その後にimport宣言が続く（なくてもよい

モジュール宣言
```cpp
module foo;  //ファイル先頭で行う
```

- module interface unit : モジュールインターフェース単位  
module unitであり、モジュール宣言にexportを伴うもの

モジュールインターフェース宣言
```cpp
export module foo;  //ファイル先頭で行う
```

モジュールのインターフェースを定義する  
インターフェース：シグネチャ、宣言みたいな

モジュールは少なくとも一つがモジュールインターフェース単位である必要がある

- primary module interface unit : プライマリモジュールインターフェース単位  
モジュール名と同じモジュールインターフェース宣言を含むモジュール単位  
モジュールfooなら`export module foo;`

- module interface partitions : モジュールインタフェースパーティション  
プライマリではないすべてのモジュールインターフェース単位

## visible と reachable

- visible : 可視  
名前探索によって宣言が見つかれば、そのコンテキストでその宣言は可視である

- reachable : 到達可能  
名前の意味論的効果が使用可能である場合、そのコンテキストでその宣言は到達可能である  
例えば、あるコンテキストでクラスが完全型であるならば、そのクラスの定義は到達可能である

宣言は可視 -> 到達可能 : true  
到達可能 -> 宣言は可視 : false（必ずしも成り立たない）

importはどの名前空間スコープの名前が可視になるか
および、どの宣言が意味論的に（semantically）到達可能か
だけをコントロールする。

あるエンティティの振る舞いは、そのエンティティの到達可能な宣言の集合によって決まる（エンティティ = 名前・定義？）
例えば、クラス・列挙体のメンバはその定義が到達可能であるとき、名前探索で可視である

## export
宣言は`export`を用いてモジュールインターフェース単位内でエクスポートできる

内部リンケージを持つものを除いて、エクスポートされていない宣言はそのモジュール単位をインポートする同じモジュール内の名前探索で可視である

推移的にインポートされたモジュール単位内のすべての宣言は、エクスポートされているかにかかわらず到達可能（？？

モジュール単位は対応するモジュールインタフェース単位を暗黙にインポートする

名前空間内の宣言（名前空間を伴う宣言）がエクスポートされると、その名前空間も暗黙的にエクスポートされる。
名前空間をエクスポートすると、名前空間内の宣言は（暗黙的に）エクスポートされる。

## module partitions : モジュールパーティション

一つのモジュールは単一のファイルでも複数のファイルでも定義できる。  
例えば、宣言（モジュールインターフェースユニット）と定義（実装）をファイルで分割することができる。

モジュールパーティションは、そのようなインターフェースと実装を分割することを可能にする

- module interface partitions : モジュールインターフェースパーティション

モジュールインターフェースは必要に応じて複数のファイルに分割することができる。
それらのファイルをモジュールインターフェースパーティションと呼ぶ。
以下のようなモジュールインターフェースパーティション宣言を（その他のモジュール宣言の代わりに）含む翻訳単位のこと。

モジュールインターフェースパーティション宣言
```cpp
export module foo::part;
```

モジュールインターフェースパーティションに含まれるエンティティの所有権は属しているモジュールと共有される。  
それ以外は、モジュールインターフェースパーティションは単一のモジュールと同じ振る舞いをする。  

そのため、エンティティの宣言と定義を別々のパーティションで行うことができる  
これは、モジュール内部で発生しうる循環参照（依存関係のループ）を解決するために必要  
これはまた、ABIを変えることなくモジュール内でコードを移動することができる

プライマリモジュールインターフェース単位は、モジュール内のすべてのインターフェースパーティションの推移的インポートと再エクスポートをしなければならない。

- module implementation partitions : モジュール実装区分

モジュール内で実装が複数のファイルに分割されており、モジュール内で他のモジュールインターフェースパーティションで定義されたものを使用している場合、実装の詳細（定義）に依存することを避けるために、宣言をモジュールインターフェース単位に含めずに実装単位間で共有することが望ましいことがある  
そうすることで、定義が変更されたときにモジュールインターフェースとその依存関係を再構築する必要がなくなる  
それを可能にするのが モジュール実装区分である。

モジュール実装区分宣言
```cpp
module foo:part;
```
これは、モジュールインターフェース単位の一部ではないモジュールパーティションとなる

モジュール実装区分はエクスポートされた宣言を含めることができない
代わりに、モジュール実装区分をインポートすることで、そのモジュール実装区分のすべての宣言は同じモジュール内の他の翻訳単位から可視となる

`export`はモジュール外部への名前と宣言の可視性にのみ影響を与える。

- module partitions : モジュールパーティション  
モジュールインタフェースパーティションとモジュール実装区分はまとめて、モジュールパーティションと呼ぶ

モジュールパーティションはモジュールの実装の詳細であり、その名前をモジュール外部から参照することはできない。
そのため、モジュールパーティションを指名する`import`宣言はモジュール名を指定できず、パーティション名のみを指定することができる


```cpp
module foo;    //モジュール宣言
import :part;  //モジュールパーティションのインポート

//モジュール名の指定はコンパイルエラー
import bar:part;  //ng
import foo:part;  //ng
```

## 非モジュールコードとの相互運用

### グローバルモジュールフラグメント

以下のように、モジュール（インターフェース）単位で旧来のヘッダをインクルードした場合、そのモジュール内のすべての翻訳単位でインクルードしたのと同じことになってしまう（同じモジュール内の他のファイルでもインクルードしたヘッダの中身が見える）。

```cpp
export module mymodule;

#include <iostream>
```

グローバルモジュールフラグメントは、モジュール内部で他のモジュールパーティションから見えないように旧来のヘッダファイルを#includeするための仕組み

```cpp
module;  //グローバルモジュールフラグメントの（開始）宣言

#include <iostream>

//グローバルモジュールフラグメントの終了
export module mymodule;  //モジュールインターフェース宣言
```

グローバルモジュールフラグメント内の宣言はモジュールによって所有されない

グローバルモジュールフラグメントに含まれる宣言によってモジュールが肥大化することを防ぐため、モジュール単位で参照されていないグローバルモジュールフラグメント内の宣言は破棄される  
そのような宣言は、モジュール単位をインポートするほかの翻訳単位からは到達不可能であり 
モジュール単位の外での2段階目のテンプレートのインスタンス化（two phase name lookup）の際に見つからない

すなわち、グローバルモジュールフラグメント内の宣言は
- グローバルモジュールフラグメント終了後のそのモジュール単位内で名前が現れるか
- そのように参照されている宣言で名前が現れる

場合にその宣言が参照されているとみなされる。

```cpp
module;

#include <tuple>

export module mymodule;

export using int_tuple = std::tuple<int, int, int>;

export auto f() -> std::tuple<char, short, double>;

//これ以外のstd::tuple特殊化および、すべての関数の宣言は使用されていないので破棄される
//破棄された宣言はモジュールに含まれず、コンパイルもされない
//そして、このモジュールをimportした先で参照することもできない
```

### ヘッダーユニット

```cpp
export module foo;  //モジュールインターフェース宣言

//ヘッダーユニットのインポート宣言
import "some-header.h";
import <version>; 
```

`import`に指定されたヘッダファイルはソースファイルのように処理され、ヘッダー内のインターフェースが抽出され`import`した翻訳単位で使用可能になる。  
また、ヘッダー内でプリプロセス時に定義されたマクロも保存され、`import`した翻訳単位で使用可能になる。

ヘッダーユニット内の宣言及びコードはどのモジュールにも所有されない。  
同じエンティティを別のヘッダーユニットもしくは非モジュールコードにおいて再宣言できる。

ヘッダーユニットは通常の再エクスポート宣言と同じように再エクスポートできる。

```cpp
export module foo;
export import "some-header.h";  //ヘッダーユニット”some-header.h”の再エクスポート
```

ただし、マクロをインポートできるのはヘッダーユニット構文だけであり、再エクスポートではマクロはエクスポートされない。

### 非モジュールコード内宣言の到達可能性
グローバルモジュールフラグメント及びヘッダーユニット内の宣言は可視であるときに到達可能である。

そのような宣言が可視ではないが、推移的にインポートされている文脈でも到達可能かどうかは未規定。  
理想的にはそのような（推移的にインポートされた）宣言は到達可能であるべきではないが、そのように規定すると実装によっては実装コストが大きくなってしまうため、標準はその扱いについて規定しない。  
このルールが適用される範囲は実装に任せている。

グローバルモジュールフラグメントにおいて破棄された宣言は、モジュールの外側で可視ではなく、到達可能でもない。


### 非モジュールコードでのモジュールの利用
モジュールとヘッダーユニットは非モジュールコードにインポートすることができる。そのような`import`宣言はプリアンブルに限定されず、どこでも行うことができる。  
これによって、ボトムアップなモジュール化が可能になり、ライブラリはモジュールによるインターフェースのみを提供し、かつモジュールによるインターフェースによってヘッダーインターフェースを定義する事を切り替えることができる。

非モジュールコードには、モジュール単位を除いた翻訳単位（インポートされたヘッダーユニットを含む）及び、モジュール単位内のグローバルモジュールフラグメントが含まれる。

非モジュールコードに#includeがあり、そこで指名されているヘッダファイルがヘッダーユニット化可能である場合、実装はその#includeをヘッダーユニットのインポートに置き換える。

このような置き換えが可能な#includeを見つける方法は実装定義である。  
実装方法は様々考えられ、研究が進むことを期待してのこと。
（ヘッダーユニットを明示的にビルドしてその後のコンパイル時に利用する、ヘッダーユニットの構成を記述するファイルを導入する、など）

実装は、マッピングメカニズムを提供せずに各ヘッダーユニットを個別に処理してもいい

## 以前のバージョンからの変更

### R2からの変更

偶然到達可能なエンティティが他の定義をill-formedにしてしまうバグを修正
```cpp
// a.h 
#ifndef A_H 
#define A_H 
class X {}; 
#endif

// b.cc 
#include "a.h" 
export module B; 
X x;

// c.cc 
export module C; 
import B; // not exported

// d.cc 
import C; 
#include "a.h" //"semantic boundaries rule"によって、Xの定義が見えたとしても問題ない
```
グローバルモジュールフラグメント内のクラスXの宣言はモジュール外で可視でも到達可能でもない
しかし、`d.cc`では（`#include "a.h"`によって）Xの宣言が可視であり到達可能である（定義が見える）
これは”semantic boundaries rule”によって許可される

モジュールリンケージを持つエンティティが複数のモジュール単位で定義を持つことを許可

### R1からの変更

#### P1299R2: Module preamble is unnecessarily fragile
この提案以前は、ヘッダーユニットからインポートされたマクロがモジュール内でインポートされている物に影響を与えることは禁止されていた。

この規則によってユーザーと実装の両方で複雑さが増してしまい、依存関係の抽出をしたい実装側にとって期待した利益では正当化されないため  
この規則は削除された

この提案によると、ヘッダーユニットからインポートされたマクロはインポート直後に利用可能になる。そのようなマクロはモジュール単位のプリアンブルの後、ほかのインポート宣言の前に展開される。

#### P1242R1: Single-ﬁle modules
この提案は モジュールTSにあった”attendant entities”ルールを削除する。

このルールはモジュールの機能に空白を残していた。
モジュールの実装詳細をモジュール外部で利用できないままで、モジュールを単一ファイルで定義する方法はもはやなかった。

この提案では`module :private;`というマーカーを利用してインターフェースから実装を分離し、インターフェースと実装を備えた完全なモジュールを単一ファイルで定義できる。

### R0からの変更

#### 名前空間のエクスポート

R0およびモジュールTSでは、モジュールインターフェース単位で宣言されている全ての名前空間（無名名前空間とその中身を除く）は外部リンケージを持ち、暗黙的にエクスポートされる。

しかし、明示的に`export`した名前空間か、エクスポートされた宣言に含まれている名前空間のみがエクスポートされるように変更された。

これによって、モジュール実装詳細で使用されてる名前空間をモジュールインターフェース単位で宣言しても、モジュールインターフェースから隠す（分離する）ことができる。

#### テンプレートのインスタンス化における到達可能性

P0947R1のルールに基づいて、テンプレートインスタンス化内の宣言の可視性と到達可能性を解決するために、インスタンス化経路（path of instantiation）ルールを使用する。

テンプレートインスタンス化時に利用される宣言が、たとえテンプレートの定義されたところでもインスタンス化されるところでも可視でも到達可能でもなかったとしても  
このルールの下では、テンプレートのインスタンス化の経路の各点で可視または到達可能であれば、それら全ての宣言を利用することが許可される。

```cpp
//moduleA.cpp
export module A;

export template<typename T, typename U> void f(T t, U u) { t.f(); }


//moduleB.cpp
module;

//グローバルモジュールフラグメント内宣言、モジュールBからのみ可視
struct S { 
  void f();
};

export module B;

import A;  //モジュールAのインポート（not エクスポート）

export template<typename U> void g(U u) { S s; f(s, u); }


//moduleC.cpp
export module C;

import B;  //モジュールBのインポート（not エクスポート）

export template<typename U> void h(const U &u) { g(u); }


//main.cpp
import C;

int main() { 
  h(0);
}
```
構造体`S`の定義およびそのメンバ関数`S::f()`の宣言は、インスタンス化地点（`f<S, int>()`）からもそのテンプレート定義からも到達可能ではない。  
しかし、`S`はインスタンス化経路上のモジュールBにおいて到達可能であるので、このコードは有効である。

宣言がインスタンス化経路上でさえも到達可能でなかったとしても、インスタンス化したところにおいてそれら宣言が推移的にインポートされているのならば、実装はそれらを到達可能な追加宣言として扱うことが許されている。

```cpp
module M;

struct S;

import C; // unspeciﬁed whether a deﬁnition of S is reachable here or in the instantiation of h<S>

void q(const S &s) { h(s); } 
```
この例ではモジュールMにおいて`S`の定義は到達可能ではないが、インポートしているモジュールCを通して推移的にインポートされているモジュールBに定義がある。  
この時、`import C;`の点およびそのあとの`h<S>`のインスタンス化地点で`S`の定義が到達可能であるかは未規定（実装は到達可能であるとしてもよい）。

この、インスタンス化経路（path of instantiation）というルールはADLにも適用される。
インスタンス化経路で可視である名前はADLでも可視になる。

さらに、そのように見つかった名前に付属する型を所有しているモジュールでエクスポートされた宣言もADLで可視となる。

ただし、グローバルモジュール内の内部リンケージ宣言は無視される。

#### プリアンブルの終端の検出

R0ではプリプロセッサはプリアンブルの終端を見つけたうえで、その場所でヘッダーユニットからインポートされたマクロを可視にするという負担を負っていた。  
実装者にとっては実装が難しく、ユーザーにとっては書いたコードの想定異なる振舞を行い、プリアンブルのインポートと非モジュールコードでのインポートとで意味が異なることになる
など、問題があった。

そのため、この提案ではよりシンプルなルールを導入する。
ヘッダーユニットからインポートされたマクロは、そのヘッダーユニットのインポート宣言の直後に可視になる。

### モジュール TSからの変更

グローバルモジュールフラグメントの前に、`module;`という導入宣言が必要になった。

モジュールによって所有されているがエクスポートされていないエンティティが、モジュールインターフェースのエクスポート宣言によって参照されている場合  
モジュール TSはそのエクスポートの時点で、エクスポートしているエンティティに関連する意味論的プロパティ（semantic properties）をエクスポートする。
もし、そのような複数のエクスポートがエンティティに異なる意味を与える場合はill-formed

```cpp
export module M;

struct S;
export S f(); // S incomplete here

struct S {};
export S g(); // S complete here, error 
```

Atom提案では、そのようなエンティティの意味は、モジュールインターフェース単位の最後にその特性から決定される。

この提案では、モジュールによって所有される全てのエンティティの意味は、モジュールインターフェース単位の終わりにその特性から決定される（エクスポートされているかに関わらず）。

モジュールインターフェースに宣言どの順番で表れるかは、どの特性による意味がエクスポートされるかとは無関係。  
（あるエンティティのどの特性が意味としてエクスポートされるかは、宣言順に依存しない）

モジュール TSにあった、付随するエンティティ（attendant entities）ルールは、適用できるケースが無くなったため削除された。

モジュール内で`extern "C"`、`extern "C++"`で宣言されたエンティティはモジュールによって所有されなくなった。  
（モジュールTSの意図からの変更であるかは不明）

この提案では、名前空間名はあまり頻繁にエクスポートされなくなった。

### P0947R0 (“Another Take On Modules”)からの変更

この提案では、グローバルモジュールフラグメントをサポートするが、Atom提案のプリアンブルをコンパイラ以外に識別させるという目標を妨げている。
しかし、その目標から得られる利点はグローバルモジュールフラグメントを利用しない場合には有効である。

Atom提案では`export`と`module`は文脈依存キーワードとされていたが、この提案ではそれぞれキーワードとして扱われる。  
これは、[P0924R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0924r0.pdf)における議論からのEWGの指示に従っている。


## Wording Change

### 5.4 Preprocessing tokens [lex.pptoken]
これまでに処理された一連のプリプロセッシングトークンが翻訳フェーズ4までコンパイル可能であり、結果として`import`宣言になる場合  
プリプロセッシングディレクティブの外側では翻訳フェーズ4を適用する。


### 6.2 One-deﬁnition rule [basic.def.odr]
1  
変数、関数、クラス型、列挙型、テンプレートは、以前の定義が到達可能であるところで再定義されてはならない。
ただし、そのような以前の宣言が別の翻訳単位にある場合の診断は不要である。

10  
inline関数/変数の定義は、discarded statementの外側でodr-usedされているすべての翻訳単位で到達可能でなければならない。

11  
クラスの定義は、そのクラスが完全型であることを要求して使用されるすべての文脈で到達可能でなければならない

12  
定義が現れる時点で、事前定義が必ずしも到達可能ではなく、定義が以下の要件を満たす場合、次のものはプログラム内に複数の定義を持つことがある。

- クラス・列挙型
- 外部リンケージを持つinline関数・変数
- クラステンプレート
  - 静的メンバ変数
  - メンバ関数
- 非static関数テンプレート
- コンセプト
- 一部のパラメータが指定されていないテンプレートの特殊化

（以下の要件、は省略・・・）

ただし、名前付きの（もしくは、指名された？）モジュールに付属するエンティティは複数の定義を持ってはならない。  
その場合、後の定義が現れるときに前の定義が到達可能でなければ、診断は不要である。

### 6.3.6 Namespace scope [basic.scope.namespace] 

翻訳単位`Q`が別の翻訳単位`R`にインポートされている時、`Q`の名前空間スコープで宣言された名前`X`の潜在的なスコープは、  
次の全てを満たす場合に`Q`を（直接または間接的に）インポートする`R`の、最初のmodule-import-declarationかmodule-declarationに続く、`R`の対応する名前空間スコープを含むように拡張される。

- `X`は内部リンケージを持たない
- `X`が`Q`内のmodule-declarationの後に宣言されている（もしあれば）
- `X`はエクスポートされているか、`Q`と`R`は同じモジュールの一部

[module-import-declarationは指定された翻訳単位と、その中でexported module-import-declarationによって指定された全てのモジュールの両方を再帰的にエクスポートする]

### 6.4 Name lookup [basic.lookup]
（ある名前の）名前探索、関数オーバーロード解決、アクセスチェック、が成功した後で初めて、その名前の宣言及び到達可能な再宣言によって導入された意味論的特性（semantic properties）が式の処理（評価）に使用される。

### 6.4.2 Argument-dependent name lookup [basic.lookup.argdep] 
関連名前空間`N`を探索するとき、次の点を除いて`N`が修飾子として使用されるときに実行される探索と同じことが行われる。

- N内のusingディレクティブはすべて無視される
- 関数と関数テンプレート（オーバーロードされているかもしれない）、以外の名前はすべて無視される
- 関連エンティティの集合の中で 到達可能な定義を持つ クラス内で宣言されたフレンド関数（テンプレート）は、たとえそれらが通常の名前探索で可視でなかったとしてもそれぞれの名前空間内で可視である
- 指名されたモジュール`M`のインターフェース内名前空間`N`の内側にある宣言`D`は、`D`を囲む最も内側の非inline名前空間内に、`M`に付属する関連エンティティがある場合にすべて可視となる
- 探索が依存名に対するものである場合、`N`内の宣言`D`が探索のインスタンス化コンテキストの任意の点における修飾名探索で可視であるとき 次の場合を除いて`N`内の宣言`D`はすべて可視である。
  - 宣言`D`は別の翻訳単位で宣言されていて、
  - グローバルモジュールに付属しており、かつ
    - 破棄されている、もしくは
    - 内部リンケージを持つ


### 6.4.3.2 Namespace members [namespace.qual] 
名前空間`X`と名前`m`があるとき、名前空間修飾探索集合`S(X, m)`は次のように定義される
- `X`内のすべての`m`の宣言及び、`X`内のinline名前空間の集合を`S'(X, m)`とする
  - その潜在的なスコープには、`m`が宣言されている場所のnested-name-speciﬁerの名前空間が含まれる
- `S'(X, m)`が空でない場合、`S'(X, m) = S(X, m)`
- そうでない場合は`S(X, m)`は`S(Ni, m)`のiについての和集合、`Ni`は`X`内にあるすべてのusingディレクティブとinline名前空間の集合の元

### 6.5 Program and linkage [basic.link]
プログラムは互いにリンクされた1つ以上の翻訳単位から成る。

翻訳単位は宣言の列から成る。

- translation-unit
  - top-level-declaration-seq (opt)
  - global-module-fragment (opt) module-declarationtop-level-declaration-seq (opt) private-module-fragment (opt)
- private-module-fragment:
  - `module : private ;` top-level-declaration-seq (opt)
- top-level-declaration-seq:
  - top-level-declaration
  - top-level-declaration-seq top-level-declaration
- top-level-declaration:
  - module-import-declaration
  - declaration 

#### 2
private-module-fragmentはプライマリモジュールインターフェース単位にだけ表れる。 
private-module-fragmentを持つモジュール単位は、そのモジュールで唯一のモジュール単位となる。その診断は不要。

#### 3  
`module`, `export module`, `import`, `export import`、のどれかで始まり、直後に`::`が続かないトークン列がtop-level-declarationのdeclarationとして扱われる事は無い。  
（訳注：例えば、`module::C f(){}`、`export import::T g(int);`のような形の宣言は既に存在している可能性がある（か存在しうる）ので、それを考慮しての文面だと思われる。`export`は予約語なのでこの心配はない）

#### 4  
別のスコープの宣言によって導入された名前と同じ、オブジェクト、参照、関数、型、テンプレート、名前空間、値、を示す可能性がある場合、その名前はリンケージを持つ。

名前がモジュールリンケージを持つ場合、その名前が示すエンティティは次の名前から参照することができる（参照されうる、逆もしかり）。
- 同じモジュール単位内の、他のスコープにある名前
- 同じモジュール内の、他のモジュール単位のスコープにある名前

#### 5  
名前空間スコープをもつ名前のうち、CV修飾されていない非テンプレートの変数は、次のいずれでもない場合に内部リンケージを持つ。
- 明示的に`extern`と宣言されている
- `inline`変数
- エクスポートされている
- その変数名は以前に宣言されていて、その宣言が内部リンケージを持たない

[Note: const修飾された型のインスタンス化された変数テンプレートは、`extern`と宣言されていなくても、外部リンケージまたはモジュールリンケージを持つ]

#### 6
無名名前空間、または無名名前空間で直接または間接的に宣言された名前空間は内部リンケージを持つ。  
そうでない名前空間は外部リンケージを持つ。  
上記の内部リンケージを持たない名前空間を持ち、次のいずれかのものの名前
- 変数
- 関数
- 名前付きクラス
- `typedef`された名前を持つ、`typedef`で宣言された名前のないクラス
- 名前付き列挙型
- `typedef`された名前を持つ、`typedef`で宣言された名前のない列挙型
- テンプレート

である場合のリンケージは次のように決定される。
- 囲む名前空間が内部リンケージを持つ場合、その名前も内部リンケージを持つ。
- そうでなく、名前の宣言はモジュールに付属しており、エクスポートされてない場合、その名前はモジュールリンケージを持つ。
- それ以外の場合、その名前は外部リンケージを持つ。

#### 8
ブロックスコープで宣言された関数名と、extern付きの変数名はリンケージを持つ。  
そのような宣言が指名されたモジュールに属している場合、プログラムはill-formed。

#### 11
2つの名前が同じであり異なるスコープで宣言されているとき、次の全てを満たす場合に同じ変数・関数型、テンプレート、名前空間、を表す。
- 2つの名前が外部リンケージかモジュールリンケージを持っており、同じモジュールに属した宣言によって宣言されている、もしくは、2つの名前が内部リンケージを持ち同じ翻訳単位で宣言されている
- 2つの名前は同じ名前空間、もしくは継承されていないクラスのメンバーを参照する
- 両方の名前が関数名であるとき、その引数型が同一である
- 両方の名前がテンプレート関数名であるとき、そのシグネチャが一致している

（関数名でなければ、上の二つを満たしていれば二つの名前は同じものを指している）

外部リンケージを持つ同じ名前の複数の宣言が、異なるモジュールに属していること以外は同じエンティティを宣言している場合、プログラムはill-formdであり、診断は不要。

#### 12
宣言が、別のモジュールに属した到達可能な宣言を再宣言する場合、プログラムはill-formd

この規則によって、エンティティのすべての宣言は同じモジュールに属していなければならない、という帰結が得られる。
そのようなエンティティはモジュールに ***属している（attached）*** と言われる


### 6.8.3.1 main function [basic.start.main]

#### 1
プログラムはグローバルモジュールに属している`main`という名前のグローバル関数を含む。

#### 2
以下のプログラムは全てill-formdである。
- グローバルスコープで`main`という名前の変数を宣言している
- 名前付きのモジュールに属しているグローバルスコープで`main`という名前の関数を宣言している
- Cリンケージを使用して`main`という名前の関数を宣言している

### 9.1.6 The inline speciﬁer [dcl.inline] 

#### 6
inline変数・関数がある翻訳単位でodr-usedされているとき、その翻訳単位の末尾からその定義が到達可能でなければならず、全ての（odr-usedされている）翻訳単位で同様かつ、全く同じ定義を持っていなければならない。（inline変数の使用、inline関数の呼び出しはその定義が（翻訳単位内で）現れる前に行われる可能性がある）

関数・変数の定義が、最初のinline宣言の時点で到達可能である場合、プログラムはill-formed。

外部リンケージまたはモジュールリンケージをもつ関数・変数が1つの翻訳単位内でinline宣言されている場合、それが宣言されているすべての翻訳単位内に到達可能なinline宣言が無ければならない。  
ただし、この診断は不要。

外部リンケージまたはモジュールリンケージを持つinline関数・変数はすべての翻訳単位で同じアドレスを持つ。  
（外部リンケージまたはモジュールリンケージを持つinline関数内の`static`ローカル変数は常に同じオブジェクトを参照する。  
外部リンケージまたはモジュールリンケージを持つinline関数内で定義された型はすべての翻訳単位で同じ型）

#### 7
エクスポートされたinline関数・変数は、（存在している場合）プライベートモジュールフラグメントの外側で、そのエクスポートされた宣言を含む翻訳単位で定義される。  
[Note: エクスポートされたinline関数の本体から参照できるエンティティのリンケージに制限はない（リンケージ無しでもok）。constexpr関数は暗黙inline]

### 9.1.7.4 The auto speciﬁer [dcl.spec.auto]
（9.1.7.5 Placeholder type specifiers 
[dcl.spec.auto]に変更されてる）

#### 10
プレースホルダ型（`auto`のこと）を戻り値型に使用する宣言を持つエクスポートされた関数は、そのエクスポートされた宣言を含む翻訳単位内で、かつ（存在している場合）プライベートモジュールフラグメントの外側で定義されなければならない。  
[Note: 推論される戻り値型のリンケージに制限はない]

### 9.7 Namespaces [basic.namespace]

#### 1
名前空間は名前付き（無くても良い）の宣言領域である。  
名前空間の名前を利用して、名前空間内に宣言されたエンティティにアクセスできる。すなわち、そのようなエンティティは名前空間のメンバである。  
他の宣言領域とは異なり、名前空間の定義は1つ以上の翻訳単位に分割でき、さらにその中で複数の部分に分割できる。

#### 2
名前空間の定義のうちの1つがエクスポートされる場合、または名前空間がエクスポートされた宣言を含む場合、外部リンケージを持つ名前空間がエクスポートされる。  
名前空間はモジュールに属すことはなく、エクスポートされなかったとしてもモジュールリンケージを持つことはない。

### 10.1 Module units and purviews [module.unit]

- module-declaration:
  - `export` (opt) `module` module-name module-partition (opt) attribute-speciﬁer-seq (opt);
- module-name:
  - module-name-qualifier (opt) identifier
- module-partition:
  - : module-name-qualifier (opt) identifier
- module-name-qualifier:
  - identifier `.`
  - module-name-qualifier identifier `.`

#### 1
__モジュール単位__（*module unit*）とは __モジュール宣言__（module-declaration）を含む翻訳単位。  
__名前付きモジュール__（*named module*）とは同じ __モジュール名__（module-name）を持つモジュールの集まり。  
`module`と`import`の識別子は、モジュール名もしくは __モジュールパーティション__（module-partition）の識別子として表れることはない。  
attribute-speciﬁerseqはモジュール宣言に属する（attribute-speciﬁerseqは0個以上の属性指定のこと）。

#### 2
__モジュールインターフェース単位__（*module interface unit*）はそのモジュール宣言に`export`が含まれているモジュール単位。  
それ以外のモジュール単位は全て __モジュール実装単位__（*module implementation unit*）。  
名前付きモジュールは、プライマリーモジュールインターフェース単位（*primary module interface unit*）と呼ばれるモジュールパーティションを持たないモジュールインターフェース単位を、ただ1つだけ含んでいなければならない。ただし、この診断は不要。

#### 3
__モジュールパーティション__（*module partition*）はそのモジュール宣言にmodule-partition（上の構文ルールの中の句）が含まれるモジュール単位。  
名前付きモジュールは同じmodule-partitionをもつ複数のモジュールパーティションを含んではならない。   
あるモジュールのモジュールインターフェース単位でもある全てのモジュールパーティションは、プライマリーモジュールインターフェース単位によって、直接的・間接的にエクスポートされなければならない。ただし、これに違反したとしても診断は不要。  
[Note: モジュールパーティションは同じモジュール内の他のモジュール単位によってのみインポートできる。モジュールのモジュール単位への分割は外側からは可視ではない。]

#### 4
```cpp
//翻訳単位#1（プライマリーモジュールインターフェース単位）

export module A;  //プライマリーモジュールインターフェース宣言
export import :Foo;  //モジュールパーティションA:Fooをimportしつつexport
export int baz();  //関数baz()のエクスポート

//翻訳単位#2（モジュールインターフェースパーティションA:Foo）

export module A:Foo;  //モジュールインターフェースパーティション宣言
import :Internals;  //モジュールパーティションA:Internalsのインポート
export int foo() {   //関数foo()のエクスポート
  return 2 * (bar() + 1);
}

//翻訳単位#3（モジュールパーティションA:Inetrnal）

module A:Internals; //モジュールパーティション宣言
int bar();  //関数宣言（エクスポートしてない）

//翻訳単位#4（モジュール実装単位）

module A;  //モジュール宣言
import :Internals;  //モジュールパーティションA:Internalsのインポート

//bar()とbaz()両関数の定義、bazのみがエクスポートされている
int bar() {
  return baz() - 10;
}
int baz() {
  return 30;
}

```
モジュール`A`は4つの翻訳単位を含んでいる。
- プライマリーモジュールインターフェース単位（翻訳単位#1）
- モジュールパーティション`A:Foo`（翻訳単位#2）、これはモジュール`A`のインターフェースの一部となるモジュールインターフェース単位。
- モジュールパーティション`A:Internals`（翻訳単位#3）、これはモジュール`A`の外向きのインターフェースには寄与しない
- 関数`baz`と`bar`の定義を提供しているモジュール実装単位（翻訳単位#4）、パーティション名が無いためインポート不可

#### 5
__モジュール単位の本文__（*module unit purview*）とは、モジュール宣言から始まりその翻訳単位の終わりまでのトークン列。  
名前付きモジュール`M`の本文は、`M`のモジュール単位のそれぞれの本文の集合である。

#### 6

__グローバルモジュール__（*global module*）とは、全てのグローバルモジュールフラグメントと全てのモジュール単位ではない翻訳単位、の集まりである。  
そのようなコンテキストで現れる宣言は、グローバルモジュールの本文内にあると言われる。  
[Note: グローバルモジュールは、名前が無く、モジュールインターフェース単位も持たず、いかなるモジュール宣言によっても導入されない]

#### 7
__モジュール__（*module*）は名前付きモジュールかグローバルモジュールのいずれか。

ある宣言はそれぞれ以下のように、モジュールに __属している__（*attached*）
- 次のいずれかの場合、宣言はグローバルモジュールに __属している__
  - 宣言は置換可能なグローバル確保・解放関数（`new/delete`）
  - 宣言は外部リンケージを持つ名前空間宣言
  - 宣言はリンケージ指定内に現れている
- それ以外の場合、宣言はそれが現れるところを本文とするモジュールに __属している__

#### 8
`export`もモジュールパーティションも含まないモジュール宣言は、module-import-declarationによるかのように、そのモジュールのプライマリーモジュールインターフェース単位を暗黙的に`import`する。

```cpp
// TU 1
module B:Y; // モジュールパーティション宣言、モジュールBを暗黙的にインポートしない
int y();

// TU 2
export module B;  //Bのプライマリーモジュールインターフェース単位の宣言
import :Y; // OK, does not create interface dependency cycle
int n = y();

// TU 3
module B:X1; //モジュールパーティション宣言、モジュールBを暗黙的にインポートしない
int &a = n;  //error: n はここでは可視ではない

// TU 4
module B:X2; //モジュールパーティション宣言、モジュールBを暗黙的にインポートしない
import B;    //明示的なBのインポート
int &b = n;  //OK、n は可視

// TU 5
module B; //exportがなくパーティションでもないモジュール宣言、モジュールBを暗黙的にインポート
int &c = n; // OK、n は可視
```

### 10.2 Export declaration [module.interface]

- export-declaration:
  - `export` declaration
  - `export` { declaration-seq (opt) }

#### 1
`export`宣言（export-declaration）は、モジュールインターフェース単位の本文内にある名前空間スコープでのみ現れる。  
`export`宣言は、無名名前空間又はプライベートモジュールフラグメント内に直接的にも間接的にも現れてはならない。  
`export`宣言は、その宣言（存在する場合は、declaration-seq）の宣言的効果を持つ。  
`export`宣言は、スコープを導入することはなく、その宣言又はdeclaration-seqは再帰的に`export`宣言を含んではならない。

#### 2
宣言は以下のいずれかに該当する場合に __エクスポート__（*exported*）される。
- `export`宣言内で宣言された名前空間スコープ
- `export`を伴うモジュールの`import`宣言
- エクスポートされた宣言を含む名前空間定義
- 少なくとも1つの名前を導入するヘッダーユニット内の宣言

モジュール`M`の __インターフェース__（*interface*）はその本文内でエクスポートされたすべての宣言の集合

```cpp
export module M;  //プライマリーモジュールインターフェース単位の宣言

namespace A {                   // exported
  export int f();               // exported
  int g();                      // not exported
}
```
このモジュール`M`のインターフェースは、名前空間`A`と関数`A::f()`からなる。

#### 3
エクスポートされた宣言は少なくとも1つの名前を宣言しなければならない。そのような宣言がヘッダーユニット内に無い場合、内部リンケージで名前を宣言してはならない。

```cpp
//a.h
export int x;

//翻訳単位 #1
module;
#include "a.h"  // error: xのexport宣言がモジュールインターフェース単位ではない所に来ている

export module M;
export namespace {}             // error: 名前を宣言していない
export namespace {
  int a1;                       // error: 内部リンケージを持つ名前のエクスポート（間接的に無名名前空間内でexportしている）
}
namespace {
  export int a2;                // error: 内部リンケージを持つ名前のエクスポート
}
export static int b;            // error: static指定は内部リンケージを与える
export int f();                 // OK
export namespace N { }          // OK
export using namespace N;       // error: 名前を宣言していない
```

#### 5
（エクスポートされている）宣言が`using`宣言であってヘッダーユニット内にない場合、全てのusing-declaratorsが最終的に参照する全てのエンティティは外部リンケージを持つ名前で導入されていなければならない。

```cpp
//Source file "b.h":
int f();

//Importable header "c.h":
int g();

//Translation unit #1:
export module X;
export int h();

//Translation unit #2:
module;

#include "b.h"

export module M;

import "c.h";
import X;
export using ::f, ::g, ::h;     // OK
struct S;
export using ::S;               // error: Sは外部リンケージではなくモジュールリンケージを持つ
namespace N {
  export int h();
  static int h(int);            // static指定は内部リンケージを与える
}
export using N::h;              // error: N::h(int)が内部リンケージを持ってしまっている
```

ただし、この制約は`typedef/using`による型エイリアスの名前には適用されない。

```cpp
export module M;

struct S;

export using T = S;             // OK, 型Sのエイリアスとなる名前Tをエクスポートする
```

#### 6
エンティティのエクスポートされた宣言の再宣言は暗黙的にエクスポートされる。
以前の宣言がエクスポートされておらず、再宣言がエクスポート宣言となる場合、プログラムはill-formd。

```cpp
export module M;

struct S { int n; };
typedef S S;

export typedef S S;             // OK, エンティティの再宣言をしない
export struct S;                // error: 以前にエクスポートされていないクラスSの再宣言
```

#### 7
ある名前がモジュールの本文内のエクスポートされた宣言によって導入or再宣言されている場合、その名前はモジュールによって __エクスポートされている__ （*exported*）。  
[Note: 
エクスポートされた名前は外部リンケージを持つか、リンケージを持たない。  
モジュールによってエクスポートされた名前空間スコープの名前は、そのモジュールをインポートしている翻訳単位の名前探索において可視となる。  
クラス・列挙型のメンバの名前は、その型の定義が到達可能なコンテキストにおいて、名前探索で可視となる。]

```cpp
//モジュールMのプライマリモジュールインターフェース単位
export module M;

export struct X {
  static void f();
  struct Y { };
};

namespace {
  struct S { };
}

export void f(S);               // OK

struct T { };
export T id(T);                 // OK

export struct A;                // A は不完全型としてエクスポート

export auto rootFinder(double a) {
  return [=](double x) { return (x + a/x)/2; };
}

export const int n = 5;         // OK, nは外部リンケージを持つ

//モジュールMの実装単位
module M;

struct A {
  int value;
};

//Main program:
import M;

int main() {
  X::f();                       // OK, Xはエクスポートされており、その定義は到達可能
  X::Y y;                       // OK, X​::​Yはエクスポートされており、完全型
  auto f = rootFinder(2);       // OK
  return A{45}.value;           // error: Aは不完全型（Aの定義はエクスポートされておらず、到達可能でない）
}
```

#### 8
エクスポート宣言（export-declaration）内で名前を再宣言しても、その名前のリンケージを変更できない（されない）。

```cpp
//モジュールMのプライマリモジュールインターフェース単位
export module M;

static int f();                 // #1 static指定は内部リンケージを与える
export int f();                 // error: #1は内部リンケージをもつためエクスポートできない
struct S;                       // #2 名前空間に包まれていないので、モジュールリンケージを持つ
export struct S;                // error: #2はモジュールリンケージを持つためエクスポートできない
namespace {
  namespace N {
    extern int x;               // #3 無名名前空間内、内部リンケージ
  }
}
export int N::x;                // error: #3は内部リンケージをもつためエクスポートできない
```

#### 9
エクスポートされた名前空間定義または、エクスポートされたリンケージ指定（linkage-specification）内部の宣言はエクスポートされ、エクスポートされた宣言のルールに従う。

```cpp
export module M;

export namespace N {
  int x;                  //ok
  static_assert(1 == 1);  //error: 名前を宣言していない
}
```

### 10.3 Import declaration [module.import]

- module-import-declaration:
  - `export`(opt) `import` module-name attribute-specifier-seq(opt);
  - `export`(opt) `import` module-partition attribute-specifier-seq(opt);
  - `export`(opt) `import` header-name attribute-specifier-seq(opt);

#### 1
モジュール単位におけるすべてのモジュールインポート宣言（module-import-declaration）は、その翻訳単位及び（存在するなら）プライベートモジュールフラグメントにおけるtop-level-declaration-seq内にあり、かつそこに含まれる他の全てのtop-level-declarationsよりも前に宣言されなければならない。  
モジュールインポート宣言に対する属性指定（attribute-specifier-seq）はモジュールインポート宣言に作用する。

#### 2
モジュールインポート宣言（module-import-declaration）は以下のように決定された翻訳単位の集合を __インポート__（*imports*）する。  
[Note: インポートされた翻訳単位でエクスポートされている名前空間スコープ名はインポートする翻訳単位で可視となる。  
インポートされた翻訳単位内の宣言はインポート宣言の後、インポートする翻訳単位で到達可能になる。]

1. モジュール`M`の名前を指定するインポート宣言（`import M;`）は、`M`の全てのモジュールインターフェース単位をインポートする。
2. モジュールパーティションを指定するインポート宣言は、あるモジュール`M`のモジュール単位におけるモジュール宣言（`module M;`）の後にのみ現れることができる。  
そのような宣言は`M`のモジュールパーティションをインポートする。
3. ヘッダー名`H`を指定するインポート宣言は、`H`で指定されたヘッダーもしくはソースファイルを翻訳フェーズ7までコンパイルすることで生成された翻訳単位である __ヘッダーユニット__（*header unit*）をインポートする。  
ヘッダーユニットは、モジュール宣言を含んではならない。  
[Note: ヘッダーユニット内のすべての宣言は暗黙的にエクスポートされ、グローバルモジュールに属する。]
    1. __インポート可能なヘッダー__（*importable header*）は実装定義のヘッダーの集合であり、`H`はインポート可能なヘッダーを識別する。
    2. 2つのインポート宣言は、それが同じヘッダーもしくはソースファイルに識別される場合にのみ、同じヘッダーユニットをインポートする。