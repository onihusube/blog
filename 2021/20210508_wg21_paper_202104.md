# ï¼»C++ï¼½WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2021å¹´03æœˆï¼‰

æ–‡æ›¸ã®ä¸€è¦§

- [JTC1/SC22/WG21 - Papers 2021 mailing2021-04](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/#mailing2021-04)

å…¨éƒ¨ã§55æœ¬ã‚ã‚Šã€SG22ï¼ˆC/C++ç›¸äº’äº’æ›æ€§ã«é–¢ã™ã‚‹ç ”ç©¶ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰ã®Cã®ææ¡ˆã‚’é™¤ãã¨48æœ¬ã«ãªã‚Šã¾ã™ã€‚

[:contents]

### [P0323R10 std::expected](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0323r10.html)

ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’æˆ»ã‚Šå€¤ã§è¡Œã†ãŸã‚ã®å‹ã€`std::expected<T, E>`ã®ææ¡ˆã€‚

`std::expected<T, E>`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯å‹`T`ã‹`E`ã®ã©ã¡ã‚‰ã‹ã®å€¤ã‚’ä¿æŒã—ã¦ãŠã‚Šã€`T`ã®å€¤ã‚’æœŸå¾…ã•ã‚Œã‚‹å€¤ï¼ˆæ­£å¸¸å€¤ï¼‰ã€`E`ã®å€¤ã‚’ã‚¨ãƒ©ãƒ¼ã¨ã—ã¦æ‰±ã†ã“ã¨ã§ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚ã“ã‚Œã¯ã€Rustã§ã¯`Result<T, E>`ã¨ã—ã¦é‡å®ã•ã‚Œã¦ã„ã¾ã™ã€‚

`std::expected`ã‚’ä½¿ã†ã¨ã€`std::optional<T>`ã¯`std::expected<T, std::nullopt_t>`ã®ã‚ˆã†ã«æ›¸ãã“ã¨ãŒã§ãã€`std::optional`ã‚’ã‚¨ãƒ©ãƒ¼å‡¦ç†ã«ç”¨ã„ã‚‹æ™‚ã«å¤±ã‚ã‚Œã¦ã—ã¾ã£ã¦ã„ãŸã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’åŒæ™‚ã«ä¿æŒã—ã¦ãŠãã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

`std::expected`ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¯`std::optional`ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€ã‚¨ãƒ©ãƒ¼å€¤ã‚’ä¿æŒã—ã¦ã„ã‚‹å ´åˆã®æ“ä½œã‚’åŠ ãˆãŸå½¢ã®ã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚

```cpp
#include <expected>

auto maybe_succeed() -> std::expected<int, std::string_view> {
  bool is_err = false;

  // ä½•ã‹å¤±æ•—ã—ã†ã‚‹å‡¦ç†
  // ...

  if (is_err) {
    return 46;  // æ­£å¸¸å€¤ã‚’è¿”ã™
  } else {
    return {std::unepect, "error!"};  // ã‚¨ãƒ©ãƒ¼å€¤ã‚’è¿”ã™
  }
}

int main() {

  auto exp = maybe_succeed();

  // boolå€¤ã«å¤‰æ›ã—ã¦çµæœã‚’ãƒã‚§ãƒƒã‚¯
  if (exp or exp.has_value()) {
    // æ­£å¸¸å€¤ã®å–ã‚Šå‡ºã—
    int n = *exp;
    int m = exp.value();

    // æœªå®šç¾©å‹•ä½œ
    exp.error();

  } else {
    // ã‚¨ãƒ©ãƒ¼å€¤ã®å–ã‚Šå‡ºã—
    std::string_view s = exp.error();
    
    // æœªå®šç¾©å‹•ä½œ
    *exp;
    // ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
    ep.value(); 
  }
}
```

å„ªã‚ŒãŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ¡ã‚«ãƒ‹ã‚ºãƒ ã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªäº‹ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚

1. ã‚¨ãƒ©ãƒ¼ã®å¯è¦–æ€§ : ãªã‚“ã‚‰ã‹ã®å‡¦ç†ãŒå¤±æ•—ã™ã‚‹ã‚±ãƒ¼ã‚¹ãŒã‚³ãƒ¼ãƒ‰ä¸Šã§éš ã•ã‚Œãšã€æ˜ç¢ºã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹
2. ã‚¨ãƒ©ãƒ¼ã®æƒ…å ± : ã‚¨ãƒ©ãƒ¼ã«ã¯ãã®ç™ºç”Ÿå ´æ‰€ã‚„åŸå› ãªã©ãŒå«ã¾ã‚Œã‚‹
3. ã‚¯ãƒªãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰ : ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ã§ãã‚‹é™ã‚Šç›®ç«‹ãŸãªã„ã‚ˆã†ã«è¡Œã‚ã‚Œã‚‹ã€‚ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯èª­ã¿ã‚„ã™ããªã‘ã‚Œã°ãªã‚‰ãªã„
4. è¢«ä¾µå…¥çš„ : ã‚¨ãƒ©ãƒ¼ãŒé€šå¸¸ã®å‡¦ç†ãƒ•ãƒ­ãƒ¼ã®ãŸã‚ã®ãƒãƒ£ãƒãƒ«ã‚’ç‹¬å ã—ãªã„ã€‚ãã‚Œã‚‰ã¯ãªã‚‹ã¹ãåˆ†é›¢ã•ã‚Œã¦ã„ã‚‹ã¹ã

ã“ã®è¦³ç‚¹ã‹ã‚‰ã€`std::expected`ã¨ä¾‹å¤–æ©Ÿæ§‹ã‚„é€šå¸¸ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰æˆ»ã‚Šå€¤ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’æ¯”è¼ƒã™ã‚‹ã¨

|æ€§è³ª|`std::expected`|ä¾‹å¤–|ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰æˆ»ã‚Šå€¤|
|---|:-:|:-:|:-:|
|å¯è¦–æ€§|â—¯|â–³|â—¯|
|æƒ…å ±|â—¯|â—¯|â–³|
|ã‚¯ãƒªãƒ¼ãƒ³ã‚³ãƒ¼ãƒ‰|â—¯â€»|â—¯|Ã—|
|éä¾µå…¥çš„|â—¯|â—¯|Ã—|

â€» monadicã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãŒã‚ã‚‹å ´åˆï¼ˆç¾åœ¨ã®ææ¡ˆã«ã¯æ¬ ã‘ã¦ã„ã‚‹ï¼‰

ã“ã®ã‚ˆã†ã«ã€`std::expected`ã¯ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¨ã„ã†è¦³ç‚¹ã‹ã‚‰æ—¢å­˜ã®æ–¹æ³•ã‚ˆã‚Šã‚‚å„ªã‚Œã¦ã„ã¾ã™ã€‚ã¾ãŸã€ä¾‹å¤–æ©Ÿæ§‹ã¨æ¯”ã¹ã‚‹ã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã§ã‚‚å‹ã‚Šã¾ã™ã€‚

- [ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’ç¶ºéº—ã«ã“ãªã™ãŸã‚ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ»expectedã®ç´¹ä»‹ã¨å¿œç”¨ - Qita](https://qiita.com/wx257osn2/items/32adec3126b03ede3034)
- [ã‚¨ãƒ©ãƒ¼å€¤ã¨æ­£å¸¸å€¤ã‚’è¡¨ã™æ±ç”¨çš„ãªå‹ï¼šexpected - Faith and Brave - C++ã§éŠã¼ã†](https://faithandbrave.hateblo.jp/entry/2014/05/30/153325)
- [P0323 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/254)

### [P0447R13 Introduction of std::colony to the standard library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0447r13.html)
### [P1121R3 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r3.pdf)
### [P1122R3 Proposed Wording for Concurrent Data Structures: Read-Copy-Update (RCU)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1122r3.pdf)

æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«Read-Copy-Update(RCU)ã‚’å°å…¥ã™ã‚‹ææ¡ˆã€‚

RCUã¯ä¸¦è¡Œå‡¦ç†ã«ãŠã‘ã‚‹ãƒ‡ãƒ¼ã‚¿å…±æœ‰ã®ãŸã‚ã®ä»•çµ„ã¿ã§ã€ãƒ­ãƒƒã‚¯ãƒ•ãƒªãƒ¼ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å®Ÿè£…ã«ç”¨ã„ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

RCUã§ã¯ã€å…±æœ‰å¯¾è±¡ã®ãƒ‡ãƒ¼ã‚¿ã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã£ã¦å…±æœ‰ã•ã‚Œã¦ãŠã‚Šã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã™ã‚‹éš›ã¯åˆ¥ã®é ˜åŸŸã«ãƒ‡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰ã—ã¦ã‹ã‚‰ã€ãƒã‚¤ãƒ³ã‚¿ã‚’å·®ã—æ›¿ãˆã‚‹ã“ã¨ã§è¡Œã„ã¾ã™ï¼ˆã“ã“ã¾ã§ã¯ãƒã‚¶ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ã‚¿ã¨åŒã˜ï¼‰ã€‚å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã«è§¦ã‚‹éš›ã®ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ï¼ˆãƒ—ãƒªã‚¨ãƒ³ãƒ—ã‚·ãƒ§ãƒ³ï¼‰ãŒèµ·ã“ã‚‰ãªã„ã‚ˆã†ã«ã—ã¦ã€ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ã‚ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å æœ‰ã—ã¦å®Ÿè¡Œã•ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã‹ã‚‰ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã¸ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«å…¥ã‚‹éš›ã¯OSã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œãªã„ã‚ˆã†ã«ã—ã¾ã™ãŒã€ä½•ã‹ãƒ­ãƒƒã‚¯ã‚’å–å¾—ã—ãŸã‚Šã™ã‚‹ã‚ã‘ã§ã¯ãªã„ã®ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã¯ã»ã¼ã‚¼ãƒ­ã§ã™ã€‚

èª­ã¿å–ã‚Šã®éš›ã¯ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿ã ã—ã¦ã„ã‚‹é–“ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œãšã€ãƒ‡ãƒ¼ã‚¿ã‚’è¦‹çµ‚ã‚ã£ãŸå¾Œã§é€šå¸¸é€šã‚Šã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°å¯¾è±¡ã«æˆ»ã‚Šã¾ã™ã€‚

æ›´æ–°ã®éš›ã¯ã€æ›´æ–°å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆ¥ã®é ˜åŸŸã«ç”¨æ„ã—ã¦ã‹ã‚‰ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«å…¥ã‚Šã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã‚’æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ã‚ˆã†ã«å·®ã—æ›¿ãˆã¾ã™ï¼ˆã“ã®å·®ã—æ›¿ãˆã¯ã‚¢ãƒˆãƒŸãƒƒã‚¯ï¼‰ã€‚ãã®å¾Œã€ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ãŒæœ€ä½ä¸€å›ä»¥ä¸Šã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿã—ã¦ã‹ã‚‰ã€å·®ã—æ›¿ãˆå‰ã®å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠœã‘ã¾ã™ã€‚

ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ä¸­ãã®ã‚¹ãƒ¬ãƒƒãƒ‰ã¯ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œãªã„ã®ã§ã€å‡¦ç†ã¯OSã«ã‚ˆã£ã¦ä¸­æ–­ã•ã‚Œã‚‹äº‹ãªãå®Ÿè¡Œã•ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€æ›´æ–°ã‚¹ãƒ¬ãƒƒãƒ‰ã‹ã‚‰è¦‹ã¦ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾ã—ã¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ä¸€å›ä»¥ä¸Šè¡Œã‚ã‚ŒãŸã¨ã„ã†ã“ã¨ã¯ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã£ã¦ã„ã‚‹ï¼ˆæ›´æ–°å‰ã®å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¦‹ã¦ã„ã‚‹ï¼‰å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ãŒèª­ã¿å–ã‚Šå‡¦ç†ã‚’çµ‚ãˆã¦ã„ã‚‹äº‹ã‚’æ„å‘³ã—ã¾ã™ã€‚

ã‚¹ãƒ¬ãƒƒãƒ‰ãŒã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã•ã‚Œãªã„ã‚ˆã†ã«ãªã‚‹ã¨ã„ã†ã“ã¨ã¯ã€ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã¯CPUã®è«–ç†ã‚³ã‚¢ã‚’å æœ‰ã™ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚å¾“ã£ã¦ã€æ›´æ–°ã‚¹ãƒ¬ãƒƒãƒ‰ãŒå®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ã‚³ã‚¢ã‚’é™¤ã„ãŸã‚·ã‚¹ãƒ†ãƒ ã®CPUã®æ®‹ã‚Šã®è«–ç†ã‚³ã‚¢ã«ãŠã„ã¦ã‚¹ãƒ¬ãƒƒãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆãŒä¸€å›ä»¥ä¸Šè¡Œã‚ã‚Œã¦ã„ã‚Œã°ã€æ›´æ–°ã‚¹ãƒ¬ãƒƒãƒ‰ãŒä¿æŒã—ã¦ã„ã‚‹å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¦‹ã¦ã„ã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰ï¼ˆ=ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ãŒç„¡ã„ã“ã¨åˆ†ã‹ã‚‹ãŸã‚ã€å®‰å…¨ã«å‰Šé™¤ã§ãã‚‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚

ãƒ‡ãƒ¼ã‚¿ã®å·®ã—æ›¿ãˆã¯ãƒã‚¤ãƒ³ã‚¿ã«ã‚ˆã£ã¦ã‚¢ãƒˆãƒŸãƒƒã‚¯ã«è¡Œã‚ã‚Œã‚‹ãŸã‚ã€æ›´æ–°ãŒåŒæ™‚ã«è¡Œã‚ã‚Œã¦ã‚‚ãƒ‡ãƒ¼ã‚¿ç«¶åˆã‚’èµ·ã“ã—ã¾ã›ã‚“ã—ã€ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚ãŸã ã—ã€RCUã®å…¨ã¦ã®ä¿è¨¼ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæ­£ã—ãã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’é‹ç”¨ã™ã‚‹äº‹ã‚’å‰æã¨ã—ã¦ã„ã¾ã™ã€‚

RCUã‚’ä½¿ç”¨ã—ã¦ã€è¤‡æ•°ã®ãƒªãƒ¼ãƒ€ãƒ¼ï¼ˆ*reader*ï¼‰ãŒä¸¦è¡Œã—ã¦å­˜åœ¨ã™ã‚‹æ™‚ã«ã€å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°ã‚’å®Ÿè¡Œã™ã‚‹ä¾‹ã€‚

```cpp
// å…±æœ‰ã—ãŸã„ã‚‚ã®
std::atomic<std::string *> name;

// ä¸¦è¡Œã—ã¦é »ç¹ã«å‘¼ã°ã‚Œã‚‹
void print_name() {
  // RAIIã«ã‚ˆã£ã¦èª­ã¿å–ã‚Šã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ§‹æˆ
  std::rcu_reader rr;
  std::string *s = name.load(std::memory_order_acquire);
  /* ...use *s... */
}

// ã‚ã¾ã‚Šå‘¼ã°ã‚Œãªã„
void update_name(std::string_view &nn) {
  // 1. å€¤ã®æ›´æ–°ï¼ˆæ–°ã—ã„å€¤ã®ç”¨æ„ã¨å…±æœ‰ãƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒˆãƒŸãƒƒã‚¯ãªå·®ã—æ›¿ãˆï¼‰
  std::string *new_name = new std::string(nn);
  std::string *s = name.exchange(new_name, std::memory_order_acq_rel);
  // 2. é…å»¶å‰Šé™¤ï¼ˆæ›´æ–°ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼‰
  std::rcu_retire(s);
}
```

ãƒªãƒ¼ãƒ€ãƒ¼ï¼ˆ`print_name()`ï¼‰ã¯1ã¤ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œã€æ›´æ–°å‡¦ç†ï¼ˆ`update_name()`ï¼‰ã¯ãã‚Œã¨ã¯åˆ¥ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚`print_name()`å†…`rcu_reader`ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€ãƒªãƒ¼ãƒ€ãƒ¼ã®å‡¦ç†ãŒå®Œäº†ã™ã‚‹ã¾ã§å‚ç…§ã—ã¦ã„ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã€`rcu_retire()`ã«ã‚ˆã£ã¦å‰Šé™¤ã•ã‚Œãªã„ã‚ˆã†ã«ä¿è­·ã—ã¦ã„ã¾ã™ã€‚

RCUã¯èª­ã¿å–ã‚ŠãŒé »ç¹ã«èµ·ã“ã‚‹ãŒæ›´æ–°ã¯ã‚ã¾ã‚Šã•ã‚Œãªã„ã‚ˆã†ãªå ´åˆã«é©ã—ãŸæ–¹æ³•ã§ã™ã€‚

ã“ã®ææ¡ˆã¯åˆ¥ã®ææ¡ˆï¼ˆ[P0461R2](http://wg21.link/P0461r2)ï¼‰ã®æ¨™æº–ã¸ææ¡ˆã™ã‚‹æ–‡æ›¸ã‚’ã¾ã¨ã‚ãŸã‚‚ã®ã§ã€Concurrency TSã«å‘ã‘ã¦ææ¡ˆã•ã‚Œã€è­°è«–ã•ã‚Œã¦ã„ã¾ã™ã€‚

è‘—è€…ã®æ–¹ï¼ˆPaul McKenneyã•ã‚“ï¼‰ã®å®Ÿè£…çµŒé¨“ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ã¦é•·ã„æ™‚é–“ã‚’ã‹ã‘ã¦è­°è«–ã•ã‚Œã¦ãã¦ãŠã‚Šã€Concurrency TSã«å‘ã‘ã¦ã®è­°è«–ãŒLWGã¾ã§é€²è¡Œã—ã¦ã„ã‚‹ã®ã§Concurrency TSã«ã¯å…¥ã‚Šãã†ã§ã™ãŒã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ä¸€éƒ¨ã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã¨ãªã‚‹ã«ã¯ã‚‚ã†å°‘ã—ã‹ã‹ã‚Šãã†ã§ã™ã€‚

- [P0461R2 Proposed RCU C++ API](http://wg21.link/P0461r2)
- [P1121R2 Hazard Pointers: Proposed Interface and Wording for Concurrency TS 2 - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2021å¹´01æœˆï¼‰](https://onihusube.hatenablog.com/entry/2021/02/11/153333#P1121R2-Hazard-Pointers-Proposed-Interface-and-Wording-for-Concurrency-TS-2)
- [P0561R5 An RAII Interface for Deferred Reclamation - WG21æœˆæ¬¡ææ¡ˆæ–‡æ›¸ã‚’çœºã‚ã‚‹ï¼ˆ2020å¹´12æœˆï¼‰](https://onihusube.hatenablog.com/entry/2021/01/17/005823#P0561R5-An-RAII-Interface-for-Deferred-Reclamation)
- [HTMã¯ãƒ¡ãƒ¢ãƒªç®¡ç†ã®ç‚ºã«ç”Ÿã¾ã‚Œã¦ããŸã‚“ã ã‚ˆï¼ã€€Î©Î©ï¼œãªã€ãªã‚“ã ã£ã¦ãƒ¼ - Software Transactional Memo](https://kumagi.hatenablog.com/entry/2013/01/08/232549)
- [P1122 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/39)

### [P1132R7 out_ptr - a scalable output pointer abstraction](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1132r7.html)

ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã¨ãƒã‚¤ãƒ³ã‚¿ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–ã‚‹ã‚¿ã‚¤ãƒ—ã®C APIã¨ã®æ©‹æ¸¡ã—ã‚’è¡Œã†ã€`std::out_ptr`ã®ææ¡ˆã€‚

C APIã§ã¯ã€é–¢æ•°ã®ä¸­ã§ã®ãƒ¡ãƒ¢ãƒªã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çµæœãªã©ã‚’å‘¼ã³å‡ºã—å…ƒã«å‡ºåŠ›ã™ã‚‹ãŸã‚ã«ã€ãƒã‚¤ãƒ³ã‚¿ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆ`T** / void**`ï¼‰ã‚’å¼•æ•°ã«å–ã‚‹ã‚‚ã®ãŒã‚ˆãè¦‹ã‚‰ã‚Œã¾ã™ã€‚ãƒã‚¤ãƒ³ã‚¿ã§ã¯ãªããƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã™å¿…è¦ãŒã‚ã‚Šã€`std::unique_ptr`ã‚’ã¯ã˜ã‚ã¨ã™ã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã¯ãã‚Œã‚’å–å¾—ã™ã‚‹æ‰‹æ®µãŒãªã„ãŸã‚ã€ç›¸æ€§ãŒè‰¯ãã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚

ææ¡ˆæ–‡æ›¸ã‚ˆã‚Šã€ffmpegã«ãŠã‘ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã€‚

```cpp
#include <memory>
#include <avformat.h>

// ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒªãƒ¼ã‚¿
struct AVFormatContextDeleter {
  void operator() (AVFormatContext* c) const noexcept {
    avformat_close_input(&c);
    avformat_free_context(c);
  }
};

using av_format_context_ptr = std::unique_ptr<AVFormatContext, AVFormatContextDeleter>;

// libavformatã®ã‚·ã‚°ãƒãƒãƒ£
//int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options);

int main (int, char* argv[]) {
  av_format_context_ptr context(avformat_alloc_context());

  // ...
  // used, need to reopen

  // AVFormatContext**ã«unique_ptrã‚’ã‚»ãƒƒãƒˆã—ãŸã„ãŒãƒ»ãƒ»ãƒ»
  AVFormatContext* raw_context = context.release();
  if (avformat_open_input(&raw_context, argv[0], nullptr, nullptr) != 0) {
    // å‡¦ç†ãŒå¤±æ•—ã—ãŸå ´åˆã«ãƒ‡ãƒªãƒ¼ã‚¿ãŒèµ°ã£ã¦æ¬²ã—ããªã„ã®ã§ã€ä¸€æ—¦release()ã—ã¦ã„ã‚‹

    std::stringstream ss;
    ss << "ffmpeg_image_loader could not open file '"
      << path << "'";
    throw FFmpegInputException(ss.str().c_str());
  }

  // æˆåŠŸã—ãŸã‚‰å‡ºåŠ›ã•ã‚ŒãŸãƒã‚¤ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆ
  context.reset(raw_context);

  // ... off to the races !

  return 0;
}
```

`std::out_ptr/std::inout_ptr`ã¯ã“ã®ã‚ˆã†ãªå ´åˆã®`release()`ã¨`reset()`ã®å‘¼ã³å‡ºã—ã‚’è‡ªå‹•åŒ–ã—ã€ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã«å†…åŒ…ã•ã‚Œã¦ã„ã‚‹ãƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŠ½å‡ºã™ã‚‹ã‚‚ã®ã§ã™ã€‚

```cpp
int main (int, char* argv[]) {
  av_format_context_ptr context(avformat_alloc_context());

  // ...
  // used, need to reopen

  // release()ã—ã¦ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã—ã€çµ‚äº†å¾Œã«å…ƒã®unique_ptrã«reset()ã™ã‚‹
  if (avformat_open_input(std::inout_ptr(context), argv[0], nullptr, nullptr) != 0) {
    std::stringstream ss;
    ss << "ffmpeg_image_loader could not open file '"
      << argv[0] << "'";
    throw FFmpegInputException(ss.str().c_str());
  }

  // ... off to the races!

  return 0;
}
```

ã“ã®ã‚ˆã†ãªãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¯ã€å¤§å°æ§˜ã€…ãªä¼æ¥­ã«ãŠã„ã¦å†ç™ºæ˜ã•ã‚Œã¦ã„ã¾ã™ãŒã€ãã®ç”¨é€”ã‚„ç›®çš„ã¯C APIã®å‡ºåŠ›ãƒã‚¤ãƒ³ã‚¿ï¼ˆ`T**`ï¼‰å¼•æ•°ã«ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã‚’ç›´æ¥æ¸¡ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹äº‹ã§ä¸€è²«ã—ã¦ã„ã¾ã™ã€‚ã“ã®ææ¡ˆã¯ã€ãã®ã‚ˆã†ãªç›®çš„ãŒåŒã˜ã§ã‚ã‚ŠãªãŒã‚‰ãã‚Œãã‚Œã§å†å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®ã€å°†æ¥æ€§ãŒã‚ã‚Šé«˜æ€§èƒ½ã§ä½¿ã„ã‚„ã™ã„å…±é€šã®å®Ÿè£…ã‚’æ¨™æº–ã§æä¾›ã™ã‚‹äº‹ã‚’ç›®æŒ‡ã—ãŸã‚‚ã®ã§ã™ã€‚

`std::out_ptr/std::inout_ptr`ã¯é–¢æ•°ã§ã‚ã‚Šã€å¼•æ•°ã§å—ã‘å–ã£ãŸã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã‚’ãƒ©ãƒƒãƒ—ã—ãŸå‹ï¼ˆ`std::out_ptr_t/std::inout_ptr_t`ï¼‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã—ã¾ã™ã€‚ãã‚Œã‚‰ã®å‹ã¯å…ƒã®ãƒã‚¤ãƒ³ã‚¿å‹ã‚„`void**`ã¸ã®æš—é»™å¤‰æ›æ¼”ç®—å­ã‚’å‚™ãˆã¦ãŠã‚Šã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã¨ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§`release()`ã¨`reset()`ã‚’è¡Œã„ã¾ã™ã€‚

`std::out_ptr`ã¨`std::inout_ptr`ã®é•ã„ã¯ã€å¯¾è±¡ã¨ãªã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ãŒäºˆã‚ãƒªã‚½ãƒ¼ã‚¹ã®æ‰€æœ‰æ¨©ã‚’æŒã£ã¦ã„ã‚‹ã‹å¦ã‹ã«ã‚ˆã£ã¦ä½¿ã„åˆ†ã‘ã‚‹ãŸã‚ã«ã‚ã‚Šã¾ã™ã€‚

```cpp
error_num c_api_create_handle(int seed_value, int** p_handle);
error_num c_api_re_create_handle(int seed_value, int** p_handle);
void c_api_delete_handle(int* handle);

struct resource_deleter {
  void operator()( int* handle ) {
    c_api_delete_handle(handle);
  }
};

// out_ptrã®ä½¿ç”¨ä¾‹
void normal_case() {
  std::unique_ptr<int, resource_deleter> resource(nullptr);

  // ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰ãã®ãƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã¸ã®å¤‰æ›ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹
  error_num err = c_api_create_handle(24, std::out_ptr(resource));

  if (err == C_API_ERROR_CONDITION) {
    // handle errors
  }
}

// inout_ptrã®ä½¿ç”¨ä¾‹
void reallocate_case(std::unique_ptr<int, resource_deleter> resource) {

  // äºˆã‚ãƒªã‚½ãƒ¼ã‚¹ã®æ‰€æœ‰æ¨©ã‚’ä¿æŒã—ã¦ã„ã‚‹å ´åˆ
  // release()ã—ã¦ã‹ã‚‰ãƒã‚¤ãƒ³ã‚¿ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æ¸¡ã—ã€çµ‚äº†å¾Œã«å…ƒã®unique_ptrã«reset()ã™ã‚‹
  error_num err = c_api_re_create_handle(24, std::inout_ptr(resource));

  if (err == C_API_ERROR_CONDITION) {
    // handle errors
  }
  // resource.get() the out-value from the C API function
}
```

`std::out_ptr`ã¯ç©ºã®ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã«C APIçµŒç”±ã§ãƒªã‚½ãƒ¼ã‚¹ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã¨ãã«ä½¿ç”¨ã—ã€`std::inout_ptr`ã¯äºˆã‚ãƒªã‚½ãƒ¼ã‚¹ã®æ‰€æœ‰æ¨©ã‚’ä¿æŒã—ã¦ã„ã‚‹ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã‚’C APIã«æ¸¡ã™ã¨ãã«ä½¿ç”¨ã—ã¾ã™ã€‚

ãã®ä»–ã®ã‚µãƒ³ãƒ—ãƒ«

```cpp
#include <memory>
#include <cstdio>

// C APIé–¢æ•°
int fopen_s(std::FILE** f, const char* name, const char* mode);

// ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒªãƒ¼ã‚¿
struct fclose_deleter {
  void operator()(std::FILE* f) const noexcept {
    std::fclose(f);
  }
};

int main(int, char*[]) {
  constexpr const char* file_name = "ow.o";
  std::unique_ptr<std::FILE, fclose_deleter> file_ptr;

  // unique_ptrã‚’FILE**ã¸æ¸¡ã™ãŸã‚ã®ã‚­ãƒ£ã‚¹ãƒˆæ§‹æ–‡
  int err = fopen_s(std::out_ptr<std::FILE*>(file_ptr), file_name, "r+b");
  if (err != 0) {
    return 1;
  }
  // *file_ptr is valid
  return 0;
}
```
```cpp
#include <memory>

struct StarFish* starfish_alloc();

// C APIé–¢æ•°
int starfish_populate(struct StarFish** ps, const char *description);

// ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒªãƒ¼ã‚¿
struct StarFishDeleter {
  void operator() (struct StarFish* c) const noexcept;
};

using StarFishPtr = std::unique_ptr<StarFish, StarFishDeleter>;

int main(int, char*[]) {
  StarFishPtr peach(starfish_context());
  // ...
  // used, need to re-make
  int err = starfish_populate(std::inout_ptr(peach), "caring clown-fish liker");
  return err;
}
```

ã“ã®ææ¡ˆã¯å…ƒã€…C++20å…¥ã‚Šã‚’ç›®æŒ‡ã—ã¦ã„ã¾ã—ãŸãŒé–“ã«åˆã„ã¾ã›ã‚“ã§ã—ãŸã€‚C++20ä½œæ¥­çµ‚äº†æ™‚ç‚¹ã§ææ¡ˆã¯æ—¢ã«LWGã«é€ä»˜æ¸ˆã¿ã§ã€ã‚³ãƒ­ãƒŠã‚¦ã‚£ãƒ«ã‚¹æµè¡Œãªã©ã«ã‚ˆã£ã¦é…ã‚Œã¦ã„ã¾ã—ãŸãŒã€æ—¢ã«LWGã§ã®æœ€å¾Œã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå®Œäº†ã—ã¦ã„ã¾ã™ã€‚æ¬¡ã®å…¨ä½“ä¼šè­°ã§æŠ•ç¥¨ã«ã‹ã‘ã‚‰ã‚Œã€ä½•äº‹ã‚‚ãªã‘ã‚Œã°C++23ã«å°å…¥ã•ã‚Œã¾ã™ã€‚

- [P1132 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/41)

### [P1169R1 static operator()](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1169r1.html)

é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ï¼ˆ`operator()`ï¼‰ã‚’ã€é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ææ¡ˆã€‚

ä»»æ„ã®é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–ã‚‹ã“ã¨ã§å‡¦ç†ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã¯ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®å¤šãã®æ‰€ã§è¡Œã‚ã‚Œã¦ã„ã¾ã™ã€‚é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚’ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«ã™ã‚‹ã“ã¨ã§ã€ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’ç”¨æ„ã™ã‚‹ã‚ˆã‚Šã‚‚ã‚ˆã‚Šç°¡æ˜“ã‹ã¤ä¾¿åˆ©ã«é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ©ç”¨ã§ãã¾ã™ã€‚

ã¾ãŸã€C++20ã‹ã‚‰ã¯ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚¤ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆCPOï¼‰ã¨å‘¼ã°ã‚Œã‚‹é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå¤šæ•°è¿½åŠ ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®CPOã¯ãƒ¡ãƒ³ãƒã‚’æŒãŸãªã„ã“ã¨ãŒè¦å®šã•ã‚Œã¦ã„ã¾ã™ã€‚

ãƒ©ãƒ ãƒ€å¼ã«ã›ã‚ˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ã®ã‚‚ã®ã«ã›ã‚ˆã€CPOã«ã›ã‚ˆã€é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ã‚ˆã£ã¦é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯æˆã‚Šç«‹ã£ã¦ã„ã¾ã™ãŒã€é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã¯éé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦ã—ã‹å®šç¾©ã§ãã¾ã›ã‚“ã€‚å¾“ã£ã¦ã€ãã®å‘¼ã³å‡ºã—ã«å½“ãŸã£ã¦ã¯æš—é»™ã®`this`å¼•æ•°ãŒæ¸¡ã•ã‚Œã¦ã„ã¾ã™ã€‚

CPOã‚„ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ã„ãªã„ãƒ©ãƒ ãƒ€ã®ã‚ˆã†ã«ãƒ¡ãƒ³ãƒã‚¢ã‚¯ã‚»ã‚¹ã®å¿…è¦ãŒçš†ç„¡ã ã£ãŸã¨ã—ã¦ã‚‚ã€é–¢æ•°å‘¼ã³å‡ºã—ãŒã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ã•ã‚Œãªã‘ã‚Œã°é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ã‚ˆã‚‹å‘¼ã³å‡ºã—ã¯å¸¸ã«`this`ãƒã‚¤ãƒ³ã‚¿ã‚’å¼•ãæ¸¡ã™ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’åŸ‹ã‚è¾¼ã‚“ã§ã„ã¾ã™ã€‚

```cpp
struct X {
  bool operator()(int) const;
  static bool f(int);
};

// ç°¡æ˜“çš„ãªCPOå®šç¾©
inline constexpr X x;

int count_x(std::vector<int> const& xs) {
  return std::count_if(xs.begin(), xs.end(),
#ifdef STATIC
  X::f  // é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’æ¸¡ã™
#else
  x     // é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆCPOï¼‰ã‚’æ¸¡ã™
#endif
  );
}    
```

- [ã‚¢ã‚»ãƒ³ãƒ–ãƒªç”Ÿæˆä¾‹ - Compiler Explorer](https://godbolt.org/z/ajTZo2)


æ±ºã—ã¦ä½¿ç”¨ã•ã‚Œãªã„äº‹ãŒåˆ†ã‹ã£ã¦ã„ã¦ã‚‚ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å¿…ãšã—ã‚‚ã“ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’å–ã‚Šé™¤ãã“ã¨ãŒã§ãã¾ã›ã‚“ã€‚ã“ã‚Œã¯ã‚¼ãƒ­ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰åŸå‰‡ã«é•åã—ã¦ã„ã¾ã™ãŒã€é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚’é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

ã“ã®ææ¡ˆã¯ã€ã“ã®æ§˜ãªã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚’å–ã‚Šé™¤ããŸã‚ã«ã€é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚’é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã—ã‚ˆã†ã¨ã™ã‚‹ã‚‚ã®ã§ã™ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¬ã‚¹ãªé–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æœ‰ç”¨æ€§ã¯ã€C++11ã®ãƒ©ãƒ ãƒ€å¼å°å…¥ä»¥é™åºƒãèªè­˜ã•ã‚Œã¦ãŠã‚Šã€ã“ã®æ§˜ãªåˆ¶é™ã‚’èª²ã—ã¦ãŠãäº‹ã«åˆ©ç›Šã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

ãã®ã»ã‹ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰å¯èƒ½ãªæ¼”ç®—å­ã«ã‚‚åŒæ§˜ã®äº‹ãŒè¨€ãˆã¾ã™ãŒã€é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ä»¥å¤–ã®ã‚‚ã®ã‚’é™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãŒè¦‹ã‚‰ã‚Œãªã„ãŸã‚ã€ã“ã“ã§ã¯é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã ã‘ã‚’å¯¾è±¡ã¨ã—ã¦ã„ã¾ã™ã€‚

ã“ã®ææ¡ˆã®å¾Œã§ã¯ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã‚’ã—ã¦ã„ãªã„ãƒ©ãƒ ãƒ€å¼ã®é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚’`static`ã«å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ãŒã€ãã‚Œã‚’ã—ã¦ã—ã¾ã†ã¨ãƒ©ãƒ ãƒ€å¼ã®é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã®ãƒ¡ãƒ³ãƒãƒã‚¤ãƒ³ã‚¿ã‚’å–ã‚Šå‡ºã™ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ãŒå£Šã‚Œã€ã¾ãŸABIç ´æã«ç¹‹ãŒã‚Šã¾ã™ã€‚

ãã®ãŸã‚ã€ã‚­ãƒ£ãƒ—ãƒãƒ£ã—ã¦ã„ãªã„ãƒ©ãƒ ãƒ€å¼ã®é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ã‚’`static`ã«ãªã‚‹ã‚ˆã†ã«ã—ã¦ã—ã¾ã†ã“ã¨ã¯å‡ºæ¥ãªã„ãŸã‚ã€ã‚ªãƒ—ãƒˆã‚¤ãƒ³ã™ã‚‹æ§‹æ–‡ã‚’ææ¡ˆã—ã¦ã„ã¾ã™ã€‚

```cpp
// é–¢æ•°å‘¼ã³å‡ºã—æ¼”ç®—å­ãŒé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹
auto four = []() static { return 4; };

// å¾“æ¥é€šã‚Šã€éé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ã¨ã—ã¦å®šç¾©ã•ã‚Œã‚‹
auto five = []() { return 5; };
```

- [P1169 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/1022)

### [P1401R5 Narrowing contextual conversions to bool](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html)
### [P1664R3 reconstructible_range - a concept for putting ranges back together](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1664r3.html)

`view`ã«ã‚ˆã£ã¦åˆ¥ã®`range`ã«å¤‰æ›ã•ã‚Œã¦ã—ã¾ã£ãŸç¯„å›²ã‚’ã€å…ƒã®`range`ï¼ˆã¨åŒã˜å‹ï¼‰ã«æˆ»ã™æ“ä½œã€`std::ranges::reconstruct`ã¨é–¢é€£ã™ã‚‹ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ææ¡ˆã€‚

*Range Adopter*ã®é©ç”¨ã§ã¯ã€å…¥åŠ›ã®`range`ã¯`view`ã®å‹ã«åŒ…ã¾ã‚Œã‚‹å½¢ã§å¤‰æ›ã•ã‚Œã€å…ƒã®å‹ã¨ã¯åˆ¥ã®å‹ã«ãªã£ã¦ã—ã¾ã„ã€å…ƒã«ã¯æˆ»ã‚‰ãªããªã‚Šã¾ã™ã€‚

```cpp
template <typename T>
using span = quickcpplib::span<T>;

std::vector<int> vec{1, 2, 3, 4, 5};
span<int> s{vec.data(), 5};

// ç¾åœ¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
span<int> v = s | views::drop(1) | views::take(10)
                | views::drop(1) | views::take(10);

// ã“ã‚Œãªã‚‰OK
auto v2 = s | views::drop(1) | views::take(10)
            | views::drop(1) | views::take(10);
// decltype(v2) == ranges::take_view<ranges::drop_view<ranges::take_view<ranges::drop_view<span<int, dynamic_extent>>>>>
```

ã“ã®ä¾‹ã§ã¯ã€`decltype(v)`ã‹ã‚‰`span<int>`ã¸ã®å¤‰æ›æ–¹æ³•ãŒãªã„ãŸã‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’èµ·ã“ã—ã¦ã„ã¾ã™ã€‚

`views::take/views::drop`ã¯æŒ‡å®šã•ã‚ŒãŸæ•°ã ã‘ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹orè½ã¨ã™ã“ã¨ã§ã€æŒ‡å®šã•ã‚ŒãŸæ•°ã ã‘è¦ç´ ã‚’å–ã‚Šå‡ºã™orç„¡è¦–ã™ã‚‹ã€ã¨ã„ã†å‡¦ç†ã‚’è¡Œã£ã¦ãŠã‚Šã€`view`ã®é©ç”¨å¾Œã‚‚å…ƒã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€å…ƒã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ç”¨ã„ã‚Œã°å…ƒã®å‹ã‚’å†æ§‹æˆã§ãã‚‹ã¯ãšã§ã™ã€‚ã—ã‹ã—ã€ç¾åœ¨ã¯ãã®æ–¹æ³•ã‚„åˆ¤åˆ¥æ–¹æ³•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚

ã“ã®ææ¡ˆã¯ã€ãã®ã‚ˆã†ãªå ´åˆã«å†æ§‹æˆã§ãã‚‹`range`ã‚’è¡¨ã™*Reconstructible Ranges*ã¨ã„ã†æ¦‚å¿µã‚’å°å…¥ã—ã€ãã®ãŸã‚ã®ADL-foundãªé–¢æ•°ã¨ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’æ•´å‚™ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

å…ˆç¨‹ã®ä¾‹ã®å ´åˆã®ã‚ˆã†ã«ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã¨ã‚»ãƒ³ãƒãƒãƒ«ã®ãƒšã‚¢ã‹ã‚‰å…ƒã®å‹ã‚’å†æ§‹æˆã§ãã‚‹å ´åˆã€ãã‚Œã‚’è¡Œã†ãŸã‚ã®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚¤ãƒ³ãƒˆã¨ã—ã¦`reconstruct`é–¢æ•°ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

ãã‚Œã‚’`std::ranges::reconstruct`CPOã«ã‚ˆã£ã¦å‘¼ã³å‡ºã™ã‚ˆã†ã«ã—ã€`reconstruct`CPOã«ã‚ˆã£ã¦`pair_reconstructible_range`ã¨`reconstructible_range`ã®äºŒã¤ã®ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’å®šç¾©ã—ã¾ã™ã€‚

```cpp
namespace std::ranges {
  inline namespace unspecified {

    inline constexpr nspecified reconstruct = unspecified;

  }

  template <class R,
            class It = ranges::iterator_t<remove_reference_t<R>>,
            class Sen = ranges::sentinel_t<remove_reference_t<R>>>
  concept pair_reconstructible_range =
    ranges::range<R> &&
    ranges::borrowed_range<remove_reference_t<R>> &&
    requires (It first, Sen last) {
      reconstruct(
        in_place_type<remove_cvref_t<R>>,
        std::move(first),
        std::move(last)
      );
    };

template <class R, class Range = remove_reference_t<R>>
concept reconstructible_range =
  ranges::range<R> &&
  ranges::borrowed_range<remove_reference_t<R>> &&
  requires (Range first_last) {
    reconstruct(
      in_place_type<remove_cvref_t<R>>,
      std::move(first_last)
    );
  };
}
```

`std::ranges::reconstruct`CPOã¯ã‚¿ã‚°å‹ï¼ˆ`in_place_type<R>`ï¼‰ã¨`R`ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒšã‚¢ã€ã‚‚ã—ãã¯ã‚¿ã‚°å‹ã¨`range`ã‚’å—ã‘å–ã‚Šã€ãã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿å‹ã«ã¤ã„ã¦å‘¼ã³å‡ºã—å¯èƒ½ãª`reconstruct`é–¢æ•°ã‚’å‘¼ã³å‡ºã—ã€å‡¦ç†ã‚’å§”è­²ã—ã¾ã™ã€‚

`reconstruct`é–¢æ•°ã§ã¯ã€ãã‚Œãã‚Œã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ï¼ˆ`range`ï¼‰ã«æœ€é©ãªæ–¹æ³•ã«ã‚ˆã£ã¦ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ãƒšã‚¢ã‹ã‚‰å…ƒã®`range`ã®å†æ§‹æˆã‚’è¡Œã„ã¾ã™ã€‚

ãã—ã¦ã€æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®`views::take/views::drop`ã®å‘¼ã³å‡ºã—ã¯ã€`reconstructible_range`ã‚³ãƒ³ã‚»ãƒ—ãƒˆã®ãƒ¢ãƒ‡ãƒ«ã¨ãªã‚‹å‹ã«å¯¾ã—ã¦ã€å…ƒã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ç›´æ¥å…ƒã®å‹ã‚’å†æ§‹æˆã—ã¦çµæœã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

ã“ã‚Œã«ã‚ˆã£ã¦å†’é ­ã®ã‚³ãƒ¼ãƒ‰ã¯ã€

```cpp
template <typename T>
using span = quickcpplib::span<T>;

std::vector<int> vec{1, 2, 3, 4, 5};
span<int> s{vec.data(), 5};

// OK
auto v = s | views::drop(1) | views::take(10)
           | views::drop(1) | views::take(10);
// decltype(v2) == span<int>
```

ä»–ã®ä¾‹

```cpp
std::u8string name = "ğŒ€ğŒ–ğŒ‹ğŒ„ğŒ‘ğŒ‰Â·ğŒŒğŒ„ğŒ•ğŒ„ğŒ‹ğŒ‰ğŒ‘ ğ‘¡ğ‘¹ğ‘¡ Â·ğ‘šğ‘»ğ‘¯ğ‘¸ğ‘› Â·ğ‘–ğ‘·";
char16_t conversion_buffer[432];

std::u8string_view name_view(name);
std::span<char16_t> output(conversion_buffer, 432);

auto encoding_result = ztd::text::transcode(input, output);

// å…¨ã¦OK
auto unprocessed_code_units = encoding_result.input;
auto unconsumed_output = encoding_result.output;
// decltype(unprocessed_code_units) == std::u8string_view
// decltype(unconsumed_output) == std::span<char16_t>
```

- [P1664 é€²è¡ŒçŠ¶æ³](https://github.com/cplusplus/papers/issues/578)

### [P1673R3 A free function linear algebra interface based on the BLAS](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1673r3.pdf)

æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã€BLASã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸå¯†è¡Œåˆ—ã®ãŸã‚ã®ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã€‚

ã“ã®ææ¡ˆã¯ã€BLASã®APIã‚’ãƒ™ãƒ¼ã‚¹ã¨ã—ãŸå¯†è¡Œåˆ—ã®ãŸã‚ã®å„ç¨®æ“ä½œã‚’è¡Œã†ãƒ•ãƒªãƒ¼é–¢æ•°ã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã‚‚ã®ã§ã€ãƒ™ã‚¯ãƒˆãƒ«å‹ã‚„è¡Œåˆ—å‹ã‚’è¿½åŠ ã™ã‚‹ã‚‚ã®ã§ã¯ãªãã€ãã‚Œã‚‰é–¢æ•°ã¯ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«ä¾å­˜ã—ã¦ã„ã¾ã›ã‚“ã€‚

é–¢æ•°ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã§å®šç¾©ã•ã‚Œã€ææ¡ˆä¸­ã®`mdspan`ã‚’ç”¨ã„ã‚‹ã“ã¨ã§ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿å‹ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«ã•ã‚Œã¦ã„ã¾ã™ã€‚ã¾ãŸã€æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’ç”¨ã„ãŸexpressionãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã‚‚ã‚ã‚Šã¾ã›ã‚“ã€‚

ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆãƒ™ã‚¯ãƒˆãƒ«/è¡Œåˆ—å‹ï¼‰ã‚’è¿½åŠ ã™ã‚‹ææ¡ˆã¯åˆ¥ã«é€²è¡Œã—ã¦ãŠã‚Šãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè§¦ã‚Œã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã¨ãªã‚‹ã®ã¯ãã¡ã‚‰ã§ã€ã“ã‚Œã¯ç·šå½¢ä»£æ•°ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®åŸºç¤ã¨ãªã‚‹ã‚‚ã®ã§ã™ã€‚

ã‚³ãƒ¬ã‚¹ã‚­ãƒ¼åˆ†è§£ã®ã‚µãƒ³ãƒ—ãƒ«ã€‚

```cpp
#include <linalg>
#include <cmath>


template<class inout_matrix_t, class Triangle>
int cholesky_factor(inout_matrix_t A, Triangle t)
{
  using element_type = typename inout_matrix_t::element_type;

  constexpr element_type ZERO {};
  constexpr element_type ONE (1.0);
  const ptrdiff_t n = A.extent(0);

  if (n == 0) {
    return 0;
  }
  else if (n == 1) {
    if (A(0,0) <= ZERO || std::isnan(A(0,0))) {
      return 1;
    }
    A(0,0) = std::sqrt(A(0,0));
  }
  else {
    // Partition A into [A11, A12,  A21, A22],
    // where A21 is the transpose of A12.
    const std::ptrdiff_t n1 = n / 2;
    const std::ptrdiff_t n2 = n - n1;
    auto A11 = std::subspan(A, std::pair{0, n1}, std::pair{0, n1});
    auto A22 = std::subspan(A, std::pair{n1, n}, std::pair{n1, n});
    
    // Factor A11
    const int info1 = cholesky_factor(A11, t);
    if (info1 != 0) {
      return info1;
    }

    using std::linalg::symmetric_matrix_rank_k_update;
    using std::linalg::transposed;
    
    if constexpr (std::is_same_v<Triangle, upper_triangle_t>) {
      // Update and scale A12
      auto A12 = subspan(A, std::pair{0, n1}, std::pair{n1, n});

      using std::linalg::triangular_matrix_matrix_left_solve;

      triangular_matrix_matrix_left_solve(transposed(A11),upper_triangle, explicit_diagonal, A12);

      // A22 = A22 - A12^T * A12
      symmetric_matrix_rank_k_update(-ONE, transposed(A12), A22, t);
    }
    else {
      //
      // Compute the Cholesky factorization A = L * L^T
      //
      // Update and scale A21
      auto A21 = std::subspan(A, std::pair{n1, n}, std::pair{0, n1});

      using std::linalg::triangular_matrix_matrix_right_solve;

      triangular_matrix_matrix_right_solve(transposed(A11), lower_triangle, explicit_diagonal, A21);

      // A22 = A22 - A21 * A21^T
      symmetric_matrix_rank_k_update(-ONE, A21, A22, t);
    }

    // Factor A22
    const int info2 = cholesky_factor(A22, t);
    if (info2 != 0) {
      return info2 + n1;
    }
  }
}
```

ãªãŠã€Wordingã®ãƒšãƒ¼ã‚¸ã ã‘ã§120Pè¿‘ãã‚’å ã‚ã¦ãŠã‚Šã€ã¨ã¦ã¤ã‚‚ãªãå·¨å¤§ã§ã™ãƒ»ãƒ»ãƒ»

- [P1417R0: Historical lessons for C++ linear algebra library](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1417r0.pdf)
- [BLAS - NEC Numeric Library Collection 2.3.0 ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚ºã‚¬ã‚¤ãƒ‰](https://www.hpc.nec/documents/sdk/SDK_NLC/UsersGuide/blas/f/ja/index.html)

### [P1706R3 Programming Language Vulnerabilities for Safety Critical C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1706r3.pdf)
### [P1708R4 Simple Statistical Functions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1708r4.pdf)
### [P1847R4 Make declaration order layout mandated](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1847r4.pdf)
### [P1938R3 if consteval](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1938r3.html)
### [P1949R7 C++ Identifier Syntax using Unicode Standard Annex 31](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1949r7.html)
### [P1967R3 #embed - a simple, scannable preprocessor-based resource acquisition method](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1967r3.html)
### [P1989R2 Range constructor for std::string_view 2: Constrain Harder](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1989r2.pdf)
### [P2128R4 Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r4.pdf)
### [P2128R5 Multidimensional subscript operator](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2128r5.pdf)
### [P2168R2 generator: A Synchronous Coroutine Generator Compatible With Ranges](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2168r2.pdf)
### [P2186R2 Removing Garbage Collection Support](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2186r2.html)
### [P2201R1 Mixed string literal concatenation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2201r1.html)
### [P2223R2 Trimming whitespaces before line splicing](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2223r2.pdf)
### [P2251R1 Require span & basic_string_view to be Trivially Copyable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf)
### [P2255R1 A type trait to detect reference binding to temporary](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2255r1.html)
### [P2265R1 Renaming any_invocable](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2265r1.pdf)
### [P2273R1 Making std::unique_ptr constexpr](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2273r1.pdf)
### [P2283R1 constexpr for specialized memory algorithms](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2283r1.pdf)
### [P2295R1 Correct UTF-8 handling during phase 1 of translation](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r1.pdf)
### [P2295R2 Support for UTF-8 as a portable source file encoding]([)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r2.pdf)
### [P2295R3 Support for UTF-8 as a portable source file encoding]([)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2295r3.pdf)
### [P2321R1 zip](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r1.html)
### [P2322R2 ranges::fold](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2322r2.html)
### [P2325R2 Views should not be required to be default constructible](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2325r2.html)
### [P2327R0 De-deprecating volatile compound assignment](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2327r0.pdf)
### [P2337R0 Less constexpr for <cmath>](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2337r0.pdf)
### [P2342R0 For a Few Punctuators More](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2342r0.pdf)
### [P2345R0 Relaxing Requirements of Moved-From Objects](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2345r0.pdf)
### [P2348R0 Whitespaces Wording Revamp](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2348r0.pdf)
### [P2350R0 constexpr class](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2350r0.pdf)
### [P2352R0 SG16: Unicode meeting summaries 2020-12-09 through 2021-03-24](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2352r0.html)
### [P2353R0 Metaprograms and fragments are needed in comma-separated contexts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2353r0.html)
### [P2355R0 Postfix fold expressions](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2355r0.html)
### [P2356R0 Implementing Factory builder on top of P2320](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2356r0.pdf)
### [P2358R0 Defining Contracts](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2358r0.pdf)
### [P2360R0 Extend init-statement to allow alias-declaration](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2360r0.html)
### [P2361R0 Unevaluated string literals](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2361r0.pdf)
### [P2362R0 Make obfuscating wide character literals ill-formed](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2362r0.pdf)
### [P2363R0 Extending associative containers with the remaining heterogeneous overloads](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2363r0.html)